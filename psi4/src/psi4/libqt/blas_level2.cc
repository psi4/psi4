/*
 * @BEGIN LICENSE
 *
 * Psi4: an open-source quantum chemistry software package
 *
 * Copyright (c) 2007-2018 The Psi4 Developers.
 *
 * The copyrights for code used from other parties are included in
 * the corresponding files.
 *
 * This file is part of Psi4.
 *
 * Psi4 is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3.
 *
 * Psi4 is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along
 * with Psi4; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * @END LICENSE
 */

/**!
 * \file
 * \brief Interface to all BLAS routines
 * \ingroup QT
 *
 * Autogenerated by Rob Parrish on 1/24/2011
 *
 */

#include "blas_level2.h"

#ifdef USING_LAPACK_MKL
#include <mkl_cblas.h>
#else
#include <cblas.h>
#endif

#include "psi4/libpsi4util/exception.h"

namespace psi {
namespace detail {
CBLAS_TRANSPOSE dispatch_trans(char trans, std::string func, const char * file, int line) {
    auto retval = CblasNoTrans;
    if (trans == 'N' || trans == 'n') {
        retval = CblasNoTrans;
    } else if (trans == 'T' || trans == 't') {
        retval = CblasTrans;
    } else if (trans == 'C' || trans == 'c') {
        retval = CblasConjTrans;
    } else {
        throw SanityCheckError(func + " trans argument is invalid.", file, line);
    }
    return retval;
}

CBLAS_UPLO dispatch_uplo(char uplo, std::string func, const char * file, int line) {
    auto retval = CblasUpper;
    if (uplo == 'U' || uplo == 'u') {
        retval = CblasUpper;
    } else if (uplo == 'L' || uplo == 'l') {
        retval = CblasLower;
    } else {
        throw SanityCheckError(func + " uplo argument is invalid.", file, line);
    }
    return retval;
}

CBLAS_DIAG dispatch_diag(char diag, std::string func, const char * file, int line) {
    auto retval = CblasNonUnit;
    if (diag == 'N' || diag == 'n') {
        retval = CblasNonUnit;
    } else if (diag == 'U' || diag == 'u') {
        retval = CblasUnit;
    } else {
        throw SanityCheckError(func + " diag argument is invalid.", file, line);
    }
    return retval;
}

CBLAS_SIDE dispatch_side(char side, std::string func, const char * file, int line) {
    auto retval = CblasLeft;
    if (side == 'L' || side == 'l') {
        retval = CblasLeft;
    } else if (side == 'R' || side == 'r') {
        retval = CblasRight;
    } else {
        throw SanityCheckError(func + " side argument is invalid.", file, line);
    }
    return retval;
}
}  // namespace detail

void C_DGBMV(char trans, int m, int n, int kl, int ku, double alpha, double* a, int lda, double* x, int incx,
             double beta, double* y, int incy) {
    if (m == 0 || n == 0) return;
    auto TransA = detail::dispatch_trans(trans, __func__, __FILE__, __LINE__);
    cblas_dgbmv(CblasRowMajor, TransA, m, n, kl, ku, alpha, a, lda, x, incx, beta, y, incy);
}

void C_DGEMV(char trans, int m, int n, double alpha, double* a, int lda, double* x, int incx, double beta, double* y,
             int incy) {
    if (m == 0 || n == 0) return;
    auto TransA = detail::dispatch_trans(trans, __func__, __FILE__, __LINE__);
    cblas_dgemv(CblasRowMajor, TransA, m, n, alpha, a, lda, x, incx, beta, y, incy);
}

void C_DGER(int m, int n, double alpha, double* x, int incx, double* y, int incy, double* a, int lda) {
    if (m == 0 || n == 0) return;
    cblas_dger(CblasRowMajor, m, n, alpha, x, incx, y, incy, a, lda);
}

void C_DSBMV(char uplo, int n, int k, double alpha, double* a, int lda, double* x, int incx, double beta, double* y,
             int incy) {
    if (n == 0) return;
    auto Uplo = detail::dispatch_uplo(uplo, __func__, __FILE__, __LINE__);
    cblas_dsbmv(CblasRowMajor, Uplo, n, k, alpha, a, lda, x, incx, beta, y, incy);
}

void C_DSPMV(char uplo, int n, double alpha, double* ap, double* x, int incx, double beta, double* y, int incy) {
    if (n == 0) return;
    auto Uplo = detail::dispatch_uplo(uplo, __func__, __FILE__, __LINE__);
    cblas_dspmv(CblasRowMajor, Uplo, n, alpha, ap, x, incx, beta, y, incy);
}

void C_DSPR(char uplo, int n, double alpha, double* x, int incx, double* ap) {
    if (n == 0) return;
    auto Uplo = detail::dispatch_uplo(uplo, __func__, __FILE__, __LINE__);
    cblas_dspr(CblasRowMajor, Uplo, n, alpha, x, incx, ap);
}

void C_DSPR2(char uplo, int n, double alpha, double* x, int incx, double* y, int incy, double* ap) {
    if (n == 0) return;
    auto Uplo = detail::dispatch_uplo(uplo, __func__, __FILE__, __LINE__);
    cblas_dspr2(CblasRowMajor, Uplo, n, alpha, x, incx, y, incy, ap);
}

void C_DSYMV(char uplo, int n, double alpha, double* a, int lda, double* x, int incx, double beta, double* y,
             int incy) {
    if (n == 0) return;
    auto Uplo = detail::dispatch_uplo(uplo, __func__, __FILE__, __LINE__);
    cblas_dsymv(CblasRowMajor, Uplo, n, alpha, a, lda, x, incx, beta, y, incy);
}

void C_DSYR(char uplo, int n, double alpha, double* x, int incx, double* a, int lda) {
    if (n == 0) return;
    auto Uplo = detail::dispatch_uplo(uplo, __func__, __FILE__, __LINE__);
    cblas_dsyr(CblasRowMajor, Uplo, n, alpha, x, incx, a, lda);
}

void C_DSYR2(char uplo, int n, double alpha, double* x, int incx, double* y, int incy, double* a, int lda) {
    if (n == 0) return;
    auto Uplo = detail::dispatch_uplo(uplo, __func__, __FILE__, __LINE__);
    cblas_dsyr2(CblasRowMajor, Uplo, n, alpha, x, incx, y, incy, a, lda);
}

void C_DTBMV(char uplo, char trans, char diag, int n, int k, double* a, int lda, double* x, int incx) {
    if (n == 0) return;
    auto Uplo = detail::dispatch_uplo(uplo, __func__, __FILE__, __LINE__);
    auto TransA = detail::dispatch_trans(trans, __func__, __FILE__, __LINE__);
    auto Diag = detail::dispatch_diag(diag, __func__, __FILE__, __LINE__);
    cblas_dtbmv(CblasRowMajor, Uplo, TransA, Diag, n, k, a, lda, x, incx);
}

void C_DTBSV(char uplo, char trans, char diag, int n, int k, double* a, int lda, double* x, int incx) {
    if (n == 0) return;
    auto Uplo = detail::dispatch_uplo(uplo, __func__, __FILE__, __LINE__);
    auto TransA = detail::dispatch_trans(trans, __func__, __FILE__, __LINE__);
    auto Diag = detail::dispatch_diag(diag, __func__, __FILE__, __LINE__);
    cblas_dtbsv(CblasRowMajor, Uplo, TransA, Diag, n, k, a, lda, x, incx);
}

void C_DTPMV(char uplo, char trans, char diag, int n, double* ap, double* x, int incx) {
    if (n == 0) return;
    auto Uplo = detail::dispatch_uplo(uplo, __func__, __FILE__, __LINE__);
    auto TransA = detail::dispatch_trans(trans, __func__, __FILE__, __LINE__);
    auto Diag = detail::dispatch_diag(diag, __func__, __FILE__, __LINE__);
    cblas_dtpmv(CblasRowMajor, Uplo, TransA, Diag, n, ap, x, incx);
}

void C_DTPSV(char uplo, char trans, char diag, int n, double* ap, double* x, int incx) {
    if (n == 0) return;
    auto Uplo = detail::dispatch_uplo(uplo, __func__, __FILE__, __LINE__);
    auto TransA = detail::dispatch_trans(trans, __func__, __FILE__, __LINE__);
    auto Diag = detail::dispatch_diag(diag, __func__, __FILE__, __LINE__);
    cblas_dtpsv(CblasRowMajor, Uplo, TransA, Diag, n, ap, x, incx);
}

void C_DTRMV(char uplo, char trans, char diag, int n, double* a, int lda, double* x, int incx) {
    if (n == 0) return;
    auto Uplo = detail::dispatch_uplo(uplo, __func__, __FILE__, __LINE__);
    auto TransA = detail::dispatch_trans(trans, __func__, __FILE__, __LINE__);
    auto Diag = detail::dispatch_diag(diag, __func__, __FILE__, __LINE__);
    cblas_dtrmv(CblasRowMajor, Uplo, TransA, Diag, n, a, lda, x, incx);
}

void C_DTRSM(char side, char uplo, char transa, char diag, int m, int n, double alpha, double* a, int lda, double* b,
             int ldb) {
    if (m == 0 || n == 0) return;
    auto Side = detail::dispatch_side(side, __func__, __FILE__, __LINE__);
    auto Uplo = detail::dispatch_uplo(uplo, __func__, __FILE__, __LINE__);
    auto TransA = detail::dispatch_trans(transa, __func__, __FILE__, __LINE__);
    auto Diag = detail::dispatch_diag(diag, __func__, __FILE__, __LINE__);
    cblas_dtrsm(CblasRowMajor, Side, Uplo, TransA, Diag, m, n, alpha, a, lda, b, ldb);
}

void C_DTRSV(char uplo, char trans, char diag, int n, double* a, int lda, double* x, int incx) {
    if (n == 0) return;
    auto Uplo = detail::dispatch_uplo(uplo, __func__, __FILE__, __LINE__);
    auto TransA = detail::dispatch_trans(trans, __func__, __FILE__, __LINE__);
    auto Diag = detail::dispatch_diag(diag, __func__, __FILE__, __LINE__);
    cblas_dtrsv(CblasRowMajor, Uplo, TransA, Diag, n, a, lda, x, incx);
}
}  // namespace psi
