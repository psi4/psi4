/*
 * @BEGIN LICENSE
 *
 * Psi4: an open-source quantum chemistry software package
 *
 * Copyright (c) 2007-2024 The Psi4 Developers.
 *
 * The copyrights for code used from other parties are included in
 * the corresponding files.
 *
 * This file is part of Psi4.
 *
 * Psi4 is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3.
 *
 * Psi4 is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along
 * with Psi4; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * @END LICENSE
 */

/*!
  \file
  \brief Obtain orbital space and reordering for CI/MCSCF wavefunctions
  \ingroup QT
*/

#include "qt.h"

#include "psi4/libciomr/libciomr.h"
#include "psi4/psifiles.h"
#include "psi4/libmints/dimension.h"
#include "psi4/liboptions/liboptions.h"
#include "psi4/libpsi4util/PsiOutStream.h"

#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <numeric>

namespace psi {

/*!
** ras_set()
**
** This function populates the various arrays for RAS orbital spaces
** (frozen core, restricted core, RAS I-IV, restricted vir, frozen vir)
** based on the available user specifications. This is done for any CI
** computation, even ones that do not update orbitals. The orbital space
** space specification is therefore normally incomplete, so this function
** also needs to supply what the user left implicit.
** It also obtains the appropriate orbital reordering array.  The
** reordering array takes a basis function in Pitzer ordering (orbitals
** grouped according to irrep) and gives the corresponding index
** in the RAS numbering scheme.  Orbitals are numbered according to
** irrep within each of the subspaces.
**
** Guesses for docc and socc should be provided, and they will be left
** as-is if they are not present in input (maybe auto-guessed by program)
**
** C. David Sherrill
**
**  \param orbspi      =  array giving num symmetry orbitals (or MOs) per irrep
**  \param docc        =  array of doubly occupied orbitals per irrep
**                        (guess must be provided)
**  \param socc        =  array of singly occupied orbitals per irrep
**                        (guess must be provided)
**  \param frdocc      =  array of frozen core per irrep
**                        (returned by function, but allocate before call)
**  \param fruocc      =  array of frozen virtuals per irrep
**                        (returned by function, but allocate before call)
**  \param rstrdocc    =  array of restricted core per irrep
**                        (returned by function, but allocate before call)
**  \param rstruocc    =  array of restricted unoccupied per irrep
**                        (returned by function, but allocate before call)
**  \param ras_opi     =  matrix giving num of orbitals per irrep per ras space,
**                        addressed as ras_opi[ras_space][irrep]
**                        (returned by function, but allocate before call)
**                        RAS IV will not be deduced unless RAS III is
**                        present in user input (in which case RAS IV needs
**                        to make up any remaining orbitals)
**  \param core_guess  =  array of the core orbitals per irrep to drop
**                        (must be provided).  This is copied into
**                        FROZEN_DOCC (if is_mcscf == false) or
**                        RESTRICTED_DOCC (if is_mcscf == true), if both
**                        of those two arrays are absent from input
**  \param order       =  array nmo big which maps Pitzer to Correlated order
**                        (returned by function, but allocate before call)
**  \param ras_type    =  if 1, put docc and socc together in same RAS space
**                        (RAS I), as appropriate for DETCI.  If 0, put socc
**                        in its own RAS space (RAS II), as appropriate for CC.
**  \param is_mcscf    =  true if an MCSCF-type wavefunction (orbital
**                        optimization), else false.  Used to determine
**                        default behavior of FROZEN_DOCC, RESTRICTED_DOCC,
**                        FROZEN_UOCC, RESTRICTED_UOCC
**  \param options     =  Options object used to parse user input
**
** Rules for how spaces can be specified:
**   1. DOCC and SOCC are not changed by this routine
**      (guesses might have been auto-generated by Psi) unless explicitly
**      given in user input, in which case the guess arrays are overwritten
**      by the user input in this routine
**   2. FROZEN_DOCC and RESTRICTED_DOCC will be as given by the user.  If
**      the user does not specify either of these keywords, then maybe
**      they specified FREEZE_CORE = TRUE instead, and we want to support
**      that.  If neither FROZEN_DOCC nor RESTRICTED_DOCC is specified, then
**      we will use the array core_guess[] to get them.  This array is
**      obtained from whatever routine figures out how many orbitals per
**      irrep to freeze when FREEZE_CORE = true (passed down as an argument
**      into this function).  If the computation is an MCSCF, then we'll
**      copy core_guess into RESTRICTED_DOCC.  If it's not an MCSCF, then
**      we'll copy it into FROZEN_DOCC.
**   3. The user can give either ACTIVE (for a CAS type computation, where
**      internally this is basically like RAS 2), or RAS keywords.  Not both.
**   4. By default, unused virtual orbitals go into FROZEN_UOCC unless
**      we're told this is an MCSCF, in which case they should go by
**      default into RESTRICTED_UOCC
**   5. RAS 4 is never used unless explicitly given in input; it's a special
**      feature not normally desired.  (Note: this is a change from previous
**      default behavior in which unused orbitals were stuffed into RAS 4)
**
** Returns: 1 for success, 0 otherwise
** \ingroup QT
*/
int ras_set(Dimension& orbspi, Dimension& docc, Dimension& socc, Dimension& frdocc, Dimension& fruocc, Dimension& restrdocc,
            Dimension& restruocc, std::vector<Dimension>& ras_opi, Dimension& core_guess, int *order, int ras_type, bool is_mcscf,
            Options &options) {
    // Initialize variables
    int point, tmpi, cnt = 0;
    int errbad = 0;
    int **tras;
    std::vector<bool> parsed_ras(ras_opi.size(), false);
    bool parsed_frozen_docc = false, parsed_restr_docc = false;
    bool parsed_frozen_uocc = false, parsed_restr_uocc = false;
    auto nirreps = static_cast<int>(orbspi.n());
    auto nmo = orbspi.sum();
    std::vector<int> used(nirreps, 0), offset(nirreps, 0);
    Dimension zerodim(nirreps);
    auto nras = ras_opi.size();

    // Zero Dimension objects that cannot possibly contain guesses
    for (auto& dimension: ras_opi) {
        dimension.zero();
    }
    frdocc.zero();
    restrdocc.zero();
    fruocc.zero();
    restruocc.zero();

    zero_int_array(order, nmo);

    // Set DOCC and SOCC. These aren't spaces we need to fill, but are invaluable in working
    // out the spaces the user left implicit.
    if (options["DOCC"].has_changed()) {
        if (options["DOCC"].size() != nirreps) {
            throw InputException("ras_set(): Wrong size of array", "DOCC", __FILE__, __LINE__);
        }
        options.fill_int_array("DOCC", docc);
    }
    if (options["SOCC"].has_changed()) {
        if (options["SOCC"].size() != nirreps) {
            throw InputException("ras_set(): Wrong size of array", "SOCC", __FILE__, __LINE__);
        }
        options.fill_int_array("SOCC", socc);
    }

    // Now we'll take the spaces we do need to fill, if explicit.
    if (options["FROZEN_DOCC"].has_changed()) {
        if (options["FROZEN_DOCC"].size() != nirreps) {
            throw InputException("ras_set(): Wrong size of array", "FROZEN_DOCC", __FILE__, __LINE__);
        }
        options.fill_int_array("FROZEN_DOCC", frdocc);
        parsed_frozen_docc = true;
    }
    if (options["RESTRICTED_DOCC"].has_changed()) {
        if (options["RESTRICTED_DOCC"].size() != nirreps) {
            throw InputException("ras_set(): Wrong size of array", "RESTRICTED_DOCC", __FILE__, __LINE__);
        }
        options.fill_int_array("RESTRICTED_DOCC", restrdocc);
        parsed_restr_docc = true;
    }
    if (options["FROZEN_UOCC"].has_changed()) {
        if (options["FROZEN_UOCC"].size() != nirreps) {
            throw InputException("ras_set(): Wrong size of array", "FROZEN_UOCC", __FILE__, __LINE__);
        }
        options.fill_int_array("FROZEN_UOCC", fruocc);
        parsed_frozen_uocc = true;
    }
    if (options["RESTRICTED_UOCC"].has_changed()) {
        if (options["RESTRICTED_UOCC"].size() != nirreps) {
            throw InputException("ras_set(): Wrong size of array", "RESTRICTED_UOCC", __FILE__, __LINE__);
        }
        options.fill_int_array("RESTRICTED_UOCC", restruocc);
        parsed_restr_uocc = true;
    }
    for (size_t i = 0; i < ras_opi.size(); i++) {
        std::string tag = "RAS" + std::to_string(i + 1); // TODO: Use auto tag = std::format("RAS{}", i+ 1) when compiler supports it.
        if (options[tag].has_changed()) {
            if (options[tag].size() != nirreps) {
                throw InputException("ras_set(): Wrong size of array", tag, __FILE__, __LINE__);
            }
            options.fill_int_array(tag, ras_opi[i]);
            parsed_ras[i] = true;
        }
    }

    // If neither FROZEN_DOCC nor RESTRICTED_DOCC is explicit, assume that one is core_guess
    // and the other is empty. For orbital-optimized, we set core_guess to RESTRICTED_DOCC,
    // signifying that we want these orbitals optimized. For non-orbital-optimized, we set
    // core_guess to FROZEN_DOCC, because that's the only meaningful category.
    if (!parsed_frozen_docc && !parsed_restr_docc) {
        if (!is_mcscf) {
            frdocc.copy(core_guess);
        } else {
            restrdocc.copy(core_guess);
        }
    }

    // Explicit RAS and explicit active are inconsistent. Check the user hasn't done that.
    if (std::any_of(parsed_ras.cbegin(), parsed_ras.cend(), [](bool v) { return v; })) {
        if (options["ACTIVE"].has_changed()) {
            throw InputException("ras_set(): RAS and ACTIVE keywords mutually exclusive", "ACTIVE", __FILE__,
                                 __LINE__);
        }
    }

    // Now it's time to work out the RAS spaces...
    if (options["ACTIVE"].has_changed()) {
        // If we're in this case, our job is easy.
        options.fill_int_array("ACTIVE", ras_opi[1]);
    } else {
        // Work out RAS1
        if (!parsed_ras[0]) {
            ras_opi[0] += docc - frdocc - restrdocc;
            if (ras_type == 1) ras_opi[0] += socc;
        }
        // Work out RAS2
        if (!parsed_ras[1] and ras_type == 1) ras_opi[1] += socc;
        // All remaining spaces default to zero, except...
        // If RAS3 isn't fixed, dump all remaining orbitals there.
        if (!parsed_ras[2]) {
            auto sum = frdocc + restrdocc + fruocc + restruocc + std::reduce(ras_opi.cbegin(), ras_opi.cend(), zerodim);
            ras_opi[2].copy(orbspi - sum);
        }
    }

    // If frozen / restricted uocc aren't fixed, dump all orbitals in there.
    // This depends on is_mcscf, just like for the occupieds.
    if (!is_mcscf) {  // if not an MCSCF, default into fruocc
        if (!parsed_frozen_uocc) {
            auto sum = frdocc + restrdocc + restruocc + std::reduce(ras_opi.cbegin(), ras_opi.cend(), zerodim);
            fruocc.copy(orbspi - sum);
        }
    } else {  // is an MCSCF, so default into restruocc instead of fruocc
        if (!parsed_restr_uocc) {
            auto sum = frdocc + restrdocc + fruocc + std::reduce(ras_opi.cbegin(), ras_opi.cend(), zerodim);
            restruocc.copy(orbspi - sum);
        }
    }

    // All orbitals are now set! Now we mess around with indexing.

    // copy everything to some temporary arrays just to count easier
    tras = init_int_matrix(nras + 4, nirreps);

    for (int irrep = 0; irrep < nirreps; irrep++) {
        tras[0][irrep] = frdocc[irrep];
        tras[1][irrep] = restrdocc[irrep];
        tras[nras + 2][irrep] = restruocc[irrep];
        tras[nras + 3][irrep] = fruocc[irrep];
    }
    for (int i = 0; i < nras; i++) {
        for (int irrep = 0; irrep < nirreps; irrep++) {
            tras[i + 2][irrep] = ras_opi[i][irrep];
        }
    }

    // construct the offset array
    offset[0] = 0;
    for (int irrep = 1; irrep < nirreps; irrep++) {
        offset[irrep] = offset[irrep - 1] + orbspi[irrep - 1];
    }

    for (int i = 0; i < nras + 4; i++) {
        for (int irrep = 0; irrep < nirreps; irrep++) {
            while (tras[i][irrep]) {
                point = used[irrep] + offset[irrep];
                if (point < 0 || point >= nmo) {
                    throw PsiException("ras_set(): Invalid point value", __FILE__, __LINE__);
                }
                order[point] = cnt++;
                used[irrep]++;
                tras[i][irrep]--;
            }
        }
    }

    // Validate.
    for (int irrep = 0; irrep < nirreps; irrep++) {
        if (used[irrep] > orbspi[irrep]) {
            outfile->Printf("ras_set(): on final check, used more orbitals");
            outfile->Printf("   than were available (%d vs %d) for irrep %d\n", used[irrep], orbspi[irrep], irrep);
            errbad = 1;
        }
        if (used[irrep] < orbspi[irrep]) {
            outfile->Printf("ras_set(): on final check, used fewer orbitals");
            outfile->Printf("   than were available (%d vs %d) for irrep %d\n", used[irrep], orbspi[irrep], irrep);
            errbad = 1;
        }
        for (const auto& space: ras_opi) {
            if (space[irrep] < 0) {
                outfile->Printf("ras_set(): on final check, found an active/RAS space with %d orbitals for irrep %d", space[irrep], irrep);
                errbad = 1;
            }
        }
        for (const auto& space: {frdocc, restrdocc, fruocc, restruocc}) {
            if (space[irrep] < 0) {
                outfile->Printf("ras_set(): on final check, found an inactive space with %d orbitals for irrep %d", space[irrep], irrep);
                errbad = 1;
            }
        }
    }

    free_int_matrix(tras);

    return (!errbad);
}
}  // namespace psi
