<!DOCTYPE html>

<html lang="English" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Integrals in |PSIfour| &#8212; Psi4 Documentation 1.11 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=61cd365c" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=12dfc556" />
    <script src="../../../_static/documentation_options.js?v=29ef4520"></script>
    <script src="../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="integrals-in-psifour">
<span id="sec-prog-integrals"></span><h1>Integrals in <a href="#id2"><span class="problematic" id="id3">|PSIfour|</span></a><a class="headerlink" href="#integrals-in-psifour" title="Link to this heading">¶</a></h1>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p><a href="#id4"><span class="problematic" id="id5">|PSIfour|</span></a> has a number of backends available to compute integrals. In order to
accomodate these options, while providing a clean interface to the programmer,
an abstraction layer is implemented within Libmints.  A recent upgrade to the
primary integral engine has seen some important changes to the way this
interface layer is used; this document is designed to aid new developers as
well as those familiar with the older calling conventions to ensure that the
most efficient calling conventions are applied.</p>
</section>
<section id="the-older-style">
<h2>The older style<a class="headerlink" href="#the-older-style" title="Link to this heading">¶</a></h2>
<p>A very simple loop that does not use permutational symmetry might look
something like this in the old scheme:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">sieve</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">ERISieve</span><span class="o">&gt;</span><span class="p">(</span><span class="n">basisset</span><span class="p">,</span><span class="w"> </span><span class="n">cutoff</span><span class="p">);</span>
<span class="k">auto</span><span class="w"> </span><span class="n">factory</span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">IntegralFactory</span><span class="o">&gt;</span><span class="p">(</span><span class="n">basisset</span><span class="p">);</span>
<span class="kt">int</span><span class="w"> </span><span class="n">deriv_level</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">use_shell_pairs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">eri</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factory</span><span class="o">-&gt;</span><span class="n">eri</span><span class="p">(</span><span class="n">deriv_level</span><span class="p">,</span><span class="w"> </span><span class="n">use_shell_pairs</span><span class="p">);</span>
<span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="o">*</span><span class="w"> </span><span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eri_</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">();</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">P</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">P</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">basisset</span><span class="o">-&gt;</span><span class="n">nshell</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">P</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">Pshell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">basisset</span><span class="o">-&gt;</span><span class="n">shell</span><span class="p">(</span><span class="n">P</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">Q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">Q</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">basisset</span><span class="o">-&gt;</span><span class="n">nshell</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">Q</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">Qshell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">basisset</span><span class="o">-&gt;</span><span class="n">shell</span><span class="p">(</span><span class="n">Q</span><span class="p">);</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">basisset</span><span class="o">-&gt;</span><span class="n">nshell</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">R</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">Rshell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">basisset</span><span class="o">-&gt;</span><span class="n">shell</span><span class="p">(</span><span class="n">R</span><span class="p">);</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">basisset</span><span class="o">-&gt;</span><span class="n">nshell</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">S</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">Sshell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">basisset</span><span class="o">-&gt;</span><span class="n">shell</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="n">sieve</span><span class="o">-&gt;</span><span class="n">shell_significant</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="w"> </span><span class="n">Q</span><span class="p">,</span><span class="w"> </span><span class="n">R</span><span class="p">,</span><span class="w"> </span><span class="n">S</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="n">eri</span><span class="o">-&gt;</span><span class="n">compute_shell</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="w"> </span><span class="n">Q</span><span class="p">,</span><span class="w"> </span><span class="n">R</span><span class="p">,</span><span class="w"> </span><span class="n">S</span><span class="p">);</span>
<span class="w">                    </span><span class="c1">// results are in buffer, do something with them..</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>An integral factory is used, which can then produce integral object for various
operator types and derivative levels.  A sieve is also constructed; this allows
a quick determination of whether an integral shell quartet will be significant
in magnitude or not, potentially saving a lot of work.  This simple scheme is
clean and easy to understand, and is still supported in the latest version of
<a href="#id6"><span class="problematic" id="id7">|PSIfour|</span></a> with only a small change to the sieve syntax and handling of buffer
addresses, noted below.</p>
</section>
<section id="the-new-syntax">
<h2>The new syntax<a class="headerlink" href="#the-new-syntax" title="Link to this heading">¶</a></h2>
<p>The newer integral engines being interfaced to <a href="#id8"><span class="problematic" id="id9">|PSIfour|</span></a> may or may not require
a group of similar integrals to be computed together in a block using
vectorized instructions.  To accomodate this possibility, a new syntax has been
introduced in Libmints:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">blocksPQ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">get_blocks12</span><span class="p">();</span>
<span class="k">auto</span><span class="w"> </span><span class="n">blocksRS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">get_blocks34</span><span class="p">();</span>

<span class="k">auto</span><span class="w"> </span><span class="n">factory</span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">IntegralFactory</span><span class="o">&gt;</span><span class="p">(</span><span class="n">basisset</span><span class="p">);</span>
<span class="kt">int</span><span class="w"> </span><span class="n">deriv_level</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">use_shell_pairs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">needs_exchange</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">eri</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factory</span><span class="o">-&gt;</span><span class="n">eri</span><span class="p">(</span><span class="n">deriv_level</span><span class="p">,</span><span class="w"> </span><span class="n">use_shell_pairs</span><span class="p">,</span><span class="w"> </span><span class="n">needs_exchange</span><span class="p">);</span>
<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">buffers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eri</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">();</span>

<span class="n">eri</span><span class="o">-&gt;</span><span class="n">update_density</span><span class="p">(</span><span class="n">D</span><span class="p">);</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">use_batching</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eri</span><span class="o">-&gt;</span><span class="n">maximum_block_size</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="c1">// loop over all the blocks of (P&gt;=Q|</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">blockPQ_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">blockPQ_idx</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">blocksPQ</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">blockPQ_idx</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">blockPQ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blocksPQ</span><span class="p">[</span><span class="n">blockPQ_idx</span><span class="p">];</span>
<span class="w">    </span><span class="c1">// loop over all the blocks of |R&gt;=S)</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eri</span><span class="o">-&gt;</span><span class="n">first_RS_shell_block</span><span class="p">(</span><span class="n">blockPQ_idx</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">blockRS_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">loop_start</span><span class="p">;</span><span class="w"> </span><span class="n">blockRS_idx</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">blocksRS</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">blockRS_idx</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">blockRS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blocksRS</span><span class="p">[</span><span class="n">blockRS_idx</span><span class="p">];</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">eri</span><span class="o">-&gt;</span><span class="n">shell_block_significant</span><span class="p">(</span><span class="n">blockPQ_idx</span><span class="p">,</span><span class="w"> </span><span class="n">blockRS_idx</span><span class="p">))</span><span class="w"> </span><span class="k">continue</span><span class="p">;</span>

<span class="w">        </span><span class="n">eri</span><span class="o">-&gt;</span><span class="n">compute_shell_blocks</span><span class="p">(</span><span class="n">blockPQ_idx</span><span class="p">,</span><span class="w"> </span><span class="n">blockRS_idx</span><span class="p">);</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">*</span><span class="w"> </span><span class="n">block_start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buffers</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

<span class="w">        </span><span class="c1">// Loop over all of the P,Q,R,S shells within the blocks.  We have P&gt;=Q, R&gt;=S and PQ&lt;=RS.</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">pairPQ</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">blockPQ</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">P</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pairPQ</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pairPQ</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">Pshell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">basisset</span><span class="o">-&gt;</span><span class="n">shell</span><span class="p">(</span><span class="n">P</span><span class="p">);</span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">Qshell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">basisset</span><span class="o">-&gt;</span><span class="n">shell</span><span class="p">(</span><span class="n">Q</span><span class="p">);</span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">Pam</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Pshell</span><span class="p">.</span><span class="n">am</span><span class="p">();</span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">Qam</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Qshell</span><span class="p">.</span><span class="n">am</span><span class="p">();</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">pairRS</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">blockRS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">R</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pairRS</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">S</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pairRS</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">Rshell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">basisset</span><span class="o">-&gt;</span><span class="n">shell</span><span class="p">(</span><span class="n">R</span><span class="p">);</span>
<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">Sshell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">basisset</span><span class="o">-&gt;</span><span class="n">shell</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">Ram</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rshell</span><span class="p">.</span><span class="n">am</span><span class="p">();</span>
<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">Sam</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Sshell</span><span class="p">.</span><span class="n">am</span><span class="p">();</span>

<span class="w">                </span><span class="kt">size_t</span><span class="w"> </span><span class="n">block_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Psize</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Qsize</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Rsize</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Ssize</span><span class="p">;</span>
<span class="w">                </span><span class="c1">// When there are chunks of shellpairs in RS, we need to make sure</span>
<span class="w">                </span><span class="c1">// we filter out redundant combinations.</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">use_batching</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">Pam</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Ram</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">Qam</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Sam</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">((</span><span class="n">P</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">R</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">P</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">Q</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">S</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="n">block_start</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">block_size</span><span class="p">;</span>
<span class="w">                    </span><span class="k">continue</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="o">*</span><span class="w"> </span><span class="n">int_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">block_start</span><span class="p">;</span>
<span class="w">                </span><span class="c1">// Query P,Q,R,S shells for metadata and loop over that quartet</span>
<span class="w">                </span><span class="c1">// as usual, getting the integrals from the int_ptr buffer.</span>
<span class="w">                </span><span class="n">block_start</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">block_size</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Although this looks more complex, it's essentially doing the same thing.  There
are a number of differences that we'll highlight now.</p>
<section id="sieving">
<h3>Sieving<a class="headerlink" href="#sieving" title="Link to this heading">¶</a></h3>
<p>This is one of two breaking changes to the old style syntax.  Instead of
constructing a sieve object, the integral object should be queried directly
using the exact same syntax.  Requests for whether a shell is significant or a
shell block is significant are both supported.  Sieving information is generated directly
within the integral object if matching basis sets are found in either the bra or the ket.
For a density fitting integral (PQ|0A) where 0 is the null basis set and A is an auxiliary
basis set the (PQ| pair will be used to construct all of the sieving data.</p>
</section>
<section id="buffer-address">
<h3>Buffer address<a class="headerlink" href="#buffer-address" title="Link to this heading">¶</a></h3>
<p>The old code copied integrals into a buffer owned by the integral object, whose
address remained constant and could be retrieved by the <code class="docutils literal notranslate"><span class="pre">buffer()</span></code> member
function.  To avoid unnecessary copies, the new code instead uses the integrals
directly from the underlying integral engine's memory, which may change with
each call to compute integrals.  The integral engine provides a
<code class="docutils literal notranslate"><span class="pre">std::vector&lt;const</span> <span class="pre">double*&gt;</span></code> containing the pointers to the start of each
&quot;chunk&quot; of integrals.  For first derivatives there are 12 such &quot;chunks&quot;, which
are ordered Px,Py,Pz,Qx,Qy,Qz,Rx,Ry,Rz,Sx,Sy,Sz, where the Px refers to the x
derivative with respect to the basis functions in shell P.  Note that all
integral derivatives are provided by the new integral code, unlike the previous
version where only 9 of 12 were provided and the user was responsible for using
translation invariance relationships to fill in the rest.  The addresses for
each chunk are updated in the vector after each call to compute integrals, so
the user should keep a const reference to that object, and query that for the
address of interest.</p>
</section>
<section id="density-screening">
<h3>Density Screening<a class="headerlink" href="#density-screening" title="Link to this heading">¶</a></h3>
<p>The old code looked only at the integral to determine whether terms can be
avoided <em>a priori</em>.  However, if the integral is to be contracted with a
density or a density-like quantity, the screening can be performed on the
product, which yields more sparsity.  To enable this, simply call the integral
object's <code class="docutils literal notranslate"><span class="pre">update_density</span></code> member, passing it a SharedMatrix holding the
current density (remember that it changes during each iteration of the SCF) and
the product will be considered during screening.  If only coulomb-like terms
are to be computed, the <code class="docutils literal notranslate"><span class="pre">needs_exchange</span></code> argument to the integral object
constructor should be set to false, otherwise it should be true to correcly
account for products of the density and integrals that contribute to
exchange-like terms.</p>
</section>
<section id="shell-blocking">
<h3>Shell blocking<a class="headerlink" href="#shell-blocking" title="Link to this heading">¶</a></h3>
<p>Each underlying integral engine knows whether it will use blocks, and will set up
the metadata automatically.  Instead of looping over individual shells, the
user should loop over blocks supplied by the integral object; these blocks will
be just a single shell quartet combination for the case where blocking is not
used. It is simple to loop over pairs within each block using C++11 syntax, as
demonstrated in the code snippet above.  Only shell pairs with significant
overlap are included in the shell block information, making this an efficient
way to loop over non-negligible terms.</p>
</section>
<section id="permutational-symmetry">
<h3>Permutational symmetry<a class="headerlink" href="#permutational-symmetry" title="Link to this heading">¶</a></h3>
<p>The pairs within each block are optimized for efficiency.  First, they are
screened during the integral object's creation to ensure that only terms with
appreciable overlap are stored.  Second, only P,Q combinations that are
permutationally unique are stored, ordered with the higher angular momentum
first.  Therefore care must be taken to ensure that the missing permutations
are correctly accounted for when processing the integrals within the loop.  See
the DirectJK code in libfock for an example of using this scheme for a Fock
matrix build.</p>
</section>
<section id="using-bra-ket-symmetry">
<h3>Using bra-ket symmetry<a class="headerlink" href="#using-bra-ket-symmetry" title="Link to this heading">¶</a></h3>
<p>In cases where there is no batching performed, bra-ket symmetry can be
trivially enforced by ensuring that one of the block indices is greater than or
equal to the other.  When batching is used, the situation is trickier; some ket
batches may contain a mixture of integrals that are bra-ket unique and those
that are not.  To handle this we must do a coarse check at the top of the loop
to see if <em>any</em> integrals in the batch are needed, which is implemented by
asking the integral engine where to start looping in the ket via the call to
<code class="docutils literal notranslate"><span class="pre">eri-&gt;first_RS_shell_block(PQpair_idx)</span></code>.  This is followed by a more fine
grained check within the loops to filter individual integrals in the case where
bra and ket have the same angular momentum and there's a possibility of a
handful of integrals coming from the ket that are redundant.  Note that the bra
is not batched in any of our engines currently: only the ket is.  For this
reason, density fitting integrals should be written as (A0|PQ) rather than
(PQ|A0) where possible, because we want the ket to contain more functions than
the bra for efficient blocking.</p>
</section>
<section id="instantiating-integral-objects">
<h3>Instantiating integral objects<a class="headerlink" href="#instantiating-integral-objects" title="Link to this heading">¶</a></h3>
<p>With sieving being introduced in the new integral objects, the cost of their
construction has increased.  Although significantly cheaper than computing
integrals themselves, construction of integral objects can be non-negligible,
especially if many threads are used.  For example, this pattern can be found in
old versions of the code:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">TwoBodyAOInt</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">ints</span><span class="p">;</span>
<span class="n">ints</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">TwoBodyAOInt</span><span class="o">&gt;</span><span class="p">(</span><span class="n">factory</span><span class="o">-&gt;</span><span class="n">eri</span><span class="p">()));</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="kr">thread</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="kr">thread</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_threads</span><span class="p">;</span><span class="w"> </span><span class="kr">thread</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">ints</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">TwoBodyAOInt</span><span class="o">&gt;</span><span class="p">(</span><span class="n">factory</span><span class="o">-&gt;</span><span class="n">eri</span><span class="p">()));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This builds many objects and the cost can add up.  With the new scheme,
integral objects are forced to implement a <cite>clone()</cite> member that can be used as
follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">TwoBodyAOInt</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">ints</span><span class="p">;</span>
<span class="n">ints</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">TwoBodyAOInt</span><span class="o">&gt;</span><span class="p">(</span><span class="n">factory</span><span class="o">-&gt;</span><span class="n">eri</span><span class="p">()));</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="kr">thread</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="kr">thread</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_threads</span><span class="p">;</span><span class="w"> </span><span class="kr">thread</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">ints</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">TwoBodyAOInt</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">clone</span><span class="p">()));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This method only incurs the cost of creating a single integral object, and
performs much cheaper cloning operations to create the other objects for each
thread.  Moreover, if integral objects are created only in the initialization
of each code that uses them, and stored persistently, the cost of integral
object creation is further reduced.</p>
</section>
</section>
<section id="one-electron-integrals-in-psifour">
<h2>One Electron Integrals in <a href="#id10"><span class="problematic" id="id11">|PSIfour|</span></a><a class="headerlink" href="#one-electron-integrals-in-psifour" title="Link to this heading">¶</a></h2>
<p>After version 1.5, we started transitioning the one electron integral code over to
use Libint2 instead of the old handwritten Obara-Saika code.  There are a
number of reasons motivating this switch.  For methods requiring
potentials and fields evaluated at many external sites, such as PCM and
polarizable embedding, the efficiency of the one electron integrals can be rate
limiting.  We also started to introduce integral screening, and it is important
to balance the screening used for one- and two-electron terms carefully, so this
is a good opportunity to re-evaluate the code.  Finally, given the complexity
of the OS recursion code, the switch to an external library leaves a more
compact codebase to maintain.  The one electron integrals which are not provided by Libint2
are now handled by a new implementation of the McMurchie-Davidson (M-D) algorithm,
leading to removal of the OS code in version 1.6. An overview of the one electron integrals
is shown in table <a class="reference internal" href="#table-oei-impl-summary"><span class="std std-ref">Algorithms used for One Electron Integrals</span></a>, together with the implementation they use.
The tips below serve as a guide to what changed,
why it changed, and how to interface with <a href="#id12"><span class="problematic" id="id13">|PSIfour|</span></a>'s one-electron integral
machinery now.</p>
<section id="calling-compute-shell-int-p-int-q">
<h3>Calling <code class="docutils literal notranslate"><span class="pre">compute_shell(int</span> <span class="pre">P,</span> <span class="pre">int</span> <span class="pre">Q)</span></code><a class="headerlink" href="#calling-compute-shell-int-p-int-q" title="Link to this heading">¶</a></h3>
<p>The hand-implemented OS recursion code also took care of the Cartesian-&gt;pure
transformation (if required by the basis set).  The mechanism for handling this
was to provide a public facing <code class="docutils literal notranslate"><span class="pre">compute_shell(int</span> <span class="pre">P,</span> <span class="pre">int</span> <span class="pre">Q)</span></code> method for the
caller; this then looked up the appropriate <code class="docutils literal notranslate"><span class="pre">GaussianShell</span></code> objects that were
passed into the corresponding (private) <code class="docutils literal notranslate"><span class="pre">compute_pair(GaussianShell</span> <span class="pre">&amp;s1,</span>
<span class="pre">GaussianShell</span> <span class="pre">&amp;s2)</span></code> function that computed the integrals and transformed them
to the spherical harmonic basis, if needed.  The switch to Libint2 integrals
preserves this mechanism, but the <code class="docutils literal notranslate"><span class="pre">compute_shell(int</span> <span class="pre">P,</span> <span class="pre">int</span> <span class="pre">Q)</span></code> simply looks
up the appropriate Libint2-compatible shells and hands them off to the
re-written, private <code class="docutils literal notranslate"><span class="pre">compute_pair()</span></code> routines, which call Libint2 directly.
Therefore, any calls to shell-pair level integral computations should look the
same as before the introduction of Libint2, however access to the integrals has
changed, as described below.</p>
</section>
<section id="accessing-integrals">
<h3>Accessing integrals<a class="headerlink" href="#accessing-integrals" title="Link to this heading">¶</a></h3>
<p>Before the Libint2 transition, one electron integrals were computed in a flat
array, internally called <cite>buffer_</cite>, which was accessed through the integral
object's <code class="docutils literal notranslate"><span class="pre">buffer()</span></code> method.  For integrals with multiple operators, e.g.,
dipole operators that have three distinct components, the buffer was simply
elongated by the appropriate amount and the caller was responsible for striding
through each resulting batch correctly.  The Libint2 engines instead return a
list of pointers into each operator's batch of integrals, the ordering of which
are detailed on the Libint2 wiki.  For this reason, the call to <code class="docutils literal notranslate"><span class="pre">buffer()</span></code>
that returns a single buffer must be replaced with a call to <code class="docutils literal notranslate"><span class="pre">buffer()</span></code> to
get a list of pointers; we recommend that be assigned the type <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">auto</span>
<span class="pre">&amp;</span></code>.  For simple integrals, such as overlap or kinetic, only the buffer
corresponding to the zeroth element of this array contains integrals.</p>
</section>
<section id="derivative-integrals">
<h3>Derivative Integrals<a class="headerlink" href="#derivative-integrals" title="Link to this heading">¶</a></h3>
<p>The old one electron integral code used translational invariance relations to
minimze the number of integrals to be computed, leaving the caller with some
bookkeeping to do to compute all terms.  For example, consider an overlap
integral: its value depends only on the relative separation of the two centers
and not their absolute positions in space.  Therefore, the derivative with
respect to center A is the negative of the same derivative with respect to
center B, so one is trivially gleaned from the other.  Extending this to second
derivatives, the same principle leads to the fact that double derivatives with
respect to center A are equal to double derivatives with respect to center B,
which are also equal to the negative of the mixed double derivatives with
respect to both center A and B.  The old code only provided the double
derivative with respect to center A, leaving the caller to determine the other
values.  The Libint2 engine instead provides all integrals, so the caller
simply needs to loop over all of the buffers provided in the appropriate order.</p>
</section>
<section id="changes-to-external-potential-engines">
<h3>Changes to External Potential Engines<a class="headerlink" href="#changes-to-external-potential-engines" title="Link to this heading">¶</a></h3>
<p>Benchmarking showed that early versions of the old code spent a non-negligible
amount of time performing the Cartesian to spherical harmonic transformation of
the integrals, which is needed for most modern basis sets.  To improve
performance, we instead backtransformed the density to the Cartesian
representation (denoted &quot;CartAO&quot;) and computed / contracted all integrals in
this Cartesian basis, eliminating the need to transform to spherical harmonics
as the integrals are computed.  This bottleneck no longer exists, so these
extra transformation steps have been removed as part of the switch to Libint2,
and the affected codes (PCM and CPPE interfaces) now compute the potential and
field integrals in the representation required by the basis set.</p>
<p>Also, note that the way external point charges are specified has changed.
Previously, a set of N external point charges would be specified by passing a
matrix with dimensions N rows and 4 columns -- corresponding to charge, x, y, z
-- to the <code class="docutils literal notranslate"><span class="pre">set_charge_field()</span></code> member of the potential integral class.  The
same information is now passed using the more verbose
<code class="docutils literal notranslate"><span class="pre">std::vector&lt;std::pair&lt;double,</span> <span class="pre">std::array&lt;double,</span> <span class="pre">3&gt;&gt;&gt;</span></code> type instead, to be
consistent with Libint2's convention.</p>
</section>
<section id="new-operators-available">
<h3>New Operators Available<a class="headerlink" href="#new-operators-available" title="Link to this heading">¶</a></h3>
<p>Libint2 provides a range of integrals that were previously not available in
<a href="#id14"><span class="problematic" id="id15">|PSIfour|</span></a>, such as the Erfc attenuated nuclear potential integrals needed for
Ewald methods.  If new integrals are added to Libint2 but are not yet
interfaced to <a href="#id16"><span class="problematic" id="id17">|PSIfour|</span></a>, please open an issue on the <a href="#id18"><span class="problematic" id="id19">|PSIfour|</span></a> GitHub page to
alert the developers, who will be able to add the appropriate code.
Available integrals classes and parameters currently documented at
<a class="reference external" href="https://github.com/evaleev/libint/wiki/using-modern-CPlusPlus-API#create-an-integral-engine">Libint2 C++11 Interface Wiki</a></p>
</section>
<section id="shell-pairs">
<h3>Shell Pairs<a class="headerlink" href="#shell-pairs" title="Link to this heading">¶</a></h3>
<p>To ensure consistency between one- and two-electron terms when screening, and
for efficiency reasons, shell pair lists should be used to iterate over pairs
of Gaussian shells.  These lists contain integer pair numbers, corresponding to
the pairs of shells that have sufficient overlap to survive the screening
process.  Iterating over these lists is simple:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">shell_pairs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Vint</span><span class="o">-&gt;</span><span class="n">shellpairs</span><span class="p">();</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">n_pairs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shell_pairs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n_pairs</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="k">auto</span><span class="w"> </span><span class="n">P</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shell_pairs</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">first</span><span class="p">;</span>
<span class="w">     </span><span class="k">auto</span><span class="w"> </span><span class="n">Q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shell_pairs</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">second</span><span class="p">;</span>
<span class="w">     </span><span class="c1">// do something with shells P and Q</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that list considers all P,Q pairs if the two basis sets differ, but only
P&gt;=Q if the basis sets are the same; the caller should account for this
restricted summation in the latter case.</p>
</section>
<section id="one-electron-integral-algorithm-overview">
<h3>One Electron Integral Algorithm Overview<a class="headerlink" href="#one-electron-integral-algorithm-overview" title="Link to this heading">¶</a></h3>
<p>The following table summarizes which implementation is used
for each type of one electron integral in <a href="#id20"><span class="problematic" id="id21">|PSIfour|</span></a>.</p>
<span id="table-oei-impl-summary"></span><table class="docutils align-default" id="id1">
<caption><span class="caption-text">Algorithms used for One Electron Integrals</span><a class="headerlink" href="#id1" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Integral</p></th>
<th class="head"><p>Class</p></th>
<th class="head"><p>Implementation</p></th>
<th class="head"><p>Comment</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Three-Center Overlap</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ThreeCenterOverlapInt</span></code></p></td>
<td><p>Libint2</p></td>
<td><p>using <code class="docutils literal notranslate"><span class="pre">libint2::Operator::delta</span></code> for 4-center integrals</p></td>
</tr>
<tr class="row-odd"><td><p>Angular Momentum</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">AngularMomentumInt</span></code></p></td>
<td><p>M-D</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>Dipole</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">DipoleInt</span></code></p></td>
<td><p>Libint2</p></td>
<td><p>no derivatives supported</p></td>
</tr>
<tr class="row-odd"><td><p>Electric Field</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ElectricFieldInt</span></code></p></td>
<td><p>Libint2</p></td>
<td><p>using first derivative of <code class="docutils literal notranslate"><span class="pre">libint2::Operator::nuclear</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Coulomb Potential</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ElectrostaticInt</span></code></p></td>
<td><p>Libint2</p></td>
<td><p>evaluated for a single origin and unity charge</p></td>
</tr>
<tr class="row-odd"><td><p>Kinetic</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">KineticInt</span></code></p></td>
<td><p>Libint2</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>Multipole Potential</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">MultipolePotentialInt</span></code></p></td>
<td><p>M-D</p></td>
<td><p>arbitrary order derivative of 1/R supported</p></td>
</tr>
<tr class="row-odd"><td><p>Multipole Moments</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">MultipoleInt</span></code></p></td>
<td><p>M-D</p></td>
<td><p>arbitrary order multipoles supported, including nuclear gradients</p></td>
</tr>
<tr class="row-even"><td><p>Nabla Operator</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">NablaInt</span></code></p></td>
<td><p>Libint2</p></td>
<td><p>using first derivative of <code class="docutils literal notranslate"><span class="pre">libint2::Operator::overlap</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Overlap</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">OverlapInt</span></code></p></td>
<td><p>Libint2</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>Nuclear Coulomb Potential</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">PotentialInt</span></code></p></td>
<td><p>Libint2</p></td>
<td><p>assumes nuclear centers/charges as the potential</p></td>
</tr>
<tr class="row-odd"><td><p>PCM Potential</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">PCMPotentialInt</span></code></p></td>
<td><p>Libint2</p></td>
<td><p>parallelized over charge points</p></td>
</tr>
<tr class="row-even"><td><p>Quadrupole</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">QuadrupoleInt</span></code></p></td>
<td><p>Libint2</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>Traceless Quadrupole</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">TracelessQuadrupoleInt</span></code></p></td>
<td><p>Libint2</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>Relativistic Potential</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">RelPotentialInt</span></code></p></td>
<td><p>Libint2</p></td>
<td></td>
</tr>
</tbody>
</table>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">Psi4 Documentation</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, Harishankar.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.3.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
      |
      <a href="../../../_sources/doc/sphinxman/source/prog_integrals.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>