/**********************************************************
* NAME_functional.cc: definitions for NAME_functional for KS-DFT
* Robert Parrish, robparrish@gmail.com
* Autogenerated by MATLAB Script on DATE
*
***********************************************************/
#include <libmints/mints.h>
#include "NAME_functional.h"
#include <stdlib.h>
#include <cmath>
#include <string>
#include <string>
#include <vector>

using namespace psi;
using namespace boost;
using namespace std;

namespace psi { namespace functional {

NAME_Functional::NAME_Functional(int npoints, int deriv) : Functional(npoints, deriv)
{

    name_ = "NAME";
    description_ = "DESCRIPTION";
    citation_ = "CITATION";

    DEFINE_PARAMS

    is_gga_ = IS_GGA;
    is_meta_ = IS_META;

    //Required allocateion
    allocate();
}
NAME_Functional::~NAME_Functional()
{
}
void NAME_Functional::computeRKSFunctional(boost::shared_ptr<RKSFunctions> prop)
{
    int ntrue = prop->npoints();

    const double* restrict rho_a;
    const double* restrict gamma_aa;
    const double* restrict tau_a;

    rho_a = prop->property_value("RHO_A")->pointer();
    if (is_gga_) {
        gamma_aa = prop->property_value("GAMMA_AA")->pointer();
    }
    if (is_meta_) {
        tau_a = prop->property_value("TAU_A")->pointer();
    }

    EXTRACT_PARAMS

    //Functional
    for (int index = 0; index < ntrue; index++) {

        //Functional Value
        RKS_FUNCTIONAL

    }
    //First Partials
    for (int index = 0; index < ntrue && deriv_ >= 1; index++) {

        //V_rho_a
        RKS_V1_RHO_A

        if (is_gga_) {

            RKS_V1_GAMMA_AA

        }
        if (is_meta_) {

            //V_tau_a
            RKS_V1_TAU_A

        }
    }
    //Second Partials
    for (int index = 0; index < ntrue && deriv_ >= 2; index++) {

        //V_rho_a_rho_a
        RKS_V2_RHO_A_RHO_A

        if (is_gga_) {

            //V_rho_a_gamma_aa
            RKS_V2_RHO_A_GAMMA_AA

            //V_gamma_aa_gamma_aa
            RKS_V2_GAMMA_AA_GAMMA_AA

        }
        if (is_meta_) {

            //V_rho_a_tau_a
            RKS_V2_RHO_A_TAU_A

            //V_tau_a_tau_a
            RKS_V2_TAU_A_TAU_A

            if (is_gga_) {

                //V_gamma_aa_tau_a
                RKS_V2_GAMMA_AA_TAU_A

            }
        }
    }
}
void NAME_Functional::computeUKSFunctional(boost::shared_ptr<UKSFunctions> prop)
{
    int ntrue = prop->npoints();

    const double* restrict rho_a;
    const double* restrict rho_b;
    const double* restrict gamma_aa;
    const double* restrict gamma_ab;
    const double* restrict gamma_bb;
    const double* restrict tau_a;
    const double* restrict tau_b;

    rho_a = prop->property_value("RHO_A")->pointer();
    rho_b = prop->property_value("RHO_B")->pointer();
    if (is_gga_) {
        gamma_aa = prop->property_value("GAMMA_AA")->pointer();
        gamma_ab = prop->property_value("GAMMA_AB")->pointer();
        gamma_bb = prop->property_value("GAMMA_BB")->pointer();
    }
    if (is_meta_) {
        tau_a = prop->property_value("TAU_A")->pointer();
        tau_b = prop->property_value("TAU_B")->pointer();
    }

    EXTRACT_PARAMS

    //Functional
    for (int index = 0; index < ntrue; index++) {

        //Functional Value
        UKS_FUNCTIONAL

    }
    //First Partials
    for (int index = 0; index < ntrue && deriv_ >= 1; index++) {

        //V_rho_a
        UKS_V1_RHO_A

        //V_rho_b
        UKS_V1_RHO_B

        if (is_gga_) {

            //V_gamma_aa
            UKS_V1_GAMMA_AA

            //V_gamma_ab
            UKS_V1_GAMMA_AB

            //V_gamma_bb
            UKS_V1_GAMMA_BB
        }
        if (is_meta_) {

            //V_tau_a
            UKS_V1_TAU_A

            //V_tau_a
            UKS_V1_TAU_B
        }
    }
    //Second Partials
    for (int index = 0; index < ntrue && deriv_ >= 2; index++) {

        //V_rho_a_rho_a
        UKS_V2_RHO_A_RHO_A

        //V_rho_a_rho_b
        UKS_V2_RHO_A_RHO_B

        //V_rho_b_rho_b
        UKS_V2_RHO_B_RHO_B

        if (is_gga_) {

            //V_rho_a_gamma_aa
            UKS_V2_RHO_A_GAMMA_AA

            //V_rho_a_gamma_ab
            UKS_V2_RHO_A_GAMMA_AB

            //V_rho_a_gamma_bb
            UKS_V2_RHO_A_GAMMA_BB

            //V_rho_b_gamma_aa
            UKS_V2_RHO_B_GAMMA_AA

            //V_rho_b_gamma_ab
            UKS_V2_RHO_B_GAMMA_AB

            //V_rho_b_gamma_bb
            UKS_V2_RHO_B_GAMMA_BB

            //V_gamma_aa_gamma_aa
            UKS_V2_GAMMA_AA_GAMMA_AA

            //V_gamma_aa_gamma_ab
            UKS_V2_GAMMA_AA_GAMMA_AB

            //V_gamma_aa_gamma_bb
            UKS_V2_GAMMA_AA_GAMMA_BB

            //V_gamma_ab_gamma_ab
            UKS_V2_GAMMA_AB_GAMMA_AB

            //V_gamma_ab_gamma_bb
            UKS_V2_GAMMA_AB_GAMMA_BB

            //V_gamma_bb_gamma_bb
            UKS_V2_GAMMA_BB_GAMMA_BB

        }
        if (is_meta_) {

            //V_rho_a_tau_a
            UKS_V2_RHO_A_TAU_A

            //V_rho_a_tau_b
            UKS_V2_RHO_A_TAU_B

            //V_rho_b_tau_a
            UKS_V2_RHO_B_TAU_A

            //V_rho_b_tau_b
            UKS_V2_RHO_B_TAU_B

            //V_tau_a_tau_a
            UKS_V2_TAU_A_TAU_A

            //V_tau_a_tau_b
            UKS_V2_TAU_A_TAU_B

            //V_tau_b_tau_b
            UKS_V2_TAU_B_TAU_B

            if (is_gga_) {

                //V_gamma_aa_tau_a
                UKS_V2_GAMMA_AA_TAU_A

                //V_gamma_aa_tau_b
                UKS_V2_GAMMA_AA_TAU_B

                //V_gamma_ab_tau_a
                UKS_V2_GAMMA_AB_TAU_A

                //V_gamma_ab_tau_b
                UKS_V2_GAMMA_AB_TAU_B

                //V_gamma_bb_tau_a
                UKS_V2_GAMMA_BB_TAU_A

                //V_gamma_bb_tau_b
                UKS_V2_GAMMA_BB_TAU_B

            }
        }
    }
}

}}

