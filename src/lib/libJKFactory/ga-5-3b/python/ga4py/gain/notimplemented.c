/* Generated by Cython 0.19.2 on Mon Dec 16 12:39:47 2013 */

#define PY_SSIZE_T_CLEAN
#ifndef CYTHON_USE_PYLONG_INTERNALS
#ifdef PYLONG_BITS_IN_DIGIT
#define CYTHON_USE_PYLONG_INTERNALS 0
#else
#include "pyconfig.h"
#ifdef PYLONG_BITS_IN_DIGIT
#define CYTHON_USE_PYLONG_INTERNALS 1
#else
#define CYTHON_USE_PYLONG_INTERNALS 0
#endif
#endif
#endif
#include "Python.h"
#ifndef Py_PYTHON_H
    #error Python headers needed to compile C extensions, please install development version of Python.
#elif PY_VERSION_HEX < 0x02040000
    #error Cython requires Python 2.4+.
#else
#include <stddef.h> /* For offsetof */
#ifndef offsetof
#define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
#endif
#if !defined(WIN32) && !defined(MS_WINDOWS)
  #ifndef __stdcall
    #define __stdcall
  #endif
  #ifndef __cdecl
    #define __cdecl
  #endif
  #ifndef __fastcall
    #define __fastcall
  #endif
#endif
#ifndef DL_IMPORT
  #define DL_IMPORT(t) t
#endif
#ifndef DL_EXPORT
  #define DL_EXPORT(t) t
#endif
#ifndef PY_LONG_LONG
  #define PY_LONG_LONG LONG_LONG
#endif
#ifndef Py_HUGE_VAL
  #define Py_HUGE_VAL HUGE_VAL
#endif
#ifdef PYPY_VERSION
#define CYTHON_COMPILING_IN_PYPY 1
#define CYTHON_COMPILING_IN_CPYTHON 0
#else
#define CYTHON_COMPILING_IN_PYPY 0
#define CYTHON_COMPILING_IN_CPYTHON 1
#endif
#if PY_VERSION_HEX < 0x02050000
  typedef int Py_ssize_t;
  #define PY_SSIZE_T_MAX INT_MAX
  #define PY_SSIZE_T_MIN INT_MIN
  #define PY_FORMAT_SIZE_T ""
  #define CYTHON_FORMAT_SSIZE_T ""
  #define PyInt_FromSsize_t(z) PyInt_FromLong(z)
  #define PyInt_AsSsize_t(o)   __Pyx_PyInt_AsInt(o)
  #define PyNumber_Index(o)    ((PyNumber_Check(o) && !PyFloat_Check(o)) ? PyNumber_Int(o) : \
                                (PyErr_Format(PyExc_TypeError, \
                                              "expected index value, got %.200s", Py_TYPE(o)->tp_name), \
                                 (PyObject*)0))
  #define __Pyx_PyIndex_Check(o) (PyNumber_Check(o) && !PyFloat_Check(o) && \
                                  !PyComplex_Check(o))
  #define PyIndex_Check __Pyx_PyIndex_Check
  #define PyErr_WarnEx(category, message, stacklevel) PyErr_Warn(category, message)
  #define __PYX_BUILD_PY_SSIZE_T "i"
#else
  #define __PYX_BUILD_PY_SSIZE_T "n"
  #define CYTHON_FORMAT_SSIZE_T "z"
  #define __Pyx_PyIndex_Check PyIndex_Check
#endif
#if PY_VERSION_HEX < 0x02060000
  #define Py_REFCNT(ob) (((PyObject*)(ob))->ob_refcnt)
  #define Py_TYPE(ob)   (((PyObject*)(ob))->ob_type)
  #define Py_SIZE(ob)   (((PyVarObject*)(ob))->ob_size)
  #define PyVarObject_HEAD_INIT(type, size) \
          PyObject_HEAD_INIT(type) size,
  #define PyType_Modified(t)
  typedef struct {
     void *buf;
     PyObject *obj;
     Py_ssize_t len;
     Py_ssize_t itemsize;
     int readonly;
     int ndim;
     char *format;
     Py_ssize_t *shape;
     Py_ssize_t *strides;
     Py_ssize_t *suboffsets;
     void *internal;
  } Py_buffer;
  #define PyBUF_SIMPLE 0
  #define PyBUF_WRITABLE 0x0001
  #define PyBUF_FORMAT 0x0004
  #define PyBUF_ND 0x0008
  #define PyBUF_STRIDES (0x0010 | PyBUF_ND)
  #define PyBUF_C_CONTIGUOUS (0x0020 | PyBUF_STRIDES)
  #define PyBUF_F_CONTIGUOUS (0x0040 | PyBUF_STRIDES)
  #define PyBUF_ANY_CONTIGUOUS (0x0080 | PyBUF_STRIDES)
  #define PyBUF_INDIRECT (0x0100 | PyBUF_STRIDES)
  #define PyBUF_RECORDS (PyBUF_STRIDES | PyBUF_FORMAT | PyBUF_WRITABLE)
  #define PyBUF_FULL (PyBUF_INDIRECT | PyBUF_FORMAT | PyBUF_WRITABLE)
  typedef int (*getbufferproc)(PyObject *, Py_buffer *, int);
  typedef void (*releasebufferproc)(PyObject *, Py_buffer *);
#endif
#if PY_MAJOR_VERSION < 3
  #define __Pyx_BUILTIN_MODULE_NAME "__builtin__"
  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos) \
          PyCode_New(a, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
#else
  #define __Pyx_BUILTIN_MODULE_NAME "builtins"
  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos) \
          PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
#endif
#if PY_MAJOR_VERSION < 3 && PY_MINOR_VERSION < 6
  #define PyUnicode_FromString(s) PyUnicode_Decode(s, strlen(s), "UTF-8", "strict")
#endif
#if PY_MAJOR_VERSION >= 3
  #define Py_TPFLAGS_CHECKTYPES 0
  #define Py_TPFLAGS_HAVE_INDEX 0
#endif
#if (PY_VERSION_HEX < 0x02060000) || (PY_MAJOR_VERSION >= 3)
  #define Py_TPFLAGS_HAVE_NEWBUFFER 0
#endif
#if PY_VERSION_HEX < 0x02060000
  #define Py_TPFLAGS_HAVE_VERSION_TAG 0
#endif
#if PY_VERSION_HEX > 0x03030000 && defined(PyUnicode_KIND)
  #define CYTHON_PEP393_ENABLED 1
  #define __Pyx_PyUnicode_READY(op)       (likely(PyUnicode_IS_READY(op)) ? \
                                              0 : _PyUnicode_Ready((PyObject *)(op)))
  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_LENGTH(u)
  #define __Pyx_PyUnicode_READ_CHAR(u, i) PyUnicode_READ_CHAR(u, i)
  #define __Pyx_PyUnicode_READ(k, d, i)   PyUnicode_READ(k, d, i)
#else
  #define CYTHON_PEP393_ENABLED 0
  #define __Pyx_PyUnicode_READY(op)       (0)
  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_SIZE(u)
  #define __Pyx_PyUnicode_READ_CHAR(u, i) ((Py_UCS4)(PyUnicode_AS_UNICODE(u)[i]))
  #define __Pyx_PyUnicode_READ(k, d, i)   ((k=k), (Py_UCS4)(((Py_UNICODE*)d)[i]))
#endif
#if PY_MAJOR_VERSION >= 3
  #define PyBaseString_Type            PyUnicode_Type
  #define PyStringObject               PyUnicodeObject
  #define PyString_Type                PyUnicode_Type
  #define PyString_Check               PyUnicode_Check
  #define PyString_CheckExact          PyUnicode_CheckExact
#endif
#if PY_VERSION_HEX < 0x02060000
  #define PyBytesObject                PyStringObject
  #define PyBytes_Type                 PyString_Type
  #define PyBytes_Check                PyString_Check
  #define PyBytes_CheckExact           PyString_CheckExact
  #define PyBytes_FromString           PyString_FromString
  #define PyBytes_FromStringAndSize    PyString_FromStringAndSize
  #define PyBytes_FromFormat           PyString_FromFormat
  #define PyBytes_DecodeEscape         PyString_DecodeEscape
  #define PyBytes_AsString             PyString_AsString
  #define PyBytes_AsStringAndSize      PyString_AsStringAndSize
  #define PyBytes_Size                 PyString_Size
  #define PyBytes_AS_STRING            PyString_AS_STRING
  #define PyBytes_GET_SIZE             PyString_GET_SIZE
  #define PyBytes_Repr                 PyString_Repr
  #define PyBytes_Concat               PyString_Concat
  #define PyBytes_ConcatAndDel         PyString_ConcatAndDel
#endif
#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyBaseString_Check(obj) PyUnicode_Check(obj)
  #define __Pyx_PyBaseString_CheckExact(obj) PyUnicode_CheckExact(obj)
#else
  #define __Pyx_PyBaseString_Check(obj) (PyString_CheckExact(obj) || PyUnicode_CheckExact(obj) || \
                                         PyString_Check(obj) || PyUnicode_Check(obj))
  #define __Pyx_PyBaseString_CheckExact(obj) (Py_TYPE(obj) == &PyBaseString_Type)
#endif
#if PY_VERSION_HEX < 0x02060000
  #define PySet_Check(obj)             PyObject_TypeCheck(obj, &PySet_Type)
  #define PyFrozenSet_Check(obj)       PyObject_TypeCheck(obj, &PyFrozenSet_Type)
#endif
#ifndef PySet_CheckExact
  #define PySet_CheckExact(obj)        (Py_TYPE(obj) == &PySet_Type)
#endif
#define __Pyx_TypeCheck(obj, type) PyObject_TypeCheck(obj, (PyTypeObject *)type)
#if PY_MAJOR_VERSION >= 3
  #define PyIntObject                  PyLongObject
  #define PyInt_Type                   PyLong_Type
  #define PyInt_Check(op)              PyLong_Check(op)
  #define PyInt_CheckExact(op)         PyLong_CheckExact(op)
  #define PyInt_FromString             PyLong_FromString
  #define PyInt_FromUnicode            PyLong_FromUnicode
  #define PyInt_FromLong               PyLong_FromLong
  #define PyInt_FromSize_t             PyLong_FromSize_t
  #define PyInt_FromSsize_t            PyLong_FromSsize_t
  #define PyInt_AsLong                 PyLong_AsLong
  #define PyInt_AS_LONG                PyLong_AS_LONG
  #define PyInt_AsSsize_t              PyLong_AsSsize_t
  #define PyInt_AsUnsignedLongMask     PyLong_AsUnsignedLongMask
  #define PyInt_AsUnsignedLongLongMask PyLong_AsUnsignedLongLongMask
#endif
#if PY_MAJOR_VERSION >= 3
  #define PyBoolObject                 PyLongObject
#endif
#if PY_VERSION_HEX < 0x03020000
  typedef long Py_hash_t;
  #define __Pyx_PyInt_FromHash_t PyInt_FromLong
  #define __Pyx_PyInt_AsHash_t   PyInt_AsLong
#else
  #define __Pyx_PyInt_FromHash_t PyInt_FromSsize_t
  #define __Pyx_PyInt_AsHash_t   PyInt_AsSsize_t
#endif
#if (PY_MAJOR_VERSION < 3) || (PY_VERSION_HEX >= 0x03010300)
  #define __Pyx_PySequence_GetSlice(obj, a, b) PySequence_GetSlice(obj, a, b)
  #define __Pyx_PySequence_SetSlice(obj, a, b, value) PySequence_SetSlice(obj, a, b, value)
  #define __Pyx_PySequence_DelSlice(obj, a, b) PySequence_DelSlice(obj, a, b)
#else
  #define __Pyx_PySequence_GetSlice(obj, a, b) (unlikely(!(obj)) ? \
        (PyErr_SetString(PyExc_SystemError, "null argument to internal routine"), (PyObject*)0) : \
        (likely((obj)->ob_type->tp_as_mapping) ? (PySequence_GetSlice(obj, a, b)) : \
            (PyErr_Format(PyExc_TypeError, "'%.200s' object is unsliceable", (obj)->ob_type->tp_name), (PyObject*)0)))
  #define __Pyx_PySequence_SetSlice(obj, a, b, value) (unlikely(!(obj)) ? \
        (PyErr_SetString(PyExc_SystemError, "null argument to internal routine"), -1) : \
        (likely((obj)->ob_type->tp_as_mapping) ? (PySequence_SetSlice(obj, a, b, value)) : \
            (PyErr_Format(PyExc_TypeError, "'%.200s' object doesn't support slice assignment", (obj)->ob_type->tp_name), -1)))
  #define __Pyx_PySequence_DelSlice(obj, a, b) (unlikely(!(obj)) ? \
        (PyErr_SetString(PyExc_SystemError, "null argument to internal routine"), -1) : \
        (likely((obj)->ob_type->tp_as_mapping) ? (PySequence_DelSlice(obj, a, b)) : \
            (PyErr_Format(PyExc_TypeError, "'%.200s' object doesn't support slice deletion", (obj)->ob_type->tp_name), -1)))
#endif
#if PY_MAJOR_VERSION >= 3
  #define PyMethod_New(func, self, klass) ((self) ? PyMethod_New(func, self) : PyInstanceMethod_New(func))
#endif
#if PY_VERSION_HEX < 0x02050000
  #define __Pyx_GetAttrString(o,n)   PyObject_GetAttrString((o),((char *)(n)))
  #define __Pyx_SetAttrString(o,n,a) PyObject_SetAttrString((o),((char *)(n)),(a))
  #define __Pyx_DelAttrString(o,n)   PyObject_DelAttrString((o),((char *)(n)))
#else
  #define __Pyx_GetAttrString(o,n)   PyObject_GetAttrString((o),(n))
  #define __Pyx_SetAttrString(o,n,a) PyObject_SetAttrString((o),(n),(a))
  #define __Pyx_DelAttrString(o,n)   PyObject_DelAttrString((o),(n))
#endif
#if PY_VERSION_HEX < 0x02050000
  #define __Pyx_NAMESTR(n) ((char *)(n))
  #define __Pyx_DOCSTR(n)  ((char *)(n))
#else
  #define __Pyx_NAMESTR(n) (n)
  #define __Pyx_DOCSTR(n)  (n)
#endif
#ifndef CYTHON_INLINE
  #if defined(__GNUC__)
    #define CYTHON_INLINE __inline__
  #elif defined(_MSC_VER)
    #define CYTHON_INLINE __inline
  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
    #define CYTHON_INLINE inline
  #else
    #define CYTHON_INLINE
  #endif
#endif
#ifndef CYTHON_RESTRICT
  #if defined(__GNUC__)
    #define CYTHON_RESTRICT __restrict__
  #elif defined(_MSC_VER) && _MSC_VER >= 1400
    #define CYTHON_RESTRICT __restrict
  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
    #define CYTHON_RESTRICT restrict
  #else
    #define CYTHON_RESTRICT
  #endif
#endif
#ifdef NAN
#define __PYX_NAN() ((float) NAN)
#else
static CYTHON_INLINE float __PYX_NAN() {
  /* Initialize NaN. The sign is irrelevant, an exponent with all bits 1 and
   a nonzero mantissa means NaN. If the first bit in the mantissa is 1, it is
   a quiet NaN. */
  float value;
  memset(&value, 0xFF, sizeof(value));
  return value;
}
#endif


#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_TrueDivide(x,y)
  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceTrueDivide(x,y)
#else
  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_Divide(x,y)
  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceDivide(x,y)
#endif

#ifndef __PYX_EXTERN_C
  #ifdef __cplusplus
    #define __PYX_EXTERN_C extern "C"
  #else
    #define __PYX_EXTERN_C extern
  #endif
#endif

#if defined(WIN32) || defined(MS_WINDOWS)
#define _USE_MATH_DEFINES
#endif
#include <math.h>
#define __PYX_HAVE__ga4py__gain__notimplemented
#define __PYX_HAVE_API__ga4py__gain__notimplemented
#include "string.h"
#include "stdio.h"
#include "stdlib.h"
#include "numpy/arrayobject.h"
#include "numpy/ufuncobject.h"
#ifdef _OPENMP
#include <omp.h>
#endif /* _OPENMP */

#ifdef PYREX_WITHOUT_ASSERTIONS
#define CYTHON_WITHOUT_ASSERTIONS
#endif

#ifndef CYTHON_UNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define CYTHON_UNUSED __attribute__ ((__unused__))
#   else
#     define CYTHON_UNUSED
#   endif
# elif defined(__ICC) || (defined(__INTEL_COMPILER) && !defined(_MSC_VER))
#   define CYTHON_UNUSED __attribute__ ((__unused__))
# else
#   define CYTHON_UNUSED
# endif
#endif
typedef struct {PyObject **p; char *s; const Py_ssize_t n; const char* encoding;
                const char is_unicode; const char is_str; const char intern; } __Pyx_StringTabEntry; /*proto*/

#define __PYX_DEFAULT_STRING_ENCODING_IS_ASCII 0
#define __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT 0
#define __PYX_DEFAULT_STRING_ENCODING ""
#define __Pyx_PyObject_FromString __Pyx_PyBytes_FromString
#define __Pyx_PyObject_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
static CYTHON_INLINE char* __Pyx_PyObject_AsString(PyObject*);
static CYTHON_INLINE char* __Pyx_PyObject_AsStringAndSize(PyObject*, Py_ssize_t* length);
#define __Pyx_PyBytes_FromString        PyBytes_FromString
#define __Pyx_PyBytes_FromStringAndSize PyBytes_FromStringAndSize
static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(char*);
#if PY_MAJOR_VERSION < 3
    #define __Pyx_PyStr_FromString        __Pyx_PyBytes_FromString
    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
#else
    #define __Pyx_PyStr_FromString        __Pyx_PyUnicode_FromString
    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyUnicode_FromStringAndSize
#endif
#define __Pyx_PyObject_AsUString(s)    ((unsigned char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_FromUString(s)  __Pyx_PyObject_FromString((char*)s)
#define __Pyx_PyBytes_FromUString(s)   __Pyx_PyBytes_FromString((char*)s)
#define __Pyx_PyStr_FromUString(s)     __Pyx_PyStr_FromString((char*)s)
#define __Pyx_PyUnicode_FromUString(s) __Pyx_PyUnicode_FromString((char*)s)
#if PY_MAJOR_VERSION < 3
static CYTHON_INLINE size_t __Pyx_Py_UNICODE_strlen(const Py_UNICODE *u)
{
    const Py_UNICODE *u_end = u;
    while (*u_end++) ;
    return u_end - u - 1;
}
#else
#define __Pyx_Py_UNICODE_strlen Py_UNICODE_strlen
#endif
#define __Pyx_PyUnicode_FromUnicode(u)       PyUnicode_FromUnicode(u, __Pyx_Py_UNICODE_strlen(u))
#define __Pyx_PyUnicode_FromUnicodeAndLength PyUnicode_FromUnicode
#define __Pyx_PyUnicode_AsUnicode            PyUnicode_AsUnicode
#define __Pyx_Owned_Py_None(b) (Py_INCREF(Py_None), Py_None)
#define __Pyx_PyBool_FromLong(b) ((b) ? (Py_INCREF(Py_True), Py_True) : (Py_INCREF(Py_False), Py_False))
static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject*);
static CYTHON_INLINE PyObject* __Pyx_PyNumber_Int(PyObject* x);
static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject*);
static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t);
static CYTHON_INLINE size_t __Pyx_PyInt_AsSize_t(PyObject*);
#if CYTHON_COMPILING_IN_CPYTHON
#define __pyx_PyFloat_AsDouble(x) (PyFloat_CheckExact(x) ? PyFloat_AS_DOUBLE(x) : PyFloat_AsDouble(x))
#else
#define __pyx_PyFloat_AsDouble(x) PyFloat_AsDouble(x)
#endif
#define __pyx_PyFloat_AsFloat(x) ((float) __pyx_PyFloat_AsDouble(x))
#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
static int __Pyx_sys_getdefaultencoding_not_ascii;
static int __Pyx_init_sys_getdefaultencoding_params() {
    PyObject* sys = NULL;
    PyObject* default_encoding = NULL;
    PyObject* ascii_chars_u = NULL;
    PyObject* ascii_chars_b = NULL;
    sys = PyImport_ImportModule("sys");
    if (sys == NULL) goto bad;
    default_encoding = PyObject_CallMethod(sys, (char*) (const char*) "getdefaultencoding", NULL);
    if (default_encoding == NULL) goto bad;
    if (strcmp(PyBytes_AsString(default_encoding), "ascii") == 0) {
        __Pyx_sys_getdefaultencoding_not_ascii = 0;
    } else {
        const char* default_encoding_c = PyBytes_AS_STRING(default_encoding);
        char ascii_chars[128];
        int c;
        for (c = 0; c < 128; c++) {
            ascii_chars[c] = c;
        }
        __Pyx_sys_getdefaultencoding_not_ascii = 1;
        ascii_chars_u = PyUnicode_DecodeASCII(ascii_chars, 128, NULL);
        if (ascii_chars_u == NULL) goto bad;
        ascii_chars_b = PyUnicode_AsEncodedString(ascii_chars_u, default_encoding_c, NULL);
        if (ascii_chars_b == NULL || strncmp(ascii_chars, PyBytes_AS_STRING(ascii_chars_b), 128) != 0) {
            PyErr_Format(
                PyExc_ValueError,
                "This module compiled with c_string_encoding=ascii, but default encoding '%s' is not a superset of ascii.",
                default_encoding_c);
            goto bad;
        }
    }
    Py_XDECREF(sys);
    Py_XDECREF(default_encoding);
    Py_XDECREF(ascii_chars_u);
    Py_XDECREF(ascii_chars_b);
    return 0;
bad:
    Py_XDECREF(sys);
    Py_XDECREF(default_encoding);
    Py_XDECREF(ascii_chars_u);
    Py_XDECREF(ascii_chars_b);
    return -1;
}
#endif
#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT && PY_MAJOR_VERSION >= 3
#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_DecodeUTF8(c_str, size, NULL)
#else
#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_Decode(c_str, size, __PYX_DEFAULT_STRING_ENCODING, NULL)
#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
static char* __PYX_DEFAULT_STRING_ENCODING;
static int __Pyx_init_sys_getdefaultencoding_params() {
    PyObject* sys = NULL;
    PyObject* default_encoding = NULL;
    char* default_encoding_c;
    sys = PyImport_ImportModule("sys");
    if (sys == NULL) goto bad;
    default_encoding = PyObject_CallMethod(sys, (char*) (const char*) "getdefaultencoding", NULL);
    if (default_encoding == NULL) goto bad;
    default_encoding_c = PyBytes_AS_STRING(default_encoding);
    __PYX_DEFAULT_STRING_ENCODING = (char*) malloc(strlen(default_encoding_c));
    strcpy(__PYX_DEFAULT_STRING_ENCODING, default_encoding_c);
    Py_DECREF(sys);
    Py_DECREF(default_encoding);
    return 0;
bad:
    Py_XDECREF(sys);
    Py_XDECREF(default_encoding);
    return -1;
}
#endif
#endif


#ifdef __GNUC__
  /* Test for GCC > 2.95 */
  #if __GNUC__ > 2 || (__GNUC__ == 2 && (__GNUC_MINOR__ > 95))
    #define likely(x)   __builtin_expect(!!(x), 1)
    #define unlikely(x) __builtin_expect(!!(x), 0)
  #else /* __GNUC__ > 2 ... */
    #define likely(x)   (x)
    #define unlikely(x) (x)
  #endif /* __GNUC__ > 2 ... */
#else /* __GNUC__ */
  #define likely(x)   (x)
  #define unlikely(x) (x)
#endif /* __GNUC__ */

static PyObject *__pyx_m;
static PyObject *__pyx_d;
static PyObject *__pyx_b;
static PyObject *__pyx_empty_tuple;
static PyObject *__pyx_empty_bytes;
static int __pyx_lineno;
static int __pyx_clineno = 0;
static const char * __pyx_cfilenm= __FILE__;
static const char *__pyx_filename;

#if !defined(CYTHON_CCOMPLEX)
  #if defined(__cplusplus)
    #define CYTHON_CCOMPLEX 1
  #elif defined(_Complex_I)
    #define CYTHON_CCOMPLEX 1
  #else
    #define CYTHON_CCOMPLEX 0
  #endif
#endif
#if CYTHON_CCOMPLEX
  #ifdef __cplusplus
    #include <complex>
  #else
    #include <complex.h>
  #endif
#endif
#if CYTHON_CCOMPLEX && !defined(__cplusplus) && defined(__sun__) && defined(__GNUC__)
  #undef _Complex_I
  #define _Complex_I 1.0fj
#endif


static const char *__pyx_f[] = {
  "notimplemented.pyx",
  "numpy.pxd",
  "type.pxd",
};

/* "numpy.pxd":723
 * # in Cython to enable them only on the right systems.
 * 
 * ctypedef npy_int8       int8_t             # <<<<<<<<<<<<<<
 * ctypedef npy_int16      int16_t
 * ctypedef npy_int32      int32_t
 */
typedef npy_int8 __pyx_t_5numpy_int8_t;

/* "numpy.pxd":724
 * 
 * ctypedef npy_int8       int8_t
 * ctypedef npy_int16      int16_t             # <<<<<<<<<<<<<<
 * ctypedef npy_int32      int32_t
 * ctypedef npy_int64      int64_t
 */
typedef npy_int16 __pyx_t_5numpy_int16_t;

/* "numpy.pxd":725
 * ctypedef npy_int8       int8_t
 * ctypedef npy_int16      int16_t
 * ctypedef npy_int32      int32_t             # <<<<<<<<<<<<<<
 * ctypedef npy_int64      int64_t
 * #ctypedef npy_int96      int96_t
 */
typedef npy_int32 __pyx_t_5numpy_int32_t;

/* "numpy.pxd":726
 * ctypedef npy_int16      int16_t
 * ctypedef npy_int32      int32_t
 * ctypedef npy_int64      int64_t             # <<<<<<<<<<<<<<
 * #ctypedef npy_int96      int96_t
 * #ctypedef npy_int128     int128_t
 */
typedef npy_int64 __pyx_t_5numpy_int64_t;

/* "numpy.pxd":730
 * #ctypedef npy_int128     int128_t
 * 
 * ctypedef npy_uint8      uint8_t             # <<<<<<<<<<<<<<
 * ctypedef npy_uint16     uint16_t
 * ctypedef npy_uint32     uint32_t
 */
typedef npy_uint8 __pyx_t_5numpy_uint8_t;

/* "numpy.pxd":731
 * 
 * ctypedef npy_uint8      uint8_t
 * ctypedef npy_uint16     uint16_t             # <<<<<<<<<<<<<<
 * ctypedef npy_uint32     uint32_t
 * ctypedef npy_uint64     uint64_t
 */
typedef npy_uint16 __pyx_t_5numpy_uint16_t;

/* "numpy.pxd":732
 * ctypedef npy_uint8      uint8_t
 * ctypedef npy_uint16     uint16_t
 * ctypedef npy_uint32     uint32_t             # <<<<<<<<<<<<<<
 * ctypedef npy_uint64     uint64_t
 * #ctypedef npy_uint96     uint96_t
 */
typedef npy_uint32 __pyx_t_5numpy_uint32_t;

/* "numpy.pxd":733
 * ctypedef npy_uint16     uint16_t
 * ctypedef npy_uint32     uint32_t
 * ctypedef npy_uint64     uint64_t             # <<<<<<<<<<<<<<
 * #ctypedef npy_uint96     uint96_t
 * #ctypedef npy_uint128    uint128_t
 */
typedef npy_uint64 __pyx_t_5numpy_uint64_t;

/* "numpy.pxd":737
 * #ctypedef npy_uint128    uint128_t
 * 
 * ctypedef npy_float32    float32_t             # <<<<<<<<<<<<<<
 * ctypedef npy_float64    float64_t
 * #ctypedef npy_float80    float80_t
 */
typedef npy_float32 __pyx_t_5numpy_float32_t;

/* "numpy.pxd":738
 * 
 * ctypedef npy_float32    float32_t
 * ctypedef npy_float64    float64_t             # <<<<<<<<<<<<<<
 * #ctypedef npy_float80    float80_t
 * #ctypedef npy_float128   float128_t
 */
typedef npy_float64 __pyx_t_5numpy_float64_t;

/* "numpy.pxd":747
 * # The int types are mapped a bit surprising --
 * # numpy.int corresponds to 'l' and numpy.long to 'q'
 * ctypedef npy_long       int_t             # <<<<<<<<<<<<<<
 * ctypedef npy_longlong   long_t
 * ctypedef npy_longlong   longlong_t
 */
typedef npy_long __pyx_t_5numpy_int_t;

/* "numpy.pxd":748
 * # numpy.int corresponds to 'l' and numpy.long to 'q'
 * ctypedef npy_long       int_t
 * ctypedef npy_longlong   long_t             # <<<<<<<<<<<<<<
 * ctypedef npy_longlong   longlong_t
 * 
 */
typedef npy_longlong __pyx_t_5numpy_long_t;

/* "numpy.pxd":749
 * ctypedef npy_long       int_t
 * ctypedef npy_longlong   long_t
 * ctypedef npy_longlong   longlong_t             # <<<<<<<<<<<<<<
 * 
 * ctypedef npy_ulong      uint_t
 */
typedef npy_longlong __pyx_t_5numpy_longlong_t;

/* "numpy.pxd":751
 * ctypedef npy_longlong   longlong_t
 * 
 * ctypedef npy_ulong      uint_t             # <<<<<<<<<<<<<<
 * ctypedef npy_ulonglong  ulong_t
 * ctypedef npy_ulonglong  ulonglong_t
 */
typedef npy_ulong __pyx_t_5numpy_uint_t;

/* "numpy.pxd":752
 * 
 * ctypedef npy_ulong      uint_t
 * ctypedef npy_ulonglong  ulong_t             # <<<<<<<<<<<<<<
 * ctypedef npy_ulonglong  ulonglong_t
 * 
 */
typedef npy_ulonglong __pyx_t_5numpy_ulong_t;

/* "numpy.pxd":753
 * ctypedef npy_ulong      uint_t
 * ctypedef npy_ulonglong  ulong_t
 * ctypedef npy_ulonglong  ulonglong_t             # <<<<<<<<<<<<<<
 * 
 * ctypedef npy_intp       intp_t
 */
typedef npy_ulonglong __pyx_t_5numpy_ulonglong_t;

/* "numpy.pxd":755
 * ctypedef npy_ulonglong  ulonglong_t
 * 
 * ctypedef npy_intp       intp_t             # <<<<<<<<<<<<<<
 * ctypedef npy_uintp      uintp_t
 * 
 */
typedef npy_intp __pyx_t_5numpy_intp_t;

/* "numpy.pxd":756
 * 
 * ctypedef npy_intp       intp_t
 * ctypedef npy_uintp      uintp_t             # <<<<<<<<<<<<<<
 * 
 * ctypedef npy_double     float_t
 */
typedef npy_uintp __pyx_t_5numpy_uintp_t;

/* "numpy.pxd":758
 * ctypedef npy_uintp      uintp_t
 * 
 * ctypedef npy_double     float_t             # <<<<<<<<<<<<<<
 * ctypedef npy_double     double_t
 * ctypedef npy_longdouble longdouble_t
 */
typedef npy_double __pyx_t_5numpy_float_t;

/* "numpy.pxd":759
 * 
 * ctypedef npy_double     float_t
 * ctypedef npy_double     double_t             # <<<<<<<<<<<<<<
 * ctypedef npy_longdouble longdouble_t
 * 
 */
typedef npy_double __pyx_t_5numpy_double_t;

/* "numpy.pxd":760
 * ctypedef npy_double     float_t
 * ctypedef npy_double     double_t
 * ctypedef npy_longdouble longdouble_t             # <<<<<<<<<<<<<<
 * 
 * ctypedef npy_cfloat      cfloat_t
 */
typedef npy_longdouble __pyx_t_5numpy_longdouble_t;
#if CYTHON_CCOMPLEX
  #ifdef __cplusplus
    typedef ::std::complex< float > __pyx_t_float_complex;
  #else
    typedef float _Complex __pyx_t_float_complex;
  #endif
#else
    typedef struct { float real, imag; } __pyx_t_float_complex;
#endif

#if CYTHON_CCOMPLEX
  #ifdef __cplusplus
    typedef ::std::complex< double > __pyx_t_double_complex;
  #else
    typedef double _Complex __pyx_t_double_complex;
  #endif
#else
    typedef struct { double real, imag; } __pyx_t_double_complex;
#endif


/*--- Type declarations ---*/

/* "numpy.pxd":762
 * ctypedef npy_longdouble longdouble_t
 * 
 * ctypedef npy_cfloat      cfloat_t             # <<<<<<<<<<<<<<
 * ctypedef npy_cdouble     cdouble_t
 * ctypedef npy_clongdouble clongdouble_t
 */
typedef npy_cfloat __pyx_t_5numpy_cfloat_t;

/* "numpy.pxd":763
 * 
 * ctypedef npy_cfloat      cfloat_t
 * ctypedef npy_cdouble     cdouble_t             # <<<<<<<<<<<<<<
 * ctypedef npy_clongdouble clongdouble_t
 * 
 */
typedef npy_cdouble __pyx_t_5numpy_cdouble_t;

/* "numpy.pxd":764
 * ctypedef npy_cfloat      cfloat_t
 * ctypedef npy_cdouble     cdouble_t
 * ctypedef npy_clongdouble clongdouble_t             # <<<<<<<<<<<<<<
 * 
 * ctypedef npy_cdouble     complex_t
 */
typedef npy_clongdouble __pyx_t_5numpy_clongdouble_t;

/* "numpy.pxd":766
 * ctypedef npy_clongdouble clongdouble_t
 * 
 * ctypedef npy_cdouble     complex_t             # <<<<<<<<<<<<<<
 * 
 * cdef inline object PyArray_MultiIterNew1(a):
 */
typedef npy_cdouble __pyx_t_5numpy_complex_t;
#ifndef CYTHON_REFNANNY
  #define CYTHON_REFNANNY 0
#endif
#if CYTHON_REFNANNY
  typedef struct {
    void (*INCREF)(void*, PyObject*, int);
    void (*DECREF)(void*, PyObject*, int);
    void (*GOTREF)(void*, PyObject*, int);
    void (*GIVEREF)(void*, PyObject*, int);
    void* (*SetupContext)(const char*, int, const char*);
    void (*FinishContext)(void**);
  } __Pyx_RefNannyAPIStruct;
  static __Pyx_RefNannyAPIStruct *__Pyx_RefNanny = NULL;
  static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname); /*proto*/
  #define __Pyx_RefNannyDeclarations void *__pyx_refnanny = NULL;
#ifdef WITH_THREAD
  #define __Pyx_RefNannySetupContext(name, acquire_gil) \
          if (acquire_gil) { \
              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure(); \
              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__); \
              PyGILState_Release(__pyx_gilstate_save); \
          } else { \
              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__); \
          }
#else
  #define __Pyx_RefNannySetupContext(name, acquire_gil) \
          __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__)
#endif
  #define __Pyx_RefNannyFinishContext() \
          __Pyx_RefNanny->FinishContext(&__pyx_refnanny)
  #define __Pyx_INCREF(r)  __Pyx_RefNanny->INCREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_DECREF(r)  __Pyx_RefNanny->DECREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_GOTREF(r)  __Pyx_RefNanny->GOTREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_GIVEREF(r) __Pyx_RefNanny->GIVEREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_XINCREF(r)  do { if((r) != NULL) {__Pyx_INCREF(r); }} while(0)
  #define __Pyx_XDECREF(r)  do { if((r) != NULL) {__Pyx_DECREF(r); }} while(0)
  #define __Pyx_XGOTREF(r)  do { if((r) != NULL) {__Pyx_GOTREF(r); }} while(0)
  #define __Pyx_XGIVEREF(r) do { if((r) != NULL) {__Pyx_GIVEREF(r);}} while(0)
#else
  #define __Pyx_RefNannyDeclarations
  #define __Pyx_RefNannySetupContext(name, acquire_gil)
  #define __Pyx_RefNannyFinishContext()
  #define __Pyx_INCREF(r) Py_INCREF(r)
  #define __Pyx_DECREF(r) Py_DECREF(r)
  #define __Pyx_GOTREF(r)
  #define __Pyx_GIVEREF(r)
  #define __Pyx_XINCREF(r) Py_XINCREF(r)
  #define __Pyx_XDECREF(r) Py_XDECREF(r)
  #define __Pyx_XGOTREF(r)
  #define __Pyx_XGIVEREF(r)
#endif /* CYTHON_REFNANNY */
#define __Pyx_XDECREF_SET(r, v) do {                            \
        PyObject *tmp = (PyObject *) r;                         \
        r = v; __Pyx_XDECREF(tmp);                              \
    } while (0)
#define __Pyx_DECREF_SET(r, v) do {                             \
        PyObject *tmp = (PyObject *) r;                         \
        r = v; __Pyx_DECREF(tmp);                               \
    } while (0)
#define __Pyx_CLEAR(r)    do { PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);} while(0)
#define __Pyx_XCLEAR(r)   do { if((r) != NULL) {PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);}} while(0)

#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name) {
    PyTypeObject* tp = Py_TYPE(obj);
    if (likely(tp->tp_getattro))
        return tp->tp_getattro(obj, attr_name);
#if PY_MAJOR_VERSION < 3
    if (likely(tp->tp_getattr))
        return tp->tp_getattr(obj, PyString_AS_STRING(attr_name));
#endif
    return PyObject_GetAttr(obj, attr_name);
}
#else
#define __Pyx_PyObject_GetAttrStr(o,n) PyObject_GetAttr(o,n)
#endif

static PyObject *__Pyx_GetBuiltinName(PyObject *name); /*proto*/

static void __Pyx_RaiseArgtupleInvalid(const char* func_name, int exact,
    Py_ssize_t num_min, Py_ssize_t num_max, Py_ssize_t num_found); /*proto*/

static void __Pyx_RaiseDoubleKeywordsError(const char* func_name, PyObject* kw_name); /*proto*/

static int __Pyx_ParseOptionalKeywords(PyObject *kwds, PyObject **argnames[], \
    PyObject *kwds2, PyObject *values[], Py_ssize_t num_pos_args, \
    const char* function_name); /*proto*/

static CYTHON_INLINE void __Pyx_ErrRestore(PyObject *type, PyObject *value, PyObject *tb); /*proto*/
static CYTHON_INLINE void __Pyx_ErrFetch(PyObject **type, PyObject **value, PyObject **tb); /*proto*/

static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause); /*proto*/

static CYTHON_INLINE int __Pyx_CheckKeywordStrings(PyObject *kwdict, const char* function_name, int kw_allowed); /*proto*/

static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected);

static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index);

static CYTHON_INLINE void __Pyx_RaiseNoneNotIterableError(void);

static CYTHON_INLINE int __Pyx_IterFinish(void); /*proto*/

static int __Pyx_IternextUnpackEndCheck(PyObject *retval, Py_ssize_t expected); /*proto*/

static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type); /*proto*/

static CYTHON_INLINE PyObject *__Pyx_GetModuleGlobalName(PyObject *name); /*proto*/

static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level); /*proto*/

#if CYTHON_CCOMPLEX
  #ifdef __cplusplus
    #define __Pyx_CREAL(z) ((z).real())
    #define __Pyx_CIMAG(z) ((z).imag())
  #else
    #define __Pyx_CREAL(z) (__real__(z))
    #define __Pyx_CIMAG(z) (__imag__(z))
  #endif
#else
    #define __Pyx_CREAL(z) ((z).real)
    #define __Pyx_CIMAG(z) ((z).imag)
#endif
#if defined(_WIN32) && defined(__cplusplus) && CYTHON_CCOMPLEX
    #define __Pyx_SET_CREAL(z,x) ((z).real(x))
    #define __Pyx_SET_CIMAG(z,y) ((z).imag(y))
#else
    #define __Pyx_SET_CREAL(z,x) __Pyx_CREAL(z) = (x)
    #define __Pyx_SET_CIMAG(z,y) __Pyx_CIMAG(z) = (y)
#endif

static CYTHON_INLINE __pyx_t_float_complex __pyx_t_float_complex_from_parts(float, float);

#if CYTHON_CCOMPLEX
    #define __Pyx_c_eqf(a, b)   ((a)==(b))
    #define __Pyx_c_sumf(a, b)  ((a)+(b))
    #define __Pyx_c_difff(a, b) ((a)-(b))
    #define __Pyx_c_prodf(a, b) ((a)*(b))
    #define __Pyx_c_quotf(a, b) ((a)/(b))
    #define __Pyx_c_negf(a)     (-(a))
  #ifdef __cplusplus
    #define __Pyx_c_is_zerof(z) ((z)==(float)0)
    #define __Pyx_c_conjf(z)    (::std::conj(z))
    #if 1
        #define __Pyx_c_absf(z)     (::std::abs(z))
        #define __Pyx_c_powf(a, b)  (::std::pow(a, b))
    #endif
  #else
    #define __Pyx_c_is_zerof(z) ((z)==0)
    #define __Pyx_c_conjf(z)    (conjf(z))
    #if 1
        #define __Pyx_c_absf(z)     (cabsf(z))
        #define __Pyx_c_powf(a, b)  (cpowf(a, b))
    #endif
 #endif
#else
    static CYTHON_INLINE int __Pyx_c_eqf(__pyx_t_float_complex, __pyx_t_float_complex);
    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_sumf(__pyx_t_float_complex, __pyx_t_float_complex);
    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_difff(__pyx_t_float_complex, __pyx_t_float_complex);
    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_prodf(__pyx_t_float_complex, __pyx_t_float_complex);
    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_quotf(__pyx_t_float_complex, __pyx_t_float_complex);
    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_negf(__pyx_t_float_complex);
    static CYTHON_INLINE int __Pyx_c_is_zerof(__pyx_t_float_complex);
    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_conjf(__pyx_t_float_complex);
    #if 1
        static CYTHON_INLINE float __Pyx_c_absf(__pyx_t_float_complex);
        static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_powf(__pyx_t_float_complex, __pyx_t_float_complex);
    #endif
#endif

static CYTHON_INLINE __pyx_t_double_complex __pyx_t_double_complex_from_parts(double, double);

#if CYTHON_CCOMPLEX
    #define __Pyx_c_eq(a, b)   ((a)==(b))
    #define __Pyx_c_sum(a, b)  ((a)+(b))
    #define __Pyx_c_diff(a, b) ((a)-(b))
    #define __Pyx_c_prod(a, b) ((a)*(b))
    #define __Pyx_c_quot(a, b) ((a)/(b))
    #define __Pyx_c_neg(a)     (-(a))
  #ifdef __cplusplus
    #define __Pyx_c_is_zero(z) ((z)==(double)0)
    #define __Pyx_c_conj(z)    (::std::conj(z))
    #if 1
        #define __Pyx_c_abs(z)     (::std::abs(z))
        #define __Pyx_c_pow(a, b)  (::std::pow(a, b))
    #endif
  #else
    #define __Pyx_c_is_zero(z) ((z)==0)
    #define __Pyx_c_conj(z)    (conj(z))
    #if 1
        #define __Pyx_c_abs(z)     (cabs(z))
        #define __Pyx_c_pow(a, b)  (cpow(a, b))
    #endif
 #endif
#else
    static CYTHON_INLINE int __Pyx_c_eq(__pyx_t_double_complex, __pyx_t_double_complex);
    static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_sum(__pyx_t_double_complex, __pyx_t_double_complex);
    static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_diff(__pyx_t_double_complex, __pyx_t_double_complex);
    static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_prod(__pyx_t_double_complex, __pyx_t_double_complex);
    static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_quot(__pyx_t_double_complex, __pyx_t_double_complex);
    static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_neg(__pyx_t_double_complex);
    static CYTHON_INLINE int __Pyx_c_is_zero(__pyx_t_double_complex);
    static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_conj(__pyx_t_double_complex);
    #if 1
        static CYTHON_INLINE double __Pyx_c_abs(__pyx_t_double_complex);
        static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_pow(__pyx_t_double_complex, __pyx_t_double_complex);
    #endif
#endif

static CYTHON_INLINE unsigned char __Pyx_PyInt_AsUnsignedChar(PyObject *);

static CYTHON_INLINE unsigned short __Pyx_PyInt_AsUnsignedShort(PyObject *);

static CYTHON_INLINE unsigned int __Pyx_PyInt_AsUnsignedInt(PyObject *);

static CYTHON_INLINE char __Pyx_PyInt_AsChar(PyObject *);

static CYTHON_INLINE short __Pyx_PyInt_AsShort(PyObject *);

static CYTHON_INLINE int __Pyx_PyInt_AsInt(PyObject *);

static CYTHON_INLINE signed char __Pyx_PyInt_AsSignedChar(PyObject *);

static CYTHON_INLINE signed short __Pyx_PyInt_AsSignedShort(PyObject *);

static CYTHON_INLINE signed int __Pyx_PyInt_AsSignedInt(PyObject *);

static CYTHON_INLINE int __Pyx_PyInt_AsLongDouble(PyObject *);

static CYTHON_INLINE unsigned long __Pyx_PyInt_AsUnsignedLong(PyObject *);

static CYTHON_INLINE unsigned PY_LONG_LONG __Pyx_PyInt_AsUnsignedLongLong(PyObject *);

static CYTHON_INLINE long __Pyx_PyInt_AsLong(PyObject *);

static CYTHON_INLINE PY_LONG_LONG __Pyx_PyInt_AsLongLong(PyObject *);

static CYTHON_INLINE signed long __Pyx_PyInt_AsSignedLong(PyObject *);

static CYTHON_INLINE signed PY_LONG_LONG __Pyx_PyInt_AsSignedLongLong(PyObject *);

static int __Pyx_check_binary_version(void);

#if !defined(__Pyx_PyIdentifier_FromString)
#if PY_MAJOR_VERSION < 3
  #define __Pyx_PyIdentifier_FromString(s) PyString_FromString(s)
#else
  #define __Pyx_PyIdentifier_FromString(s) PyUnicode_FromString(s)
#endif
#endif

static PyObject *__Pyx_ImportModule(const char *name); /*proto*/

static PyTypeObject *__Pyx_ImportType(const char *module_name, const char *class_name, size_t size, int strict);  /*proto*/

typedef struct {
    int code_line;
    PyCodeObject* code_object;
} __Pyx_CodeObjectCacheEntry;
struct __Pyx_CodeObjectCache {
    int count;
    int max_count;
    __Pyx_CodeObjectCacheEntry* entries;
};
static struct __Pyx_CodeObjectCache __pyx_code_cache = {0,0,NULL};
static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line);
static PyCodeObject *__pyx_find_code_object(int code_line);
static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object);

static void __Pyx_AddTraceback(const char *funcname, int c_line,
                               int py_line, const char *filename); /*proto*/

static int __Pyx_InitStrings(__Pyx_StringTabEntry *t); /*proto*/


/* Module declarations from 'cpython.buffer' */

/* Module declarations from 'cpython.ref' */

/* Module declarations from 'libc.string' */

/* Module declarations from 'libc.stdio' */

/* Module declarations from 'cpython.object' */

/* Module declarations from '__builtin__' */

/* Module declarations from 'cpython.type' */
static PyTypeObject *__pyx_ptype_7cpython_4type_type = 0;

/* Module declarations from 'libc.stdlib' */

/* Module declarations from 'numpy' */

/* Module declarations from 'numpy' */
static PyTypeObject *__pyx_ptype_5numpy_dtype = 0;
static PyTypeObject *__pyx_ptype_5numpy_flatiter = 0;
static PyTypeObject *__pyx_ptype_5numpy_broadcast = 0;
static PyTypeObject *__pyx_ptype_5numpy_ndarray = 0;
static PyTypeObject *__pyx_ptype_5numpy_ufunc = 0;
static CYTHON_INLINE char *__pyx_f_5numpy__util_dtypestring(PyArray_Descr *, char *, char *, int *); /*proto*/

/* Module declarations from 'ga4py.gain.notimplemented' */
#define __Pyx_MODULE_NAME "ga4py.gain.notimplemented"
int __pyx_module_is_main_ga4py__gain__notimplemented = 0;

/* Implementation of 'ga4py.gain.notimplemented' */
static PyObject *__pyx_builtin_NotImplementedError;
static PyObject *__pyx_builtin_ValueError;
static PyObject *__pyx_builtin_range;
static PyObject *__pyx_builtin_RuntimeError;
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_docstring(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_obj, CYTHON_UNUSED PyObject *__pyx_v_docstring); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_2add_newdoc(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_place, CYTHON_UNUSED PyObject *__pyx_v_obj, CYTHON_UNUSED PyObject *__pyx_v_doc); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_4all(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_6allclose(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_b, CYTHON_UNUSED PyObject *__pyx_v_rtol, CYTHON_UNUSED PyObject *__pyx_v_atol); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_8alltrue(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_10alterdot(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_12amax(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_14amin(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_16angle(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_z, CYTHON_UNUSED PyObject *__pyx_v_deg); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_18any(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_20append(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_arr, CYTHON_UNUSED PyObject *__pyx_v_values, CYTHON_UNUSED PyObject *__pyx_v_axis); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_22apply_along_axis(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_func1d, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_arr); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_24apply_over_axes(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_func, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axes); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_26argmax(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_28argmin(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_30argsort(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_kind, CYTHON_UNUSED PyObject *__pyx_v_order); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_32argwhere(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_34around(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_decimals, CYTHON_UNUSED PyObject *__pyx_v_out); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_36array(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_object, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_copy, CYTHON_UNUSED PyObject *__pyx_v_order, CYTHON_UNUSED PyObject *__pyx_v_subok, CYTHON_UNUSED PyObject *__pyx_v_ndmin); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_38array2string(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_max_line_width, CYTHON_UNUSED PyObject *__pyx_v_precision, CYTHON_UNUSED PyObject *__pyx_v_suppress_small, CYTHON_UNUSED PyObject *__pyx_v_separator, CYTHON_UNUSED PyObject *__pyx_v_prefix, CYTHON_UNUSED PyObject *__pyx_v_style); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_40array_equal(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a1, CYTHON_UNUSED PyObject *__pyx_v_a2); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_42array_equiv(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a1, CYTHON_UNUSED PyObject *__pyx_v_a2); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_44array_repr(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_arr, CYTHON_UNUSED PyObject *__pyx_v_max_line_width, CYTHON_UNUSED PyObject *__pyx_v_precision, CYTHON_UNUSED PyObject *__pyx_v_suppress_small); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_46array_split(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_ary, CYTHON_UNUSED PyObject *__pyx_v_indices_or_sections, CYTHON_UNUSED PyObject *__pyx_v_axis); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_48array_str(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_max_line_width, CYTHON_UNUSED PyObject *__pyx_v_precision, CYTHON_UNUSED PyObject *__pyx_v_suppress_small); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_50asanyarray(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_order); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_52asarray_chkfinite(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_54ascontiguousarray(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_dtype); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_56asfarray(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_dtype); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_58asfortranarray(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_dtype); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_60asmatrix(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_data, CYTHON_UNUSED PyObject *__pyx_v_dtype); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_62asscalar(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_64atleast_1d(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_66atleast_2d(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_68atleast_3d(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_70average(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_weights, CYTHON_UNUSED PyObject *__pyx_v_returned); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_72bartlett(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_M); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_74base_repr(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_number, CYTHON_UNUSED PyObject *__pyx_v_base, CYTHON_UNUSED PyObject *__pyx_v_padding); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_76binary_repr(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_num, CYTHON_UNUSED PyObject *__pyx_v_width); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_78bincount(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_weights, CYTHON_UNUSED PyObject *__pyx_v_minlength); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_80blackman(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_M); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_82bmat(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_obj, CYTHON_UNUSED PyObject *__pyx_v_ldict, CYTHON_UNUSED PyObject *__pyx_v_gdict); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_84broadcast_arrays(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_86byte_bounds(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_88can_cast(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_90choose(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_choices, CYTHON_UNUSED PyObject *__pyx_v_out, CYTHON_UNUSED PyObject *__pyx_v_mode); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_92column_stack(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_tup); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_94common_type(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_96compare_chararrays(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_98compress(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_condition, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_100concatenate(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_102convolve(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_v, CYTHON_UNUSED PyObject *__pyx_v_mode); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_104copy(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_106corrcoef(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_y, CYTHON_UNUSED PyObject *__pyx_v_rowvar, CYTHON_UNUSED PyObject *__pyx_v_bias, CYTHON_UNUSED PyObject *__pyx_v_ddof); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_108correlate(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_v, CYTHON_UNUSED PyObject *__pyx_v_mode, CYTHON_UNUSED PyObject *__pyx_v_old_behavior); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_110count_nonzero(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_112cov(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_m, CYTHON_UNUSED PyObject *__pyx_v_y, CYTHON_UNUSED PyObject *__pyx_v_rowvar, CYTHON_UNUSED PyObject *__pyx_v_bias, CYTHON_UNUSED PyObject *__pyx_v_ddof); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_114cross(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_b, CYTHON_UNUSED PyObject *__pyx_v_axisa, CYTHON_UNUSED PyObject *__pyx_v_axisb, CYTHON_UNUSED PyObject *__pyx_v_axisc, CYTHON_UNUSED PyObject *__pyx_v_axis); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_116cumprod(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_out); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_118cumproduct(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_out); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_120cumsum(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_out); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_122datetime_data(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_dtype); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_124delete(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_arr, CYTHON_UNUSED PyObject *__pyx_v_obj, CYTHON_UNUSED PyObject *__pyx_v_axis); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_126deprecate(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_128deprecate_with_doc(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_msg); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_130diag_indices(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_n, CYTHON_UNUSED PyObject *__pyx_v_ndim); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_132diag_indices_from(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_arr); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_134diagflat(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_v, CYTHON_UNUSED PyObject *__pyx_v_k); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_136diff(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_n, CYTHON_UNUSED PyObject *__pyx_v_axis); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_138digitize(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_bins); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_140disp(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_mesg, CYTHON_UNUSED PyObject *__pyx_v_device, CYTHON_UNUSED PyObject *__pyx_v_linefeed); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_142dsplit(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_ary, CYTHON_UNUSED PyObject *__pyx_v_indices_or_sections); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_144dstack(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_tup); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_146ediff1d(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_ary, CYTHON_UNUSED PyObject *__pyx_v_to_end, CYTHON_UNUSED PyObject *__pyx_v_to_begin); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_148einsum(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_150expand_dims(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_152extract(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_condition, CYTHON_UNUSED PyObject *__pyx_v_arr); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_154_fastCopyAndTranspose(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_156fill_diagonal(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_val); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_158find_common_type(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_array_types, CYTHON_UNUSED PyObject *__pyx_v_scalar_types); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_160fix(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_y); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_162flatnonzero(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_164fliplr(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_m); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_166flipud(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_m); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_168frombuffer(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_buffer, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_count, CYTHON_UNUSED PyObject *__pyx_v_offset); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_170fromfile(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_file, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_count, CYTHON_UNUSED PyObject *__pyx_v_sep); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_172fromiter(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_iterable, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_count); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_174frompyfunc(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_func, CYTHON_UNUSED PyObject *__pyx_v_nin, CYTHON_UNUSED PyObject *__pyx_v_nout); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_176fromregex(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_file, CYTHON_UNUSED PyObject *__pyx_v_regexp, CYTHON_UNUSED PyObject *__pyx_v_dtype); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_178fromstring(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_string, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_count, CYTHON_UNUSED PyObject *__pyx_v_sep); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_180fv(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_rate, CYTHON_UNUSED PyObject *__pyx_v_nper, CYTHON_UNUSED PyObject *__pyx_v_pmt, CYTHON_UNUSED PyObject *__pyx_v_pv, CYTHON_UNUSED PyObject *__pyx_v_when); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_182genfromtxt(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_fname, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_comments, CYTHON_UNUSED PyObject *__pyx_v_delimiter, CYTHON_UNUSED PyObject *__pyx_v_skiprows, CYTHON_UNUSED PyObject *__pyx_v_skip_header, CYTHON_UNUSED PyObject *__pyx_v_skip_footer, CYTHON_UNUSED PyObject *__pyx_v_converters, CYTHON_UNUSED PyObject *__pyx_v_missing, CYTHON_UNUSED PyObject *__pyx_v_missing_values, CYTHON_UNUSED PyObject *__pyx_v_filling_values, CYTHON_UNUSED PyObject *__pyx_v_usecols, CYTHON_UNUSED PyObject *__pyx_v_names, CYTHON_UNUSED PyObject *__pyx_v_excludelist, CYTHON_UNUSED PyObject *__pyx_v_deletechars, CYTHON_UNUSED PyObject *__pyx_v_replace_space, CYTHON_UNUSED PyObject *__pyx_v_autostrip, CYTHON_UNUSED PyObject *__pyx_v_case_sensitive, CYTHON_UNUSED PyObject *__pyx_v_defaultfmt, CYTHON_UNUSED PyObject *__pyx_v_unpack, CYTHON_UNUSED PyObject *__pyx_v_usemask, CYTHON_UNUSED PyObject *__pyx_v_loose, CYTHON_UNUSED PyObject *__pyx_v_invalid_raise); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_184get_array_wrap(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_186get_include(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_188get_numarray_include(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_type); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_190get_printoptions(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_192getbuffer(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_194getbufsize(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_196geterr(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_198geterrcall(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_200geterrobj(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_202gradient(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_f); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_204hamming(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_M); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_206hanning(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_M); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_208histogram(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_bins, CYTHON_UNUSED PyObject *__pyx_v_range, CYTHON_UNUSED PyObject *__pyx_v_normed, CYTHON_UNUSED PyObject *__pyx_v_weights, CYTHON_UNUSED PyObject *__pyx_v_density); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_210histogram2d(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_y, CYTHON_UNUSED PyObject *__pyx_v_bins, CYTHON_UNUSED PyObject *__pyx_v_range, CYTHON_UNUSED PyObject *__pyx_v_normed, CYTHON_UNUSED PyObject *__pyx_v_weights); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_212histogramdd(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_sample, CYTHON_UNUSED PyObject *__pyx_v_bins, CYTHON_UNUSED PyObject *__pyx_v_range, CYTHON_UNUSED PyObject *__pyx_v_normed, CYTHON_UNUSED PyObject *__pyx_v_weights); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_214hsplit(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_ary, CYTHON_UNUSED PyObject *__pyx_v_indices_or_sections); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_216hstack(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_tup); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_218i0(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_220imag(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_val); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_222in1d(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_ar1, CYTHON_UNUSED PyObject *__pyx_v_ar2, CYTHON_UNUSED PyObject *__pyx_v_assume_unique); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_224indices(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_dimensions, CYTHON_UNUSED PyObject *__pyx_v_dtype); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_226info(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_object, CYTHON_UNUSED PyObject *__pyx_v_maxwidth, CYTHON_UNUSED PyObject *__pyx_v_output, CYTHON_UNUSED PyObject *__pyx_v_toplevel); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_228inner(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_b); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_230insert(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_arr, CYTHON_UNUSED PyObject *__pyx_v_obj, CYTHON_UNUSED PyObject *__pyx_v_values, CYTHON_UNUSED PyObject *__pyx_v_axis); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_232int_asbuffer(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_234interp(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_xp, CYTHON_UNUSED PyObject *__pyx_v_fp, CYTHON_UNUSED PyObject *__pyx_v_left, CYTHON_UNUSED PyObject *__pyx_v_right); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_236intersect1d(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_ar1, CYTHON_UNUSED PyObject *__pyx_v_ar2, CYTHON_UNUSED PyObject *__pyx_v_assume_unique); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_238ipmt(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_rate, CYTHON_UNUSED PyObject *__pyx_v_per, CYTHON_UNUSED PyObject *__pyx_v_nper, CYTHON_UNUSED PyObject *__pyx_v_pv, CYTHON_UNUSED PyObject *__pyx_v_fv, CYTHON_UNUSED PyObject *__pyx_v_when); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_240irr(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_values); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_242iscomplex(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_244iscomplexobj(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_246isfortran(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_248isneginf(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_y); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_250isposinf(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_y); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_252isreal(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_254isrealobj(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_256isscalar(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_num); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_258issctype(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_rep); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_260issubclass_(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_arg1, CYTHON_UNUSED PyObject *__pyx_v_arg2); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_262issubdtype(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_arg1, CYTHON_UNUSED PyObject *__pyx_v_arg2); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_264issubsctype(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_arg1, CYTHON_UNUSED PyObject *__pyx_v_arg2); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_266iterable(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_y); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_268ix_(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_270kaiser(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_M, CYTHON_UNUSED PyObject *__pyx_v_beta); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_272kron(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_b); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_274lexsort(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_keys, CYTHON_UNUSED PyObject *__pyx_v_axis); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_276load(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_file, CYTHON_UNUSED PyObject *__pyx_v_mmap_mode); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_278loads(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_280loadtxt(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_fname, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_comments, CYTHON_UNUSED PyObject *__pyx_v_delimiter, CYTHON_UNUSED PyObject *__pyx_v_converters, CYTHON_UNUSED PyObject *__pyx_v_skiprows, CYTHON_UNUSED PyObject *__pyx_v_usecols, CYTHON_UNUSED PyObject *__pyx_v_unpack, CYTHON_UNUSED PyObject *__pyx_v_ndmin); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_282lookfor(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_what, CYTHON_UNUSED PyObject *__pyx_v_module, CYTHON_UNUSED PyObject *__pyx_v_import_modules, CYTHON_UNUSED PyObject *__pyx_v_regenerate, CYTHON_UNUSED PyObject *__pyx_v_output); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_284mafromtxt(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_fname); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_286mask_indices(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_n, CYTHON_UNUSED PyObject *__pyx_v_mask_func, CYTHON_UNUSED PyObject *__pyx_v_k); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_288mat(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_data, CYTHON_UNUSED PyObject *__pyx_v_dtype); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_290max(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_292maximum_sctype(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_t); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_294may_share_memory(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_b); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_296mean(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_out); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_298median(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out, CYTHON_UNUSED PyObject *__pyx_v_overwrite_input); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_300meshgrid(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_y); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_302min(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_304min_scalar_type(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_306mintypecode(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_typechars, CYTHON_UNUSED PyObject *__pyx_v_typeset, CYTHON_UNUSED PyObject *__pyx_v_default); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_308mirr(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_values, CYTHON_UNUSED PyObject *__pyx_v_finance_rate, CYTHON_UNUSED PyObject *__pyx_v_reinvest_rate); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_310msort(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_312nan_to_num(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_314nanargmax(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_316nanargmin(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_318nanmax(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_320nanmin(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_322nansum(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_324ndfromtxt(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_fname); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_326ndim(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_328nested_iters(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_330newbuffer(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_size); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_332nonzero(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_334nper(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_rate, CYTHON_UNUSED PyObject *__pyx_v_pmt, CYTHON_UNUSED PyObject *__pyx_v_pv, CYTHON_UNUSED PyObject *__pyx_v_fv, CYTHON_UNUSED PyObject *__pyx_v_when); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_336npv(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_rate, CYTHON_UNUSED PyObject *__pyx_v_values); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_338obj2sctype(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_rep, CYTHON_UNUSED PyObject *__pyx_v_default); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_340outer(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_b); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_342packbits(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_myarray, CYTHON_UNUSED PyObject *__pyx_v_axis); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_344percentile(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_q, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out, CYTHON_UNUSED PyObject *__pyx_v_overwrite_input); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_346piecewise(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_condlist, CYTHON_UNUSED PyObject *__pyx_v_funclist); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_348pkgload(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_350place(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_arr, CYTHON_UNUSED PyObject *__pyx_v_mask, CYTHON_UNUSED PyObject *__pyx_v_vals); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_352pmt(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_rate, CYTHON_UNUSED PyObject *__pyx_v_nper, CYTHON_UNUSED PyObject *__pyx_v_pv, CYTHON_UNUSED PyObject *__pyx_v_fv, CYTHON_UNUSED PyObject *__pyx_v_when); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_354poly(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_seq_of_zeros); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_356polyadd(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a1, CYTHON_UNUSED PyObject *__pyx_v_a2); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_358polyder(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_p, CYTHON_UNUSED PyObject *__pyx_v_m); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_360polydiv(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_u, CYTHON_UNUSED PyObject *__pyx_v_v); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_362polyfit(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_y, CYTHON_UNUSED PyObject *__pyx_v_deg, CYTHON_UNUSED PyObject *__pyx_v_rcond, CYTHON_UNUSED PyObject *__pyx_v_full); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_364polyint(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_p, CYTHON_UNUSED PyObject *__pyx_v_m, CYTHON_UNUSED PyObject *__pyx_v_k); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_366polymul(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a1, CYTHON_UNUSED PyObject *__pyx_v_a2); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_368polysub(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a1, CYTHON_UNUSED PyObject *__pyx_v_a2); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_370polyval(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_p, CYTHON_UNUSED PyObject *__pyx_v_x); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_372ppmt(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_rate, CYTHON_UNUSED PyObject *__pyx_v_per, CYTHON_UNUSED PyObject *__pyx_v_nper, CYTHON_UNUSED PyObject *__pyx_v_pv, CYTHON_UNUSED PyObject *__pyx_v_fv, CYTHON_UNUSED PyObject *__pyx_v_when); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_374prod(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_out); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_376product(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_out); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_378promote_types(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_type1, CYTHON_UNUSED PyObject *__pyx_v_type2); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_380ptp(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_382put(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_ind, CYTHON_UNUSED PyObject *__pyx_v_v, CYTHON_UNUSED PyObject *__pyx_v_mode); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_384putmask(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_mask, CYTHON_UNUSED PyObject *__pyx_v_values); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_386pv(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_rate, CYTHON_UNUSED PyObject *__pyx_v_nper, CYTHON_UNUSED PyObject *__pyx_v_pmt, CYTHON_UNUSED PyObject *__pyx_v_fv, CYTHON_UNUSED PyObject *__pyx_v_when); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_388rank(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_390rate(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_nper, CYTHON_UNUSED PyObject *__pyx_v_pmt, CYTHON_UNUSED PyObject *__pyx_v_pv, CYTHON_UNUSED PyObject *__pyx_v_fv, CYTHON_UNUSED PyObject *__pyx_v_when, CYTHON_UNUSED PyObject *__pyx_v_guess, CYTHON_UNUSED PyObject *__pyx_v_tol, CYTHON_UNUSED PyObject *__pyx_v_maxiter); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_392ravel(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_order); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_394ravel_multi_index(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_multi_index, CYTHON_UNUSED PyObject *__pyx_v_dims, CYTHON_UNUSED PyObject *__pyx_v_mode, CYTHON_UNUSED PyObject *__pyx_v_order); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_396real(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_val); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_398real_if_close(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_tol); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_400recfromcsv(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_fname); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_402recfromtxt(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_fname); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_404repeat(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_repeats, CYTHON_UNUSED PyObject *__pyx_v_axis); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_406require(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_requirements); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_408reshape(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_newshape, CYTHON_UNUSED PyObject *__pyx_v_order); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_410resize(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_new_shape); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_412restoredot(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_414result_type(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_arrays_and_dtypes); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_416roll(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_shift, CYTHON_UNUSED PyObject *__pyx_v_axis); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_418rollaxis(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_start); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_420roots(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_p); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_422rot90(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_m, CYTHON_UNUSED PyObject *__pyx_v_k); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_424round(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_decimals, CYTHON_UNUSED PyObject *__pyx_v_out); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_426round_(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_decimals, CYTHON_UNUSED PyObject *__pyx_v_out); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_428row_stack(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_tup); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_430safe_eval(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_source); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_432save(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_file, CYTHON_UNUSED PyObject *__pyx_v_arr); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_434savetxt(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_fname, CYTHON_UNUSED PyObject *__pyx_v_X, CYTHON_UNUSED PyObject *__pyx_v_fmt, CYTHON_UNUSED PyObject *__pyx_v_delimiter, CYTHON_UNUSED PyObject *__pyx_v_newline); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_436savez(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_file); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_438savez_compressed(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_file); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_440sctype2char(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_sctype); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_442searchsorted(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_v, CYTHON_UNUSED PyObject *__pyx_v_side); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_444select(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_condlist, CYTHON_UNUSED PyObject *__pyx_v_choicelist, CYTHON_UNUSED PyObject *__pyx_v_default); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_446set_numeric_ops(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_448set_printoptions(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_precision, CYTHON_UNUSED PyObject *__pyx_v_threshold, CYTHON_UNUSED PyObject *__pyx_v_edgeitems, CYTHON_UNUSED PyObject *__pyx_v_linewidth, CYTHON_UNUSED PyObject *__pyx_v_suppress, CYTHON_UNUSED PyObject *__pyx_v_nanstr, CYTHON_UNUSED PyObject *__pyx_v_infstr); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_450set_string_function(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_f, CYTHON_UNUSED PyObject *__pyx_v_repr); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_452setbufsize(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_size); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_454setdiff1d(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_ar1, CYTHON_UNUSED PyObject *__pyx_v_ar2, CYTHON_UNUSED PyObject *__pyx_v_assume_unique); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_456seterr(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_all, CYTHON_UNUSED PyObject *__pyx_v_divide, CYTHON_UNUSED PyObject *__pyx_v_over, CYTHON_UNUSED PyObject *__pyx_v_under, CYTHON_UNUSED PyObject *__pyx_v_invalid); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_458seterrcall(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_func); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_460seterrobj(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_errobj); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_462setxor1d(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_ar1, CYTHON_UNUSED PyObject *__pyx_v_ar2, CYTHON_UNUSED PyObject *__pyx_v_assume_unique); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_464show_config(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_466sinc(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_468size(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_470sometrue(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_472sort(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_kind, CYTHON_UNUSED PyObject *__pyx_v_order); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_474sort_complex(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_476source(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_object, CYTHON_UNUSED PyObject *__pyx_v_output); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_478split(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_ary, CYTHON_UNUSED PyObject *__pyx_v_indices_or_sections, CYTHON_UNUSED PyObject *__pyx_v_axis); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_480squeeze(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_482std(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_out, CYTHON_UNUSED PyObject *__pyx_v_ddof); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_484sum(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_out); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_486swapaxes(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis1, CYTHON_UNUSED PyObject *__pyx_v_axis2); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_488take(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_indices, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out, CYTHON_UNUSED PyObject *__pyx_v_mode); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_490tensordot(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_b, CYTHON_UNUSED PyObject *__pyx_v_axes); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_492tile(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_A, CYTHON_UNUSED PyObject *__pyx_v_reps); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_494trace(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_offset, CYTHON_UNUSED PyObject *__pyx_v_axis1, CYTHON_UNUSED PyObject *__pyx_v_axis2, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_out); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_496transpose(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axes); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_498trapz(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_y, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_dx, CYTHON_UNUSED PyObject *__pyx_v_axis); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_500tri(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_N, CYTHON_UNUSED PyObject *__pyx_v_M, CYTHON_UNUSED PyObject *__pyx_v_k, CYTHON_UNUSED PyObject *__pyx_v_dtype); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_502tril(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_m, CYTHON_UNUSED PyObject *__pyx_v_k); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_504tril_indices(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_n, CYTHON_UNUSED PyObject *__pyx_v_k); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_506tril_indices_from(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_arr, CYTHON_UNUSED PyObject *__pyx_v_k); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_508trim_zeros(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_filt, CYTHON_UNUSED PyObject *__pyx_v_trim); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_510triu(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_m, CYTHON_UNUSED PyObject *__pyx_v_k); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_512triu_indices(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_n, CYTHON_UNUSED PyObject *__pyx_v_k); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_514triu_indices_from(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_arr, CYTHON_UNUSED PyObject *__pyx_v_k); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_516typename(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_char_); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_518union1d(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_ar1, CYTHON_UNUSED PyObject *__pyx_v_ar2); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_520unique(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_ar, CYTHON_UNUSED PyObject *__pyx_v_return_index, CYTHON_UNUSED PyObject *__pyx_v_return_inverse); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_522unpackbits(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_myarray, CYTHON_UNUSED PyObject *__pyx_v_axis); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_524unravel_index(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_indices, CYTHON_UNUSED PyObject *__pyx_v_dims, CYTHON_UNUSED PyObject *__pyx_v_order); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_526unwrap(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_p, CYTHON_UNUSED PyObject *__pyx_v_discont, CYTHON_UNUSED PyObject *__pyx_v_axis); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_528vander(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_N); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_530var(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_out, CYTHON_UNUSED PyObject *__pyx_v_ddof); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_532vdot(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_534vsplit(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_ary, CYTHON_UNUSED PyObject *__pyx_v_indices_or_sections); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_536vstack(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_tup); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_538where(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_540who(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_vardict); /* proto */
static int __pyx_pf_5numpy_7ndarray___getbuffer__(PyArrayObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /* proto */
static void __pyx_pf_5numpy_7ndarray_2__releasebuffer__(PyArrayObject *__pyx_v_self, Py_buffer *__pyx_v_info); /* proto */
static char __pyx_k_5[] = " ";
static char __pyx_k_6[] = "";
static char __pyx_k_16[] = "#";
static char __pyx_k_19[] = "f%i";
static char __pyx_k_42[] = "%.18e";
static char __pyx_k_43[] = "\n";
static char __pyx_k_53[] = "ndarray is not C contiguous";
static char __pyx_k_55[] = "ndarray is not Fortran contiguous";
static char __pyx_k_57[] = "Non-native byte order not supported";
static char __pyx_k_59[] = "unknown dtype code in numpy.pxd (%d)";
static char __pyx_k_60[] = "Format string allocated too short, see comment in numpy.pxd";
static char __pyx_k_63[] = "Format string allocated too short.";
static char __pyx_k_67[] = "/home/d3n000/ga/hpc_website_again/globalarrays/download/ga-5-3b/python/ga4py/gain/notimplemented.pyx";
static char __pyx_k_68[] = "ga4py.gain.notimplemented";
static char __pyx_k__A[] = "A";
static char __pyx_k__B[] = "B";
static char __pyx_k__C[] = "C";
static char __pyx_k__H[] = "H";
static char __pyx_k__I[] = "I";
static char __pyx_k__L[] = "L";
static char __pyx_k__M[] = "M";
static char __pyx_k__N[] = "N";
static char __pyx_k__O[] = "O";
static char __pyx_k__Q[] = "Q";
static char __pyx_k__X[] = "X";
static char __pyx_k___[] = "_";
static char __pyx_k__a[] = "a";
static char __pyx_k__b[] = "b";
static char __pyx_k__d[] = "d";
static char __pyx_k__f[] = "f";
static char __pyx_k__g[] = "g";
static char __pyx_k__h[] = "h";
static char __pyx_k__i[] = "i";
static char __pyx_k__k[] = "k";
static char __pyx_k__l[] = "l";
static char __pyx_k__m[] = "m";
static char __pyx_k__n[] = "n";
static char __pyx_k__p[] = "p";
static char __pyx_k__q[] = "q";
static char __pyx_k__t[] = "t";
static char __pyx_k__u[] = "u";
static char __pyx_k__v[] = "v";
static char __pyx_k__x[] = "x";
static char __pyx_k__y[] = "y";
static char __pyx_k__z[] = "z";
static char __pyx_k_212[] = "_fastCopyAndTranspose";
static char __pyx_k_245[] = "get_numarray_include";
static char __pyx_k_582[] = "all (line 40)";
static char __pyx_k_583[] = "Test whether all array elements along a given axis evaluate to True.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array or object that can be converted to an array.\n    axis : int, optional\n        Axis along which a logical AND is performed.\n        The default (`axis` = `None`) is to perform a logical AND\n        over a flattened input array.  `axis` may be negative, in which\n        case it counts from the last to the first axis.\n    out : ndarray, optional\n        Alternate output array in which to place the result.\n        It must have the same shape as the expected output and its\n        type is preserved (e.g., if ``dtype(out)`` is float, the result\n        will consist of 0.0's and 1.0's).  See `doc.ufuncs` (Section\n        \"Output arguments\") for more details.\n\n    Returns\n    -------\n    all : ndarray, bool\n        A new boolean or array is returned unless `out` is specified,\n        in which case a reference to `out` is returned.\n\n    See Also\n    --------\n    ndarray.all : equivalent method\n\n    any : Test whether any element along a given axis evaluates to True.\n\n    Notes\n    -----\n    Not a Number (NaN), positive infinity and negative infinity\n    evaluate to `True` because these are not equal to zero.\n\n    Examples\n    --------\n    >>> np.all([[True,False],[True,True]])\n    False\n\n    >>> np.all([[True,False],[True,True]], axis=0)\n    array([ True, False], dtype=bool)\n\n    >>> np.all([-1, 4, 5])\n    True\n\n    >>> np.all([1.0, np.nan])\n    True\n\n    >>> o=np.array([False])\n    >>> z=np.all([-1, 4, 5], out=o)\n    >>> id(z), id(o), z                             # doctest: +SKIP\n    (28293632, 28293632, array([ True], dtype=bool))\n    \n    ";
static char __pyx_k_584[] = "allclose (line 99)";
static char __pyx_k_585[] = "Returns True if two arrays are element-wise equal within a tolerance.\n\n    The tolerance values are positive, typically very small numbers.  The\n    relative difference (`rtol` * abs(`b`)) and the absolute difference\n    `atol` are added together to compare against the absolute difference\n    between `a` and `b`.\n\n    Parameters\n    ----------\n    a, b : array_like\n        Input arrays to compare.\n    rtol : float\n        The relative tolerance parameter (see Notes).\n    atol : float\n        The absolute tolerance parameter (see Notes).\n\n    Returns\n    -------\n    y : bool\n        Returns True if the two arrays are equal within the given\n        tolerance; False otherwise. If either array contains NaN, then\n        False is returned.\n\n    See Also\n    --------\n    all, any, alltrue, sometrue\n\n    Notes\n    -----\n    If the following equation is element-wise True, then allclose returns\n    True.\n\n     absolute(`a` - `b`) <= (`atol` + `rtol` * absolute(`b`))\n\n    The above equation is not symmetric in `a` and `b`, so that\n    `allclose(a, b)` might be different from `allclose(b, a)` in\n    some rare cases.\n\n    Examples\n    --------\n    >>> np.allclose([1e10,1e-7], [1.00001e10,1e-8])\n    False\n    >>> np.allclose([1e10,1e-8], [1.00001e10,1e-9])\n    True\n    >>> np.allclose([1e10,1e-8], [1.0001e10,1e-9])\n    False\n    >>> np.allclose([1.0, np.nan], [1.0, np.nan])\n    False\n    \n    ";
static char __pyx_k_586[] = "amax (line 187)";
static char __pyx_k_587[] = "Return the maximum of an array or maximum along an axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    axis : int, optional\n        Axis along which to operate.  By default flattened input is used.\n    out : ndarray, optional\n        Alternate output array in which to place the result.  Must be of\n        the same shape and buffer length as the expected output.  See\n        `doc.ufuncs` (Section \"Output arguments\") for more details.\n\n    Returns\n    -------\n    amax : ndarray or scalar\n        Maximum of `a`. If `axis` is None, the result is a scalar value.\n        If `axis` is given, the result is an array of dimension\n        ``a.ndim - 1``.\n\n    See Also\n    --------\n    nanmax : NaN values are ignored instead of being propagated.\n    fmax : same behavior as the C99 fmax function.\n    argmax : indices of the maximum values.\n\n    Notes\n    -----\n    NaN values are propagated, that is if at least one item is NaN, the\n    corresponding max value will be NaN as well.  To ignore NaN values\n    (MATLAB behavior), please use nanmax.\n\n    Examples\n    --------\n    >>> a = np.arange(4).reshape((2,2))\n    >>> a\n    array([[0, 1],\n           [2, 3]])\n    >>> np.amax(a)\n    3\n    >>> np.amax(a, axis=0)\n    array([2, 3])\n    >>> np.amax(a, axis=1)\n    array([1, 3])\n\n    >>> b = np.arange(5, dtype=np.float)\n    >>> b[2] = np.NaN\n    >>> np.amax(b)\n    nan\n    >>> np.nanmax(b)\n    4.0\n    \n    ";
static char __pyx_k_588[] = "amin (line 244)";
static char __pyx_k_589[] = "Return the minimum of an array or minimum along an axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    axis : int, optional\n        Axis along which to operate.  By default a flattened input is used.\n    out : ndarray, optional\n        Alternative output array in which to place the result.  Must\n        be of the same shape and buffer length as the expected output.\n        See `doc.ufuncs` (Section \"Output arguments\") for more details.\n\n    Returns\n    -------\n    amin : ndarray\n        A new array or a scalar array with the result.\n\n    See Also\n    --------\n    nanmin: nan values are ignored instead of being propagated\n    fmin: same behavior as the C99 fmin function\n    argmin: Return the indices of the minimum values.\n\n    amax, nanmax, fmax\n\n    Notes\n    -----\n    NaN values are propagated, that is if at least one item is nan, the\n    corresponding min value will be nan as well. To ignore NaN values (matlab\n    behavior), please use nanmin.\n\n    Examples\n    --------\n    >>> a = np.arange(4).reshape((2,2))\n    >>> a\n    array([[0, 1],\n           [2, 3]])\n    >>> np.amin(a)           # Minimum of the flattened array\n    0\n    >>> np.amin(a, axis=0)         # Minima along the first axis\n    array([0, 1])\n    >>> np.amin(a, axis=1)         # Minima along the second axis\n    array([0, 2])\n\n    >>> b = np.arange(5, dtype=np.float)\n    >>> b[2] = np.NaN\n    >>> np.amin(b)\n    nan\n    >>> np.nanmin(b)\n    0.0\n    \n    ";
static char __pyx_k_590[] = "angle (line 301)";
static char __pyx_k_591[] = "Return the angle of the complex argument.\n\n    Parameters\n    ----------\n    z : array_like\n        A complex number or sequence of complex numbers.\n    deg : bool, optional\n        Return angle in degrees if True, radians if False (default).\n\n    Returns\n    -------\n    angle : {ndarray, scalar}\n        The counterclockwise angle from the positive real axis on\n        the complex plane, with dtype as numpy.float64.\n\n    See Also\n    --------\n    arctan2\n    absolute\n\n\n\n    Examples\n    --------\n    >>> np.angle([1.0, 1.0j, 1+1j])               # in radians\n    array([ 0.        ,  1.57079633,  0.78539816])\n    >>> np.angle(1+1j, deg=True)                  # in degrees\n    45.0\n    \n    ";
static char __pyx_k_592[] = "any (line 335)";
static char __pyx_k_593[] = "Test whether any array element along a given axis evaluates to True.\n\n    Returns single boolean unless `axis` is not ``None``\n\n    Parameters\n    ----------\n    a : array_like\n        Input array or object that can be converted to an array.\n    axis : int, optional\n        Axis along which a logical OR is performed.  The default\n        (`axis` = `None`) is to perform a logical OR over a flattened\n        input array. `axis` may be negative, in which case it counts\n        from the last to the first axis.\n    out : ndarray, optional\n        Alternate output array in which to place the result.  It must have\n        the same shape as the expected output and its type is preserved\n        (e.g., if it is of type float, then it will remain so, returning\n        1.0 for True and 0.0 for False, regardless of the type of `a`).\n        See `doc.ufuncs` (Section \"Output arguments\") for details.\n\n    Returns\n    -------\n    any : bool or ndarray\n        A new boolean or `ndarray` is returned unless `out` is specified,\n        in which case a reference to `out` is returned.\n\n    See Also\n    --------\n    ndarray.any : equivalent method\n\n    all : Test whether all elements along a given axis evaluate to True.\n\n    Notes\n    -----\n    Not a Number (NaN), positive infinity and negative infinity evaluate\n    to `True` because these are not equal to zero.\n\n    Examples\n    --------\n    >>> np.any([[True, False], [True, True]])\n    True\n\n    >>> np.any([[True, False], [False, False]], axis=0)\n    array([ True, False], dtype=bool)\n\n    >>> np.any([-1, 0, 5])\n    True\n\n    >>> np.any(np.nan)\n    True\n\n    >>> o=np.array([False])\n    >>> z=np.any([-1, 4, 5], out=o)\n    >>> z, o\n    (array([ True], dtype=bool), array([ True], dtype=bool))\n    >>> # Check now that z is a reference to o\n    >>> z is o\n    True\n    >>> id(z), id(o) # identity of z and o              # doctest: +SKIP\n    (191614240, 191614240)\n    \n    ";
static char __pyx_k_594[] = "append (line 401)";
static char __pyx_k_595[] = "Append values to the end of an array.\n\n    Parameters\n    ----------\n    arr : array_like\n        Values are appended to a copy of this array.\n    values : array_like\n        These values are appended to a copy of `arr`.  It must be of the\n        correct shape (the same shape as `arr`, excluding `axis`).  If `axis`\n        is not specified, `values` can be any shape and will be flattened\n        before use.\n    axis : int, optional\n        The axis along which `values` are appended.  If `axis` is not given,\n        both `arr` and `values` are flattened before use.\n\n    Returns\n    -------\n    out : ndarray\n        A copy of `arr` with `values` appended to `axis`.  Note that `append`\n        does not occur in-place: a new array is allocated and filled.  If\n        `axis` is None, `out` is a flattened array.\n\n    See Also\n    --------\n    insert : Insert elements into an array.\n    delete : Delete elements from an array.\n\n    Examples\n    --------\n    >>> np.append([1, 2, 3], [[4, 5, 6], [7, 8, 9]])\n    array([1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n    When `axis` is specified, `values` must have the correct shape.\n\n    >>> np.append([[1, 2, 3], [4, 5, 6]], [[7, 8, 9]], axis=0)\n    array([[1, 2, 3],\n           [4, 5, 6],\n           [7, 8, 9]])\n    >>> np.append([[1, 2, 3], [4, 5, 6]], [7, 8, 9], axis=0)\n    Traceback (most recent call last):\n    ...\n    ValueError: arrays must have same number of dimensions\n    \n    ";
static char __pyx_k_596[] = "apply_along_axis (line 449)";
static char __pyx_k_597[] = "Apply a function to 1-D slices along the given axis.\n\n    Execute `func1d(a, *args)` where `func1d` operates on 1-D arrays and `a`\n    is a 1-D slice of `arr` along `axis`.\n\n    Parameters\n    ----------\n    func1d : function\n        This function should accept 1-D arrays. It is applied to 1-D\n        slices of `arr` along the specified axis.\n    axis : integer\n        Axis along which `arr` is sliced.\n    arr : ndarray\n        Input array.\n    args : any\n        Additional arguments to `func1d`.\n\n    Returns\n    -------\n    outarr : ndarray\n        The output array. The shape of `outarr` is identical to the shape of\n        `arr`, except along the `axis` dimension, where the length of `outarr`\n        is equal to the size of the return value of `func1d`.  If `func1d`\n        returns a scalar `outarr` will have one fewer dimensions than `arr`.\n\n    See Also\n    --------\n    apply_over_axes : Apply a function repeatedly over multiple axes.\n\n    Examples\n    --------\n    >>> def my_func(a):\n    ...     '''Average first and last element of a 1-D array'''\n    ...     return (a[0] + a[-1]) * 0.5\n    >>> b = np.array([[1,2,3], [4,5,6], [7,8,9]])\n    >>> np.apply_along_axis(my_func, 0, b)\n    array([ 4.,  5.,  6.])\n    >>> np.apply_along_axis(my_func, 1, b)\n    array([ 2.,  5.,  8.])\n\n    For a function that doesn't return a scalar, the number of dimensions in\n    `outarr` is the same as `arr`.\n\n    >>> def new_func(a):\n    ...     '''Divide elements of a by 2.'''\n    ...     return a * 0.5\n    >>> b = np.array([[1,2,3], [4,5,6], [7,8,9]])\n    >>> np.apply_along_axis(new_func, 0, b)\n    array([[ 0.5,  1. ,  1.5],\n           [ 2. ,  2.5,  3. ],\n           [ 3.5,  4. ,  4.5]])\n    \n    ";
static char __pyx_k_598[] = "apply_over_axes (line 506)";
static char __pyx_k_599[] = "Apply a function repeatedly over multiple axes.\n\n    `func` is called as `res = func(a, axis)`, where `axis` is the first\n    element of `axes`.  The result `res` of the function call must have\n    either the same dimensions as `a` or one less dimension.  If `res`\n    has one less dimension than `a`, a dimension is inserted before\n    `axis`.  The call to `func` is then repeated for each axis in `axes`,\n    with `res` as the first argument.\n\n    Parameters\n    ----------\n    func : function\n        This function must take two arguments, `func(a, axis)`.\n    a : array_like\n        Input array.\n    axes : array_like\n        Axes over which `func` is applied; the elements must be integers.\n\n    Returns\n    -------\n    val : ndarray\n        The output array.  The number of dimensions is the same as `a`,\n        but the shape can be different.  This depends on whether `func`\n        changes the shape of its output with respect to its input.\n\n    See Also\n    --------\n    apply_along_axis :\n        Apply a function to 1-D slices of an array along the given axis.\n\n    Examples\n    --------\n    >>> a = np.arange(24).reshape(2,3,4)\n    >>> a\n    array([[[ 0,  1,  2,  3],\n            [ 4,  5,  6,  7],\n            [ 8,  9, 10, 11]],\n           [[12, 13, 14, 15],\n            [16, 17, 18, 19],\n            [20, 21, 22, 23]]])\n\n    Sum over axes 0 and 2. The result has same number of dimensions\n    as the original array:\n\n    >>> np.apply_over_axes(np.sum, a, [0,2])\n    array([[[ 60],\n            [ 92],\n            [124]]])\n    \n    ";
static char __pyx_k_600[] = "argmax (line 560)";
static char __pyx_k_601[] = "Indices of the maximum values along an axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    axis : int, optional\n        By default, the index is into the flattened array, otherwise\n        along the specified axis.\n\n    Returns\n    -------\n    index_array : ndarray of ints\n        Array of indices into the array. It has the same shape as `a.shape`\n        with the dimension along `axis` removed.\n\n    See Also\n    --------\n    ndarray.argmax, argmin\n    amax : The maximum value along a given axis.\n    unravel_index : Convert a flat index into an index tuple.\n\n    Notes\n    -----\n    In case of multiple occurrences of the maximum values, the indices\n    corresponding to the first occurrence are returned.\n\n    Examples\n    --------\n    >>> a = np.arange(6).reshape(2,3)\n    >>> a\n    array([[0, 1, 2],\n           [3, 4, 5]])\n    >>> np.argmax(a)\n    5\n    >>> np.argmax(a, axis=0)\n    array([1, 1, 1])\n    >>> np.argmax(a, axis=1)\n    array([2, 2])\n\n    >>> b = np.arange(6)\n    >>> b[1] = 5\n    >>> b\n    array([0, 5, 2, 3, 4, 5])\n    >>> np.argmax(b) # Only the first occurrence is returned.\n    1\n    \n    ";
static char __pyx_k_602[] = "argsort (line 624)";
static char __pyx_k_603[] = "Returns the indices that would sort an array.\n\n    Perform an indirect sort along the given axis using the algorithm specified\n    by the `kind` keyword. It returns an array of indices of the same shape as\n    `a` that index data along the given axis in sorted order.\n\n    Parameters\n    ----------\n    a : array_like\n        Array to sort.\n    axis : int or None, optional\n        Axis along which to sort.  The default is -1 (the last axis). If None,\n        the flattened array is used.\n    kind : {'quicksort', 'mergesort', 'heapsort'}, optional\n        Sorting algorithm.\n    order : list, optional\n        When `a` is an array with fields defined, this argument specifies\n        which fields to compare first, second, etc.  Not all fields need be\n        specified.\n\n    Returns\n    -------\n    index_array : ndarray, int\n        Array of indices that sort `a` along the specified axis.\n        In other words, ``a[index_array]`` yields a sorted `a`.\n\n    See Also\n    --------\n    sort : Describes sorting algorithms used.\n    lexsort : Indirect stable sort with multiple keys.\n    ndarray.sort : Inplace sort.\n\n    Notes\n    -----\n    See `sort` for notes on the different sorting algorithms.\n\n    As of NumPy 1.4.0 `argsort` works with real/complex arrays containing\n    nan values. The enhanced sort order is documented in `sort`.\n\n    Examples\n    --------\n    One dimensional array:\n\n    >>> x = np.array([3, 1, 2])\n    >>> np.argsort(x)\n    array([1, 2, 0])\n\n    Two-dimensional array:\n\n    >>> x = np.array([[0, 3], [2, 2]])\n    >>> x\n    array([[0, 3],\n           [2, 2]])\n\n    >>> np.argsort(x, axis=0)\n    array([[0, 1],\n           [1, 0]])\n\n    >>> np.argsort(x, axis=1)\n    array([[0, 1],\n           [0, 1]])\n\n    Sorting with keys:\n\n    >>> x = np.array([(1, 0), (0, 1)], dtype=[('x', '<i4'), ('y', '<i4')])\n    >>> x\n    array([(1, 0), (0, 1)],\n          dtype=[('x', '<i4'), ('y', '<i4')])\n\n    >>> np.argsor""t(x, order=('x','y'))\n    array([1, 0])\n\n    >>> np.argsort(x, order=('y','x'))\n    array([0, 1])\n    \n    ";
static char __pyx_k_604[] = "argwhere (line 704)";
static char __pyx_k_605[] = "Find the indices of array elements that are non-zero, grouped by element.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n\n    Returns\n    -------\n    index_array : ndarray\n        Indices of elements that are non-zero. Indices are grouped by element.\n\n    See Also\n    --------\n    where, nonzero\n\n    Notes\n    -----\n    ``np.argwhere(a)`` is the same as ``np.transpose(np.nonzero(a))``.\n\n    The output of ``argwhere`` is not suitable for indexing arrays.\n    For this purpose use ``where(a)`` instead.\n\n    Examples\n    --------\n    >>> x = np.arange(6).reshape(2,3)\n    >>> x\n    array([[0, 1, 2],\n           [3, 4, 5]])\n    >>> np.argwhere(x>1)\n    array([[0, 2],\n           [1, 0],\n           [1, 1],\n           [1, 2]])\n    \n    ";
static char __pyx_k_606[] = "around (line 744)";
static char __pyx_k_607[] = "Evenly round to the given number of decimals.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    decimals : int, optional\n        Number of decimal places to round to (default: 0).  If\n        decimals is negative, it specifies the number of positions to\n        the left of the decimal point.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must have\n        the same shape as the expected output, but the type of the output\n        values will be cast if necessary. See `doc.ufuncs` (Section\n        \"Output arguments\") for details.\n\n    Returns\n    -------\n    rounded_array : ndarray\n        An array of the same type as `a`, containing the rounded values.\n        Unless `out` was specified, a new array is created.  A reference to\n        the result is returned.\n\n        The real and imaginary parts of complex numbers are rounded\n        separately.  The result of rounding a float is a float.\n\n    See Also\n    --------\n    ndarray.round : equivalent method\n\n    ceil, fix, floor, rint, trunc\n\n\n    Notes\n    -----\n    For values exactly halfway between rounded decimal values, Numpy\n    rounds to the nearest even value. Thus 1.5 and 2.5 round to 2.0,\n    -0.5 and 0.5 round to 0.0, etc. Results may also be surprising due\n    to the inexact representation of decimal fractions in the IEEE\n    floating point standard [1]_ and errors introduced when scaling\n    by powers of ten.\n\n    References\n    ----------\n    .. [1] \"Lecture Notes on the Status of  IEEE 754\", William Kahan,\n           http://www.cs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF\n    .. [2] \"How Futile are Mindless Assessments of\n           Roundoff in Floating-Point Computation?\", William Kahan,\n           http://www.cs.berkeley.edu/~wkahan/Mindless.pdf\n\n    Examples\n    --------\n    >>> np.around([0.37, 1.64])\n    array([ 0.,  2.])\n    >>> np.around([0.37, 1.64], decimals=1)\n    ""array([ 0.4,  1.6])\n    >>> np.around([.5, 1.5, 2.5, 3.5, 4.5]) # rounds to nearest even value\n    array([ 0.,  2.,  2.,  4.,  4.])\n    >>> np.around([1,2,3,11], decimals=1) # ndarray of ints is returned\n    array([ 1,  2,  3, 11])\n    >>> np.around([1,2,3,11], decimals=-1)\n    array([ 0,  0,  0, 10])\n    \n    ";
static char __pyx_k_608[] = "array (line 812)";
static char __pyx_k_609[] = "array(object, dtype=None, copy=True, order=None, subok=False, ndmin=0)\n\n    Create an array.\n\n    Parameters\n    ----------\n    object : array_like\n        An array, any object exposing the array interface, an\n        object whose __array__ method returns an array, or any\n        (nested) sequence.\n    dtype : data-type, optional\n        The desired data-type for the array.  If not given, then\n        the type will be determined as the minimum type required\n        to hold the objects in the sequence.  This argument can only\n        be used to 'upcast' the array.  For downcasting, use the\n        .astype(t) method.\n    copy : bool, optional\n        If true (default), then the object is copied.  Otherwise, a copy\n        will only be made if __array__ returns a copy, if obj is a\n        nested sequence, or if a copy is needed to satisfy any of the other\n        requirements (`dtype`, `order`, etc.).\n    order : {'C', 'F', 'A'}, optional\n        Specify the order of the array.  If order is 'C' (default), then the\n        array will be in C-contiguous order (last-index varies the\n        fastest).  If order is 'F', then the returned array\n        will be in Fortran-contiguous order (first-index varies the\n        fastest).  If order is 'A', then the returned array may\n        be in any order (either C-, Fortran-contiguous, or even\n        discontiguous).\n    subok : bool, optional\n        If True, then sub-classes will be passed-through, otherwise\n        the returned array will be forced to be a base-class array (default).\n    ndmin : int, optional\n        Specifies the minimum number of dimensions that the resulting\n        array should have.  Ones will be pre-pended to the shape as\n        needed to meet this requirement.\n\n    Returns\n    -------\n    out : ndarray\n        An array object satisfying the specified requirements.\n\n    See Also\n    --------\n    empty, empty_like, zeros, zeros_like, ones, ones_like, fill\n\n    ""Examples\n    --------\n    >>> np.array([1, 2, 3])\n    array([1, 2, 3])\n\n    Upcasting:\n\n    >>> np.array([1, 2, 3.0])\n    array([ 1.,  2.,  3.])\n\n    More than one dimension:\n\n    >>> np.array([[1, 2], [3, 4]])\n    array([[1, 2],\n           [3, 4]])\n\n    Minimum dimensions 2:\n\n    >>> np.array([1, 2, 3], ndmin=2)\n    array([[1, 2, 3]])\n\n    Type provided:\n\n    >>> np.array([1, 2, 3], dtype=complex)\n    array([ 1.+0.j,  2.+0.j,  3.+0.j])\n\n    Data-type consisting of more than one element:\n\n    >>> x = np.array([(1,2),(3,4)],dtype=[('a','<i4'),('b','<i4')])\n    >>> x['a']\n    array([1, 3])\n\n    Creating an array from sub-classes:\n\n    >>> np.array(np.mat('1 2; 3 4'))\n    array([[1, 2],\n           [3, 4]])\n\n    >>> np.array(np.mat('1 2; 3 4'), subok=True)\n    matrix([[1, 2],\n            [3, 4]])\n    \n    ";
static char __pyx_k_610[] = "array2string (line 906)";
static char __pyx_k_611[] = "Return a string representation of an array.\n\n    Parameters\n    ----------\n    a : ndarray\n        Input array.\n    max_line_width : int, optional\n        The maximum number of columns the string should span. Newline\n        characters splits the string appropriately after array elements.\n    precision : int, optional\n        Floating point precision. Default is the current printing\n        precision (usually 8), which can be altered using `set_printoptions`.\n    suppress_small : bool, optional\n        Represent very small numbers as zero. A number is \"very small\" if it\n        is smaller than the current printing precision.\n    separator : str, optional\n        Inserted between elements.\n    prefix : str, optional\n        An array is typically printed as::\n\n          'prefix(' + array2string(a) + ')'\n\n        The length of the prefix string is used to align the\n        output correctly.\n    style : function, optional\n        A function that accepts an ndarray and returns a string.  Used only\n        when the shape of `a` is equal to ().\n\n    Returns\n    -------\n    array_str : str\n        String representation of the array.\n\n    See Also\n    --------\n    array_str, array_repr, set_printoptions\n\n    Examples\n    --------\n    >>> x = np.array([1e-16,1,2,3])\n    >>> print np.array2string(x, precision=2, separator=',',\n    ...                       suppress_small=True)\n    [ 0., 1., 2., 3.]\n    \n    ";
static char __pyx_k_612[] = "array_equal (line 955)";
static char __pyx_k_613[] = "True if two arrays have the same shape and elements, False otherwise.\n\n    Parameters\n    ----------\n    a1, a2 : array_like\n        Input arrays.\n\n    Returns\n    -------\n    b : bool\n        Returns True if the arrays are equal.\n\n    See Also\n    --------\n    allclose: Returns True if two arrays are element-wise equal within a\n              tolerance.\n    array_equiv: Returns True if input arrays are shape consistent and all\n                 elements equal.\n\n    Examples\n    --------\n    >>> np.array_equal([1, 2], [1, 2])\n    True\n    >>> np.array_equal(np.array([1, 2]), np.array([1, 2]))\n    True\n    >>> np.array_equal([1, 2], [1, 2, 3])\n    False\n    >>> np.array_equal([1, 2], [1, 4])\n    False\n    \n    ";
static char __pyx_k_614[] = "array_equiv (line 990)";
static char __pyx_k_615[] = "Returns True if input arrays are shape consistent and all elements equal.\n\n    Shape consistent means they are either the same shape, or one input array\n    can be broadcasted to create the same shape as the other one.\n\n    Parameters\n    ----------\n    a1, a2 : array_like\n        Input arrays.\n\n    Returns\n    -------\n    out : bool\n        True if equivalent, False otherwise.\n\n    Examples\n    --------\n    >>> np.array_equiv([1, 2], [1, 2])\n    True\n    >>> np.array_equiv([1, 2], [1, 3])\n    False\n\n    Showing the shape equivalence:\n\n    >>> np.array_equiv([1, 2], [[1, 2], [1, 2]])\n    True\n    >>> np.array_equiv([1, 2], [[1, 2, 1, 2], [1, 2, 1, 2]])\n    False\n\n    >>> np.array_equiv([1, 2], [[1, 2], [1, 3]])\n    False\n    \n    ";
static char __pyx_k_616[] = "array_repr (line 1027)";
static char __pyx_k_617[] = "Return the string representation of an array.\n\n    Parameters\n    ----------\n    arr : ndarray\n        Input array.\n    max_line_width : int, optional\n        The maximum number of columns the string should span. Newline\n        characters split the string appropriately after array elements.\n    precision : int, optional\n        Floating point precision. Default is the current printing precision\n        (usually 8), which can be altered using `set_printoptions`.\n    suppress_small : bool, optional\n        Represent very small numbers as zero, default is False. Very small\n        is defined by `precision`, if the precision is 8 then\n        numbers smaller than 5e-9 are represented as zero.\n\n    Returns\n    -------\n    string : str\n      The string representation of an array.\n\n    See Also\n    --------\n    array_str, array2string, set_printoptions\n\n    Examples\n    --------\n    >>> np.array_repr(np.array([1,2]))\n    'array([1, 2])'\n    >>> np.array_repr(np.ma.array([0.]))\n    'MaskedArray([ 0.])'\n    >>> np.array_repr(np.array([], np.int32))\n    'array([], dtype=int32)'\n\n    >>> x = np.array([1e-6, 4e-7, 2, 3])\n    >>> np.array_repr(x, precision=6, suppress_small=True)\n    'array([ 0.000001,  0.      ,  2.      ,  3.      ])'\n    \n    ";
static char __pyx_k_618[] = "array_split (line 1071)";
static char __pyx_k_619[] = "Split an array into multiple sub-arrays of equal or near-equal size.\n\n    Please refer to the ``split`` documentation.  The only difference\n    between these functions is that ``array_split`` allows\n    `indices_or_sections` to be an integer that does *not* equally\n    divide the axis.\n\n    See Also\n    --------\n    split : Split array into multiple sub-arrays of equal size.\n\n    Examples\n    --------\n    >>> x = np.arange(8.0)\n    >>> np.array_split(x, 3)\n        [array([ 0.,  1.,  2.]), array([ 3.,  4.,  5.]), array([ 6.,  7.])]\n    \n    ";
static char __pyx_k_620[] = "array_str (line 1093)";
static char __pyx_k_621[] = "Return a string representation of the data in an array.\n\n    The data in the array is returned as a single string.  This function is\n    similar to `array_repr`, the difference being that `array_repr` also\n    returns information on the kind of array and its data type.\n\n    Parameters\n    ----------\n    a : ndarray\n        Input array.\n    max_line_width : int, optional\n        Inserts newlines if text is longer than `max_line_width`.  The\n        default is, indirectly, 75.\n    precision : int, optional\n        Floating point precision.  Default is the current printing precision\n        (usually 8), which can be altered using `set_printoptions`.\n    suppress_small : bool, optional\n        Represent numbers \"very close\" to zero as zero; default is False.\n        Very close is defined by precision: if the precision is 8, e.g.,\n        numbers smaller (in absolute value) than 5e-9 are represented as\n        zero.\n\n    See Also\n    --------\n    array2string, array_repr, set_printoptions\n\n    Examples\n    --------\n    >>> np.array_str(np.arange(3))\n    '[0 1 2]'\n    \n    ";
static char __pyx_k_622[] = "asanyarray (line 1129)";
static char __pyx_k_623[] = "Convert the input to an ndarray, but pass ndarray subclasses through.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data, in any form that can be converted to an array.  This\n        includes scalars, lists, lists of tuples, tuples, tuples of tuples,\n        tuples of lists, and ndarrays.\n    dtype : data-type, optional\n        By default, the data-type is inferred from the input data.\n    order : {'C', 'F'}, optional\n        Whether to use row-major ('C') or column-major ('F') memory\n        representation.  Defaults to 'C'.\n\n    Returns\n    -------\n    out : ndarray or an ndarray subclass\n        Array interpretation of `a`.  If `a` is an ndarray or a subclass\n        of ndarray, it is returned as-is and no copy is performed.\n\n    See Also\n    --------\n    asarray : Similar function which always returns ndarrays.\n    ascontiguousarray : Convert input to a contiguous array.\n    asfarray : Convert input to a floating point ndarray.\n    asfortranarray : Convert input to an ndarray with column-major\n                     memory order.\n    asarray_chkfinite : Similar function which checks input for NaNs and\n                        Infs.\n    fromiter : Create an array from an iterator.\n    fromfunction : Construct an array by executing a function on grid\n                   positions.\n\n    Examples\n    --------\n    Convert a list into an array:\n\n    >>> a = [1, 2]\n    >>> np.asanyarray(a)\n    array([1, 2])\n\n    Instances of `ndarray` subclasses are passed through as-is:\n\n    >>> a = np.matrix([1, 2])\n    >>> np.asanyarray(a) is a\n    True\n    \n    ";
static char __pyx_k_624[] = "asarray_chkfinite (line 1181)";
static char __pyx_k_625[] = "Convert the input to an array, checking for NaNs or Infs.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data, in any form that can be converted to an array.  This\n        includes lists, lists of tuples, tuples, tuples of tuples, tuples\n        of lists and ndarrays.  Success requires no NaNs or Infs.\n    dtype : data-type, optional\n        By default, the data-type is inferred from the input data.\n    order : {'C', 'F'}, optional\n        Whether to use row-major ('C') or column-major ('FORTRAN') memory\n        representation.  Defaults to 'C'.\n\n    Returns\n    -------\n    out : ndarray\n        Array interpretation of `a`.  No copy is performed if the input\n        is already an ndarray.  If `a` is a subclass of ndarray, a base\n        class ndarray is returned.\n\n    Raises\n    ------\n    ValueError\n        Raises ValueError if `a` contains NaN (Not a Number) or Inf (Infinity).\n\n    See Also\n    --------\n    asarray : Create and array.\n    asanyarray : Similar function which passes through subclasses.\n    ascontiguousarray : Convert input to a contiguous array.\n    asfarray : Convert input to a floating point ndarray.\n    asfortranarray : Convert input to an ndarray with column-major\n                     memory order.\n    fromiter : Create an array from an iterator.\n    fromfunction : Construct an array by executing a function on grid\n                   positions.\n\n    Examples\n    --------\n    Convert a list into an array.  If all elements are finite\n    ``asarray_chkfinite`` is identical to ``asarray``.\n\n    >>> a = [1, 2]\n    >>> np.asarray_chkfinite(a)\n    array([1, 2])\n\n    Raises ValueError if array_like contains Nans or Infs.\n\n    >>> a = [1, 2, np.inf]\n    >>> try:\n    ...     np.asarray_chkfinite(a)\n    ... except ValueError:\n    ...     print 'ValueError'\n    ...\n    ValueError\n    \n    ";
static char __pyx_k_626[] = "ascontiguousarray (line 1243)";
static char __pyx_k_627[] = "Return a contiguous array in memory (C order).\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    dtype : str or dtype object, optional\n        Data-type of returned array.\n\n    Returns\n    -------\n    out : ndarray\n        Contiguous array of same shape and content as `a`, with type `dtype`\n        if specified.\n\n    See Also\n    --------\n    asfortranarray : Convert input to an ndarray with column-major\n                     memory order.\n    require : Return an ndarray that satisfies requirements.\n    ndarray.flags : Information about the memory layout of the array.\n\n    Examples\n    --------\n    >>> x = np.arange(6).reshape(2,3)\n    >>> np.ascontiguousarray(x, dtype=np.float32)\n    array([[ 0.,  1.,  2.],\n           [ 3.,  4.,  5.]], dtype=float32)\n    >>> x.flags['C_CONTIGUOUS']\n    True\n    \n    ";
static char __pyx_k_628[] = "asfarray (line 1279)";
static char __pyx_k_629[] = "Return an array converted to a float type.\n\n    Parameters\n    ----------\n    a : array_like\n        The input array.\n    dtype : str or dtype object, optional\n        Float type code to coerce input array `a`.  If `dtype` is one of the\n        'int' dtypes, it is replaced with float64.\n\n    Returns\n    -------\n    out : ndarray\n        The input `a` as a float ndarray.\n\n    Examples\n    --------\n    >>> np.asfarray([2, 3])\n    array([ 2.,  3.])\n    >>> np.asfarray([2, 3], dtype='float')\n    array([ 2.,  3.])\n    >>> np.asfarray([2, 3], dtype='int8')\n    array([ 2.,  3.])\n    \n    ";
static char __pyx_k_630[] = "asfortranarray (line 1308)";
static char __pyx_k_631[] = "Return an array laid out in Fortran order in memory.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    dtype : str or dtype object, optional\n        By default, the data-type is inferred from the input data.\n\n    Returns\n    -------\n    out : ndarray\n        The input `a` in Fortran, or column-major, order.\n\n    See Also\n    --------\n    ascontiguousarray : Convert input to a contiguous (C order) array.\n    asanyarray : Convert input to an ndarray with either row or\n        column-major memory order.\n    require : Return an ndarray that satisfies requirements.\n    ndarray.flags : Information about the memory layout of the array.\n\n    Examples\n    --------\n    >>> x = np.arange(6).reshape(2,3)\n    >>> y = np.asfortranarray(x)\n    >>> x.flags['F_CONTIGUOUS']\n    False\n    >>> y.flags['F_CONTIGUOUS']\n    True\n    \n    ";
static char __pyx_k_632[] = "asmatrix (line 1344)";
static char __pyx_k_633[] = "Interpret the input as a matrix.\n\n    Unlike `matrix`, `asmatrix` does not make a copy if the input is already\n    a matrix or an ndarray.  Equivalent to ``matrix(data, copy=False)``.\n\n    Parameters\n    ----------\n    data : array_like\n        Input data.\n\n    Returns\n    -------\n    mat : matrix\n        `data` interpreted as a matrix.\n\n    Examples\n    --------\n    >>> x = np.array([[1, 2], [3, 4]])\n\n    >>> m = np.asmatrix(x)\n\n    >>> x[0,0] = 5\n\n    >>> m\n    matrix([[5, 2],\n            [3, 4]])\n    \n    ";
static char __pyx_k_634[] = "asscalar (line 1376)";
static char __pyx_k_635[] = "Convert an array of size 1 to its scalar equivalent.\n\n    Parameters\n    ----------\n    a : ndarray\n        Input array of size 1.\n\n    Returns\n    -------\n    out : scalar\n        Scalar representation of `a`. The input data type is preserved.\n\n    Examples\n    --------\n    >>> np.asscalar(np.array([24]))\n    24\n    \n    ";
static char __pyx_k_636[] = "atleast_1d (line 1398)";
static char __pyx_k_637[] = "Convert inputs to arrays with at least one dimension.\n\n    Scalar inputs are converted to 1-dimensional arrays, whilst\n    higher-dimensional inputs are preserved.\n\n    Parameters\n    ----------\n    array1, array2, ... : array_like\n        One or more input arrays.\n\n    Returns\n    -------\n    ret : ndarray\n        An array, or sequence of arrays, each with ``a.ndim >= 1``.\n        Copies are made only if necessary.\n\n    See Also\n    --------\n    atleast_2d, atleast_3d\n\n    Examples\n    --------\n    >>> np.atleast_1d(1.0)\n    array([ 1.])\n\n    >>> x = np.arange(9.0).reshape(3,3)\n    >>> np.atleast_1d(x)\n    array([[ 0.,  1.,  2.],\n           [ 3.,  4.,  5.],\n           [ 6.,  7.,  8.]])\n    >>> np.atleast_1d(x) is x\n    True\n\n    >>> np.atleast_1d(1, [3, 4])\n    [array([1]), array([3, 4])]\n    \n    ";
static char __pyx_k_638[] = "atleast_2d (line 1439)";
static char __pyx_k_639[] = "View inputs as arrays with at least two dimensions.\n\n    Parameters\n    ----------\n    array1, array2, ... : array_like\n        One or more array-like sequences.  Non-array inputs are converted\n        to arrays.  Arrays that already have two or more dimensions are\n        preserved.\n\n    Returns\n    -------\n    res, res2, ... : ndarray\n        An array, or tuple of arrays, each with ``a.ndim >= 2``.\n        Copies are avoided where possible, and views with two or more\n        dimensions are returned.\n\n    See Also\n    --------\n    atleast_1d, atleast_3d\n\n    Examples\n    --------\n    >>> np.atleast_2d(3.0)\n    array([[ 3.]])\n\n    >>> x = np.arange(3.0)\n    >>> np.atleast_2d(x)\n    array([[ 0.,  1.,  2.]])\n    >>> np.atleast_2d(x).base is x\n    True\n\n    >>> np.atleast_2d(1, [1, 2], [[1, 2]])\n    [array([[1]]), array([[1, 2]]), array([[1, 2]])]\n    \n    ";
static char __pyx_k_640[] = "atleast_3d (line 1478)";
static char __pyx_k_641[] = "View inputs as arrays with at least three dimensions.\n\n    Parameters\n    ----------\n    array1, array2, ... : array_like\n        One or more array-like sequences.  Non-array inputs are converted to\n        arrays.  Arrays that already have three or more dimensions are\n        preserved.\n\n    Returns\n    -------\n    res1, res2, ... : ndarray\n        An array, or tuple of arrays, each with ``a.ndim >= 3``.  Copies are\n        avoided where possible, and views with three or more dimensions are\n        returned.  For example, a 1-D array of shape ``(N,)`` becomes a view\n        of shape ``(1, N, 1)``, and a 2-D array of shape ``(M, N)`` becomes a\n        view of shape ``(M, N, 1)``.\n\n    See Also\n    --------\n    atleast_1d, atleast_2d\n\n    Examples\n    --------\n    >>> np.atleast_3d(3.0)\n    array([[[ 3.]]])\n\n    >>> x = np.arange(3.0)\n    >>> np.atleast_3d(x).shape\n    (1, 3, 1)\n\n    >>> x = np.arange(12.0).reshape(4,3)\n    >>> np.atleast_3d(x).shape\n    (4, 3, 1)\n    >>> np.atleast_3d(x).base is x\n    True\n\n    >>> for arr in np.atleast_3d([1, 2], [[1, 2]], [[[1, 2]]]):\n    ...     print arr, arr.shape\n    ...\n    [[[1]\n      [2]]] (1, 2, 1)\n    [[[1]\n      [2]]] (1, 2, 1)\n    [[[1 2]]] (1, 1, 2)\n    \n    ";
static char __pyx_k_642[] = "average (line 1529)";
static char __pyx_k_643[] = "Compute the weighted average along the specified axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Array containing data to be averaged. If `a` is not an array, a\n        conversion is attempted.\n    axis : int, optional\n        Axis along which to average `a`. If `None`, averaging is done over\n        the flattened array.\n    weights : array_like, optional\n        An array of weights associated with the values in `a`. Each value in\n        `a` contributes to the average according to its associated weight.\n        The weights array can either be 1-D (in which case its length must be\n        the size of `a` along the given axis) or of the same shape as `a`.\n        If `weights=None`, then all data in `a` are assumed to have a\n        weight equal to one.\n    returned : bool, optional\n        Default is `False`. If `True`, the tuple (`average`, `sum_of_weights`)\n        is returned, otherwise only the average is returned.\n        If `weights=None`, `sum_of_weights` is equivalent to the number of\n        elements over which the average is taken.\n\n\n    Returns\n    -------\n    average, [sum_of_weights] : {array_type, double}\n        Return the average along the specified axis. When returned is `True`,\n        return a tuple with the average as the first element and the sum\n        of the weights as the second element. The return type is `Float`\n        if `a` is of integer type, otherwise it is of the same type as `a`.\n        `sum_of_weights` is of the same type as `average`.\n\n    Raises\n    ------\n    ZeroDivisionError\n        When all weights along axis are zero. See `numpy.ma.average` for a\n        version robust to this type of error.\n    TypeError\n        When the length of 1D `weights` is not the same as the shape of `a`\n        along axis.\n\n    See Also\n    --------\n    mean\n\n    ma.average : average for masked arrays\n\n    Examples\n    --------\n    >>> data = range(1,5)\n    >>> data\n    [1, 2, 3, 4""]\n    >>> np.average(data)\n    2.5\n    >>> np.average(range(1,11), weights=range(10,0,-1))\n    4.0\n\n    >>> data = np.arange(6).reshape((3,2))\n    >>> data\n    array([[0, 1],\n           [2, 3],\n           [4, 5]])\n    >>> np.average(data, axis=1, weights=[1./4, 3./4])\n    array([ 0.75,  2.75,  4.75])\n    >>> np.average(data, weights=[1./4, 3./4])\n    Traceback (most recent call last):\n    ...\n    TypeError: Axis must be specified when shapes of a and weights differ.\n    \n    ";
static char __pyx_k_644[] = "bartlett (line 1604)";
static char __pyx_k_645[] = "Return the Bartlett window.\n\n    The Bartlett window is very similar to a triangular window, except\n    that the end points are at zero.  It is often used in signal\n    processing for tapering a signal, without generating too much\n    ripple in the frequency domain.\n\n    Parameters\n    ----------\n    M : int\n        Number of points in the output window. If zero or less, an\n        empty array is returned.\n\n    Returns\n    -------\n    out : array\n        The triangular window, normalized to one (the value one\n        appears only if the number of samples is odd), with the first\n        and last samples equal to zero.\n\n    See Also\n    --------\n    blackman, hamming, hanning, kaiser\n\n    Notes\n    -----\n    The Bartlett window is defined as\n\n    .. math:: w(n) = \014rac{2}{M-1} \\left(\n              \014rac{M-1}{2} - \\left|n - \014rac{M-1}{2}\right|\n              \right)\n\n    Most references to the Bartlett window come from the signal\n    processing literature, where it is used as one of many windowing\n    functions for smoothing values.  Note that convolution with this\n    window produces linear interpolation.  It is also known as an\n    apodization (which means\"removing the foot\", i.e. smoothing\n    discontinuities at the beginning and end of the sampled signal) or\n    tapering function. The fourier transform of the Bartlett is the product\n    of two sinc functions.\n    Note the excellent discussion in Kanasewich.\n\n    References\n    ----------\n    .. [1] M.S. Bartlett, \"Periodogram Analysis and Continuous Spectra\",\n           Biometrika 37, 1-16, 1950.\n    .. [2] E.R. Kanasewich, \"Time Sequence Analysis in Geophysics\",\n           The University of Alberta Press, 1975, pp. 109-110.\n    .. [3] A.V. Oppenheim and R.W. Schafer, \"Discrete-Time Signal\n           Processing\", Prentice-Hall, 1999, pp. 468-471.\n    .. [4] Wikipedia, \"Window function\",\n           http://en.wikipedia.org/wiki/Window_function\n    "".. [5] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,\n           \"Numerical Recipes\", Cambridge University Press, 1986, page 429.\n\n\n    Examples\n    --------\n    >>> np.bartlett(12)\n    array([ 0.        ,  0.18181818,  0.36363636,  0.54545455,  0.72727273,\n            0.90909091,  0.90909091,  0.72727273,  0.54545455,  0.36363636,\n            0.18181818,  0.        ])\n\n    Plot the window and its frequency response (requires SciPy and matplotlib):\n\n    >>> from numpy import clip, log10, array, bartlett, linspace\n    >>> from numpy.fft import fft, fftshift\n    >>> import matplotlib.pyplot as plt\n\n    >>> window = bartlett(51)\n    >>> plt.plot(window)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Bartlett window\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.ylabel(\"Amplitude\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.xlabel(\"Sample\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.show()\n\n    >>> plt.figure()\n    <matplotlib.figure.Figure object at 0x...>\n    >>> A = fft(window, 2048) / 25.5\n    >>> mag = abs(fftshift(A))\n    >>> freq = linspace(-0.5,0.5,len(A))\n    >>> response = 20*log10(mag)\n    >>> response = clip(response,-100,100)\n    >>> plt.plot(freq, response)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Frequency response of Bartlett window\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.ylabel(\"Magnitude [dB]\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.xlabel(\"Normalized frequency [cycles per sample]\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.axis('tight')\n    (-0.5, 0.5, -100.0, ...)\n    >>> plt.show()\n    \n    ";
static char __pyx_k_646[] = "base_repr (line 1708)";
static char __pyx_k_647[] = "Return a string representation of a number in the given base system.\n\n    Parameters\n    ----------\n    number : int\n        The value to convert. Only positive values are handled.\n    base : int, optional\n        Convert `number` to the `base` number system. The valid range is 2-36,\n        the default value is 2.\n    padding : int, optional\n        Number of zeros padded on the left. Default is 0 (no padding).\n\n    Returns\n    -------\n    out : str\n        String representation of `number` in `base` system.\n\n    See Also\n    --------\n    binary_repr : Faster version of `base_repr` for base 2.\n\n    Examples\n    --------\n    >>> np.base_repr(5)\n    '101'\n    >>> np.base_repr(6, 5)\n    '11'\n    >>> np.base_repr(7, base=5, padding=3)\n    '00012'\n\n    >>> np.base_repr(10, base=16)\n    'A'\n    >>> np.base_repr(32, base=16)\n    '20'\n    \n    ";
static char __pyx_k_648[] = "binary_repr (line 1748)";
static char __pyx_k_649[] = "Return the binary representation of the input number as a string.\n\n    For negative numbers, if width is not given, a minus sign is added to the\n    front. If width is given, the two's complement of the number is\n    returned, with respect to that width.\n\n    In a two's-complement system negative numbers are represented by the two's\n    complement of the absolute value. This is the most common method of\n    representing signed integers on computers [1]_. A N-bit two's-complement\n    system can represent every integer in the range\n    :math:`-2^{N-1}` to :math:`+2^{N-1}-1`.\n\n    Parameters\n    ----------\n    num : int\n        Only an integer decimal number can be used.\n    width : int, optional\n        The length of the returned string if `num` is positive, the length of\n        the two's complement if `num` is negative.\n\n    Returns\n    -------\n    bin : str\n        Binary representation of `num` or two's complement of `num`.\n\n    See Also\n    --------\n    base_repr: Return a string representation of a number in the given base\n               system.\n\n    Notes\n    -----\n    `binary_repr` is equivalent to using `base_repr` with base 2, but about 25x\n    faster.\n\n    References\n    ----------\n    .. [1] Wikipedia, \"Two's complement\",\n        http://en.wikipedia.org/wiki/Two's_complement\n\n    Examples\n    --------\n    >>> np.binary_repr(3)\n    '11'\n    >>> np.binary_repr(-3)\n    '-11'\n    >>> np.binary_repr(3, width=4)\n    '0011'\n\n    The two's complement is returned when the input number is negative and\n    width is specified:\n\n    >>> np.binary_repr(-3, width=4)\n    '1101'\n    \n    ";
static char __pyx_k_650[] = "bincount (line 1808)";
static char __pyx_k_651[] = "bincount(x, weights=None, minlength=None)\n\n    Count number of occurrences of each value in array of non-negative ints.\n\n    The number of bins (of size 1) is one larger than the largest value in\n    `x`. If `minlength` is specified, there will be at least this number\n    of bins in the output array (though it will be longer if necessary,\n    depending on the contents of `x`).\n    Each bin gives the number of occurrences of its index value in `x`.\n    If `weights` is specified the input array is weighted by it, i.e. if a\n    value ``n`` is found at position ``i``, ``out[n] += weight[i]`` instead\n    of ``out[n] += 1``.\n\n    Parameters\n    ----------\n    x : array_like, 1 dimension, nonnegative ints\n        Input array.\n    weights : array_like, optional\n        Weights, array of the same shape as `x`.\n    minlength : int, optional\n        .. versionadded:: 1.6.0\n\n        A minimum number of bins for the output array.\n\n    Returns\n    -------\n    out : ndarray of ints\n        The result of binning the input array.\n        The length of `out` is equal to ``np.amax(x)+1``.\n\n    Raises\n    ------\n    ValueError\n        If the input is not 1-dimensional, or contains elements with negative\n        values, or if `minlength` is non-positive.\n    TypeError\n        If the type of the input is float or complex.\n\n    See Also\n    --------\n    histogram, digitize, unique\n\n    Examples\n    --------\n    >>> np.bincount(np.arange(5))\n    array([1, 1, 1, 1, 1])\n    >>> np.bincount(np.array([0, 1, 1, 3, 2, 1, 7]))\n    array([1, 3, 1, 1, 0, 0, 0, 1])\n\n    >>> x = np.array([0, 1, 1, 3, 2, 1, 7, 23])\n    >>> np.bincount(x).size == np.amax(x)+1\n    True\n\n    The input array needs to be of integer dtype, otherwise a\n    TypeError is raised:\n\n    >>> np.bincount(np.arange(5, dtype=np.float))\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    TypeError: array cannot be safely cast to required type""\n\n    A possible use of ``bincount`` is to perform sums over\n    variable-size chunks of an array, using the ``weights`` keyword.\n\n    >>> w = np.array([0.3, 0.5, 0.2, 0.7, 1., -0.6]) # weights\n    >>> x = np.array([0, 1, 1, 2, 2, 2])\n    >>> np.bincount(x,  weights=w)\n    array([ 0.3,  0.7,  1.1])\n    \n    ";
static char __pyx_k_652[] = "blackman (line 1883)";
static char __pyx_k_653[] = "Return the Blackman window.\n\n    The Blackman window is a taper formed by using the the first three\n    terms of a summation of cosines. It was designed to have close to the\n    minimal leakage possible.  It is close to optimal, only slightly worse\n    than a Kaiser window.\n\n    Parameters\n    ----------\n    M : int\n        Number of points in the output window. If zero or less, an empty\n        array is returned.\n\n    Returns\n    -------\n    out : ndarray\n        The window, normalized to one (the value one appears only if the\n        number of samples is odd).\n\n    See Also\n    --------\n    bartlett, hamming, hanning, kaiser\n\n    Notes\n    -----\n    The Blackman window is defined as\n\n    .. math::  w(n) = 0.42 - 0.5 \\cos(2\\pi n/M) + 0.08 \\cos(4\\pi n/M)\n\n    Most references to the Blackman window come from the signal processing\n    literature, where it is used as one of many windowing functions for\n    smoothing values.  It is also known as an apodization (which means\n    \"removing the foot\", i.e. smoothing discontinuities at the beginning\n    and end of the sampled signal) or tapering function. It is known as a\n    \"near optimal\" tapering function, almost as good (by some measures)\n    as the kaiser window.\n\n    References\n    ----------\n    Blackman, R.B. and Tukey, J.W., (1958) The measurement of power spectra,\n    Dover Publications, New York.\n\n    Oppenheim, A.V., and R.W. Schafer. Discrete-Time Signal Processing.\n    Upper Saddle River, NJ: Prentice-Hall, 1999, pp. 468-471.\n\n    Examples\n    --------\n    >>> from numpy import blackman\n    >>> blackman(12)\n    array([ -1.38777878e-17,   3.26064346e-02,   1.59903635e-01,\n             4.14397981e-01,   7.36045180e-01,   9.67046769e-01,\n             9.67046769e-01,   7.36045180e-01,   4.14397981e-01,\n             1.59903635e-01,   3.26064346e-02,  -1.38777878e-17])\n\n\n    Plot the window and the frequency response:\n\n    >>> from numpy import clip, lo""g10, array, blackman, linspace\n    >>> from numpy.fft import fft, fftshift\n    >>> import matplotlib.pyplot as plt\n\n    >>> window = blackman(51)\n    >>> plt.plot(window)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Blackman window\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.ylabel(\"Amplitude\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.xlabel(\"Sample\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.show()\n\n    >>> plt.figure()\n    <matplotlib.figure.Figure object at 0x...>\n    >>> A = fft(window, 2048) / 25.5\n    >>> mag = abs(fftshift(A))\n    >>> freq = linspace(-0.5,0.5,len(A))\n    >>> response = 20*log10(mag)\n    >>> response = clip(response,-100,100)\n    >>> plt.plot(freq, response)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Frequency response of Blackman window\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.ylabel(\"Magnitude [dB]\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.xlabel(\"Normalized frequency [cycles per sample]\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.axis('tight')\n    (-0.5, 0.5, -100.0, ...)\n    >>> plt.show()\n    \n    ";
static char __pyx_k_654[] = "bmat (line 1979)";
static char __pyx_k_655[] = "Build a matrix object from a string, nested sequence, or array.\n\n    Parameters\n    ----------\n    obj : str or array_like\n        Input data.  Names of variables in the current scope may be\n        referenced, even if `obj` is a string.\n\n    Returns\n    -------\n    out : matrix\n        Returns a matrix object, which is a specialized 2-D array.\n\n    See Also\n    --------\n    matrix\n\n    Examples\n    --------\n    >>> A = np.mat('1 1; 1 1')\n    >>> B = np.mat('2 2; 2 2')\n    >>> C = np.mat('3 4; 5 6')\n    >>> D = np.mat('7 8; 9 0')\n\n    All the following expressions construct the same block matrix:\n\n    >>> np.bmat([[A, B], [C, D]])\n    matrix([[1, 1, 2, 2],\n            [1, 1, 2, 2],\n            [3, 4, 7, 8],\n            [5, 6, 9, 0]])\n    >>> np.bmat(np.r_[np.c_[A, B], np.c_[C, D]])\n    matrix([[1, 1, 2, 2],\n            [1, 1, 2, 2],\n            [3, 4, 7, 8],\n            [5, 6, 9, 0]])\n    >>> np.bmat('A,B; C,D')\n    matrix([[1, 1, 2, 2],\n            [1, 1, 2, 2],\n            [3, 4, 7, 8],\n            [5, 6, 9, 0]])\n    \n    ";
static char __pyx_k_656[] = "broadcast_arrays (line 2026)";
static char __pyx_k_657[] = "Broadcast any number of arrays against each other.\n\n    Parameters\n    ----------\n    `*args` : array_likes\n        The arrays to broadcast.\n\n    Returns\n    -------\n    broadcasted : list of arrays\n        These arrays are views on the original arrays.  They are typically\n        not contiguous.  Furthermore, more than one element of a\n        broadcasted array may refer to a single memory location.  If you\n        need to write to the arrays, make copies first.\n\n    Examples\n    --------\n    >>> x = np.array([[1,2,3]])\n    >>> y = np.array([[1],[2],[3]])\n    >>> np.broadcast_arrays(x, y)\n    [array([[1, 2, 3],\n           [1, 2, 3],\n           [1, 2, 3]]), array([[1, 1, 1],\n           [2, 2, 2],\n           [3, 3, 3]])]\n\n    Here is a useful idiom for getting contiguous copies instead of\n    non-contiguous views.\n\n    >>> map(np.array, np.broadcast_arrays(x, y))\n    [array([[1, 2, 3],\n           [1, 2, 3],\n           [1, 2, 3]]), array([[1, 1, 1],\n           [2, 2, 2],\n           [3, 3, 3]])]\n    \n    ";
static char __pyx_k_658[] = "byte_bounds (line 2067)";
static char __pyx_k_659[] = "Returns pointers to the end-points of an array.\n\n    Parameters\n    ----------\n    a : ndarray\n        Input array. It must conform to the Python-side of the array interface.\n\n    Returns\n    -------\n    (low, high) : tuple of 2 integers\n        The first integer is the first byte of the array, the second integer is\n        just past the last byte of the array.  If `a` is not contiguous it\n        will not use every byte between the (`low`, `high`) values.\n\n    Examples\n    --------\n    >>> I = np.eye(2, dtype='f'); I.dtype\n    dtype('float32')\n    >>> low, high = np.byte_bounds(I)\n    >>> high - low == I.size*I.itemsize\n    True\n    >>> I = np.eye(2, dtype='G'); I.dtype\n    dtype('complex192')\n    >>> low, high = np.byte_bounds(I)\n    >>> high - low == I.size*I.itemsize\n    True\n    \n    ";
static char __pyx_k_660[] = "can_cast (line 2099)";
static char __pyx_k_661[] = "can_cast(from, totype, casting = 'safe')\n\n    Returns True if cast between data types can occur according to the\n    casting rule.  If from is a scalar or array scalar, also returns\n    True if the scalar value can be cast without overflow or truncation\n    to an integer.\n\n    Parameters\n    ----------\n    from : dtype, dtype specifier, scalar, or array\n        Data type, scalar, or array to cast from.\n    totype : dtype or dtype specifier\n        Data type to cast to.\n    casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional\n        Controls what kind of data casting may occur.\n\n          * 'no' means the data types should not be cast at all.\n          * 'equiv' means only byte-order changes are allowed.\n          * 'safe' means only casts which can preserve values are allowed.\n          * 'same_kind' means only safe casts or casts within a kind,\n            like float64 to float32, are allowed.\n          * 'unsafe' means any data conversions may be done.\n\n    Returns\n    -------\n    out : bool\n        True if cast can occur according to the casting rule.\n\n    See also\n    --------\n    dtype, result_type\n\n    Examples\n    --------\n\n    Basic examples\n\n    >>> np.can_cast(np.int32, np.int64)\n    True\n    >>> np.can_cast(np.float64, np.complex)\n    True\n    >>> np.can_cast(np.complex, np.float)\n    False\n\n    >>> np.can_cast('i8', 'f8')\n    True\n    >>> np.can_cast('i8', 'f4')\n    False\n    >>> np.can_cast('i4', 'S4')\n    True\n\n    Casting scalars\n\n    >>> np.can_cast(100, 'i1')\n    True\n    >>> np.can_cast(150, 'i1')\n    False\n    >>> np.can_cast(150, 'u1')\n    True\n\n    >>> np.can_cast(3.5e100, np.float32)\n    False\n    >>> np.can_cast(1000.0, np.float32)\n    True\n\n    Array scalar checks the value, array does not\n\n    >>> np.can_cast(np.array(1000.0), np.float32)\n    True\n    >>> np.can_cast(np.array([1000.0]), np.float32)\n    False\n\n    Using the casting rules\n\n    >>> np.can_c""ast('i8', 'i8', 'no')\n    True\n    >>> np.can_cast('<i8', '>i8', 'no')\n    False\n\n    >>> np.can_cast('<i8', '>i8', 'equiv')\n    True\n    >>> np.can_cast('<i4', '>i8', 'equiv')\n    False\n\n    >>> np.can_cast('<i4', '>i8', 'safe')\n    True\n    >>> np.can_cast('<i8', '>i4', 'safe')\n    False\n\n    >>> np.can_cast('<i8', '>i4', 'same_kind')\n    True\n    >>> np.can_cast('<i8', '>u4', 'same_kind')\n    False\n\n    >>> np.can_cast('<i8', '>u4', 'unsafe')\n    True\n    \n    ";
static char __pyx_k_662[] = "choose (line 2202)";
static char __pyx_k_663[] = "Construct an array from an index array and a set of arrays to choose from.\n\n    First of all, if confused or uncertain, definitely look at the Examples -\n    in its full generality, this function is less simple than it might\n    seem from the following code description (below ndi =\n    `numpy.lib.index_tricks`):\n\n    ``np.choose(a,c) == np.array([c[a[I]][I] for I in ndi.ndindex(a.shape)])``.\n\n    But this omits some subtleties.  Here is a fully general summary:\n\n    Given an \"index\" array (`a`) of integers and a sequence of `n` arrays\n    (`choices`), `a` and each choice array are first broadcast, as necessary,\n    to arrays of a common shape; calling these *Ba* and *Bchoices[i], i =\n    0,...,n-1* we have that, necessarily, ``Ba.shape == Bchoices[i].shape``\n    for each `i`.  Then, a new array with shape ``Ba.shape`` is created as\n    follows:\n\n    * if ``mode=raise`` (the default), then, first of all, each element of\n      `a` (and thus `Ba`) must be in the range `[0, n-1]`; now, suppose that\n      `i` (in that range) is the value at the `(j0, j1, ..., jm)` position\n      in `Ba` - then the value at the same position in the new array is the\n      value in `Bchoices[i]` at that same position;\n\n    * if ``mode=wrap``, values in `a` (and thus `Ba`) may be any (signed)\n      integer; modular arithmetic is used to map integers outside the range\n      `[0, n-1]` back into that range; and then the new array is constructed\n      as above;\n\n    * if ``mode=clip``, values in `a` (and thus `Ba`) may be any (signed)\n      integer; negative integers are mapped to 0; values greater than `n-1`\n      are mapped to `n-1`; and then the new array is constructed as above.\n\n    Parameters\n    ----------\n    a : int array\n        This array must contain integers in `[0, n-1]`, where `n` is the number\n        of choices, unless ``mode=wrap`` or ``mode=clip``, in which cases any\n        integers are permissible.\n    choices : sequence of arrays""\n        Choice arrays. `a` and all of the choices must be broadcastable to the\n        same shape.  If `choices` is itself an array (not recommended), then\n        its outermost dimension (i.e., the one corresponding to\n        ``choices.shape[0]``) is taken as defining the \"sequence\".\n    out : array, optional\n        If provided, the result will be inserted into this array. It should\n        be of the appropriate shape and dtype.\n    mode : {'raise' (default), 'wrap', 'clip'}, optional\n        Specifies how indices outside `[0, n-1]` will be treated:\n\n          * 'raise' : an exception is raised\n          * 'wrap' : value becomes value mod `n`\n          * 'clip' : values < 0 are mapped to 0, values > n-1 are mapped to n-1\n\n    Returns\n    -------\n    merged_array : array\n        The merged result.\n\n    Raises\n    ------\n    ValueError: shape mismatch\n        If `a` and each choice array are not all broadcastable to the same\n        shape.\n\n    See Also\n    --------\n    ndarray.choose : equivalent method\n\n    Notes\n    -----\n    To reduce the chance of misinterpretation, even though the following\n    \"abuse\" is nominally supported, `choices` should neither be, nor be\n    thought of as, a single array, i.e., the outermost sequence-like container\n    should be either a list or a tuple.\n\n    Examples\n    --------\n\n    >>> choices = [[0, 1, 2, 3], [10, 11, 12, 13],\n    ...   [20, 21, 22, 23], [30, 31, 32, 33]]\n    >>> np.choose([2, 3, 1, 0], choices\n    ... # the first element of the result will be the first element of the\n    ... # third (2+1) \"array\" in choices, namely, 20; the second element\n    ... # will be the second element of the fourth (3+1) choice array, i.e.,\n    ... # 31, etc.\n    ... )\n    array([20, 31, 12,  3])\n    >>> np.choose([2, 4, 1, 0], choices, mode='clip') # 4 goes to 3 (4-1)\n    array([20, 31, 12,  3])\n    >>> # because there are 4 choice arrays\n    >>> np.choose([2, 4, 1, 0], choices, m""ode='wrap') # 4 goes to (4 mod 4)\n    array([20,  1, 12,  3])\n    >>> # i.e., 0\n\n    A couple examples illustrating how choose broadcasts:\n\n    >>> a = [[1, 0, 1], [0, 1, 0], [1, 0, 1]]\n    >>> choices = [-10, 10]\n    >>> np.choose(a, choices)\n    array([[ 10, -10,  10],\n           [-10,  10, -10],\n           [ 10, -10,  10]])\n\n    >>> # With thanks to Anne Archibald\n    >>> a = np.array([0, 1]).reshape((2,1,1))\n    >>> c1 = np.array([1, 2, 3]).reshape((1,3,1))\n    >>> c2 = np.array([-1, -2, -3, -4, -5]).reshape((1,1,5))\n    >>> np.choose(a, (c1, c2)) # result is 2x3x5, res[0,:,:]=c1, res[1,:,:]=c2\n    array([[[ 1,  1,  1,  1,  1],\n            [ 2,  2,  2,  2,  2],\n            [ 3,  3,  3,  3,  3]],\n           [[-1, -2, -3, -4, -5],\n            [-1, -2, -3, -4, -5],\n            [-1, -2, -3, -4, -5]]])\n    \n    ";
static char __pyx_k_664[] = "column_stack (line 2323)";
static char __pyx_k_665[] = "Stack 1-D arrays as columns into a 2-D array.\n\n    Take a sequence of 1-D arrays and stack them as columns\n    to make a single 2-D array. 2-D arrays are stacked as-is,\n    just like with `hstack`.  1-D arrays are turned into 2-D columns\n    first.\n\n    Parameters\n    ----------\n    tup : sequence of 1-D or 2-D arrays.\n        Arrays to stack. All of them must have the same first dimension.\n\n    Returns\n    -------\n    stacked : 2-D array\n        The array formed by stacking the given arrays.\n\n    See Also\n    --------\n    hstack, vstack, concatenate\n\n    Notes\n    -----\n    This function is equivalent to ``np.vstack(tup).T``.\n\n    Examples\n    --------\n    >>> a = np.array((1,2,3))\n    >>> b = np.array((2,3,4))\n    >>> np.column_stack((a,b))\n    array([[1, 2],\n           [2, 3],\n           [3, 4]])\n    \n    ";
static char __pyx_k_666[] = "common_type (line 2362)";
static char __pyx_k_667[] = "Return a scalar type which is common to the input arrays.\n\n    The return type will always be an inexact (i.e. floating point) scalar\n    type, even if all the arrays are integer arrays. If one of the inputs is\n    an integer array, the minimum precision type that is returned is a\n    64-bit floating point dtype.\n\n    All input arrays can be safely cast to the returned dtype without loss\n    of information.\n\n    Parameters\n    ----------\n    array1, array2, ... : ndarrays\n        Input arrays.\n\n    Returns\n    -------\n    out : data type code\n        Data type code.\n\n    See Also\n    --------\n    dtype, mintypecode\n\n    Examples\n    --------\n    >>> np.common_type(np.arange(2, dtype=np.float32))\n    <type 'numpy.float32'>\n    >>> np.common_type(np.arange(2, dtype=np.float32), np.arange(2))\n    <type 'numpy.float64'>\n    >>> np.common_type(np.arange(4), np.array([45, 6.j]), np.array([45.0]))\n    <type 'numpy.complex128'>\n    \n    ";
static char __pyx_k_668[] = "compress (line 2408)";
static char __pyx_k_669[] = "Return selected slices of an array along given axis.\n\n    When working along a given axis, a slice along that axis is returned in\n    `output` for each index where `condition` evaluates to True. When\n    working on a 1-D array, `compress` is equivalent to `extract`.\n\n    Parameters\n    ----------\n    condition : 1-D array of bools\n        Array that selects which entries to return. If len(condition)\n        is less than the size of `a` along the given axis, then output is\n        truncated to the length of the condition array.\n    a : array_like\n        Array from which to extract a part.\n    axis : int, optional\n        Axis along which to take slices. If None (default), work on the\n        flattened array.\n    out : ndarray, optional\n        Output array.  Its type is preserved and it must be of the right\n        shape to hold the output.\n\n    Returns\n    -------\n    compressed_array : ndarray\n        A copy of `a` without the slices along axis for which `condition`\n        is false.\n\n    See Also\n    --------\n    take, choose, diag, diagonal, select\n    ndarray.compress : Equivalent method.\n    numpy.doc.ufuncs : Section \"Output arguments\"\n\n    Examples\n    --------\n    >>> a = np.array([[1, 2], [3, 4], [5, 6]])\n    >>> a\n    array([[1, 2],\n           [3, 4],\n           [5, 6]])\n    >>> np.compress([0, 1], a, axis=0)\n    array([[3, 4]])\n    >>> np.compress([False, True, True], a, axis=0)\n    array([[3, 4],\n           [5, 6]])\n    >>> np.compress([False, True], a, axis=1)\n    array([[2],\n           [4],\n           [6]])\n\n    Working on the flattened array does not return slices along an axis but\n    selects elements.\n\n    >>> np.compress([False, True], a)\n    array([2])\n    \n    ";
static char __pyx_k_670[] = "concatenate (line 2469)";
static char __pyx_k_671[] = "concatenate((a1, a2, ...), axis=0)\n\n    Join a sequence of arrays together.\n\n    Parameters\n    ----------\n    a1, a2, ... : sequence of array_like\n        The arrays must have the same shape, except in the dimension\n        corresponding to `axis` (the first, by default).\n    axis : int, optional\n        The axis along which the arrays will be joined.  Default is 0.\n\n    Returns\n    -------\n    res : ndarray\n        The concatenated array.\n\n    See Also\n    --------\n    ma.concatenate : Concatenate function that preserves input masks.\n    array_split : Split an array into multiple sub-arrays of equal or\n                  near-equal size.\n    split : Split array into a list of multiple sub-arrays of equal size.\n    hsplit : Split array into multiple sub-arrays horizontally (column wise)\n    vsplit : Split array into multiple sub-arrays vertically (row wise)\n    dsplit : Split array into multiple sub-arrays along the 3rd axis (depth).\n    hstack : Stack arrays in sequence horizontally (column wise)\n    vstack : Stack arrays in sequence vertically (row wise)\n    dstack : Stack arrays in sequence depth wise (along third dimension)\n\n    Notes\n    -----\n    When one or more of the arrays to be concatenated is a MaskedArray,\n    this function will return a MaskedArray object instead of an ndarray,\n    but the input masks are *not* preserved. In cases where a MaskedArray\n    is expected as input, use the ma.concatenate function from the masked\n    array module instead.\n\n    Examples\n    --------\n    >>> a = np.array([[1, 2], [3, 4]])\n    >>> b = np.array([[5, 6]])\n    >>> np.concatenate((a, b), axis=0)\n    array([[1, 2],\n           [3, 4],\n           [5, 6]])\n    >>> np.concatenate((a, b.T), axis=1)\n    array([[1, 2, 5],\n           [3, 4, 6]])\n\n    This function will not preserve masking of MaskedArray inputs.\n\n    >>> a = np.ma.arange(3)\n    >>> a[1] = np.ma.masked\n    >>> b = np.arange(2, 5)\n    >>> a\n    masked_arr""ay(data = [0 -- 2],\n                 mask = [False  True False],\n           fill_value = 999999)\n    >>> b\n    array([2, 3, 4])\n    >>> np.concatenate([a, b])\n    masked_array(data = [0 1 2 2 3 4],\n                 mask = False,\n           fill_value = 999999)\n    >>> np.ma.concatenate([a, b])\n    masked_array(data = [0 -- 2 2 3 4],\n                 mask = [False  True False False False False],\n           fill_value = 999999)\n    \n    ";
static char __pyx_k_672[] = "convolve (line 2545)";
static char __pyx_k_673[] = "Returns the discrete, linear convolution of two one-dimensional sequences.\n\n    The convolution operator is often seen in signal processing, where it\n    models the effect of a linear time-invariant system on a signal [1]_.  In\n    probability theory, the sum of two independent random variables is\n    distributed according to the convolution of their individual\n    distributions.\n\n    Parameters\n    ----------\n    a : (N,) array_like\n        First one-dimensional input array.\n    v : (M,) array_like\n        Second one-dimensional input array.\n    mode : {'full', 'valid', 'same'}, optional\n        'full':\n          By default, mode is 'full'.  This returns the convolution\n          at each point of overlap, with an output shape of (N+M-1,). At\n          the end-points of the convolution, the signals do not overlap\n          completely, and boundary effects may be seen.\n\n        'same':\n          Mode `same` returns output of length ``max(M, N)``.  Boundary\n          effects are still visible.\n\n        'valid':\n          Mode `valid` returns output of length\n          ``max(M, N) - min(M, N) + 1``.  The convolution product is only given\n          for points where the signals overlap completely.  Values outside\n          the signal boundary have no effect.\n\n    Returns\n    -------\n    out : ndarray\n        Discrete, linear convolution of `a` and `v`.\n\n    See Also\n    --------\n    scipy.signal.fftconvolve : Convolve two arrays using the Fast Fourier\n                               Transform.\n    scipy.linalg.toeplitz : Used to construct the convolution operator.\n\n    Notes\n    -----\n    The discrete convolution operation is defined as\n\n    .. math:: (f * g)[n] = \\sum_{m = -\\infty}^{\\infty} f[m] g[n - m]\n\n    It can be shown that a convolution :math:`x(t) * y(t)` in time/space\n    is equivalent to the multiplication :math:`X(f) Y(f)` in the Fourier\n    domain, after appropriate padding (padding is necessary to prevent""\n    circular convolution).  Since multiplication is more efficient (faster)\n    than convolution, the function `scipy.signal.fftconvolve` exploits the\n    FFT to calculate the convolution of large data-sets.\n\n    References\n    ----------\n    .. [1] Wikipedia, \"Convolution\", http://en.wikipedia.org/wiki/Convolution.\n\n    Examples\n    --------\n    Note how the convolution operator flips the second array\n    before \"sliding\" the two across one another:\n\n    >>> np.convolve([1, 2, 3], [0, 1, 0.5])\n    array([ 0. ,  1. ,  2.5,  4. ,  1.5])\n\n    Only return the middle values of the convolution.\n    Contains boundary effects, where zeros are taken\n    into account:\n\n    >>> np.convolve([1,2,3],[0,1,0.5], 'same')\n    array([ 1. ,  2.5,  4. ])\n\n    The two arrays are of the same length, so there\n    is only one position where they completely overlap:\n\n    >>> np.convolve([1,2,3],[0,1,0.5], 'valid')\n    array([ 2.5])\n    \n    ";
static char __pyx_k_674[] = "copy (line 2630)";
static char __pyx_k_675[] = "Return an array copy of the given object.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n\n    Returns\n    -------\n    arr : ndarray\n        Array interpretation of `a`.\n\n    Notes\n    -----\n    This is equivalent to\n\n    >>> np.array(a, copy=True)                              #doctest: +SKIP\n\n    Examples\n    --------\n    Create an array x, with a reference y and a copy z:\n\n    >>> x = np.array([1, 2, 3])\n    >>> y = x\n    >>> z = np.copy(x)\n\n    Note that, when we modify x, y changes, but not z:\n\n    >>> x[0] = 10\n    >>> x[0] == y[0]\n    True\n    >>> x[0] == z[0]\n    False\n    \n    ";
static char __pyx_k_676[] = "correlate (line 2718)";
static char __pyx_k_677[] = "Cross-correlation of two 1-dimensional sequences.\n\n    This function computes the correlation as generally defined in signal\n    processing texts::\n\n        z[k] = sum_n a[n] * conj(v[n+k])\n\n    with a and v sequences being zero-padded where necessary and conj being\n    the conjugate.\n\n    Parameters\n    ----------\n    a, v : array_like\n        Input sequences.\n    mode : {'valid', 'same', 'full'}, optional\n        Refer to the `convolve` docstring.  Note that the default\n        is `valid`, unlike `convolve`, which uses `full`.\n    old_behavior : bool\n        If True, uses the old behavior from Numeric, (correlate(a,v) == correlate(v,\n        a), and the conjugate is not taken for complex arrays). If False, uses\n        the conventional signal processing definition (see note).\n\n    See Also\n    --------\n    convolve : Discrete, linear convolution of two one-dimensional sequences.\n\n    Examples\n    --------\n    >>> np.correlate([1, 2, 3], [0, 1, 0.5])\n    array([ 3.5])\n    >>> np.correlate([1, 2, 3], [0, 1, 0.5], \"same\")\n    array([ 2. ,  3.5,  3. ])\n    >>> np.correlate([1, 2, 3], [0, 1, 0.5], \"full\")\n    array([ 0.5,  2. ,  3.5,  3. ,  0. ])\n    \n    ";
static char __pyx_k_678[] = "count_nonzero (line 2758)";
static char __pyx_k_679[] = "count_nonzero(a)\n\n    Counts the number of non-zero values in the array ``a``.\n\n    Parameters\n    ----------\n    a : array_like\n        The array for which to count non-zeros.\n\n    Returns\n    -------\n    count : int\n        Number of non-zero values in the array.\n\n    See Also\n    --------\n    nonzero : Return the coordinates of all the non-zero values.\n\n    Examples\n    --------\n    >>> np.count_nonzero(np.eye(4))\n    4\n\n    >>> np.count_nonzero([[0,1,7,0,0],[3,0,0,2,19]])\n    5\n    \n    ";
static char __pyx_k_680[] = "cov (line 2790)";
static char __pyx_k_681[] = "Estimate a covariance matrix, given data.\n\n    Covariance indicates the level to which two variables vary together.\n    If we examine N-dimensional samples, :math:`X = [x_1, x_2, ... x_N]^T`,\n    then the covariance matrix element :math:`C_{ij}` is the covariance of\n    :math:`x_i` and :math:`x_j`. The element :math:`C_{ii}` is the variance\n    of :math:`x_i`.\n\n    Parameters\n    ----------\n    m : array_like\n        A 1-D or 2-D array containing multiple variables and observations.\n        Each row of `m` represents a variable, and each column a single\n        observation of all those variables. Also see `rowvar` below.\n    y : array_like, optional\n        An additional set of variables and observations. `y` has the same\n        form as that of `m`.\n    rowvar : int, optional\n        If `rowvar` is non-zero (default), then each row represents a\n        variable, with observations in the columns. Otherwise, the relationship\n        is transposed: each column represents a variable, while the rows\n        contain observations.\n    bias : int, optional\n        Default normalization is by ``(N - 1)``, where ``N`` is the number of\n        observations given (unbiased estimate). If `bias` is 1, then\n        normalization is by ``N``. These values can be overridden by using\n        the keyword ``ddof`` in numpy versions >= 1.5.\n    ddof : int, optional\n        .. versionadded:: 1.5\n        If not ``None`` normalization is by ``(N - ddof)``, where ``N`` is\n        the number of observations; this overrides the value implied by\n        ``bias``. The default value is ``None``.\n\n    Returns\n    -------\n    out : ndarray\n        The covariance matrix of the variables.\n\n    See Also\n    --------\n    corrcoef : Normalized covariance matrix\n\n    Examples\n    --------\n    Consider two variables, :math:`x_0` and :math:`x_1`, which\n    correlate perfectly, but in opposite directions:\n\n    >>> x = np.array([[0, 2], [1, 1], [2, 0]]).T\n   "" >>> x\n    array([[0, 1, 2],\n           [2, 1, 0]])\n\n    Note how :math:`x_0` increases while :math:`x_1` decreases. The covariance\n    matrix shows this clearly:\n\n    >>> np.cov(x)\n    array([[ 1., -1.],\n           [-1.,  1.]])\n\n    Note that element :math:`C_{0,1}`, which shows the correlation between\n    :math:`x_0` and :math:`x_1`, is negative.\n\n    Further, note how `x` and `y` are combined:\n\n    >>> x = [-2.1, -1,  4.3]\n    >>> y = [3,  1.1,  0.12]\n    >>> X = np.vstack((x,y))\n    >>> print np.cov(X)\n    [[ 11.71        -4.286     ]\n     [ -4.286        2.14413333]]\n    >>> print np.cov(x, y)\n    [[ 11.71        -4.286     ]\n     [ -4.286        2.14413333]]\n    >>> print np.cov(x)\n    11.71\n    \n    ";
static char __pyx_k_682[] = "cross (line 2871)";
static char __pyx_k_683[] = "Return the cross product of two (arrays of) vectors.\n\n    The cross product of `a` and `b` in :math:`R^3` is a vector perpendicular\n    to both `a` and `b`.  If `a` and `b` are arrays of vectors, the vectors\n    are defined by the last axis of `a` and `b` by default, and these axes\n    can have dimensions 2 or 3.  Where the dimension of either `a` or `b` is\n    2, the third component of the input vector is assumed to be zero and the\n    cross product calculated accordingly.  In cases where both input vectors\n    have dimension 2, the z-component of the cross product is returned.\n\n    Parameters\n    ----------\n    a : array_like\n        Components of the first vector(s).\n    b : array_like\n        Components of the second vector(s).\n    axisa : int, optional\n        Axis of `a` that defines the vector(s).  By default, the last axis.\n    axisb : int, optional\n        Axis of `b` that defines the vector(s).  By default, the last axis.\n    axisc : int, optional\n        Axis of `c` containing the cross product vector(s).  By default, the\n        last axis.\n    axis : int, optional\n        If defined, the axis of `a`, `b` and `c` that defines the vector(s)\n        and cross product(s).  Overrides `axisa`, `axisb` and `axisc`.\n\n    Returns\n    -------\n    c : ndarray\n        Vector cross product(s).\n\n    Raises\n    ------\n    ValueError\n        When the dimension of the vector(s) in `a` and/or `b` does not\n        equal 2 or 3.\n\n    See Also\n    --------\n    inner : Inner product\n    outer : Outer product.\n    ix_ : Construct index arrays.\n\n    Examples\n    --------\n    Vector cross-product.\n\n    >>> x = [1, 2, 3]\n    >>> y = [4, 5, 6]\n    >>> np.cross(x, y)\n    array([-3,  6, -3])\n\n    One vector with dimension 2.\n\n    >>> x = [1, 2]\n    >>> y = [4, 5, 6]\n    >>> np.cross(x, y)\n    array([12, -6, -3])\n\n    Equivalently:\n\n    >>> x = [1, 2, 0]\n    >>> y = [4, 5, 6]\n    >>> np.cross(x, y)\n    array([12, -6, -3""])\n\n    Both vectors with dimension 2.\n\n    >>> x = [1,2]\n    >>> y = [4,5]\n    >>> np.cross(x, y)\n    -3\n\n    Multiple vector cross-products. Note that the direction of the cross\n    product vector is defined by the `right-hand rule`.\n\n    >>> x = np.array([[1,2,3], [4,5,6]])\n    >>> y = np.array([[4,5,6], [1,2,3]])\n    >>> np.cross(x, y)\n    array([[-3,  6, -3],\n           [ 3, -6,  3]])\n\n    The orientation of `c` can be changed using the `axisc` keyword.\n\n    >>> np.cross(x, y, axisc=0)\n    array([[-3,  3],\n           [ 6, -6],\n           [-3,  3]])\n\n    Change the vector definition of `x` and `y` using `axisa` and `axisb`.\n\n    >>> x = np.array([[1,2,3], [4,5,6], [7, 8, 9]])\n    >>> y = np.array([[7, 8, 9], [4,5,6], [1,2,3]])\n    >>> np.cross(x, y)\n    array([[ -6,  12,  -6],\n           [  0,   0,   0],\n           [  6, -12,   6]])\n    >>> np.cross(x, y, axisa=0, axisb=0)\n    array([[-24,  48, -24],\n           [-30,  60, -30],\n           [-36,  72, -36]])\n    \n    ";
static char __pyx_k_684[] = "cumprod (line 2979)";
static char __pyx_k_685[] = "Return the cumulative product of elements along a given axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    axis : int, optional\n        Axis along which the cumulative product is computed.  By default\n        the input is flattened.\n    dtype : dtype, optional\n        Type of the returned array, as well as of the accumulator in which\n        the elements are multiplied.  If *dtype* is not specified, it\n        defaults to the dtype of `a`, unless `a` has an integer dtype with\n        a precision less than that of the default platform integer.  In\n        that case, the default platform integer is used instead.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must\n        have the same shape and buffer length as the expected output\n        but the type of the resulting values will be cast if necessary.\n\n    Returns\n    -------\n    cumprod : ndarray\n        A new array holding the result is returned unless `out` is\n        specified, in which case a reference to out is returned.\n\n    See Also\n    --------\n    numpy.doc.ufuncs : Section \"Output arguments\"\n\n    Notes\n    -----\n    Arithmetic is modular when using integer types, and no error is\n    raised on overflow.\n\n    Examples\n    --------\n    >>> a = np.array([1,2,3])\n    >>> np.cumprod(a) # intermediate results 1, 1*2\n    ...               # total product 1*2*3 = 6\n    array([1, 2, 6])\n    >>> a = np.array([[1, 2, 3], [4, 5, 6]])\n    >>> np.cumprod(a, dtype=float) # specify type of output\n    array([   1.,    2.,    6.,   24.,  120.,  720.])\n\n    The cumulative product for each column (i.e., over the rows) of `a`:\n\n    >>> np.cumprod(a, axis=0)\n    array([[ 1,  2,  3],\n           [ 4, 10, 18]])\n\n    The cumulative product for each row (i.e. over the columns) of `a`:\n\n    >>> np.cumprod(a,axis=1)\n    array([[  1,   2,   6],\n           [  4,  20, 120]])\n    \n    ";
static char __pyx_k_686[] = "cumsum (line 3053)";
static char __pyx_k_687[] = "Return the cumulative sum of the elements along a given axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    axis : int, optional\n        Axis along which the cumulative sum is computed. The default\n        (None) is to compute the cumsum over the flattened array.\n    dtype : dtype, optional\n        Type of the returned array and of the accumulator in which the\n        elements are summed.  If `dtype` is not specified, it defaults\n        to the dtype of `a`, unless `a` has an integer dtype with a\n        precision less than that of the default platform integer.  In\n        that case, the default platform integer is used.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must\n        have the same shape and buffer length as the expected output\n        but the type will be cast if necessary. See `doc.ufuncs`\n        (Section \"Output arguments\") for more details.\n\n    Returns\n    -------\n    cumsum_along_axis : ndarray.\n        A new array holding the result is returned unless `out` is\n        specified, in which case a reference to `out` is returned. The\n        result has the same size as `a`, and the same shape as `a` if\n        `axis` is not None or `a` is a 1-d array.\n\n\n    See Also\n    --------\n    sum : Sum array elements.\n\n    trapz : Integration of array values using the composite trapezoidal rule.\n\n    Notes\n    -----\n    Arithmetic is modular when using integer types, and no error is\n    raised on overflow.\n\n    Examples\n    --------\n    >>> a = np.array([[1,2,3], [4,5,6]])\n    >>> a\n    array([[1, 2, 3],\n           [4, 5, 6]])\n    >>> np.cumsum(a)\n    array([ 1,  3,  6, 10, 15, 21])\n    >>> np.cumsum(a, dtype=float)     # specifies type of output value(s)\n    array([  1.,   3.,   6.,  10.,  15.,  21.])\n\n    >>> np.cumsum(a,axis=0)      # sum over rows for each of the 3 columns\n    array([[1, 2, 3],\n           [5, 7, 9]])\n    >>> ""np.cumsum(a,axis=1)      # sum over columns for each of the 2 rows\n    array([[ 1,  3,  6],\n           [ 4,  9, 15]])\n    \n    ";
static char __pyx_k_688[] = "delete (line 3124)";
static char __pyx_k_689[] = "Return a new array with sub-arrays along an axis deleted.\n\n    Parameters\n    ----------\n    arr : array_like\n      Input array.\n    obj : slice, int or array of ints\n      Indicate which sub-arrays to remove.\n    axis : int, optional\n      The axis along which to delete the subarray defined by `obj`.\n      If `axis` is None, `obj` is applied to the flattened array.\n\n    Returns\n    -------\n    out : ndarray\n        A copy of `arr` with the elements specified by `obj` removed. Note\n        that `delete` does not occur in-place. If `axis` is None, `out` is\n        a flattened array.\n\n    See Also\n    --------\n    insert : Insert elements into an array.\n    append : Append elements at the end of an array.\n\n    Examples\n    --------\n    >>> arr = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])\n    >>> arr\n    array([[ 1,  2,  3,  4],\n           [ 5,  6,  7,  8],\n           [ 9, 10, 11, 12]])\n    >>> np.delete(arr, 1, 0)\n    array([[ 1,  2,  3,  4],\n           [ 9, 10, 11, 12]])\n\n    >>> np.delete(arr, np.s_[::2], 1)\n    array([[ 2,  4],\n           [ 6,  8],\n           [10, 12]])\n    >>> np.delete(arr, [1,3,5], None)\n    array([ 1,  3,  5,  7,  8,  9, 10, 11, 12])\n    \n    ";
static char __pyx_k_690[] = "deprecate (line 3171)";
static char __pyx_k_691[] = "Issues a DeprecationWarning, adds warning to `old_name`'s\n    docstring, rebinds ``old_name.__name__`` and returns the new\n    function object.\n\n    This function may also be used as a decorator.\n\n    Parameters\n    ----------\n    func : function\n        The function to be deprecated.\n    old_name : str, optional\n        The name of the function to be deprecated. Default is None, in which\n        case the name of `func` is used.\n    new_name : str, optional\n        The new name for the function. Default is None, in which case\n        the deprecation message is that `old_name` is deprecated. If given,\n        the deprecation message is that `old_name` is deprecated and `new_name`\n        should be used instead.\n    message : str, optional\n        Additional explanation of the deprecation.  Displayed in the docstring\n        after the warning.\n\n    Returns\n    -------\n    old_func : function\n        The deprecated function.\n\n    Examples\n    --------\n    Note that ``olduint`` returns a value after printing Deprecation Warning:\n\n    >>> olduint = np.deprecate(np.uint)\n    >>> olduint(6)\n    /usr/lib/python2.5/site-packages/numpy/lib/utils.py:114:\n    DeprecationWarning: uint32 is deprecated\n      warnings.warn(str1, DeprecationWarning)\n    6\n    \n    ";
static char __pyx_k_692[] = "diag_indices (line 3221)";
static char __pyx_k_693[] = "Return the indices to access the main diagonal of an array.\n\n    This returns a tuple of indices that can be used to access the main\n    diagonal of an array `a` with ``a.ndim >= 2`` dimensions and shape\n    (n, n, ..., n). For ``a.ndim = 2`` this is the usual diagonal, for\n    ``a.ndim > 2`` this is the set of indices to access ``a[i, i, ..., i]``\n    for ``i = [0..n-1]``.\n\n    Parameters\n    ----------\n    n : int\n      The size, along each dimension, of the arrays for which the returned\n      indices can be used.\n\n    ndim : int, optional\n      The number of dimensions.\n\n    See also\n    --------\n    diag_indices_from\n\n    Notes\n    -----\n    .. versionadded:: 1.4.0\n\n    Examples\n    --------\n    Create a set of indices to access the diagonal of a (4, 4) array:\n\n    >>> di = np.diag_indices(4)\n    >>> di\n    (array([0, 1, 2, 3]), array([0, 1, 2, 3]))\n    >>> a = np.arange(16).reshape(4, 4)\n    >>> a\n    array([[ 0,  1,  2,  3],\n           [ 4,  5,  6,  7],\n           [ 8,  9, 10, 11],\n           [12, 13, 14, 15]])\n    >>> a[di] = 100\n    >>> a\n    array([[100,   1,   2,   3],\n           [  4, 100,   6,   7],\n           [  8,   9, 100,  11],\n           [ 12,  13,  14, 100]])\n\n    Now, we create indices to manipulate a 3-D array:\n\n    >>> d3 = np.diag_indices(2, 3)\n    >>> d3\n    (array([0, 1]), array([0, 1]), array([0, 1]))\n\n    And use it to set the diagonal of an array of zeros to 1:\n\n    >>> a = np.zeros((2, 2, 2), dtype=np.int)\n    >>> a[d3] = 1\n    >>> a\n    array([[[1, 0],\n            [0, 0]],\n           [[0, 0],\n            [0, 1]]])\n    \n    ";
static char __pyx_k_694[] = "diagflat (line 3308)";
static char __pyx_k_695[] = "Create a two-dimensional array with the flattened input as a diagonal.\n\n    Parameters\n    ----------\n    v : array_like\n        Input data, which is flattened and set as the `k`-th\n        diagonal of the output.\n    k : int, optional\n        Diagonal to set; 0, the default, corresponds to the \"main\" diagonal,\n        a positive (negative) `k` giving the number of the diagonal above\n        (below) the main.\n\n    Returns\n    -------\n    out : ndarray\n        The 2-D output array.\n\n    See Also\n    --------\n    diag : MATLAB work-alike for 1-D and 2-D arrays.\n    diagonal : Return specified diagonals.\n    trace : Sum along diagonals.\n\n    Examples\n    --------\n    >>> np.diagflat([[1,2], [3,4]])\n    array([[1, 0, 0, 0],\n           [0, 2, 0, 0],\n           [0, 0, 3, 0],\n           [0, 0, 0, 4]])\n\n    >>> np.diagflat([1,2], 1)\n    array([[0, 1, 0],\n           [0, 0, 2],\n           [0, 0, 0]])\n    \n    ";
static char __pyx_k_696[] = "diff (line 3349)";
static char __pyx_k_697[] = "Calculate the n-th order discrete difference along given axis.\n\n    The first order difference is given by ``out[n] = a[n+1] - a[n]`` along\n    the given axis, higher order differences are calculated by using `diff`\n    recursively.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array\n    n : int, optional\n        The number of times values are differenced.\n    axis : int, optional\n        The axis along which the difference is taken, default is the last axis.\n\n    Returns\n    -------\n    out : ndarray\n        The `n` order differences. The shape of the output is the same as `a`\n        except along `axis` where the dimension is smaller by `n`.\n\n    See Also\n    --------\n    gradient, ediff1d\n\n    Examples\n    --------\n    >>> x = np.array([1, 2, 4, 7, 0])\n    >>> np.diff(x)\n    array([ 1,  2,  3, -7])\n    >>> np.diff(x, n=2)\n    array([  1,   1, -10])\n\n    >>> x = np.array([[1, 3, 6, 10], [0, 5, 6, 8]])\n    >>> np.diff(x)\n    array([[2, 3, 4],\n           [5, 1, 2]])\n    >>> np.diff(x, axis=0)\n    array([[-1,  2,  0, -2]])\n    \n    ";
static char __pyx_k_698[] = "digitize (line 3394)";
static char __pyx_k_699[] = "digitize(x, bins)\n\n    Return the indices of the bins to which each value in input array belongs.\n\n    Each index ``i`` returned is such that ``bins[i-1] <= x < bins[i]`` if\n    `bins` is monotonically increasing, or ``bins[i-1] > x >= bins[i]`` if\n    `bins` is monotonically decreasing. If values in `x` are beyond the\n    bounds of `bins`, 0 or ``len(bins)`` is returned as appropriate.\n\n    Parameters\n    ----------\n    x : array_like\n        Input array to be binned. It has to be 1-dimensional.\n    bins : array_like\n        Array of bins. It has to be 1-dimensional and monotonic.\n\n    Returns\n    -------\n    out : ndarray of ints\n        Output array of indices, of same shape as `x`.\n\n    Raises\n    ------\n    ValueError\n        If the input is not 1-dimensional, or if `bins` is not monotonic.\n    TypeError\n        If the type of the input is complex.\n\n    See Also\n    --------\n    bincount, histogram, unique\n\n    Notes\n    -----\n    If values in `x` are such that they fall outside the bin range,\n    attempting to index `bins` with the indices that `digitize` returns\n    will result in an IndexError.\n\n    Examples\n    --------\n    >>> x = np.array([0.2, 6.4, 3.0, 1.6])\n    >>> bins = np.array([0.0, 1.0, 2.5, 4.0, 10.0])\n    >>> inds = np.digitize(x, bins)\n    >>> inds\n    array([1, 4, 3, 2])\n    >>> for n in range(x.size):\n    ...   print bins[inds[n]-1], \"<=\", x[n], \"<\", bins[inds[n]]\n    ...\n    0.0 <= 0.2 < 1.0\n    4.0 <= 6.4 < 10.0\n    2.5 <= 3.0 < 4.0\n    1.0 <= 1.6 < 2.5\n    \n    ";
static char __pyx_k_700[] = "disp (line 3453)";
static char __pyx_k_701[] = "Display a message on a device.\n\n    Parameters\n    ----------\n    mesg : str\n        Message to display.\n    device : object\n        Device to write message. If None, defaults to ``sys.stdout`` which is\n        very similar to ``print``. `device` needs to have ``write()`` and\n        ``flush()`` methods.\n    linefeed : bool, optional\n        Option whether to print a line feed or not. Defaults to True.\n\n    Raises\n    ------\n    AttributeError\n        If `device` does not have a ``write()`` or ``flush()`` method.\n\n    Examples\n    --------\n    Besides ``sys.stdout``, a file-like object can also be used as it has\n    both required methods:\n\n    >>> from StringIO import StringIO\n    >>> buf = StringIO()\n    >>> np.disp('\"Display\" in a file', device=buf)\n    >>> buf.getvalue()\n    '\"Display\" in a file\n'\n    \n    ";
static char __pyx_k_702[] = "dsplit (line 3487)";
static char __pyx_k_703[] = "Split array into multiple sub-arrays along the 3rd axis (depth).\n\n    Please refer to the `split` documentation.  `dsplit` is equivalent\n    to `split` with ``axis=2``, the array is always split along the third\n    axis provided the array dimension is greater than or equal to 3.\n\n    See Also\n    --------\n    split : Split an array into multiple sub-arrays of equal size.\n\n    Examples\n    --------\n    >>> x = np.arange(16.0).reshape(2, 2, 4)\n    >>> x\n    array([[[  0.,   1.,   2.,   3.],\n            [  4.,   5.,   6.,   7.]],\n           [[  8.,   9.,  10.,  11.],\n            [ 12.,  13.,  14.,  15.]]])\n    >>> np.dsplit(x, 2)\n    [array([[[  0.,   1.],\n            [  4.,   5.]],\n           [[  8.,   9.],\n            [ 12.,  13.]]]),\n     array([[[  2.,   3.],\n            [  6.,   7.]],\n           [[ 10.,  11.],\n            [ 14.,  15.]]])]\n    >>> np.dsplit(x, np.array([3, 6]))\n    [array([[[  0.,   1.,   2.],\n            [  4.,   5.,   6.]],\n           [[  8.,   9.,  10.],\n            [ 12.,  13.,  14.]]]),\n     array([[[  3.],\n            [  7.]],\n           [[ 11.],\n            [ 15.]]]),\n     array([], dtype=float64)]\n    \n    ";
static char __pyx_k_704[] = "dstack (line 3530)";
static char __pyx_k_705[] = "Stack arrays in sequence depth wise (along third axis).\n\n    Takes a sequence of arrays and stack them along the third axis\n    to make a single array. Rebuilds arrays divided by `dsplit`.\n    This is a simple way to stack 2D arrays (images) into a single\n    3D array for processing.\n\n    Parameters\n    ----------\n    tup : sequence of arrays\n        Arrays to stack. All of them must have the same shape along all\n        but the third axis.\n\n    Returns\n    -------\n    stacked : ndarray\n        The array formed by stacking the given arrays.\n\n    See Also\n    --------\n    vstack : Stack along first axis.\n    hstack : Stack along second axis.\n    concatenate : Join arrays.\n    dsplit : Split array along third axis.\n\n    Notes\n    -----\n    Equivalent to ``np.concatenate(tup, axis=2)``.\n\n    Examples\n    --------\n    >>> a = np.array((1,2,3))\n    >>> b = np.array((2,3,4))\n    >>> np.dstack((a,b))\n    array([[[1, 2],\n            [2, 3],\n            [3, 4]]])\n\n    >>> a = np.array([[1],[2],[3]])\n    >>> b = np.array([[2],[3],[4]])\n    >>> np.dstack((a,b))\n    array([[[1, 2]],\n           [[2, 3]],\n           [[3, 4]]])\n    \n    ";
static char __pyx_k_706[] = "ediff1d (line 3580)";
static char __pyx_k_707[] = "The differences between consecutive elements of an array.\n\n    Parameters\n    ----------\n    ary : array_like\n        If necessary, will be flattened before the differences are taken.\n    to_end : array_like, optional\n        Number(s) to append at the end of the returned differences.\n    to_begin : array_like, optional\n        Number(s) to prepend at the beginning of the returned differences.\n\n    Returns\n    -------\n    ed : ndarray\n        The differences. Loosely, this is ``ary.flat[1:] - ary.flat[:-1]``.\n\n    See Also\n    --------\n    diff, gradient\n\n    Notes\n    -----\n    When applied to masked arrays, this function drops the mask information\n    if the `to_begin` and/or `to_end` parameters are used.\n\n    Examples\n    --------\n    >>> x = np.array([1, 2, 4, 7, 0])\n    >>> np.ediff1d(x)\n    array([ 1,  2,  3, -7])\n\n    >>> np.ediff1d(x, to_begin=-99, to_end=np.array([88, 99]))\n    array([-99,   1,   2,   3,  -7,  88,  99])\n\n    The returned array is always 1D.\n\n    >>> y = [[1, 2, 4], [1, 6, 24]]\n    >>> np.ediff1d(y)\n    array([ 1,  2, -3,  5, 18])\n    \n    ";
static char __pyx_k_708[] = "einsum (line 3625)";
static char __pyx_k_709[] = "einsum(subscripts, *operands, out=None, dtype=None, order='K', casting='safe')\n\n    Evaluates the Einstein summation convention on the operands.\n\n    Using the Einstein summation convention, many common multi-dimensional\n    array operations can be represented in a simple fashion.  This function\n    provides a way compute such summations. The best way to understand this\n    function is to try the examples below, which show how many common NumPy\n    functions can be implemented as calls to `einsum`.\n\n    Parameters\n    ----------\n    subscripts : str\n        Specifies the subscripts for summation.\n    operands : list of array_like\n        These are the arrays for the operation.\n    out : ndarray, optional\n        If provided, the calculation is done into this array.\n    dtype : data-type, optional\n        If provided, forces the calculation to use the data type specified.\n        Note that you may have to also give a more liberal `casting`\n        parameter to allow the conversions.\n    order : {'C', 'F', 'A', or 'K'}, optional\n        Controls the memory layout of the output. 'C' means it should\n        be C contiguous. 'F' means it should be Fortran contiguous,\n        'A' means it should be 'F' if the inputs are all 'F', 'C' otherwise.\n        'K' means it should be as close to the layout as the inputs as\n        is possible, including arbitrarily permuted axes.\n        Default is 'K'.\n    casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional\n        Controls what kind of data casting may occur.  Setting this to\n        'unsafe' is not recommended, as it can adversely affect accumulations.\n\n          * 'no' means the data types should not be cast at all.\n          * 'equiv' means only byte-order changes are allowed.\n          * 'safe' means only casts which can preserve values are allowed.\n          * 'same_kind' means only safe casts or casts within a kind,\n            like float64 to float32, are allowed.\n      ""    * 'unsafe' means any data conversions may be done.\n\n    Returns\n    -------\n    output : ndarray\n        The calculation based on the Einstein summation convention.\n\n    See Also\n    --------\n    dot, inner, outer, tensordot\n\n    Notes\n    -----\n    .. versionadded:: 1.6.0\n\n    The subscripts string is a comma-separated list of subscript labels,\n    where each label refers to a dimension of the corresponding operand.\n    Repeated subscripts labels in one operand take the diagonal.  For example,\n    ``np.einsum('ii', a)`` is equivalent to ``np.trace(a)``.\n\n    Whenever a label is repeated, it is summed, so ``np.einsum('i,i', a, b)``\n    is equivalent to ``np.inner(a,b)``.  If a label appears only once,\n    it is not summed, so ``np.einsum('i', a)`` produces a view of ``a``\n    with no changes.\n\n    The order of labels in the output is by default alphabetical.  This\n    means that ``np.einsum('ij', a)`` doesn't affect a 2D array, while\n    ``np.einsum('ji', a)`` takes its transpose.\n\n    The output can be controlled by specifying output subscript labels\n    as well.  This specifies the label order, and allows summing to\n    be disallowed or forced when desired.  The call ``np.einsum('i->', a)``\n    is like ``np.sum(a, axis=-1)``, and ``np.einsum('ii->i', a)``\n    is like ``np.diag(a)``.  The difference is that `einsum` does not\n    allow broadcasting by default.\n\n    To enable and control broadcasting, use an ellipsis.  Default\n    NumPy-style broadcasting is done by adding an ellipsis\n    to the left of each term, like ``np.einsum('...ii->...i', a)``.\n    To take the trace along the first and last axes,\n    you can do ``np.einsum('i...i', a)``, or to do a matrix-matrix\n    product with the left-most indices instead of rightmost, you can do\n    ``np.einsum('ij...,jk...->ik...', a, b)``.\n\n    When there is only one operand, no axes are summed, and no output\n    parameter is provided, a view into the operand is returned i""nstead\n    of a new array.  Thus, taking the diagonal as ``np.einsum('ii->i', a)``\n    produces a view.\n\n    An alternative way to provide the subscripts and operands is as\n    ``einsum(op0, sublist0, op1, sublist1, ..., [sublistout])``. The examples\n    below have corresponding `einsum` calls with the two parameter methods.\n\n    Examples\n    --------\n    >>> a = np.arange(25).reshape(5,5)\n    >>> b = np.arange(5)\n    >>> c = np.arange(6).reshape(2,3)\n\n    >>> np.einsum('ii', a)\n    60\n    >>> np.einsum(a, [0,0])\n    60\n    >>> np.trace(a)\n    60\n\n    >>> np.einsum('ii->i', a)\n    array([ 0,  6, 12, 18, 24])\n    >>> np.einsum(a, [0,0], [0])\n    array([ 0,  6, 12, 18, 24])\n    >>> np.diag(a)\n    array([ 0,  6, 12, 18, 24])\n\n    >>> np.einsum('ij,j', a, b)\n    array([ 30,  80, 130, 180, 230])\n    >>> np.einsum(a, [0,1], b, [1])\n    array([ 30,  80, 130, 180, 230])\n    >>> np.dot(a, b)\n    array([ 30,  80, 130, 180, 230])\n\n    >>> np.einsum('ji', c)\n    array([[0, 3],\n           [1, 4],\n           [2, 5]])\n    >>> np.einsum(c, [1,0])\n    array([[0, 3],\n           [1, 4],\n           [2, 5]])\n    >>> c.T\n    array([[0, 3],\n           [1, 4],\n           [2, 5]])\n\n    >>> np.einsum('..., ...', 3, c)\n    array([[ 0,  3,  6],\n           [ 9, 12, 15]])\n    >>> np.einsum(3, [Ellipsis], c, [Ellipsis])\n    array([[ 0,  3,  6],\n           [ 9, 12, 15]])\n    >>> np.multiply(3, c)\n    array([[ 0,  3,  6],\n           [ 9, 12, 15]])\n\n    >>> np.einsum('i,i', b, b)\n    30\n    >>> np.einsum(b, [0], b, [0])\n    30\n    >>> np.inner(b,b)\n    30\n\n    >>> np.einsum('i,j', np.arange(2)+1, b)\n    array([[0, 1, 2, 3, 4],\n           [0, 2, 4, 6, 8]])\n    >>> np.einsum(np.arange(2)+1, [0], b, [1])\n    array([[0, 1, 2, 3, 4],\n           [0, 2, 4, 6, 8]])\n    >>> np.outer(np.arange(2)+1, b)\n    array([[0, 1, 2, 3, 4],\n           [0, 2, 4, 6, 8]])\n\n    >>> np.einsum('i...->...', a)\n    array([50, 55, 60, 65, 70])\n    >>> n""p.einsum(a, [0,Ellipsis], [Ellipsis])\n    array([50, 55, 60, 65, 70])\n    >>> np.sum(a, axis=0)\n    array([50, 55, 60, 65, 70])\n\n    >>> a = np.arange(60.).reshape(3,4,5)\n    >>> b = np.arange(24.).reshape(4,3,2)\n    >>> np.einsum('ijk,jil->kl', a, b)\n    array([[ 4400.,  4730.],\n           [ 4532.,  4874.],\n           [ 4664.,  5018.],\n           [ 4796.,  5162.],\n           [ 4928.,  5306.]])\n    >>> np.einsum(a, [0,1,2], b, [1,0,3], [2,3])\n    array([[ 4400.,  4730.],\n           [ 4532.,  4874.],\n           [ 4664.,  5018.],\n           [ 4796.,  5162.],\n           [ 4928.,  5306.]])\n    >>> np.tensordot(a,b, axes=([1,0],[0,1]))\n    array([[ 4400.,  4730.],\n           [ 4532.,  4874.],\n           [ 4664.,  5018.],\n           [ 4796.,  5162.],\n           [ 4928.,  5306.]])\n    \n    ";
static char __pyx_k_710[] = "expand_dims (line 3817)";
static char __pyx_k_711[] = "Expand the shape of an array.\n\n    Insert a new axis, corresponding to a given position in the array shape.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    axis : int\n        Position (amongst axes) where new axis is to be inserted.\n\n    Returns\n    -------\n    res : ndarray\n        Output array. The number of dimensions is one greater than that of\n        the input array.\n\n    See Also\n    --------\n    doc.indexing, atleast_1d, atleast_2d, atleast_3d\n\n    Examples\n    --------\n    >>> x = np.array([1,2])\n    >>> x.shape\n    (2,)\n\n    The following is equivalent to ``x[np.newaxis,:]`` or ``x[np.newaxis]``:\n\n    >>> y = np.expand_dims(x, axis=0)\n    >>> y\n    array([[1, 2]])\n    >>> y.shape\n    (1, 2)\n\n    >>> y = np.expand_dims(x, axis=1)  # Equivalent to x[:,newaxis]\n    >>> y\n    array([[1],\n           [2]])\n    >>> y.shape\n    (2, 1)\n\n    Note that some examples may use ``None`` instead of ``np.newaxis``.  These\n    are the same objects:\n\n    >>> np.newaxis is None\n    True\n    \n    ";
static char __pyx_k_712[] = "extract (line 3870)";
static char __pyx_k_713[] = "Return the elements of an array that satisfy some condition.\n\n    This is equivalent to ``np.compress(ravel(condition), ravel(arr))``.  If\n    `condition` is boolean ``np.extract`` is equivalent to ``arr[condition]``.\n\n    Parameters\n    ----------\n    condition : array_like\n        An array whose nonzero or True entries indicate the elements of `arr`\n        to extract.\n    arr : array_like\n        Input array of the same size as `condition`.\n\n    See Also\n    --------\n    take, put, putmask, compress\n\n    Examples\n    --------\n    >>> arr = np.arange(12).reshape((3, 4))\n    >>> arr\n    array([[ 0,  1,  2,  3],\n           [ 4,  5,  6,  7],\n           [ 8,  9, 10, 11]])\n    >>> condition = np.mod(arr, 3)==0\n    >>> condition\n    array([[ True, False, False,  True],\n           [False, False,  True, False],\n           [False,  True, False, False]], dtype=bool)\n    >>> np.extract(condition, arr)\n    array([0, 3, 6, 9])\n\n\n    If `condition` is boolean:\n\n    >>> arr[condition]\n    array([0, 3, 6, 9])\n    \n    ";
static char __pyx_k_714[] = "fill_diagonal (line 3921)";
static char __pyx_k_715[] = "Fill the main diagonal of the given array of any dimensionality.\n\n    For an array `a` with ``a.ndim > 2``, the diagonal is the list of\n    locations with indices ``a[i, i, ..., i]`` all identical. This function\n    modifies the input array in-place, it does not return a value.\n\n    Parameters\n    ----------\n    a : array, at least 2-D.\n      Array whose diagonal is to be filled, it gets modified in-place.\n\n    val : scalar\n      Value to be written on the diagonal, its type must be compatible with\n      that of the array a.\n\n    See also\n    --------\n    diag_indices, diag_indices_from\n\n    Notes\n    -----\n    .. versionadded:: 1.4.0\n\n    This functionality can be obtained via `diag_indices`, but internally\n    this version uses a much faster implementation that never constructs the\n    indices and uses simple slicing.\n\n    Examples\n    --------\n    >>> a = np.zeros((3, 3), int)\n    >>> np.fill_diagonal(a, 5)\n    >>> a\n    array([[5, 0, 0],\n           [0, 5, 0],\n           [0, 0, 5]])\n\n    The same function can operate on a 4-D array:\n\n    >>> a = np.zeros((3, 3, 3, 3), int)\n    >>> np.fill_diagonal(a, 4)\n\n    We only show a few blocks for clarity:\n\n    >>> a[0, 0]\n    array([[4, 0, 0],\n           [0, 0, 0],\n           [0, 0, 0]])\n    >>> a[1, 1]\n    array([[0, 0, 0],\n           [0, 4, 0],\n           [0, 0, 0]])\n    >>> a[2, 2]\n    array([[0, 0, 0],\n           [0, 0, 0],\n           [0, 0, 4]])\n    \n    ";
static char __pyx_k_716[] = "find_common_type (line 3982)";
static char __pyx_k_717[] = "Determine common type following standard coercion rules.\n\n    Parameters\n    ----------\n    array_types : sequence\n        A list of dtypes or dtype convertible objects representing arrays.\n    scalar_types : sequence\n        A list of dtypes or dtype convertible objects representing scalars.\n\n    Returns\n    -------\n    datatype : dtype\n        The common data type, which is the maximum of `array_types` ignoring\n        `scalar_types`, unless the maximum of `scalar_types` is of a\n        different kind (`dtype.kind`). If the kind is not understood, then\n        None is returned.\n\n    See Also\n    --------\n    dtype, common_type, can_cast, mintypecode\n\n    Examples\n    --------\n    >>> np.find_common_type([], [np.int64, np.float32, np.complex])\n    dtype('complex128')\n    >>> np.find_common_type([np.int64, np.float32], [])\n    dtype('float64')\n\n    The standard casting rules ensure that a scalar cannot up-cast an\n    array unless the scalar is of a fundamentally different kind of data\n    (i.e. under a different hierarchy in the data type hierarchy) then\n    the array:\n\n    >>> np.find_common_type([np.float32], [np.int64, np.float64])\n    dtype('float32')\n\n    Complex is of a different type, so it up-casts the float in the\n    `array_types` argument:\n\n    >>> np.find_common_type([np.float32], [np.complex])\n    dtype('complex128')\n\n    Type specifier strings are convertible to dtypes and can therefore\n    be used instead of dtypes:\n\n    >>> np.find_common_type(['f4', 'f4', 'i4'], ['c8'])\n    dtype('complex128')\n    \n    ";
static char __pyx_k_718[] = "fix (line 4035)";
static char __pyx_k_719[] = "Round to nearest integer towards zero.\n\n    Round an array of floats element-wise to nearest integer towards zero.\n    The rounded values are returned as floats.\n\n    Parameters\n    ----------\n    x : array_like\n        An array of floats to be rounded\n    y : ndarray, optional\n        Output array\n\n    Returns\n    -------\n    out : ndarray of floats\n        The array of rounded numbers\n\n    See Also\n    --------\n    trunc, floor, ceil\n    around : Round to given number of decimals\n\n    Examples\n    --------\n    >>> np.fix(3.14)\n    3.0\n    >>> np.fix(3)\n    3.0\n    >>> np.fix([2.1, 2.9, -2.1, -2.9])\n    array([ 2.,  2., -2., -2.])\n    \n    ";
static char __pyx_k_720[] = "flatnonzero (line 4071)";
static char __pyx_k_721[] = "Return indices that are non-zero in the flattened version of a.\n\n    This is equivalent to a.ravel().nonzero()[0].\n\n    Parameters\n    ----------\n    a : ndarray\n        Input array.\n\n    Returns\n    -------\n    res : ndarray\n        Output array, containing the indices of the elements of `a.ravel()`\n        that are non-zero.\n\n    See Also\n    --------\n    nonzero : Return the indices of the non-zero elements of the input array.\n    ravel : Return a 1-D array containing the elements of the input array.\n\n    Examples\n    --------\n    >>> x = np.arange(-2, 3)\n    >>> x\n    array([-2, -1,  0,  1,  2])\n    >>> np.flatnonzero(x)\n    array([0, 1, 3, 4])\n\n    Use the indices of the non-zero elements as an index array to extract\n    these elements:\n\n    >>> x.ravel()[np.flatnonzero(x)]\n    array([-2, -1,  1,  2])\n    \n    ";
static char __pyx_k_722[] = "fliplr (line 4110)";
static char __pyx_k_723[] = "Flip array in the left/right direction.\n\n    Flip the entries in each row in the left/right direction.\n    Columns are preserved, but appear in a different order than before.\n\n    Parameters\n    ----------\n    m : array_like\n        Input array.\n\n    Returns\n    -------\n    f : ndarray\n        A view of `m` with the columns reversed.  Since a view\n        is returned, this operation is :math:`\\mathcal O(1)`.\n\n    See Also\n    --------\n    flipud : Flip array in the up/down direction.\n    rot90 : Rotate array counterclockwise.\n\n    Notes\n    -----\n    Equivalent to A[:,::-1]. Does not require the array to be\n    two-dimensional.\n\n    Examples\n    --------\n    >>> A = np.diag([1.,2.,3.])\n    >>> A\n    array([[ 1.,  0.,  0.],\n           [ 0.,  2.,  0.],\n           [ 0.,  0.,  3.]])\n    >>> np.fliplr(A)\n    array([[ 0.,  0.,  1.],\n           [ 0.,  2.,  0.],\n           [ 3.,  0.,  0.]])\n\n    >>> A = np.random.randn(2,3,5)\n    >>> np.all(np.fliplr(A)==A[:,::-1,...])\n    True\n    \n    ";
static char __pyx_k_724[] = "flipud (line 4157)";
static char __pyx_k_725[] = "Flip array in the up/down direction.\n\n    Flip the entries in each column in the up/down direction.\n    Rows are preserved, but appear in a different order than before.\n\n    Parameters\n    ----------\n    m : array_like\n        Input array.\n\n    Returns\n    -------\n    out : array_like\n        A view of `m` with the rows reversed.  Since a view is\n        returned, this operation is :math:`\\mathcal O(1)`.\n\n    See Also\n    --------\n    fliplr : Flip array in the left/right direction.\n    rot90 : Rotate array counterclockwise.\n\n    Notes\n    -----\n    Equivalent to ``A[::-1,...]``.\n    Does not require the array to be two-dimensional.\n\n    Examples\n    --------\n    >>> A = np.diag([1.0, 2, 3])\n    >>> A\n    array([[ 1.,  0.,  0.],\n           [ 0.,  2.,  0.],\n           [ 0.,  0.,  3.]])\n    >>> np.flipud(A)\n    array([[ 0.,  0.,  3.],\n           [ 0.,  2.,  0.],\n           [ 1.,  0.,  0.]])\n\n    >>> A = np.random.randn(2,3,5)\n    >>> np.all(np.flipud(A)==A[::-1,...])\n    True\n\n    >>> np.flipud([1,2])\n    array([2, 1])\n    \n    ";
static char __pyx_k_726[] = "frombuffer (line 4207)";
static char __pyx_k_727[] = "frombuffer(buffer, dtype=float, count=-1, offset=0)\n\n    Interpret a buffer as a 1-dimensional array.\n\n    Parameters\n    ----------\n    buffer : buffer_like\n        An object that exposes the buffer interface.\n    dtype : data-type, optional\n        Data-type of the returned array; default: float.\n    count : int, optional\n        Number of items to read. ``-1`` means all data in the buffer.\n    offset : int, optional\n        Start reading the buffer from this offset; default: 0.\n\n    Notes\n    -----\n    If the buffer has data that is not in machine byte-order, this should\n    be specified as part of the data-type, e.g.::\n\n      >>> dt = np.dtype(int)\n      >>> dt = dt.newbyteorder('>')\n      >>> np.frombuffer(buf, dtype=dt)\n\n    The data of the resulting array will not be byteswapped, but will be\n    interpreted correctly.\n\n    Examples\n    --------\n    >>> s = 'hello world'\n    >>> np.frombuffer(s, dtype='S1', count=5, offset=6)\n    array(['w', 'o', 'r', 'l', 'd'],\n          dtype='|S1')\n    \n    ";
static char __pyx_k_728[] = "fromfile (line 4247)";
static char __pyx_k_729[] = "fromfile(file, dtype=float, count=-1, sep='')\n\n    Construct an array from data in a text or binary file.\n\n    A highly efficient way of reading binary data with a known data-type,\n    as well as parsing simply formatted text files.  Data written using the\n    `tofile` method can be read using this function.\n\n    Parameters\n    ----------\n    file : file or str\n        Open file object or filename.\n    dtype : data-type\n        Data type of the returned array.\n        For binary files, it is used to determine the size and byte-order\n        of the items in the file.\n    count : int\n        Number of items to read. ``-1`` means all items (i.e., the complete\n        file).\n    sep : str\n        Separator between items if file is a text file.\n        Empty (\"\") separator means the file should be treated as binary.\n        Spaces (\" \") in the separator match zero or more whitespace characters.\n        A separator consisting only of spaces must match at least one\n        whitespace.\n\n    See also\n    --------\n    load, save\n    ndarray.tofile\n    loadtxt : More flexible way of loading data from a text file.\n\n    Notes\n    -----\n    Do not rely on the combination of `tofile` and `fromfile` for\n    data storage, as the binary files generated are are not platform\n    independent.  In particular, no byte-order or data-type information is\n    saved.  Data can be stored in the platform independent ``.npy`` format\n    using `save` and `load` instead.\n\n    Examples\n    --------\n    Construct an ndarray:\n\n    >>> dt = np.dtype([('time', [('min', int), ('sec', int)]),\n    ...                ('temp', float)])\n    >>> x = np.zeros((1,), dtype=dt)\n    >>> x['time']['min'] = 10; x['temp'] = 98.25\n    >>> x\n    array([((10, 0), 98.25)],\n          dtype=[('time', [('min', '<i4'), ('sec', '<i4')]), ('temp', '<f8')])\n\n    Save the raw data to disk:\n\n    >>> import os\n    >>> fname = os.tmpnam()\n    >>> x.tofile(fname)\n\n    Read"" the raw data from disk:\n\n    >>> np.fromfile(fname, dtype=dt)\n    array([((10, 0), 98.25)],\n          dtype=[('time', [('min', '<i4'), ('sec', '<i4')]), ('temp', '<f8')])\n\n    The recommended way to store and load data:\n\n    >>> np.save(fname, x)\n    >>> np.load(fname + '.npy')\n    array([((10, 0), 98.25)],\n          dtype=[('time', [('min', '<i4'), ('sec', '<i4')]), ('temp', '<f8')])\n    \n    ";
static char __pyx_k_730[] = "fromiter (line 4324)";
static char __pyx_k_731[] = "fromiter(iterable, dtype, count=-1)\n\n    Create a new 1-dimensional array from an iterable object.\n\n    Parameters\n    ----------\n    iterable : iterable object\n        An iterable object providing data for the array.\n    dtype : data-type\n        The data-type of the returned array.\n    count : int, optional\n        The number of items to read from *iterable*.  The default is -1,\n        which means all data is read.\n\n    Returns\n    -------\n    out : ndarray\n        The output array.\n\n    Notes\n    -----\n    Specify `count` to improve performance.  It allows ``fromiter`` to\n    pre-allocate the output array, instead of resizing it on demand.\n\n    Examples\n    --------\n    >>> iterable = (x*x for x in range(5))\n    >>> np.fromiter(iterable, np.float)\n    array([  0.,   1.,   4.,   9.,  16.])\n    \n    ";
static char __pyx_k_732[] = "frompyfunc (line 4360)";
static char __pyx_k_733[] = "frompyfunc(func, nin, nout)\n\n    Takes an arbitrary Python function and returns a Numpy ufunc.\n\n    Can be used, for example, to add broadcasting to a built-in Python\n    function (see Examples section).\n\n    Parameters\n    ----------\n    func : Python function object\n        An arbitrary Python function.\n    nin : int\n        The number of input arguments.\n    nout : int\n        The number of objects returned by `func`.\n\n    Returns\n    -------\n    out : ufunc\n        Returns a Numpy universal function (``ufunc``) object.\n\n    Notes\n    -----\n    The returned ufunc always returns PyObject arrays.\n\n    Examples\n    --------\n    Use frompyfunc to add broadcasting to the Python function ``oct``:\n\n    >>> oct_array = np.frompyfunc(oct, 1, 1)\n    >>> oct_array(np.array((10, 30, 100)))\n    array([012, 036, 0144], dtype=object)\n    >>> np.array((oct(10), oct(30), oct(100))) # for comparison\n    array(['012', '036', '0144'],\n          dtype='|S4')\n    \n    ";
static char __pyx_k_734[] = "fromregex (line 4402)";
static char __pyx_k_735[] = "Construct an array from a text file, using regular expression parsing.\n\n    The returned array is always a structured array, and is constructed from\n    all matches of the regular expression in the file. Groups in the regular\n    expression are converted to fields of the structured array.\n\n    Parameters\n    ----------\n    file : str or file\n        File name or file object to read.\n    regexp : str or regexp\n        Regular expression used to parse the file.\n        Groups in the regular expression correspond to fields in the dtype.\n    dtype : dtype or list of dtypes\n        Dtype for the structured array.\n\n    Returns\n    -------\n    output : ndarray\n        The output array, containing the part of the content of `file` that\n        was matched by `regexp`. `output` is always a structured array.\n\n    Raises\n    ------\n    TypeError\n        When `dtype` is not a valid dtype for a structured array.\n\n    See Also\n    --------\n    fromstring, loadtxt\n\n    Notes\n    -----\n    Dtypes for structured arrays can be specified in several forms, but all\n    forms specify at least the data type and field name. For details see\n    `doc.structured_arrays`.\n\n    Examples\n    --------\n    >>> f = open('test.dat', 'w')\n    >>> f.write(\"1312 foo\n1534  bar\n444   qux\")\n    >>> f.close()\n\n    >>> regexp = r\"(\\d+)\\s+(...)\"  # match [digits, whitespace, anything]\n    >>> output = np.fromregex('test.dat', regexp,\n    ...                       [('num', np.int64), ('key', 'S3')])\n    >>> output\n    array([(1312L, 'foo'), (1534L, 'bar'), (444L, 'qux')],\n          dtype=[('num', '<i8'), ('key', '|S3')])\n    >>> output['num']\n    array([1312, 1534,  444], dtype=int64)\n    \n    ";
static char __pyx_k_736[] = "fromstring (line 4459)";
static char __pyx_k_737[] = "fromstring(string, dtype=float, count=-1, sep='')\n\n    A new 1-D array initialized from raw binary or text data in a string.\n\n    Parameters\n    ----------\n    string : str\n        A string containing the data.\n    dtype : data-type, optional\n        The data type of the array; default: float.  For binary input data,\n        the data must be in exactly this format.\n    count : int, optional\n        Read this number of `dtype` elements from the data.  If this is\n        negative (the default), the count will be determined from the\n        length of the data.\n    sep : str, optional\n        If not provided or, equivalently, the empty string, the data will\n        be interpreted as binary data; otherwise, as ASCII text with\n        decimal numbers.  Also in this latter case, this argument is\n        interpreted as the string separating numbers in the data; extra\n        whitespace between elements is also ignored.\n\n    Returns\n    -------\n    arr : ndarray\n        The constructed array.\n\n    Raises\n    ------\n    ValueError\n        If the string is not the correct size to satisfy the requested\n        `dtype` and `count`.\n\n    See Also\n    --------\n    frombuffer, fromfile, fromiter\n\n    Examples\n    --------\n    >>> np.fromstring('\001\002', dtype=np.uint8)\n    array([1, 2], dtype=uint8)\n    >>> np.fromstring('1 2', dtype=int, sep=' ')\n    array([1, 2])\n    >>> np.fromstring('1, 2', dtype=int, sep=',')\n    array([1, 2])\n    >>> np.fromstring('\001\002\003\004\005', dtype=np.uint8, count=3)\n    array([1, 2, 3], dtype=uint8)\n    \n    ";
static char __pyx_k_738[] = "fv (line 4513)";
static char __pyx_k_739[] = "Compute the future value.\n\n    Given:\n     * a present value, `pv`\n     * an interest `rate` compounded once per period, of which\n       there are\n     * `nper` total\n     * a (fixed) payment, `pmt`, paid either\n     * at the beginning (`when` = {'begin', 1}) or the end\n       (`when` = {'end', 0}) of each period\n\n    Return:\n       the value at the end of the `nper` periods\n\n    Parameters\n    ----------\n    rate : scalar or array_like of shape(M, )\n        Rate of interest as decimal (not per cent) per period\n    nper : scalar or array_like of shape(M, )\n        Number of compounding periods\n    pmt : scalar or array_like of shape(M, )\n        Payment\n    pv : scalar or array_like of shape(M, )\n        Present value\n    when : {{'begin', 1}, {'end', 0}}, {string, int}, optional\n        When payments are due ('begin' (1) or 'end' (0)).\n        Defaults to {'end', 0}.\n\n    Returns\n    -------\n    out : ndarray\n        Future values.  If all input is scalar, returns a scalar float.  If\n        any input is array_like, returns future values for each input element.\n        If multiple inputs are array_like, they all must have the same shape.\n\n    Notes\n    -----\n    The future value is computed by solving the equation::\n\n     fv +\n     pv*(1+rate)**nper +\n     pmt*(1 + rate*when)/rate*((1 + rate)**nper - 1) == 0\n\n    or, when ``rate == 0``::\n\n     fv + pv + pmt * nper == 0\n\n    References\n    ----------\n    .. [WRW] Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May).\n       Open Document Format for Office Applications (OpenDocument)v1.2,\n       Part 2: Recalculated Formula (OpenFormula) Format - Annotated Version,\n       Pre-Draft 12. Organization for the Advancement of Structured Information\n       Standards (OASIS). Billerica, MA, USA. [ODT Document].\n       Available:\n       http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula\n       OpenDocument-formula-20090508.odt\n\n    Example""s\n    --------\n    What is the future value after 10 years of saving $100 now, with\n    an additional monthly savings of $100.  Assume the interest rate is\n    5% (annually) compounded monthly?\n\n    >>> np.fv(0.05/12, 10*12, -100, -100)\n    15692.928894335748\n\n    By convention, the negative sign represents cash flow out (i.e. money not\n    available today).  Thus, saving $100 a month at 5% annual interest leads\n    to $15,692.93 available to spend in 10 years.\n\n    If any input is array_like, returns an array of equal shape.  Let's\n    compare different interest rates from the example above.\n\n    >>> a = np.array((0.05, 0.06, 0.07))/12\n    >>> np.fv(a, 10*12, -100, -100)\n    array([ 15692.92889434,  16569.87435405,  17509.44688102])\n    \n    ";
static char __pyx_k_740[] = "genfromtxt (line 4596)";
static char __pyx_k_741[] = "Load data from a text file, with missing values handled as specified.\n\n    Each line past the first `skip_header` lines is split at the `delimiter`\n    character, and characters following the `comments` character are discarded.\n\n    Parameters\n    ----------\n    fname : file or str\n        File, filename, or generator to read.  If the filename extension is\n        `.gz` or `.bz2`, the file is first decompressed. Note that\n        generators must return byte strings in Python 3k.\n    dtype : dtype, optional\n        Data type of the resulting array.\n        If None, the dtypes will be determined by the contents of each\n        column, individually.\n    comments : str, optional\n        The character used to indicate the start of a comment.\n        All the characters occurring on a line after a comment are discarded\n    delimiter : str, int, or sequence, optional\n        The string used to separate values.  By default, any consecutive\n        whitespaces act as delimiter.  An integer or sequence of integers\n        can also be provided as width(s) of each field.\n    skip_header : int, optional\n        The numbers of lines to skip at the beginning of the file.\n    skip_footer : int, optional\n        The numbers of lines to skip at the end of the file\n    converters : variable, optional\n        The set of functions that convert the data of a column to a value.\n        The converters can also be used to provide a default value\n        for missing data: ``converters = {3: lambda s: float(s or 0)}``.\n    missing_values : variable, optional\n        The set of strings corresponding to missing data.\n    filling_values : variable, optional\n        The set of values to be used as default when the data are missing.\n    usecols : sequence, optional\n        Which columns to read, with 0 being the first.  For example,\n        ``usecols = (1, 4, 5)`` will extract the 2nd, 5th and 6th columns.\n    names : {None, True, str, sequence}, optional\n     ""   If `names` is True, the field names are read from the first valid line\n        after the first `skip_header` lines.\n        If `names` is a sequence or a single-string of comma-separated names,\n        the names will be used to define the field names in a structured dtype.\n        If `names` is None, the names of the dtype fields will be used, if any.\n    excludelist : sequence, optional\n        A list of names to exclude. This list is appended to the default list\n        ['return','file','print']. Excluded names are appended an underscore:\n        for example, `file` would become `file_`.\n    deletechars : str, optional\n        A string combining invalid characters that must be deleted from the\n        names.\n    defaultfmt : str, optional\n        A format used to define default field names, such as \"f%i\" or \"f_%02i\".\n    autostrip : bool, optional\n        Whether to automatically strip white spaces from the variables.\n    replace_space : char, optional\n        Character(s) used in replacement of white spaces in the variables names.\n        By default, use a '_'.\n    case_sensitive : {True, False, 'upper', 'lower'}, optional\n        If True, field names are case sensitive.\n        If False or 'upper', field names are converted to upper case.\n        If 'lower', field names are converted to lower case.\n    unpack : bool, optional\n        If True, the returned array is transposed, so that arguments may be\n        unpacked using ``x, y, z = loadtxt(...)``\n    usemask : bool, optional\n        If True, return a masked array.\n        If False, return a regular array.\n    invalid_raise : bool, optional\n        If True, an exception is raised if an inconsistency is detected in the\n        number of columns.\n        If False, a warning is emitted and the offending lines are skipped.\n\n    Returns\n    -------\n    out : ndarray\n        Data read from the text file. If `usemask` is True, this is a\n        masked array.\n\n    See Als""o\n    --------\n    numpy.loadtxt : equivalent function when no data is missing.\n\n    Notes\n    -----\n    * When spaces are used as delimiters, or when no delimiter has been given\n      as input, there should not be any missing data between two fields.\n    * When the variables are named (either by a flexible dtype or with `names`,\n      there must not be any header in the file (else a ValueError\n      exception is raised).\n    * Individual values are not stripped of spaces by default.\n      When using a custom converter, make sure the function does remove spaces.\n\n    Examples\n    ---------\n    >>> from StringIO import StringIO\n    >>> import numpy as np\n\n    Comma delimited file with mixed dtype\n\n    >>> s = StringIO(\"1,1.3,abcde\")\n    >>> data = np.genfromtxt(s, dtype=[('myint','i8'),('myfloat','f8'),\n    ... ('mystring','S5')], delimiter=\",\")\n    >>> data\n    array((1, 1.3, 'abcde'),\n          dtype=[('myint', '<i8'), ('myfloat', '<f8'), ('mystring', '|S5')])\n\n    Using dtype = None\n\n    >>> s.seek(0) # needed for StringIO example only\n    >>> data = np.genfromtxt(s, dtype=None,\n    ... names = ['myint','myfloat','mystring'], delimiter=\",\")\n    >>> data\n    array((1, 1.3, 'abcde'),\n          dtype=[('myint', '<i8'), ('myfloat', '<f8'), ('mystring', '|S5')])\n\n    Specifying dtype and names\n\n    >>> s.seek(0)\n    >>> data = np.genfromtxt(s, dtype=\"i8,f8,S5\",\n    ... names=['myint','myfloat','mystring'], delimiter=\",\")\n    >>> data\n    array((1, 1.3, 'abcde'),\n          dtype=[('myint', '<i8'), ('myfloat', '<f8'), ('mystring', '|S5')])\n\n    An example with fixed-width columns\n\n    >>> s = StringIO(\"11.3abcde\")\n    >>> data = np.genfromtxt(s, dtype=None, names=['intvar','fltvar','strvar'],\n    ...     delimiter=[1,3,5])\n    >>> data\n    array((1, 1.3, 'abcde'),\n          dtype=[('intvar', '<i8'), ('fltvar', '<f8'), ('strvar', '|S5')])\n    \n    ";
static char __pyx_k_742[] = "getbuffer (line 4826)";
static char __pyx_k_743[] = "getbuffer(obj [,offset[, size]])\n\n    Create a buffer object from the given object referencing a slice of\n    length size starting at offset.\n\n    Default is the entire buffer. A read-write buffer is attempted followed\n    by a read-only buffer.\n\n    Parameters\n    ----------\n    obj : object\n\n    offset : int, optional\n\n    size : int, optional\n\n    Returns\n    -------\n    buffer_obj : buffer\n\n    Examples\n    --------\n    >>> buf = np.getbuffer(np.ones(5), 1, 3)\n    >>> len(buf)\n    3\n    >>> buf[0]\n    '\000'\n    >>> buf\n    <read-write buffer for 0x8af1e70, size 3, offset 1 at 0x8ba4ec0>\n    \n    ";
static char __pyx_k_744[] = "geterr (line 4869)";
static char __pyx_k_745[] = "Get the current way of handling floating-point errors.\n\n    Returns\n    -------\n    res : dict\n        A dictionary with keys \"divide\", \"over\", \"under\", and \"invalid\",\n        whose values are from the strings \"ignore\", \"print\", \"log\", \"warn\",\n        \"raise\", and \"call\". The keys represent possible floating-point\n        exceptions, and the values define how these exceptions are handled.\n\n    See Also\n    --------\n    geterrcall, seterr, seterrcall\n\n    Notes\n    -----\n    For complete documentation of the types of floating-point exceptions and\n    treatment options, see `seterr`.\n\n    Examples\n    --------\n    >>> np.geterr()\n    {'over': 'warn', 'divide': 'warn', 'invalid': 'warn',\n    'under': 'ignore'}\n    >>> np.arange(3.) / np.arange(3.)\n    array([ NaN,   1.,   1.])\n\n    >>> oldsettings = np.seterr(all='warn', over='raise')\n    >>> np.geterr()\n    {'over': 'raise', 'divide': 'warn', 'invalid': 'warn', 'under': 'warn'}\n    >>> np.arange(3.) / np.arange(3.)\n    __main__:1: RuntimeWarning: invalid value encountered in divide\n    array([ NaN,   1.,   1.])\n    \n    ";
static char __pyx_k_746[] = "geterrcall (line 4908)";
static char __pyx_k_747[] = "Return the current callback function used on floating-point errors.\n\n    When the error handling for a floating-point error (one of \"divide\",\n    \"over\", \"under\", or \"invalid\") is set to 'call' or 'log', the function\n    that is called or the log instance that is written to is returned by\n    `geterrcall`. This function or log instance has been set with\n    `seterrcall`.\n\n    Returns\n    -------\n    errobj : callable, log instance or None\n        The current error handler. If no handler was set through `seterrcall`,\n        ``None`` is returned.\n\n    See Also\n    --------\n    seterrcall, seterr, geterr\n\n    Notes\n    -----\n    For complete documentation of the types of floating-point exceptions and\n    treatment options, see `seterr`.\n\n    Examples\n    --------\n    >>> np.geterrcall()  # we did not yet set a handler, returns None\n\n    >>> oldsettings = np.seterr(all='call')\n    >>> def err_handler(type, flag):\n    ...     print \"Floating point error (%s), with flag %s\" % (type, flag)\n    >>> oldhandler = np.seterrcall(err_handler)\n    >>> np.array([1, 2, 3]) / 0.0\n    Floating point error (divide by zero), with flag 1\n    array([ Inf,  Inf,  Inf])\n\n    >>> cur_handler = np.geterrcall()\n    >>> cur_handler is err_handler\n    True\n    \n    ";
static char __pyx_k_748[] = "geterrobj (line 4952)";
static char __pyx_k_749[] = "geterrobj()\n\n    Return the current object that defines floating-point error handling.\n\n    The error object contains all information that defines the error handling\n    behavior in Numpy. `geterrobj` is used internally by the other\n    functions that get and set error handling behavior (`geterr`, `seterr`,\n    `geterrcall`, `seterrcall`).\n\n    Returns\n    -------\n    errobj : list\n        The error object, a list containing three elements:\n        [internal numpy buffer size, error mask, error callback function].\n\n        The error mask is a single integer that holds the treatment information\n        on all four floating point errors. The information for each error type\n        is contained in three bits of the integer. If we print it in base 8, we\n        can see what treatment is set for \"invalid\", \"under\", \"over\", and\n        \"divide\" (in that order). The printed string can be interpreted with\n\n        * 0 : 'ignore'\n        * 1 : 'warn'\n        * 2 : 'raise'\n        * 3 : 'call'\n        * 4 : 'print'\n        * 5 : 'log'\n\n    See Also\n    --------\n    seterrobj, seterr, geterr, seterrcall, geterrcall\n    getbufsize, setbufsize\n\n    Notes\n    -----\n    For complete documentation of the types of floating-point exceptions and\n    treatment options, see `seterr`.\n\n    Examples\n    --------\n    >>> np.geterrobj()  # first get the defaults\n    [10000, 0, None]\n\n    >>> def err_handler(type, flag):\n    ...     print \"Floating point error (%s), with flag %s\" % (type, flag)\n    ...\n    >>> old_bufsize = np.setbufsize(20000)\n    >>> old_err = np.seterr(divide='raise')\n    >>> old_handler = np.seterrcall(err_handler)\n    >>> np.geterrobj()\n    [20000, 2, <function err_handler at 0x91dcaac>]\n\n    >>> old_err = np.seterr(all='ignore')\n    >>> np.base_repr(np.geterrobj()[1], 8)\n    '0'\n    >>> old_err = np.seterr(divide='warn', over='log', under='call',\n                            invalid='print')\n    >>> np.b""ase_repr(np.geterrobj()[1], 8)\n    '4351'\n    \n    ";
static char __pyx_k_750[] = "gradient (line 5018)";
static char __pyx_k_751[] = "Return the gradient of an N-dimensional array.\n\n    The gradient is computed using central differences in the interior\n    and first differences at the boundaries. The returned gradient hence has\n    the same shape as the input array.\n\n    Parameters\n    ----------\n    f : array_like\n      An N-dimensional array containing samples of a scalar function.\n    `*varargs` : scalars\n      0, 1, or N scalars specifying the sample distances in each direction,\n      that is: `dx`, `dy`, `dz`, ... The default distance is 1.\n\n\n    Returns\n    -------\n    g : ndarray\n      N arrays of the same shape as `f` giving the derivative of `f` with\n      respect to each dimension.\n\n    Examples\n    --------\n    >>> x = np.array([1, 2, 4, 7, 11, 16], dtype=np.float)\n    >>> np.gradient(x)\n    array([ 1. ,  1.5,  2.5,  3.5,  4.5,  5. ])\n    >>> np.gradient(x, 2)\n    array([ 0.5 ,  0.75,  1.25,  1.75,  2.25,  2.5 ])\n\n    >>> np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=np.float))\n    [array([[ 2.,  2., -1.],\n           [ 2.,  2., -1.]]),\n    array([[ 1. ,  2.5,  4. ],\n           [ 1. ,  1. ,  1. ]])]\n    \n    ";
static char __pyx_k_752[] = "hamming (line 5058)";
static char __pyx_k_753[] = "Return the Hamming window.\n\n    The Hamming window is a taper formed by using a weighted cosine.\n\n    Parameters\n    ----------\n    M : int\n        Number of points in the output window. If zero or less, an\n        empty array is returned.\n\n    Returns\n    -------\n    out : ndarray\n        The window, normalized to one (the value one\n        appears only if the number of samples is odd).\n\n    See Also\n    --------\n    bartlett, blackman, hanning, kaiser\n\n    Notes\n    -----\n    The Hamming window is defined as\n\n    .. math::  w(n) = 0.54 + 0.46cos\\left(\014rac{2\\pi{n}}{M-1}\right)\n               \\qquad 0 \\leq n \\leq M-1\n\n    The Hamming was named for R. W. Hamming, an associate of J. W. Tukey and\n    is described in Blackman and Tukey. It was recommended for smoothing the\n    truncated autocovariance function in the time domain.\n    Most references to the Hamming window come from the signal processing\n    literature, where it is used as one of many windowing functions for\n    smoothing values.  It is also known as an apodization (which means\n    \"removing the foot\", i.e. smoothing discontinuities at the beginning\n    and end of the sampled signal) or tapering function.\n\n    References\n    ----------\n    .. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power\n           spectra, Dover Publications, New York.\n    .. [2] E.R. Kanasewich, \"Time Sequence Analysis in Geophysics\", The\n           University of Alberta Press, 1975, pp. 109-110.\n    .. [3] Wikipedia, \"Window function\",\n           http://en.wikipedia.org/wiki/Window_function\n    .. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,\n           \"Numerical Recipes\", Cambridge University Press, 1986, page 425.\n\n    Examples\n    --------\n    >>> np.hamming(12)\n    array([ 0.08      ,  0.15302337,  0.34890909,  0.60546483,  0.84123594,\n            0.98136677,  0.98136677,  0.84123594,  0.60546483,  0.34890909,\n         ""   0.15302337,  0.08      ])\n\n    Plot the window and the frequency response:\n\n    >>> from numpy.fft import fft, fftshift\n    >>> import matplotlib.pyplot as plt\n\n    >>> window = np.hamming(51)\n    >>> plt.plot(window)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Hamming window\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.ylabel(\"Amplitude\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.xlabel(\"Sample\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.show()\n\n    >>> plt.figure()\n    <matplotlib.figure.Figure object at 0x...>\n    >>> A = fft(window, 2048) / 25.5\n    >>> mag = np.abs(fftshift(A))\n    >>> freq = np.linspace(-0.5, 0.5, len(A))\n    >>> response = 20 * np.log10(mag)\n    >>> response = np.clip(response, -100, 100)\n    >>> plt.plot(freq, response)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Frequency response of Hamming window\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.ylabel(\"Magnitude [dB]\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.xlabel(\"Normalized frequency [cycles per sample]\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.axis('tight')\n    (-0.5, 0.5, -100.0, ...)\n    >>> plt.show()\n    \n    ";
static char __pyx_k_754[] = "hanning (line 5152)";
static char __pyx_k_755[] = "Return the Hanning window.\n\n    The Hanning window is a taper formed by using a weighted cosine.\n\n    Parameters\n    ----------\n    M : int\n        Number of points in the output window. If zero or less, an\n        empty array is returned.\n\n    Returns\n    -------\n    out : ndarray, shape(M,)\n        The window, normalized to one (the value one\n        appears only if `M` is odd).\n\n    See Also\n    --------\n    bartlett, blackman, hamming, kaiser\n\n    Notes\n    -----\n    The Hanning window is defined as\n\n    .. math::  w(n) = 0.5 - 0.5cos\\left(\014rac{2\\pi{n}}{M-1}\right)\n               \\qquad 0 \\leq n \\leq M-1\n\n    The Hanning was named for Julius van Hann, an Austrian meterologist. It is\n    also known as the Cosine Bell. Some authors prefer that it be called a\n    Hann window, to help avoid confusion with the very similar Hamming window.\n\n    Most references to the Hanning window come from the signal processing\n    literature, where it is used as one of many windowing functions for\n    smoothing values.  It is also known as an apodization (which means\n    \"removing the foot\", i.e. smoothing discontinuities at the beginning\n    and end of the sampled signal) or tapering function.\n\n    References\n    ----------\n    .. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power\n           spectra, Dover Publications, New York.\n    .. [2] E.R. Kanasewich, \"Time Sequence Analysis in Geophysics\",\n           The University of Alberta Press, 1975, pp. 106-108.\n    .. [3] Wikipedia, \"Window function\",\n           http://en.wikipedia.org/wiki/Window_function\n    .. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,\n           \"Numerical Recipes\", Cambridge University Press, 1986, page 425.\n\n    Examples\n    --------\n    >>> from numpy import hanning\n    >>> hanning(12)\n    array([ 0.        ,  0.07937323,  0.29229249,  0.57115742,  0.82743037,\n            0.97974649,  0.97974649,  0.""82743037,  0.57115742,  0.29229249,\n            0.07937323,  0.        ])\n\n    Plot the window and its frequency response:\n\n    >>> from numpy.fft import fft, fftshift\n    >>> import matplotlib.pyplot as plt\n\n    >>> window = np.hanning(51)\n    >>> plt.plot(window)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Hann window\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.ylabel(\"Amplitude\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.xlabel(\"Sample\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.show()\n\n    >>> plt.figure()\n    <matplotlib.figure.Figure object at 0x...>\n    >>> A = fft(window, 2048) / 25.5\n    >>> mag = abs(fftshift(A))\n    >>> freq = np.linspace(-0.5,0.5,len(A))\n    >>> response = 20*np.log10(mag)\n    >>> response = np.clip(response,-100,100)\n    >>> plt.plot(freq, response)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Frequency response of the Hann window\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.ylabel(\"Magnitude [dB]\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.xlabel(\"Normalized frequency [cycles per sample]\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.axis('tight')\n    (-0.5, 0.5, -100.0, ...)\n    >>> plt.show()\n    \n    ";
static char __pyx_k_756[] = "histogram (line 5248)";
static char __pyx_k_757[] = "Compute the histogram of a set of data.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data. The histogram is computed over the flattened array.\n    bins : int or sequence of scalars, optional\n        If `bins` is an int, it defines the number of equal-width\n        bins in the given range (10, by default). If `bins` is a sequence,\n        it defines the bin edges, including the rightmost edge, allowing\n        for non-uniform bin widths.\n    range : (float, float), optional\n        The lower and upper range of the bins.  If not provided, range\n        is simply ``(a.min(), a.max())``.  Values outside the range are\n        ignored.\n    normed : bool, optional\n        This keyword is deprecated in Numpy 1.6 due to confusing/buggy\n        behavior. It will be removed in Numpy 2.0. Use the density keyword\n        instead.\n        If False, the result will contain the number of samples\n        in each bin.  If True, the result is the value of the\n        probability *density* function at the bin, normalized such that\n        the *integral* over the range is 1. Note that this latter behavior is\n        known to be buggy with unequal bin widths; use `density` instead.\n    weights : array_like, optional\n        An array of weights, of the same shape as `a`.  Each value in `a`\n        only contributes its associated weight towards the bin count\n        (instead of 1).  If `normed` is True, the weights are normalized,\n        so that the integral of the density over the range remains 1\n    density : bool, optional\n        If False, the result will contain the number of samples\n        in each bin.  If True, the result is the value of the\n        probability *density* function at the bin, normalized such that\n        the *integral* over the range is 1. Note that the sum of the\n        histogram values will not be equal to 1 unless bins of unity\n        width are chosen; it is not a probability *mass* function.\n        Overr""ides the `normed` keyword if given.\n\n    Returns\n    -------\n    hist : array\n        The values of the histogram. See `normed` and `weights` for a\n        description of the possible semantics.\n    bin_edges : array of dtype float\n        Return the bin edges ``(length(hist)+1)``.\n\n\n    See Also\n    --------\n    histogramdd, bincount, searchsorted, digitize\n\n    Notes\n    -----\n    All but the last (righthand-most) bin is half-open.  In other words, if\n    `bins` is::\n\n      [1, 2, 3, 4]\n\n    then the first bin is ``[1, 2)`` (including 1, but excluding 2) and the\n    second ``[2, 3)``.  The last bin, however, is ``[3, 4]``, which *includes*\n    4.\n\n    Examples\n    --------\n    >>> np.histogram([1, 2, 1], bins=[0, 1, 2, 3])\n    (array([0, 2, 1]), array([0, 1, 2, 3]))\n    >>> np.histogram(np.arange(4), bins=np.arange(5), density=True)\n    (array([ 0.25,  0.25,  0.25,  0.25]), array([0, 1, 2, 3, 4]))\n    >>> np.histogram([[1, 2, 1], [1, 0, 1]], bins=[0,1,2,3])\n    (array([1, 4, 1]), array([0, 1, 2, 3]))\n\n    >>> a = np.arange(5)\n    >>> hist, bin_edges = np.histogram(a, density=True)\n    >>> hist\n    array([ 0.5,  0. ,  0.5,  0. ,  0. ,  0.5,  0. ,  0.5,  0. ,  0.5])\n    >>> hist.sum()\n    2.4999999999999996\n    >>> np.sum(hist*np.diff(bin_edges))\n    1.0\n    \n    ";
static char __pyx_k_758[] = "histogram2d (line 5333)";
static char __pyx_k_759[] = "Compute the bi-dimensional histogram of two data samples.\n\n    Parameters\n    ----------\n    x : array_like, shape(N,)\n        A sequence of values to be histogrammed along the first dimension.\n    y : array_like, shape(M,)\n        A sequence of values to be histogrammed along the second dimension.\n    bins : int or [int, int] or array_like or [array, array], optional\n        The bin specification:\n\n          * If int, the number of bins for the two dimensions (nx=ny=bins).\n          * If [int, int], the number of bins in each dimension (nx, ny = bins).\n          * If array_like, the bin edges for the two dimensions (x_edges=y_edges=bins).\n          * If [array, array], the bin edges in each dimension (x_edges, y_edges = bins).\n\n    range : array_like, shape(2,2), optional\n        The leftmost and rightmost edges of the bins along each dimension\n        (if not specified explicitly in the `bins` parameters):\n        ``[[xmin, xmax], [ymin, ymax]]``. All values outside of this range\n        will be considered outliers and not tallied in the histogram.\n    normed : bool, optional\n        If False, returns the number of samples in each bin. If True, returns\n        the bin density, i.e. the bin count divided by the bin area.\n    weights : array_like, shape(N,), optional\n        An array of values ``w_i`` weighing each sample ``(x_i, y_i)``. Weights\n        are normalized to 1 if `normed` is True. If `normed` is False, the\n        values of the returned histogram are equal to the sum of the weights\n        belonging to the samples falling into each bin.\n\n    Returns\n    -------\n    H : ndarray, shape(nx, ny)\n        The bi-dimensional histogram of samples `x` and `y`. Values in `x`\n        are histogrammed along the first dimension and values in `y` are\n        histogrammed along the second dimension.\n    xedges : ndarray, shape(nx,)\n        The bin edges along the first dimension.\n    yedges : ndarray, shape(ny,)\n        The bin e""dges along the second dimension.\n\n    See Also\n    --------\n    histogram: 1D histogram\n    histogramdd: Multidimensional histogram\n\n    Notes\n    -----\n    When `normed` is True, then the returned histogram is the sample density,\n    defined such that:\n\n    .. math::\n      \\sum_{i=0}^{nx-1} \\sum_{j=0}^{ny-1} H_{i,j} \\Delta x_i \\Delta y_j = 1\n\n    where `H` is the histogram array and :math:`\\Delta x_i \\Delta y_i`\n    the area of bin `{i,j}`.\n\n    Please note that the histogram does not follow the Cartesian convention\n    where `x` values are on the abcissa and `y` values on the ordinate axis.\n    Rather, `x` is histogrammed along the first dimension of the array\n    (vertical), and `y` along the second dimension of the array (horizontal).\n    This ensures compatibility with `histogramdd`.\n\n    Examples\n    --------\n    >>> x, y = np.random.randn(2, 100)\n    >>> H, xedges, yedges = np.histogram2d(x, y, bins=(5, 8))\n    >>> H.shape, xedges.shape, yedges.shape\n    ((5, 8), (6,), (9,))\n\n    We can now use the Matplotlib to visualize this 2-dimensional histogram:\n\n    >>> extent = [yedges[0], yedges[-1], xedges[-1], xedges[0]]\n    >>> import matplotlib.pyplot as plt\n    >>> plt.imshow(H, extent=extent, interpolation='nearest')\n    <matplotlib.image.AxesImage object at ...>\n    >>> plt.colorbar()\n    <matplotlib.colorbar.Colorbar instance at ...>\n    >>> plt.show()\n    \n    ";
static char __pyx_k_760[] = "histogramdd (line 5418)";
static char __pyx_k_761[] = "Compute the multidimensional histogram of some data.\n\n    Parameters\n    ----------\n    sample : array_like\n        The data to be histogrammed. It must be an (N,D) array or data\n        that can be converted to such. The rows of the resulting array\n        are the coordinates of points in a D dimensional polytope.\n    bins : sequence or int, optional\n        The bin specification:\n\n        * A sequence of arrays describing the bin edges along each dimension.\n        * The number of bins for each dimension (nx, ny, ... =bins)\n        * The number of bins for all dimensions (nx=ny=...=bins).\n\n    range : sequence, optional\n        A sequence of lower and upper bin edges to be used if the edges are\n        not given explicitely in `bins`. Defaults to the minimum and maximum\n        values along each dimension.\n    normed : bool, optional\n        If False, returns the number of samples in each bin. If True, returns\n        the bin density, ie, the bin count divided by the bin hypervolume.\n    weights : array_like (N,), optional\n        An array of values `w_i` weighing each sample `(x_i, y_i, z_i, ...)`.\n        Weights are normalized to 1 if normed is True. If normed is False, the\n        values of the returned histogram are equal to the sum of the weights\n        belonging to the samples falling into each bin.\n\n    Returns\n    -------\n    H : ndarray\n        The multidimensional histogram of sample x. See normed and weights for\n        the different possible semantics.\n    edges : list\n        A list of D arrays describing the bin edges for each dimension.\n\n    See Also\n    --------\n    histogram: 1-D histogram\n    histogram2d: 2-D histogram\n\n    Examples\n    --------\n    >>> r = np.random.randn(100,3)\n    >>> H, edges = np.histogramdd(r, bins = (5, 8, 4))\n    >>> H.shape, edges[0].size, edges[1].size, edges[2].size\n    ((5, 8, 4), 6, 9, 5)\n    \n    ";
static char __pyx_k_762[] = "hsplit (line 5471)";
static char __pyx_k_763[] = "Split an array into multiple sub-arrays horizontally (column-wise).\n\n    Please refer to the `split` documentation.  `hsplit` is equivalent\n    to `split` with ``axis=1``, the array is always split along the second\n    axis regardless of the array dimension.\n\n    See Also\n    --------\n    split : Split an array into multiple sub-arrays of equal size.\n\n    Examples\n    --------\n    >>> x = np.arange(16.0).reshape(4, 4)\n    >>> x\n    array([[  0.,   1.,   2.,   3.],\n           [  4.,   5.,   6.,   7.],\n           [  8.,   9.,  10.,  11.],\n           [ 12.,  13.,  14.,  15.]])\n    >>> np.hsplit(x, 2)\n    [array([[  0.,   1.],\n           [  4.,   5.],\n           [  8.,   9.],\n           [ 12.,  13.]]),\n     array([[  2.,   3.],\n           [  6.,   7.],\n           [ 10.,  11.],\n           [ 14.,  15.]])]\n    >>> np.hsplit(x, np.array([3, 6]))\n    [array([[  0.,   1.,   2.],\n           [  4.,   5.,   6.],\n           [  8.,   9.,  10.],\n           [ 12.,  13.,  14.]]),\n     array([[  3.],\n           [  7.],\n           [ 11.],\n           [ 15.]]),\n     array([], dtype=float64)]\n\n    With a higher dimensional array the split is still along the second axis.\n\n    >>> x = np.arange(8.0).reshape(2, 2, 2)\n    >>> x\n    array([[[ 0.,  1.],\n            [ 2.,  3.]],\n           [[ 4.,  5.],\n            [ 6.,  7.]]])\n    >>> np.hsplit(x, 2)\n    [array([[[ 0.,  1.]],\n           [[ 4.,  5.]]]),\n     array([[[ 2.,  3.]],\n           [[ 6.,  7.]]])]\n    \n    ";
static char __pyx_k_764[] = "hstack (line 5528)";
static char __pyx_k_765[] = "Stack arrays in sequence horizontally (column wise).\n\n    Take a sequence of arrays and stack them horizontally to make\n    a single array. Rebuild arrays divided by `hsplit`.\n\n    Parameters\n    ----------\n    tup : sequence of ndarrays\n        All arrays must have the same shape along all but the second axis.\n\n    Returns\n    -------\n    stacked : ndarray\n        The array formed by stacking the given arrays.\n\n    See Also\n    --------\n    vstack : Stack arrays in sequence vertically (row wise).\n    dstack : Stack arrays in sequence depth wise (along third axis).\n    concatenate : Join a sequence of arrays together.\n    hsplit : Split array along second axis.\n\n    Notes\n    -----\n    Equivalent to ``np.concatenate(tup, axis=1)``\n\n    Examples\n    --------\n    >>> a = np.array((1,2,3))\n    >>> b = np.array((2,3,4))\n    >>> np.hstack((a,b))\n    array([1, 2, 3, 2, 3, 4])\n    >>> a = np.array([[1],[2],[3]])\n    >>> b = np.array([[2],[3],[4]])\n    >>> np.hstack((a,b))\n    array([[1, 2],\n           [2, 3],\n           [3, 4]])\n    \n    ";
static char __pyx_k_766[] = "i0 (line 5572)";
static char __pyx_k_767[] = "Modified Bessel function of the first kind, order 0.\n\n    Usually denoted :math:`I_0`.  This function does broadcast, but will *not*\n    \"up-cast\" int dtype arguments unless accompanied by at least one float or\n    complex dtype argument (see Raises below).\n\n    Parameters\n    ----------\n    x : array_like, dtype float or complex\n        Argument of the Bessel function.\n\n    Returns\n    -------\n    out : ndarray, shape = x.shape, dtype = x.dtype\n        The modified Bessel function evaluated at each of the elements of `x`.\n\n    Raises\n    ------\n    TypeError: array cannot be safely cast to required type\n        If argument consists exclusively of int dtypes.\n\n    See Also\n    --------\n    scipy.special.iv, scipy.special.ive\n\n    Notes\n    -----\n    We use the algorithm published by Clenshaw [1]_ and referenced by\n    Abramowitz and Stegun [2]_, for which the function domain is partitioned\n    into the two intervals [0,8] and (8,inf), and Chebyshev polynomial\n    expansions are employed in each interval. Relative error on the domain\n    [0,30] using IEEE arithmetic is documented [3]_ as having a peak of 5.8e-16\n    with an rms of 1.4e-16 (n = 30000).\n\n    References\n    ----------\n    .. [1] C. W. Clenshaw, \"Chebyshev series for mathematical functions,\" in\n           *National Physical Laboratory Mathematical Tables*, vol. 5, London:\n           Her Majesty's Stationery Office, 1962.\n    .. [2] M. Abramowitz and I. A. Stegun, *Handbook of Mathematical\n           Functions*, 10th printing, New York: Dover, 1964, pp. 379.\n           http://www.math.sfu.ca/~cbm/aands/page_379.htm\n    .. [3] http://kobesearch.cpan.org/htdocs/Math-Cephes/Math/Cephes.html\n\n    Examples\n    --------\n    >>> np.i0([0.])\n    array(1.0)\n    >>> np.i0([0., 1. + 2j])\n    array([ 1.00000000+0.j        ,  0.18785373+0.64616944j])\n    \n    ";
static char __pyx_k_768[] = "imag (line 5628)";
static char __pyx_k_769[] = "Return the imaginary part of the elements of the array.\n\n    Parameters\n    ----------\n    val : array_like\n        Input array.\n\n    Returns\n    -------\n    out : ndarray\n        Output array. If `val` is real, the type of `val` is used for the\n        output.  If `val` has complex elements, the returned type is float.\n\n    See Also\n    --------\n    real, angle, real_if_close\n\n    Examples\n    --------\n    >>> a = np.array([1+2j, 3+4j, 5+6j])\n    >>> a.imag\n    array([ 2.,  4.,  6.])\n    >>> a.imag = np.array([8, 10, 12])\n    >>> a\n    array([ 1. +8.j,  3.+10.j,  5.+12.j])\n    \n    ";
static char __pyx_k_770[] = "in1d (line 5659)";
static char __pyx_k_771[] = "Test whether each element of a 1D array is also present in a second array.\n\n    Returns a boolean array the same length as `ar1` that is True\n    where an element of `ar1` is in `ar2` and False otherwise.\n\n    Parameters\n    ----------\n    ar1 : array_like, shape (M,)\n        Input array.\n    ar2 : array_like\n        The values against which to test each value of `ar1`.\n    assume_unique : bool, optional\n        If True, the input arrays are both assumed to be unique, which\n        can speed up the calculation.  Default is False.\n\n    Returns\n    -------\n    mask : ndarray of bools, shape(M,)\n        The values `ar1[mask]` are in `ar2`.\n\n    See Also\n    --------\n    numpy.lib.arraysetops : Module with a number of other functions for\n                            performing set operations on arrays.\n\n    Notes\n    -----\n    `in1d` can be considered as an element-wise function version of the\n    python keyword `in`, for 1D sequences. ``in1d(a, b)`` is roughly\n    equivalent to ``np.array([item in b for item in a])``.\n\n    .. versionadded:: 1.4.0\n\n    Examples\n    --------\n    >>> test = np.array([0, 1, 2, 5, 0])\n    >>> states = [0, 2]\n    >>> mask = np.in1d(test, states)\n    >>> mask\n    array([ True, False,  True, False,  True], dtype=bool)\n    >>> test[mask]\n    array([0, 2, 0])\n    \n    ";
static char __pyx_k_772[] = "indices (line 5707)";
static char __pyx_k_773[] = "Return an array representing the indices of a grid.\n\n    Compute an array where the subarrays contain index values 0,1,...\n    varying only along the corresponding axis.\n\n    Parameters\n    ----------\n    dimensions : sequence of ints\n        The shape of the grid.\n    dtype : dtype, optional\n        Data type of the result.\n\n    Returns\n    -------\n    grid : ndarray\n        The array of grid indices,\n        ``grid.shape = (len(dimensions),) + tuple(dimensions)``.\n\n    See Also\n    --------\n    mgrid, meshgrid\n\n    Notes\n    -----\n    The output shape is obtained by prepending the number of dimensions\n    in front of the tuple of dimensions, i.e. if `dimensions` is a tuple\n    ``(r0, ..., rN-1)`` of length ``N``, the output shape is\n    ``(N,r0,...,rN-1)``.\n\n    The subarrays ``grid[k]`` contains the N-D array of indices along the\n    ``k-th`` axis. Explicitly::\n\n        grid[k,i0,i1,...,iN-1] = ik\n\n    Examples\n    --------\n    >>> grid = np.indices((2, 3))\n    >>> grid.shape\n    (2, 2, 3)\n    >>> grid[0]        # row indices\n    array([[0, 0, 0],\n           [1, 1, 1]])\n    >>> grid[1]        # column indices\n    array([[0, 1, 2],\n           [0, 1, 2]])\n\n    The indices can be used as an index into an array.\n\n    >>> x = np.arange(20).reshape(5, 4)\n    >>> row, col = np.indices((2, 3))\n    >>> x[row, col]\n    array([[0, 1, 2],\n           [4, 5, 6]])\n\n    Note that it would be more straightforward in the above example to\n    extract the required elements directly with ``x[:2, :3]``.\n    \n    ";
static char __pyx_k_774[] = "info (line 5769)";
static char __pyx_k_775[] = "Get help information for a function, class, or module.\n\n    Parameters\n    ----------\n    object : object or str, optional\n        Input object or name to get information about. If `object` is a\n        numpy object, its docstring is given. If it is a string, available\n        modules are searched for matching objects.\n        If None, information about `info` itself is returned.\n    maxwidth : int, optional\n        Printing width.\n    output : file like object, optional\n        File like object that the output is written to, default is ``stdout``.\n        The object has to be opened in 'w' or 'a' mode.\n    toplevel : str, optional\n        Start search at this level.\n\n    See Also\n    --------\n    source, lookfor\n\n    Notes\n    -----\n    When used interactively with an object, ``np.info(obj)`` is equivalent to\n    ``help(obj)`` on the Python prompt or ``obj?`` on the IPython prompt.\n\n    Examples\n    --------\n    >>> np.info(np.polyval) # doctest: +SKIP\n       polyval(p, x)\n         Evaluate the polynomial p at x.\n         ...\n\n    When using a string for `object` it is possible to get multiple results.\n\n    >>> np.info('fft') # doctest: +SKIP\n         *** Found in numpy ***\n    Core FFT routines\n    ...\n         *** Found in numpy.fft ***\n     fft(a, n=None, axis=-1)\n    ...\n         *** Repeat reference found in numpy.fft.fftpack ***\n         *** Total of 3 references found. ***\n    \n    ";
static char __pyx_k_776[] = "inner (line 5819)";
static char __pyx_k_777[] = "inner(a, b)\n\n    Inner product of two arrays.\n\n    Ordinary inner product of vectors for 1-D arrays (without complex\n    conjugation), in higher dimensions a sum product over the last axes.\n\n    Parameters\n    ----------\n    a, b : array_like\n        If `a` and `b` are nonscalar, their last dimensions of must match.\n\n    Returns\n    -------\n    out : ndarray\n        `out.shape = a.shape[:-1] + b.shape[:-1]`\n\n    Raises\n    ------\n    ValueError\n        If the last dimension of `a` and `b` has different size.\n\n    See Also\n    --------\n    tensordot : Sum products over arbitrary axes.\n    dot : Generalised matrix product, using second last dimension of `b`.\n    einsum : Einstein summation convention.\n\n    Notes\n    -----\n    For vectors (1-D arrays) it computes the ordinary inner-product::\n\n        np.inner(a, b) = sum(a[:]*b[:])\n\n    More generally, if `ndim(a) = r > 0` and `ndim(b) = s > 0`::\n\n        np.inner(a, b) = np.tensordot(a, b, axes=(-1,-1))\n\n    or explicitly::\n\n        np.inner(a, b)[i0,...,ir-1,j0,...,js-1]\n             = sum(a[i0,...,ir-1,:]*b[j0,...,js-1,:])\n\n    In addition `a` or `b` may be scalars, in which case::\n\n       np.inner(a,b) = a*b\n\n    Examples\n    --------\n    Ordinary inner product for vectors:\n\n    >>> a = np.array([1,2,3])\n    >>> b = np.array([0,1,0])\n    >>> np.inner(a, b)\n    2\n\n    A multidimensional example:\n\n    >>> a = np.arange(24).reshape((2,3,4))\n    >>> b = np.arange(4)\n    >>> np.inner(a, b)\n    array([[ 14,  38,  62],\n           [ 86, 110, 134]])\n\n    An example where `b` is a scalar:\n\n    >>> np.inner(np.eye(2), 7)\n    array([[ 7.,  0.],\n           [ 0.,  7.]])\n    \n    ";
static char __pyx_k_778[] = "insert (line 5895)";
static char __pyx_k_779[] = "Insert values along the given axis before the given indices.\n\n    Parameters\n    ----------\n    arr : array_like\n        Input array.\n    obj : int, slice or sequence of ints\n        Object that defines the index or indices before which `values` is\n        inserted.\n    values : array_like\n        Values to insert into `arr`. If the type of `values` is different\n        from that of `arr`, `values` is converted to the type of `arr`.\n    axis : int, optional\n        Axis along which to insert `values`.  If `axis` is None then `arr`\n        is flattened first.\n\n    Returns\n    -------\n    out : ndarray\n        A copy of `arr` with `values` inserted.  Note that `insert`\n        does not occur in-place: a new array is returned. If\n        `axis` is None, `out` is a flattened array.\n\n    See Also\n    --------\n    append : Append elements at the end of an array.\n    delete : Delete elements from an array.\n\n    Examples\n    --------\n    >>> a = np.array([[1, 1], [2, 2], [3, 3]])\n    >>> a\n    array([[1, 1],\n           [2, 2],\n           [3, 3]])\n    >>> np.insert(a, 1, 5)\n    array([1, 5, 1, 2, 2, 3, 3])\n    >>> np.insert(a, 1, 5, axis=1)\n    array([[1, 5, 1],\n           [2, 5, 2],\n           [3, 5, 3]])\n\n    >>> b = a.flatten()\n    >>> b\n    array([1, 1, 2, 2, 3, 3])\n    >>> np.insert(b, [2, 2], [5, 6])\n    array([1, 1, 5, 6, 2, 2, 3, 3])\n\n    >>> np.insert(b, slice(2, 4), [5, 6])\n    array([1, 1, 5, 2, 6, 2, 3, 3])\n\n    >>> np.insert(b, [2, 2], [7.13, False]) # type casting\n    array([1, 1, 7, 0, 2, 2, 3, 3])\n\n    >>> x = np.arange(8).reshape(2, 4)\n    >>> idx = (1, 3)\n    >>> np.insert(x, idx, 999, axis=1)\n    array([[  0, 999,   1,   2, 999,   3],\n           [  4, 999,   5,   6, 999,   7]])\n    \n    ";
static char __pyx_k_780[] = "interp (line 5968)";
static char __pyx_k_781[] = "One-dimensional linear interpolation.\n\n    Returns the one-dimensional piecewise linear interpolant to a function\n    with given values at discrete data-points.\n\n    Parameters\n    ----------\n    x : array_like\n        The x-coordinates of the interpolated values.\n\n    xp : 1-D sequence of floats\n        The x-coordinates of the data points, must be increasing.\n\n    fp : 1-D sequence of floats\n        The y-coordinates of the data points, same length as `xp`.\n\n    left : float, optional\n        Value to return for `x < xp[0]`, default is `fp[0]`.\n\n    right : float, optional\n        Value to return for `x > xp[-1]`, defaults is `fp[-1]`.\n\n    Returns\n    -------\n    y : {float, ndarray}\n        The interpolated values, same shape as `x`.\n\n    Raises\n    ------\n    ValueError\n        If `xp` and `fp` have different length\n\n    Notes\n    -----\n    Does not check that the x-coordinate sequence `xp` is increasing.\n    If `xp` is not increasing, the results are nonsense.\n    A simple check for increasingness is::\n\n        np.all(np.diff(xp) > 0)\n\n\n    Examples\n    --------\n    >>> xp = [1, 2, 3]\n    >>> fp = [3, 2, 0]\n    >>> np.interp(2.5, xp, fp)\n    1.0\n    >>> np.interp([0, 1, 1.5, 2.72, 3.14], xp, fp)\n    array([ 3. ,  3. ,  2.5 ,  0.56,  0. ])\n    >>> UNDEF = -99.0\n    >>> np.interp(3.14, xp, fp, right=UNDEF)\n    -99.0\n\n    Plot an interpolant to the sine function:\n\n    >>> x = np.linspace(0, 2*np.pi, 10)\n    >>> y = np.sin(x)\n    >>> xvals = np.linspace(0, 2*np.pi, 50)\n    >>> yinterp = np.interp(xvals, x, y)\n    >>> import matplotlib.pyplot as plt\n    >>> plt.plot(x, y, 'o')\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.plot(xvals, yinterp, '-x')\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.show()\n    \n    ";
static char __pyx_k_782[] = "intersect1d (line 6039)";
static char __pyx_k_783[] = "Find the intersection of two arrays.\n\n    Return the sorted, unique values that are in both of the input arrays.\n\n    Parameters\n    ----------\n    ar1, ar2 : array_like\n        Input arrays.\n    assume_unique : bool\n        If True, the input arrays are both assumed to be unique, which\n        can speed up the calculation.  Default is False.\n\n    Returns\n    -------\n    out : ndarray\n        Sorted 1D array of common and unique elements.\n\n    See Also\n    --------\n    numpy.lib.arraysetops : Module with a number of other functions for\n                            performing set operations on arrays.\n\n    Examples\n    --------\n    >>> np.intersect1d([1, 3, 4, 3], [3, 1, 2, 1])\n    array([1, 3])\n    \n    ";
static char __pyx_k_784[] = "irr (line 6113)";
static char __pyx_k_785[] = "Return the Internal Rate of Return (IRR).\n\n    This is the \"average\" periodically compounded rate of return\n    that gives a net present value of 0.0; for a more complete explanation,\n    see Notes below.\n\n    Parameters\n    ----------\n    values : array_like, shape(N,)\n        Input cash flows per time period.  By convention, net \"deposits\"\n        are negative and net \"withdrawals\" are positive.  Thus, for example,\n        at least the first element of `values`, which represents the initial\n        investment, will typically be negative.\n\n    Returns\n    -------\n    out : float\n        Internal Rate of Return for periodic input values.\n\n    Notes\n    -----\n    The IRR is perhaps best understood through an example (illustrated\n    using np.irr in the Examples section below).  Suppose one invests\n    100 units and then makes the following withdrawals at regular\n    (fixed) intervals: 39, 59, 55, 20.  Assuming the ending value is 0,\n    one's 100 unit investment yields 173 units; however, due to the\n    combination of compounding and the periodic withdrawals, the\n    \"average\" rate of return is neither simply 0.73/4 nor (1.73)^0.25-1.\n    Rather, it is the solution (for :math:`r`) of the equation:\n\n    .. math:: -100 + \014rac{39}{1+r} + \014rac{59}{(1+r)^2}\n     + \014rac{55}{(1+r)^3} + \014rac{20}{(1+r)^4} = 0\n\n    In general, for `values` :math:`= [v_0, v_1, ... v_M]`,\n    irr is the solution of the equation: [G]_\n\n    .. math:: \\sum_{t=0}^M{\014rac{v_t}{(1+irr)^{t}}} = 0\n\n    References\n    ----------\n    .. [G] L. J. Gitman, \"Principles of Managerial Finance, Brief,\" 3rd ed.,\n       Addison-Wesley, 2003, pg. 348.\n\n    Examples\n    --------\n    >>> np.irr([-100, 39, 59, 55, 20])\n    0.2809484211599611\n\n    (Compare with the Example given for numpy.lib.financial.npv)\n    \n    ";
static char __pyx_k_786[] = "iscomplex (line 6168)";
static char __pyx_k_787[] = "Returns a bool array, where True if input element is complex.\n\n    What is tested is whether the input has a non-zero imaginary part, not if\n    the input type is complex.\n\n    Parameters\n    ----------\n    x : array_like\n        Input array.\n\n    Returns\n    -------\n    out : ndarray of bools\n        Output array.\n\n    See Also\n    --------\n    isreal\n    iscomplexobj : Return True if x is a complex type or an array of complex\n                   numbers.\n\n    Examples\n    --------\n    >>> np.iscomplex([1+1j, 1+0j, 4.5, 3, 2, 2j])\n    array([ True, False, False, False, False,  True], dtype=bool)\n    \n    ";
static char __pyx_k_788[] = "iscomplexobj (line 6199)";
static char __pyx_k_789[] = "Return True if x is a complex type or an array of complex numbers.\n\n    The type of the input is checked, not the value. So even if the input\n    has an imaginary part equal to zero, `iscomplexobj` evaluates to True\n    if the data type is complex.\n\n    Parameters\n    ----------\n    x : any\n        The input can be of any type and shape.\n\n    Returns\n    -------\n    y : bool\n        The return value, True if `x` is of a complex type.\n\n    See Also\n    --------\n    isrealobj, iscomplex\n\n    Examples\n    --------\n    >>> np.iscomplexobj(1)\n    False\n    >>> np.iscomplexobj(1+0j)\n    True\n    >>> np.iscomplexobj([3, 1+0j, True])\n    True\n    \n    ";
static char __pyx_k_790[] = "isfortran (line 6233)";
static char __pyx_k_791[] = "Returns True if array is arranged in Fortran-order in memory\n    and dimension > 1.\n\n    Parameters\n    ----------\n    a : ndarray\n        Input array.\n\n\n    Examples\n    --------\n\n    np.array allows to specify whether the array is written in C-contiguous\n    order (last index varies the fastest), or FORTRAN-contiguous order in\n    memory (first index varies the fastest).\n\n    >>> a = np.array([[1, 2, 3], [4, 5, 6]], order='C')\n    >>> a\n    array([[1, 2, 3],\n           [4, 5, 6]])\n    >>> np.isfortran(a)\n    False\n\n    >>> b = np.array([[1, 2, 3], [4, 5, 6]], order='FORTRAN')\n    >>> b\n    array([[1, 2, 3],\n           [4, 5, 6]])\n    >>> np.isfortran(b)\n    True\n\n\n    The transpose of a C-ordered array is a FORTRAN-ordered array.\n\n    >>> a = np.array([[1, 2, 3], [4, 5, 6]], order='C')\n    >>> a\n    array([[1, 2, 3],\n           [4, 5, 6]])\n    >>> np.isfortran(a)\n    False\n    >>> b = a.T\n    >>> b\n    array([[1, 4],\n           [2, 5],\n           [3, 6]])\n    >>> np.isfortran(b)\n    True\n\n    1-D arrays always evaluate as False.\n\n    >>> np.isfortran(np.array([1, 2], order='FORTRAN'))\n    False\n    \n    ";
static char __pyx_k_792[] = "isneginf (line 6290)";
static char __pyx_k_793[] = "Test element-wise for negative infinity, return result as bool array.\n\n    Parameters\n    ----------\n    x : array_like\n        The input array.\n    y : array_like, optional\n        A boolean array with the same shape and type as `x` to store the\n        result.\n\n    Returns\n    -------\n    y : ndarray\n        A boolean array with the same dimensions as the input.\n        If second argument is not supplied then a numpy boolean array is\n        returned with values True where the corresponding element of the\n        input is negative infinity and values False where the element of\n        the input is not negative infinity.\n\n        If a second argument is supplied the result is stored there. If the\n        type of that array is a numeric type the result is represented as\n        zeros and ones, if the type is boolean then as False and True. The\n        return value `y` is then a reference to that array.\n\n    See Also\n    --------\n    isinf, isposinf, isnan, isfinite\n\n    Notes\n    -----\n    Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n    (IEEE 754).\n\n    Errors result if the second argument is also supplied when x is a scalar\n    input, or if first and second arguments have different shapes.\n\n    Examples\n    --------\n    >>> np.isneginf(np.NINF)\n    array(True, dtype=bool)\n    >>> np.isneginf(np.inf)\n    array(False, dtype=bool)\n    >>> np.isneginf(np.PINF)\n    array(False, dtype=bool)\n    >>> np.isneginf([-np.inf, 0., np.inf])\n    array([ True, False, False], dtype=bool)\n\n    >>> x = np.array([-np.inf, 0., np.inf])\n    >>> y = np.array([2, 2, 2])\n    >>> np.isneginf(x, y)\n    array([1, 0, 0])\n    >>> y\n    array([1, 0, 0])\n    \n    ";
static char __pyx_k_794[] = "isposinf (line 6349)";
static char __pyx_k_795[] = "Test element-wise for positive infinity, return result as bool array.\n\n    Parameters\n    ----------\n    x : array_like\n        The input array.\n    y : array_like, optional\n        A boolean array with the same shape as `x` to store the result.\n\n    Returns\n    -------\n    y : ndarray\n        A boolean array with the same dimensions as the input.\n        If second argument is not supplied then a boolean array is returned\n        with values True where the corresponding element of the input is\n        positive infinity and values False where the element of the input is\n        not positive infinity.\n\n        If a second argument is supplied the result is stored there. If the\n        type of that array is a numeric type the result is represented as zeros\n        and ones, if the type is boolean then as False and True.\n        The return value `y` is then a reference to that array.\n\n    See Also\n    --------\n    isinf, isneginf, isfinite, isnan\n\n    Notes\n    -----\n    Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n    (IEEE 754).\n\n    Errors result if the second argument is also supplied when `x` is a\n    scalar input, or if first and second arguments have different shapes.\n\n    Examples\n    --------\n    >>> np.isposinf(np.PINF)\n    array(True, dtype=bool)\n    >>> np.isposinf(np.inf)\n    array(True, dtype=bool)\n    >>> np.isposinf(np.NINF)\n    array(False, dtype=bool)\n    >>> np.isposinf([-np.inf, 0., np.inf])\n    array([False, False,  True], dtype=bool)\n\n    >>> x = np.array([-np.inf, 0., np.inf])\n    >>> y = np.array([2, 2, 2])\n    >>> np.isposinf(x, y)\n    array([0, 0, 1])\n    >>> y\n    array([0, 0, 1])\n    \n    ";
static char __pyx_k_796[] = "isreal (line 6407)";
static char __pyx_k_797[] = "Returns a bool array, where True if input element is real.\n\n    If element has complex type with zero complex part, the return value\n    for that element is True.\n\n    Parameters\n    ----------\n    x : array_like\n        Input array.\n\n    Returns\n    -------\n    out : ndarray, bool\n        Boolean array of same shape as `x`.\n\n    See Also\n    --------\n    iscomplex\n    isrealobj : Return True if x is not a complex type.\n\n    Examples\n    --------\n    >>> np.isreal([1+1j, 1+0j, 4.5, 3, 2, 2j])\n    array([False,  True,  True,  True,  True, False], dtype=bool)\n    \n    ";
static char __pyx_k_798[] = "isrealobj (line 6437)";
static char __pyx_k_799[] = "Return True if x is a not complex type or an array of complex numbers.\n\n    The type of the input is checked, not the value. So even if the input\n    has an imaginary part equal to zero, `isrealobj` evaluates to False\n    if the data type is complex.\n\n    Parameters\n    ----------\n    x : any\n        The input can be of any type and shape.\n\n    Returns\n    -------\n    y : bool\n        The return value, False if `x` is of a complex type.\n\n    See Also\n    --------\n    iscomplexobj, isreal\n\n    Examples\n    --------\n    >>> np.isrealobj(1)\n    True\n    >>> np.isrealobj(1+0j)\n    False\n    >>> np.isrealobj([3, 1+0j, True])\n    False\n    \n    ";
static char __pyx_k_800[] = "isscalar (line 6471)";
static char __pyx_k_801[] = "Returns True if the type of `num` is a scalar type.\n\n    Parameters\n    ----------\n    num : any\n        Input argument, can be of any type and shape.\n\n    Returns\n    -------\n    val : bool\n        True if `num` is a scalar type, False if it is not.\n\n    Examples\n    --------\n    >>> np.isscalar(3.1)\n    True\n    >>> np.isscalar([3.1])\n    False\n    >>> np.isscalar(False)\n    True\n    \n    ";
static char __pyx_k_802[] = "issctype (line 6497)";
static char __pyx_k_803[] = "Determines whether the given object represents a scalar data-type.\n\n    Parameters\n    ----------\n    rep : any\n        If `rep` is an instance of a scalar dtype, True is returned. If not,\n        False is returned.\n\n    Returns\n    -------\n    out : bool\n        Boolean result of check whether `rep` is a scalar dtype.\n\n    See Also\n    --------\n    issubsctype, issubdtype, obj2sctype, sctype2char\n\n    Examples\n    --------\n    >>> np.issctype(np.int32)\n    True\n    >>> np.issctype(list)\n    False\n    >>> np.issctype(1.1)\n    False\n\n    Strings are also a scalar type:\n\n    >>> np.issctype(np.dtype('str'))\n    True\n    \n    ";
static char __pyx_k_804[] = "issubclass_ (line 6533)";
static char __pyx_k_805[] = "Determine if a class is a subclass of a second class.\n\n    `issubclass_` is equivalent to the Python built-in ``issubclass``,\n    except that it returns False instead of raising a TypeError is one\n    of the arguments is not a class.\n\n    Parameters\n    ----------\n    arg1 : class\n        Input class. True is returned if `arg1` is a subclass of `arg2`.\n    arg2 : class or tuple of classes.\n        Input class. If a tuple of classes, True is returned if `arg1` is a\n        subclass of any of the tuple elements.\n\n    Returns\n    -------\n    out : bool\n        Whether `arg1` is a subclass of `arg2` or not.\n\n    See Also\n    --------\n    issubsctype, issubdtype, issctype\n\n    Examples\n    --------\n    >>> np.issubclass_(np.int32, np.int)\n    True\n    >>> np.issubclass_(np.int32, np.float)\n    False\n    \n    ";
static char __pyx_k_806[] = "issubdtype (line 6568)";
static char __pyx_k_807[] = "Returns True if first argument is a typecode lower/equal in type hierarchy.\n\n    Parameters\n    ----------\n    arg1, arg2 : dtype_like\n        dtype or string representing a typecode.\n\n    Returns\n    -------\n    out : bool\n\n    See Also\n    --------\n    issubsctype, issubclass_\n    numpy.core.numerictypes : Overview of numpy type hierarchy.\n\n    Examples\n    --------\n    >>> np.issubdtype('S1', str)\n    True\n    >>> np.issubdtype(np.float64, np.float32)\n    False\n    \n    ";
static char __pyx_k_808[] = "issubsctype (line 6596)";
static char __pyx_k_809[] = "Determine if the first argument is a subclass of the second argument.\n\n    Parameters\n    ----------\n    arg1, arg2 : dtype or dtype specifier\n        Data-types.\n\n    Returns\n    -------\n    out : bool\n        The result.\n\n    See Also\n    --------\n    issctype, issubdtype,obj2sctype\n\n    Examples\n    --------\n    >>> np.issubsctype('S8', str)\n    True\n    >>> np.issubsctype(np.array([1]), np.int)\n    True\n    >>> np.issubsctype(np.array([1]), np.float)\n    False\n    \n    ";
static char __pyx_k_810[] = "iterable (line 6626)";
static char __pyx_k_811[] = "Check whether or not an object can be iterated over.\n\n    Parameters\n    ----------\n    y : object\n      Input object.\n\n    Returns\n    -------\n    b : {0, 1}\n      Return 1 if the object has an iterator method or is a sequence,\n      and 0 otherwise.\n\n\n    Examples\n    --------\n    >>> np.iterable([1, 2, 3])\n    1\n    >>> np.iterable(2)\n    0\n    \n    ";
static char __pyx_k_812[] = "ix_ (line 6652)";
static char __pyx_k_813[] = "Construct an open mesh from multiple sequences.\n\n    This function takes N 1-D sequences and returns N outputs with N\n    dimensions each, such that the shape is 1 in all but one dimension\n    and the dimension with the non-unit shape value cycles through all\n    N dimensions.\n\n    Using `ix_` one can quickly construct index arrays that will index\n    the cross product. ``a[np.ix_([1,3],[2,5])]`` returns the array\n    ``[[a[1,2] a[1,5]], [a[3,2] a[3,5]]]``.\n\n    Parameters\n    ----------\n    args : 1-D sequences\n\n    Returns\n    -------\n    out : tuple of ndarrays\n        N arrays with N dimensions each, with N the number of input\n        sequences. Together these arrays form an open mesh.\n\n    See Also\n    --------\n    ogrid, mgrid, meshgrid\n\n    Examples\n    --------\n    >>> a = np.arange(10).reshape(2, 5)\n    >>> a\n    array([[0, 1, 2, 3, 4],\n           [5, 6, 7, 8, 9]])\n    >>> ixgrid = np.ix_([0,1], [2,4])\n    >>> ixgrid\n    (array([[0],\n           [1]]), array([[2, 4]]))\n    >>> ixgrid[0].shape, ixgrid[1].shape\n    ((2, 1), (1, 2))\n    >>> a[ixgrid]\n    array([[2, 4],\n           [7, 9]])\n    \n    ";
static char __pyx_k_814[] = "kaiser (line 6698)";
static char __pyx_k_815[] = "Return the Kaiser window.\n\n    The Kaiser window is a taper formed by using a Bessel function.\n\n    Parameters\n    ----------\n    M : int\n        Number of points in the output window. If zero or less, an\n        empty array is returned.\n    beta : float\n        Shape parameter for window.\n\n    Returns\n    -------\n    out : array\n        The window, normalized to one (the value one\n        appears only if the number of samples is odd).\n\n    See Also\n    --------\n    bartlett, blackman, hamming, hanning\n\n    Notes\n    -----\n    The Kaiser window is defined as\n\n    .. math::  w(n) = I_0\\left( \010eta \\sqrt{1-\014rac{4n^2}{(M-1)^2}}\n               \right)/I_0(\010eta)\n\n    with\n\n    .. math:: \\quad -\014rac{M-1}{2} \\leq n \\leq \014rac{M-1}{2},\n\n    where :math:`I_0` is the modified zeroth-order Bessel function.\n\n    The Kaiser was named for Jim Kaiser, who discovered a simple approximation\n    to the DPSS window based on Bessel functions.\n    The Kaiser window is a very good approximation to the Digital Prolate\n    Spheroidal Sequence, or Slepian window, which is the transform which\n    maximizes the energy in the main lobe of the window relative to total\n    energy.\n\n    The Kaiser can approximate many other windows by varying the beta\n    parameter.\n\n    ====  =======================\n    beta  Window shape\n    ====  =======================\n    0     Rectangular\n    5     Similar to a Hamming\n    6     Similar to a Hanning\n    8.6   Similar to a Blackman\n    ====  =======================\n\n    A beta value of 14 is probably a good starting point. Note that as beta\n    gets large, the window narrows, and so the number of samples needs to be\n    large enough to sample the increasingly narrow spike, otherwise nans will\n    get returned.\n\n\n    Most references to the Kaiser window come from the signal processing\n    literature, where it is used as one of many windowing functions for\n    smoothing values.  It"" is also known as an apodization (which means\n    \"removing the foot\", i.e. smoothing discontinuities at the beginning\n    and end of the sampled signal) or tapering function.\n\n    References\n    ----------\n    .. [1] J. F. Kaiser, \"Digital Filters\" - Ch 7 in \"Systems analysis by\n           digital computer\", Editors: F.F. Kuo and J.F. Kaiser, p 218-285.\n           John Wiley and Sons, New York, (1966).\n    .. [2] E.R. Kanasewich, \"Time Sequence Analysis in Geophysics\", The\n           University of Alberta Press, 1975, pp. 177-178.\n    .. [3] Wikipedia, \"Window function\",\n           http://en.wikipedia.org/wiki/Window_function\n\n    Examples\n    --------\n    >>> from numpy import kaiser\n    >>> kaiser(12, 14)\n    array([  7.72686684e-06,   3.46009194e-03,   4.65200189e-02,\n             2.29737120e-01,   5.99885316e-01,   9.45674898e-01,\n             9.45674898e-01,   5.99885316e-01,   2.29737120e-01,\n             4.65200189e-02,   3.46009194e-03,   7.72686684e-06])\n\n\n    Plot the window and the frequency response:\n\n    >>> from numpy import clip, log10, array, kaiser, linspace\n    >>> from numpy.fft import fft, fftshift\n    >>> import matplotlib.pyplot as plt\n\n    >>> window = kaiser(51, 14)\n    >>> plt.plot(window)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Kaiser window\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.ylabel(\"Amplitude\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.xlabel(\"Sample\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.show()\n\n    >>> plt.figure()\n    <matplotlib.figure.Figure object at 0x...>\n    >>> A = fft(window, 2048) / 25.5\n    >>> mag = abs(fftshift(A))\n    >>> freq = linspace(-0.5,0.5,len(A))\n    >>> response = 20*log10(mag)\n    >>> response = clip(response,-100,100)\n    >>> plt.plot(freq, response)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Frequency response of Kaiser window\")\n    <matplot""lib.text.Text object at 0x...>\n    >>> plt.ylabel(\"Magnitude [dB]\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.xlabel(\"Normalized frequency [cycles per sample]\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.axis('tight')\n    (-0.5, 0.5, -100.0, ...)\n    >>> plt.show()\n    \n    ";
static char __pyx_k_816[] = "kron (line 6825)";
static char __pyx_k_817[] = "Kronecker product of two arrays.\n\n    Computes the Kronecker product, a composite array made of blocks of the\n    second array scaled by the first.\n\n    Parameters\n    ----------\n    a, b : array_like\n\n    Returns\n    -------\n    out : ndarray\n\n    See Also\n    --------\n\n    outer : The outer product\n\n    Notes\n    -----\n\n    The function assumes that the number of dimenensions of `a` and `b`\n    are the same, if necessary prepending the smallest with ones.\n    If `a.shape = (r0,r1,..,rN)` and `b.shape = (s0,s1,...,sN)`,\n    the Kronecker product has shape `(r0*s0, r1*s1, ..., rN*SN)`.\n    The elements are products of elements from `a` and `b`, organized\n    explicitly by::\n\n        kron(a,b)[k0,k1,...,kN] = a[i0,i1,...,iN] * b[j0,j1,...,jN]\n\n    where::\n\n        kt = it * st + jt,  t = 0,...,N\n\n    In the common 2-D case (N=1), the block structure can be visualized::\n\n        [[ a[0,0]*b,   a[0,1]*b,  ... , a[0,-1]*b  ],\n         [  ...                              ...   ],\n         [ a[-1,0]*b,  a[-1,1]*b, ... , a[-1,-1]*b ]]\n\n\n    Examples\n    --------\n    >>> np.kron([1,10,100], [5,6,7])\n    array([  5,   6,   7,  50,  60,  70, 500, 600, 700])\n    >>> np.kron([5,6,7], [1,10,100])\n    array([  5,  50, 500,   6,  60, 600,   7,  70, 700])\n\n    >>> np.kron(np.eye(2), np.ones((2,2)))\n    array([[ 1.,  1.,  0.,  0.],\n           [ 1.,  1.,  0.,  0.],\n           [ 0.,  0.,  1.,  1.],\n           [ 0.,  0.,  1.,  1.]])\n\n    >>> a = np.arange(100).reshape((2,5,2,5))\n    >>> b = np.arange(24).reshape((2,3,4))\n    >>> c = np.kron(a,b)\n    >>> c.shape\n    (2, 10, 6, 20)\n    >>> I = (1,3,0,2)\n    >>> J = (0,2,1)\n    >>> J1 = (0,) + J             # extend to ndim=4\n    >>> S1 = (1,) + b.shape\n    >>> K = tuple(np.array(I) * np.array(S1) + np.array(J1))\n    >>> c[K] == a[I]*b[J]\n    True\n    \n    ";
static char __pyx_k_818[] = "lexsort (line 6897)";
static char __pyx_k_819[] = "lexsort(keys, axis=-1)\n\n    Perform an indirect sort using a sequence of keys.\n\n    Given multiple sorting keys, which can be interpreted as columns in a\n    spreadsheet, lexsort returns an array of integer indices that describes\n    the sort order by multiple columns. The last key in the sequence is used\n    for the primary sort order, the second-to-last key for the secondary sort\n    order, and so on. The keys argument must be a sequence of objects that\n    can be converted to arrays of the same shape. If a 2D array is provided\n    for the keys argument, it's rows are interpreted as the sorting keys and\n    sorting is according to the last row, second last row etc.\n\n    Parameters\n    ----------\n    keys : (k,N) array or tuple containing k (N,)-shaped sequences\n        The `k` different \"columns\" to be sorted.  The last column (or row if\n        `keys` is a 2D array) is the primary sort key.\n    axis : int, optional\n        Axis to be indirectly sorted.  By default, sort over the last axis.\n\n    Returns\n    -------\n    indices : (N,) ndarray of ints\n        Array of indices that sort the keys along the specified axis.\n\n    See Also\n    --------\n    argsort : Indirect sort.\n    ndarray.sort : In-place sort.\n    sort : Return a sorted copy of an array.\n\n    Examples\n    --------\n    Sort names: first by surname, then by name.\n\n    >>> surnames =    ('Hertz',    'Galilei', 'Hertz')\n    >>> first_names = ('Heinrich', 'Galileo', 'Gustav')\n    >>> ind = np.lexsort((first_names, surnames))\n    >>> ind\n    array([1, 2, 0])\n\n    >>> [surnames[i] + \", \" + first_names[i] for i in ind]\n    ['Galilei, Galileo', 'Hertz, Gustav', 'Hertz, Heinrich']\n\n    Sort two columns of numbers:\n\n    >>> a = [1,5,1,4,3,4,4] # First column\n    >>> b = [9,4,0,4,0,2,1] # Second column\n    >>> ind = np.lexsort((b,a)) # Sort by a, then by b\n    >>> print ind\n    [2 0 4 6 5 3 1]\n\n    >>> [(a[i],b[i]) for i in ind]\n    [(1, 0), (1, 9), (3, 0)"", (4, 1), (4, 2), (4, 4), (5, 4)]\n\n    Note that sorting is first according to the elements of ``a``.\n    Secondary sorting is according to the elements of ``b``.\n\n    A normal ``argsort`` would have yielded:\n\n    >>> [(a[i],b[i]) for i in np.argsort(a)]\n    [(1, 9), (1, 0), (3, 0), (4, 4), (4, 2), (4, 1), (5, 4)]\n\n    Structured arrays are sorted lexically by ``argsort``:\n\n    >>> x = np.array([(1,9), (5,4), (1,0), (4,4), (3,0), (4,2), (4,1)],\n    ...              dtype=np.dtype([('x', int), ('y', int)]))\n\n    >>> np.argsort(x) # or np.argsort(x, order=('x', 'y'))\n    array([2, 0, 4, 6, 5, 3, 1])\n    \n    ";
static char __pyx_k_820[] = "load (line 6975)";
static char __pyx_k_821[] = "Load a pickled, ``.npy``, or ``.npz`` binary file.\n\n    Parameters\n    ----------\n    file : file-like object or string\n        The file to read.  It must support ``seek()`` and ``read()`` methods.\n        If the filename extension is ``.gz``, the file is first decompressed.\n    mmap_mode: {None, 'r+', 'r', 'w+', 'c'}, optional\n        If not None, then memory-map the file, using the given mode\n        (see `numpy.memmap`).  The mode has no effect for pickled or\n        zipped files.\n        A memory-mapped array is stored on disk, and not directly loaded\n        into memory.  However, it can be accessed and sliced like any\n        ndarray.  Memory mapping is especially useful for accessing\n        small fragments of large files without reading the entire file\n        into memory.\n\n    Returns\n    -------\n    result : array, tuple, dict, etc.\n        Data stored in the file.\n\n    Raises\n    ------\n    IOError\n        If the input file does not exist or cannot be read.\n\n    See Also\n    --------\n    save, savez, loadtxt\n    memmap : Create a memory-map to an array stored in a file on disk.\n\n    Notes\n    -----\n    - If the file contains pickle data, then whatever is stored in the\n      pickle is returned.\n    - If the file is a ``.npy`` file, then an array is returned.\n    - If the file is a ``.npz`` file, then a dictionary-like object is\n      returned, containing ``{filename: array}`` key-value pairs, one for\n      each file in the archive.\n\n    Examples\n    --------\n    Store data to disk, and load it again:\n\n    >>> np.save('/tmp/123', np.array([[1, 2, 3], [4, 5, 6]]))\n    >>> np.load('/tmp/123.npy')\n    array([[1, 2, 3],\n           [4, 5, 6]])\n\n    Mem-map the stored array, and then access the second row\n    directly from disk:\n\n    >>> X = np.load('/tmp/123.npy', mmap_mode='r')\n    >>> X[1, :]\n    memmap([4, 5, 6])\n    \n    ";
static char __pyx_k_822[] = "loadtxt (line 7045)";
static char __pyx_k_823[] = "Load data from a text file.\n\n    Each row in the text file must have the same number of values.\n\n    Parameters\n    ----------\n    fname : file or str\n        File, filename, or generator to read.  If the filename extension is\n        ``.gz`` or ``.bz2``, the file is first decompressed. Note that\n        generators should return byte strings for Python 3k.\n    dtype : data-type, optional\n        Data-type of the resulting array; default: float.  If this is a\n        record data-type, the resulting array will be 1-dimensional, and\n        each row will be interpreted as an element of the array.  In this\n        case, the number of columns used must match the number of fields in\n        the data-type.\n    comments : str, optional\n        The character used to indicate the start of a comment;\n        default: '#'.\n    delimiter : str, optional\n        The string used to separate values.  By default, this is any\n        whitespace.\n    converters : dict, optional\n        A dictionary mapping column number to a function that will convert\n        that column to a float.  E.g., if column 0 is a date string:\n        ``converters = {0: datestr2num}``.  Converters can also be used to\n        provide a default value for missing data (but see also `genfromtxt`):\n        ``converters = {3: lambda s: float(s.strip() or 0)}``.  Default: None.\n    skiprows : int, optional\n        Skip the first `skiprows` lines; default: 0.\n    usecols : sequence, optional\n        Which columns to read, with 0 being the first.  For example,\n        ``usecols = (1,4,5)`` will extract the 2nd, 5th and 6th columns.\n        The default, None, results in all columns being read.\n    unpack : bool, optional\n        If True, the returned array is transposed, so that arguments may be\n        unpacked using ``x, y, z = loadtxt(...)``.  When used with a record\n        data-type, arrays are returned for each field.  Default is False.\n    ndmin : int, optional\n        The ""returned array will have at least `ndmin` dimensions.\n        Otherwise mono-dimensional axes will be squeezed. \n        Legal values: 0 (default), 1 or 2.\n        .. versionadded:: 1.6.0\n\n    Returns\n    -------\n    out : ndarray\n        Data read from the text file.\n\n    See Also\n    --------\n    load, fromstring, fromregex\n    genfromtxt : Load data with missing values handled as specified.\n    scipy.io.loadmat : reads MATLAB data files\n\n    Notes\n    -----\n    This function aims to be a fast reader for simply formatted files.  The\n    `genfromtxt` function provides more sophisticated handling of, e.g.,\n    lines with missing values.\n\n    Examples\n    --------\n    >>> from StringIO import StringIO   # StringIO behaves like a file object\n    >>> c = StringIO(\"0 1\n2 3\")\n    >>> np.loadtxt(c)\n    array([[ 0.,  1.],\n           [ 2.,  3.]])\n\n    >>> d = StringIO(\"M 21 72\nF 35 58\")\n    >>> np.loadtxt(d, dtype={'names': ('gender', 'age', 'weight'),\n    ...                      'formats': ('S1', 'i4', 'f4')})\n    array([('M', 21, 72.0), ('F', 35, 58.0)],\n          dtype=[('gender', '|S1'), ('age', '<i4'), ('weight', '<f4')])\n\n    >>> c = StringIO(\"1,0,2\n3,0,4\")\n    >>> x, y = np.loadtxt(c, delimiter=',', usecols=(0, 2), unpack=True)\n    >>> x\n    array([ 1.,  3.])\n    >>> y\n    array([ 2.,  4.])\n    \n    ";
static char __pyx_k_824[] = "lookfor (line 7132)";
static char __pyx_k_825[] = "Do a keyword search on docstrings.\n\n    A list of of objects that matched the search is displayed,\n    sorted by relevance. All given keywords need to be found in the\n    docstring for it to be returned as a result, but the order does\n    not matter.\n\n    Parameters\n    ----------\n    what : str\n        String containing words to look for.\n    module : str or list, optional\n        Name of module(s) whose docstrings to go through.\n    import_modules : bool, optional\n        Whether to import sub-modules in packages. Default is True.\n    regenerate : bool, optional\n        Whether to re-generate the docstring cache. Default is False.\n    output : file-like, optional\n        File-like object to write the output to. If omitted, use a pager.\n\n    See Also\n    --------\n    source, info\n\n    Notes\n    -----\n    Relevance is determined only roughly, by checking if the keywords occur\n    in the function name, at the start of a docstring, etc.\n\n    Examples\n    --------\n    >>> np.lookfor('binary representation')\n    Search results for 'binary representation'\n    ------------------------------------------\n    numpy.binary_repr\n        Return the binary representation of the input number as a string.\n    numpy.core.setup_common.long_double_representation\n        Given a binary dump as given by GNU od -b, look for long double\n    numpy.base_repr\n        Return a string representation of a number in the given base system.\n    ...\n    \n    ";
static char __pyx_k_826[] = "mask_indices (line 7192)";
static char __pyx_k_827[] = "Return the indices to access (n, n) arrays, given a masking function.\n\n    Assume `mask_func` is a function that, for a square array a of size\n    ``(n, n)`` with a possible offset argument `k`, when called as\n    ``mask_func(a, k)`` returns a new array with zeros in certain locations\n    (functions like `triu` or `tril` do precisely this). Then this function\n    returns the indices where the non-zero values would be located.\n\n    Parameters\n    ----------\n    n : int\n        The returned indices will be valid to access arrays of shape (n, n).\n    mask_func : callable\n        A function whose call signature is similar to that of `triu`, `tril`.\n        That is, ``mask_func(x, k)`` returns a boolean array, shaped like `x`.\n        `k` is an optional argument to the function.\n    k : scalar\n        An optional argument which is passed through to `mask_func`. Functions\n        like `triu`, `tril` take a second argument that is interpreted as an\n        offset.\n\n    Returns\n    -------\n    indices : tuple of arrays.\n        The `n` arrays of indices corresponding to the locations where\n        ``mask_func(np.ones((n, n)), k)`` is True.\n\n    See Also\n    --------\n    triu, tril, triu_indices, tril_indices\n\n    Notes\n    -----\n    .. versionadded:: 1.4.0\n\n    Examples\n    --------\n    These are the indices that would allow you to access the upper triangular\n    part of any 3x3 array:\n\n    >>> iu = np.mask_indices(3, np.triu)\n\n    For example, if `a` is a 3x3 array:\n\n    >>> a = np.arange(9).reshape(3, 3)\n    >>> a\n    array([[0, 1, 2],\n           [3, 4, 5],\n           [6, 7, 8]])\n    >>> a[iu]\n    array([0, 1, 2, 4, 5, 8])\n\n    An offset can be passed also to the masking function.  This gets us the\n    indices starting on the first diagonal right of the main one:\n\n    >>> iu1 = np.mask_indices(3, np.triu, 1)\n\n    with which we now extract only three elements:\n\n    >>> a[iu1]\n    array([1, 2, 5])\n    \n    ";
static char __pyx_k_828[] = "mat (line 7259)";
static char __pyx_k_829[] = "max (line 7291)";
static char __pyx_k_830[] = "maximum_sctype (line 7348)";
static char __pyx_k_831[] = "Return the scalar type of highest precision of the same kind as the input.\n\n    Parameters\n    ----------\n    t : dtype or dtype specifier\n        The input data type. This can be a `dtype` object or an object that\n        is convertible to a `dtype`.\n\n    Returns\n    -------\n    out : dtype\n        The highest precision data type of the same kind (`dtype.kind`) as `t`.\n\n    See Also\n    --------\n    obj2sctype, mintypecode, sctype2char\n    dtype\n\n    Examples\n    --------\n    >>> np.maximum_sctype(np.int)\n    <type 'numpy.int64'>\n    >>> np.maximum_sctype(np.uint8)\n    <type 'numpy.uint64'>\n    >>> np.maximum_sctype(np.complex)\n    <type 'numpy.complex192'>\n\n    >>> np.maximum_sctype(str)\n    <type 'numpy.string_'>\n\n    >>> np.maximum_sctype('i2')\n    <type 'numpy.int64'>\n    >>> np.maximum_sctype('f4')\n    <type 'numpy.float96'>\n    \n    ";
static char __pyx_k_832[] = "may_share_memory (line 7388)";
static char __pyx_k_833[] = "Determine if two arrays can share memory\n\n    The memory-bounds of a and b are computed.  If they overlap then\n    this function returns True.  Otherwise, it returns False.\n\n    A return of True does not necessarily mean that the two arrays\n    share any element.  It just means that they *might*.\n\n    Parameters\n    ----------\n    a, b : ndarray\n\n    Returns\n    -------\n    out : bool\n\n    Examples\n    --------\n    >>> np.may_share_memory(np.array([1,2]), np.array([5,8,9]))\n    False\n    \n    ";
static char __pyx_k_834[] = "mean (line 7414)";
static char __pyx_k_835[] = "Compute the arithmetic mean along the specified axis.\n\n    Returns the average of the array elements.  The average is taken over\n    the flattened array by default, otherwise over the specified axis.\n    `float64` intermediate and return values are used for integer inputs.\n\n    Parameters\n    ----------\n    a : array_like\n        Array containing numbers whose mean is desired. If `a` is not an\n        array, a conversion is attempted.\n    axis : int, optional\n        Axis along which the means are computed. The default is to compute\n        the mean of the flattened array.\n    dtype : data-type, optional\n        Type to use in computing the mean.  For integer inputs, the default\n        is `float64`; for floating point inputs, it is the same as the\n        input dtype.\n    out : ndarray, optional\n        Alternate output array in which to place the result.  The default\n        is ``None``; if provided, it must have the same shape as the\n        expected output, but the type will be cast if necessary.\n        See `doc.ufuncs` for details.\n\n    Returns\n    -------\n    m : ndarray, see dtype parameter above\n        If `out=None`, returns a new array containing the mean values,\n        otherwise a reference to the output array is returned.\n\n    See Also\n    --------\n    average : Weighted average\n\n    Notes\n    -----\n    The arithmetic mean is the sum of the elements along the axis divided\n    by the number of elements.\n\n    Note that for floating-point input, the mean is computed using the\n    same precision the input has.  Depending on the input data, this can\n    cause the results to be inaccurate, especially for `float32` (see\n    example below).  Specifying a higher-precision accumulator using the\n    `dtype` keyword can alleviate this issue.\n\n    Examples\n    --------\n    >>> a = np.array([[1, 2], [3, 4]])\n    >>> np.mean(a)\n    2.5\n    >>> np.mean(a, axis=0)\n    array([ 2.,  3.])\n    >>> np.mean(a, axis=1)\n    ""array([ 1.5,  3.5])\n\n    In single precision, `mean` can be inaccurate:\n\n    >>> a = np.zeros((2, 512*512), dtype=np.float32)\n    >>> a[0, :] = 1.0\n    >>> a[1, :] = 0.1\n    >>> np.mean(a)\n    0.546875\n\n    Computing the mean in float64 is more accurate:\n\n    >>> np.mean(a, dtype=np.float64)\n    0.55000000074505806\n    \n    ";
static char __pyx_k_836[] = "median (line 7487)";
static char __pyx_k_837[] = "Compute the median along the specified axis.\n\n    Returns the median of the array elements.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array or object that can be converted to an array.\n    axis : {None, int}, optional\n        Axis along which the medians are computed. The default (axis=None)\n        is to compute the median along a flattened version of the array.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must\n        have the same shape and buffer length as the expected output,\n        but the type (of the output) will be cast if necessary.\n    overwrite_input : {False, True}, optional\n       If True, then allow use of memory of input array (a) for\n       calculations. The input array will be modified by the call to\n       median. This will save memory when you do not need to preserve\n       the contents of the input array. Treat the input as undefined,\n       but it will probably be fully or partially sorted. Default is\n       False. Note that, if `overwrite_input` is True and the input\n       is not already an ndarray, an error will be raised.\n\n    Returns\n    -------\n    median : ndarray\n        A new array holding the result (unless `out` is specified, in\n        which case that array is returned instead).  If the input contains\n        integers, or floats of smaller precision than 64, then the output\n        data-type is float64.  Otherwise, the output data-type is the same\n        as that of the input.\n\n    See Also\n    --------\n    mean, percentile\n\n    Notes\n    -----\n    Given a vector V of length N, the median of V is the middle value of\n    a sorted copy of V, ``V_sorted`` - i.e., ``V_sorted[(N-1)/2]``, when N is\n    odd.  When N is even, it is the average of the two middle values of\n    ``V_sorted``.\n\n    Examples\n    --------\n    >>> a = np.array([[10, 7, 4], [3, 2, 1]])\n    >>> a\n    array([[10,  7,  4],\n           [ 3,  2,  1]])""\n    >>> np.median(a)\n    3.5\n    >>> np.median(a, axis=0)\n    array([ 6.5,  4.5,  2.5])\n    >>> np.median(a, axis=1)\n    array([ 7.,  2.])\n    >>> m = np.median(a, axis=0)\n    >>> out = np.zeros_like(m)\n    >>> np.median(a, axis=0, out=m)\n    array([ 6.5,  4.5,  2.5])\n    >>> m\n    array([ 6.5,  4.5,  2.5])\n    >>> b = a.copy()\n    >>> np.median(b, axis=1, overwrite_input=True)\n    array([ 7.,  2.])\n    >>> assert not np.all(a==b)\n    >>> b = a.copy()\n    >>> np.median(b, axis=None, overwrite_input=True)\n    3.5\n    >>> assert not np.all(a==b)\n    \n    ";
static char __pyx_k_838[] = "meshgrid (line 7563)";
static char __pyx_k_839[] = "Return coordinate matrices from two coordinate vectors.\n\n    Parameters\n    ----------\n    x, y : ndarray\n        Two 1-D arrays representing the x and y coordinates of a grid.\n\n    Returns\n    -------\n    X, Y : ndarray\n        For vectors `x`, `y` with lengths ``Nx=len(x)`` and ``Ny=len(y)``,\n        return `X`, `Y` where `X` and `Y` are ``(Ny, Nx)`` shaped arrays\n        with the elements of `x` and y repeated to fill the matrix along\n        the first dimension for `x`, the second for `y`.\n\n    See Also\n    --------\n    index_tricks.mgrid : Construct a multi-dimensional \"meshgrid\"\n                         using indexing notation.\n    index_tricks.ogrid : Construct an open multi-dimensional \"meshgrid\"\n                         using indexing notation.\n\n    Examples\n    --------\n    >>> X, Y = np.meshgrid([1,2,3], [4,5,6,7])\n    >>> X\n    array([[1, 2, 3],\n           [1, 2, 3],\n           [1, 2, 3],\n           [1, 2, 3]])\n    >>> Y\n    array([[4, 4, 4],\n           [5, 5, 5],\n           [6, 6, 6],\n           [7, 7, 7]])\n\n    `meshgrid` is very useful to evaluate functions on a grid.\n\n    >>> x = np.arange(-5, 5, 0.1)\n    >>> y = np.arange(-5, 5, 0.1)\n    >>> xx, yy = np.meshgrid(x, y)\n    >>> z = np.sin(xx**2+yy**2)/(xx**2+yy**2)\n    \n    ";
static char __pyx_k_840[] = "min (line 7611)";
static char __pyx_k_841[] = "min_scalar_type (line 7668)";
static char __pyx_k_842[] = "min_scalar_type(a)\n\n    For scalar ``a``, returns the data type with the smallest size\n    and smallest scalar kind which can hold its value.  For non-scalar\n    array ``a``, returns the vector's dtype unmodified.\n\n    Floating point values are not demoted to integers,\n    and complex values are not demoted to floats.\n\n    Parameters\n    ----------\n    a : scalar or array_like\n        The value whose minimal data type is to be found.\n\n    Returns\n    -------\n    out : dtype\n        The minimal data type.\n\n    Notes\n    -----\n    .. versionadded:: 1.6.0\n\n    See Also\n    --------\n    result_type, promote_types, dtype, can_cast\n\n    Examples\n    --------\n    >>> np.min_scalar_type(10)\n    dtype('uint8')\n\n    >>> np.min_scalar_type(-260)\n    dtype('int16')\n\n    >>> np.min_scalar_type(3.1)\n    dtype('float16')\n\n    >>> np.min_scalar_type(1e50)\n    dtype('float64')\n\n    >>> np.min_scalar_type(np.arange(4,dtype='f8'))\n    dtype('float64')\n    \n    ";
static char __pyx_k_843[] = "mintypecode (line 7718)";
static char __pyx_k_844[] = "Return the character for the minimum-size type to which given types can\n    be safely cast.\n\n    The returned type character must represent the smallest size dtype such\n    that an array of the returned type can handle the data from an array of\n    all types in `typechars` (or if `typechars` is an array, then its\n    dtype.char).\n\n    Parameters\n    ----------\n    typechars : list of str or array_like\n        If a list of strings, each string should represent a dtype.\n        If array_like, the character representation of the array dtype is used.\n    typeset : str or list of str, optional\n        The set of characters that the returned character is chosen from.\n        The default set is 'GDFgdf'.\n    default : str, optional\n        The default character, this is returned if none of the characters in\n        `typechars` matches a character in `typeset`.\n\n    Returns\n    -------\n    typechar : str\n        The character representing the minimum-size type that was found.\n\n    See Also\n    --------\n    dtype, sctype2char, maximum_sctype\n\n    Examples\n    --------\n    >>> np.mintypecode(['d', 'f', 'S'])\n    'd'\n    >>> x = np.array([1.1, 2-3.j])\n    >>> np.mintypecode(x)\n    'D'\n\n    >>> np.mintypecode('abceh', default='G')\n    'G'\n    \n    ";
static char __pyx_k_845[] = "nan_to_num (line 7810)";
static char __pyx_k_846[] = "Replace nan with zero and inf with finite numbers.\n\n    Returns an array or scalar replacing Not a Number (NaN) with zero,\n    (positive) infinity with a very large number and negative infinity\n    with a very small (or negative) number.\n\n    Parameters\n    ----------\n    x : array_like\n        Input data.\n\n    Returns\n    -------\n    out : ndarray, float\n        Array with the same shape as `x` and dtype of the element in `x`  with\n        the greatest precision. NaN is replaced by zero, and infinity\n        (-infinity) is replaced by the largest (smallest or most negative)\n        floating point value that fits in the output dtype. All finite numbers\n        are upcast to the output dtype (default float64).\n\n    See Also\n    --------\n    isinf : Shows which elements are negative or negative infinity.\n    isneginf : Shows which elements are negative infinity.\n    isposinf : Shows which elements are positive infinity.\n    isnan : Shows which elements are Not a Number (NaN).\n    isfinite : Shows which elements are finite (not NaN, not infinity)\n\n    Notes\n    -----\n    Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n    (IEEE 754). This means that Not a Number is not equivalent to infinity.\n\n\n    Examples\n    --------\n    >>> np.set_printoptions(precision=8)\n    >>> x = np.array([np.inf, -np.inf, np.nan, -128, 128])\n    >>> np.nan_to_num(x)\n    array([  1.79769313e+308,  -1.79769313e+308,   0.00000000e+000,\n            -1.28000000e+002,   1.28000000e+002])\n    \n    ";
static char __pyx_k_847[] = "nanargmax (line 7857)";
static char __pyx_k_848[] = "Return indices of the maximum values over an axis, ignoring NaNs.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    axis : int, optional\n        Axis along which to operate.  By default flattened input is used.\n\n    Returns\n    -------\n    index_array : ndarray\n        An array of indices or a single index value.\n\n    See Also\n    --------\n    argmax, nanargmin\n\n    Examples\n    --------\n    >>> a = np.array([[np.nan, 4], [2, 3]])\n    >>> np.argmax(a)\n    0\n    >>> np.nanargmax(a)\n    1\n    >>> np.nanargmax(a, axis=0)\n    array([1, 0])\n    >>> np.nanargmax(a, axis=1)\n    array([1, 1])\n    \n    ";
static char __pyx_k_849[] = "nanargmin (line 7892)";
static char __pyx_k_850[] = "Return indices of the minimum values over an axis, ignoring NaNs.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    axis : int, optional\n        Axis along which to operate.  By default flattened input is used.\n\n    Returns\n    -------\n    index_array : ndarray\n        An array of indices or a single index value.\n\n    See Also\n    --------\n    argmin, nanargmax\n\n    Examples\n    --------\n    >>> a = np.array([[np.nan, 4], [2, 3]])\n    >>> np.argmin(a)\n    0\n    >>> np.nanargmin(a)\n    2\n    >>> np.nanargmin(a, axis=0)\n    array([1, 1])\n    >>> np.nanargmin(a, axis=1)\n    array([1, 0])\n    \n    ";
static char __pyx_k_851[] = "nanmax (line 7927)";
static char __pyx_k_852[] = "Return the maximum of an array or maximum along an axis ignoring any NaNs.\n\n    Parameters\n    ----------\n    a : array_like\n        Array containing numbers whose maximum is desired. If `a` is not\n        an array, a conversion is attempted.\n    axis : int, optional\n        Axis along which the maximum is computed. The default is to compute\n        the maximum of the flattened array.\n\n    Returns\n    -------\n    nanmax : ndarray\n        An array with the same shape as `a`, with the specified axis removed.\n        If `a` is a 0-d array, or if axis is None, a ndarray scalar is\n        returned.  The the same dtype as `a` is returned.\n\n    See Also\n    --------\n    numpy.amax : Maximum across array including any Not a Numbers.\n    numpy.nanmin : Minimum across array ignoring any Not a Numbers.\n    isnan : Shows which elements are Not a Number (NaN).\n    isfinite: Shows which elements are not: Not a Number, positive and\n             negative infinity\n\n    Notes\n    -----\n    Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n    (IEEE 754). This means that Not a Number is not equivalent to infinity.\n    Positive infinity is treated as a very large number and negative infinity\n    is treated as a very small (i.e. negative) number.\n\n    If the input has a integer type the function is equivalent to np.max.\n\n    Examples\n    --------\n    >>> a = np.array([[1, 2], [3, np.nan]])\n    >>> np.nanmax(a)\n    3.0\n    >>> np.nanmax(a, axis=0)\n    array([ 3.,  2.])\n    >>> np.nanmax(a, axis=1)\n    array([ 2.,  3.])\n\n    When positive infinity and negative infinity are present:\n\n    >>> np.nanmax([1, 2, np.nan, np.NINF])\n    2.0\n    >>> np.nanmax([1, 2, np.nan, np.inf])\n    inf\n    \n    ";
static char __pyx_k_853[] = "nanmin (line 7984)";
static char __pyx_k_854[] = "Return the minimum of an array or minimum along an axis ignoring any NaNs.\n\n    Parameters\n    ----------\n    a : array_like\n        Array containing numbers whose minimum is desired.\n    axis : int, optional\n        Axis along which the minimum is computed.The default is to compute\n        the minimum of the flattened array.\n\n    Returns\n    -------\n    nanmin : ndarray\n        A new array or a scalar array with the result.\n\n    See Also\n    --------\n    numpy.amin : Minimum across array including any Not a Numbers.\n    numpy.nanmax : Maximum across array ignoring any Not a Numbers.\n    isnan : Shows which elements are Not a Number (NaN).\n    isfinite: Shows which elements are not: Not a Number, positive and\n             negative infinity\n\n    Notes\n    -----\n    Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n    (IEEE 754). This means that Not a Number is not equivalent to infinity.\n    Positive infinity is treated as a very large number and negative infinity\n    is treated as a very small (i.e. negative) number.\n\n    If the input has a integer type the function is equivalent to np.min.\n\n\n    Examples\n    --------\n    >>> a = np.array([[1, 2], [3, np.nan]])\n    >>> np.nanmin(a)\n    1.0\n    >>> np.nanmin(a, axis=0)\n    array([ 1.,  2.])\n    >>> np.nanmin(a, axis=1)\n    array([ 1.,  3.])\n\n    When positive infinity and negative infinity are present:\n\n    >>> np.nanmin([1, 2, np.nan, np.inf])\n    1.0\n    >>> np.nanmin([1, 2, np.nan, np.NINF])\n    -inf\n    \n    ";
static char __pyx_k_855[] = "nansum (line 8039)";
static char __pyx_k_856[] = "Return the sum of array elements over a given axis treating\n    Not a Numbers (NaNs) as zero.\n\n    Parameters\n    ----------\n    a : array_like\n        Array containing numbers whose sum is desired. If `a` is not an\n        array, a conversion is attempted.\n    axis : int, optional\n        Axis along which the sum is computed. The default is to compute\n        the sum of the flattened array.\n\n    Returns\n    -------\n    y : ndarray\n        An array with the same shape as a, with the specified axis removed.\n        If a is a 0-d array, or if axis is None, a scalar is returned with\n        the same dtype as `a`.\n\n    See Also\n    --------\n    numpy.sum : Sum across array including Not a Numbers.\n    isnan : Shows which elements are Not a Number (NaN).\n    isfinite: Shows which elements are not: Not a Number, positive and\n             negative infinity\n\n    Notes\n    -----\n    Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n    (IEEE 754). This means that Not a Number is not equivalent to infinity.\n    If positive or negative infinity are present the result is positive or\n    negative infinity. But if both positive and negative infinity are present,\n    the result is Not A Number (NaN).\n\n    Arithmetic is modular when using integer types (all elements of `a` must\n    be finite i.e. no elements that are NaNs, positive infinity and negative\n    infinity because NaNs are floating point types), and no error is raised\n    on overflow.\n\n\n    Examples\n    --------\n    >>> np.nansum(1)\n    1\n    >>> np.nansum([1])\n    1\n    >>> np.nansum([1, np.nan])\n    1.0\n    >>> a = np.array([[1, 1], [1, np.nan]])\n    >>> np.nansum(a)\n    3.0\n    >>> np.nansum(a, axis=0)\n    array([ 2.,  1.])\n\n    When positive infinity and negative infinity are present\n\n    >>> np.nansum([1, np.nan, np.inf])\n    inf\n    >>> np.nansum([1, np.nan, np.NINF])\n    -inf\n    >>> np.nansum([1, np.nan, np.inf, np.NINF])\n    nan\n   "" \n    ";
static char __pyx_k_857[] = "ndim (line 8121)";
static char __pyx_k_858[] = "Return the number of dimensions of an array.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.  If it is not already an ndarray, a conversion is\n        attempted.\n\n    Returns\n    -------\n    number_of_dimensions : int\n        The number of dimensions in `a`.  Scalars are zero-dimensional.\n\n    See Also\n    --------\n    ndarray.ndim : equivalent method\n    shape : dimensions of array\n    ndarray.shape : dimensions of array\n\n    Examples\n    --------\n    >>> np.ndim([[1,2,3],[4,5,6]])\n    2\n    >>> np.ndim(np.array([[1,2,3],[4,5,6]]))\n    2\n    >>> np.ndim(1)\n    0\n    \n    ";
static char __pyx_k_859[] = "nonzero (line 8172)";
static char __pyx_k_860[] = "Return the indices of the elements that are non-zero.\n\n    Returns a tuple of arrays, one for each dimension of `a`, containing\n    the indices of the non-zero elements in that dimension. The\n    corresponding non-zero values can be obtained with::\n\n        a[nonzero(a)]\n\n    To group the indices by element, rather than dimension, use::\n\n        transpose(nonzero(a))\n\n    The result of this is always a 2-D array, with a row for\n    each non-zero element.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n\n    Returns\n    -------\n    tuple_of_arrays : tuple\n        Indices of elements that are non-zero.\n\n    See Also\n    --------\n    flatnonzero :\n        Return indices that are non-zero in the flattened version of the input\n        array.\n    ndarray.nonzero :\n        Equivalent ndarray method.\n    count_nonzero :\n        Counts the number of non-zero elements in the input array.\n\n    Examples\n    --------\n    >>> x = np.eye(3)\n    >>> x\n    array([[ 1.,  0.,  0.],\n           [ 0.,  1.,  0.],\n           [ 0.,  0.,  1.]])\n    >>> np.nonzero(x)\n    (array([0, 1, 2]), array([0, 1, 2]))\n\n    >>> x[np.nonzero(x)]\n    array([ 1.,  1.,  1.])\n    >>> np.transpose(np.nonzero(x))\n    array([[0, 0],\n           [1, 1],\n           [2, 2]])\n\n    A common use for ``nonzero`` is to find the indices of an array, where\n    a condition is True.  Given an array `a`, the condition `a` > 3 is a\n    boolean array and since False is interpreted as 0, np.nonzero(a > 3)\n    yields the indices of the `a` where the condition is true.\n\n    >>> a = np.array([[1,2,3],[4,5,6],[7,8,9]])\n    >>> a > 3\n    array([[False, False, False],\n           [ True,  True,  True],\n           [ True,  True,  True]], dtype=bool)\n    >>> np.nonzero(a > 3)\n    (array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))\n\n    The ``nonzero`` method of the boolean array can also be called.\n\n    >>> (a > 3).nonzero()\n    (array([1, 1, 1, ""2, 2, 2]), array([0, 1, 2, 0, 1, 2]))\n    \n    ";
static char __pyx_k_861[] = "nper (line 8247)";
static char __pyx_k_862[] = "Compute the number of periodic payments.\n\n    Parameters\n    ----------\n    rate : array_like\n        Rate of interest (per period)\n    pmt : array_like\n        Payment\n    pv : array_like\n        Present value\n    fv : array_like, optional\n        Future value\n    when : {{'begin', 1}, {'end', 0}}, {string, int}, optional\n        When payments are due ('begin' (1) or 'end' (0))\n\n    Notes\n    -----\n    The number of periods ``nper`` is computed by solving the equation::\n\n     fv + pv*(1+rate)**nper + pmt*(1+rate*when)/rate*((1+rate)**nper-1) = 0\n\n    but if ``rate = 0`` then::\n\n     fv + pv + pmt*nper = 0\n\n    Examples\n    --------\n    If you only had $150/month to pay towards the loan, how long would it take\n    to pay-off a loan of $8,000 at 7% annual interest?\n\n    >>> np.nper(0.07/12, -150, 8000)\n    64.073348770661852\n\n    So, over 64 months would be required to pay off the loan.\n\n    The same analysis could be done with several different interest rates\n    and/or payments and/or total amounts to produce an entire table.\n\n    >>> np.nper(*(np.ogrid[0.07/12: 0.08/12: 0.01/12,\n    ...                    -150   : -99     : 50    ,\n    ...                    8000   : 9001    : 1000]))\n    array([[[  64.07334877,   74.06368256],\n            [ 108.07548412,  127.99022654]],\n           [[  66.12443902,   76.87897353],\n            [ 114.70165583,  137.90124779]]])\n    \n    ";
static char __pyx_k_863[] = "npv (line 8298)";
static char __pyx_k_864[] = "Returns the NPV (Net Present Value) of a cash flow series.\n\n    Parameters\n    ----------\n    rate : scalar\n        The discount rate.\n    values : array_like, shape(M, )\n        The values of the time series of cash flows.  The (fixed) time\n        interval between cash flow \"events\" must be the same as that\n        for which `rate` is given (i.e., if `rate` is per year, then\n        precisely a year is understood to elapse between each cash flow\n        event).  By convention, investments or \"deposits\" are negative,\n        income or \"withdrawals\" are positive; `values` must begin with\n        the initial investment, thus `values[0]` will typically be\n        negative.\n\n    Returns\n    -------\n    out : float\n        The NPV of the input cash flow series `values` at the discount `rate`.\n\n    Notes\n    -----\n    Returns the result of: [G]_\n\n    .. math :: \\sum_{t=0}^M{\014rac{values_t}{(1+rate)^{t}}}\n\n    References\n    ----------\n    .. [G] L. J. Gitman, \"Principles of Managerial Finance, Brief,\" 3rd ed.,\n       Addison-Wesley, 2003, pg. 346.\n\n    Examples\n    --------\n    >>> np.npv(0.281,[-100, 39, 59, 55, 20])\n    -0.0066187288356340801\n\n    (Compare with the Example given for numpy.lib.financial.irr)\n    \n    ";
static char __pyx_k_865[] = "obj2sctype (line 8342)";
static char __pyx_k_866[] = "Return the scalar dtype or NumPy equivalent of Python type of an object.\n\n    Parameters\n    ----------\n    rep : any\n        The object of which the type is returned.\n    default : any, optional\n        If given, this is returned for objects whose types can not be\n        determined. If not given, None is returned for those objects.\n\n    Returns\n    -------\n    dtype : dtype or Python type\n        The data type of `rep`.\n\n    See Also\n    --------\n    sctype2char, issctype, issubsctype, issubdtype, maximum_sctype\n\n    Examples\n    --------\n    >>> np.obj2sctype(np.int32)\n    <type 'numpy.int32'>\n    >>> np.obj2sctype(np.array([1., 2.]))\n    <type 'numpy.float64'>\n    >>> np.obj2sctype(np.array([1.j]))\n    <type 'numpy.complex128'>\n\n    >>> np.obj2sctype(dict)\n    <type 'numpy.object_'>\n    >>> np.obj2sctype('string')\n    <type 'numpy.string_'>\n\n    >>> np.obj2sctype(1, default=list)\n    <type 'list'>\n    \n    ";
static char __pyx_k_867[] = "outer (line 8383)";
static char __pyx_k_868[] = "Compute the outer product of two vectors.\n\n    Given two vectors, ``a = [a0, a1, ..., aM]`` and\n    ``b = [b0, b1, ..., bN]``,\n    the outer product [1]_ is::\n\n      [[a0*b0  a0*b1 ... a0*bN ]\n       [a1*b0    .\n       [ ...          .\n       [aM*b0            aM*bN ]]\n\n    Parameters\n    ----------\n    a, b : array_like, shape (M,), (N,)\n        First and second input vectors.  Inputs are flattened if they\n        are not already 1-dimensional.\n\n    Returns\n    -------\n    out : ndarray, shape (M, N)\n        ``out[i, j] = a[i] * b[j]``\n\n    See also\n    --------\n    inner, einsum\n\n    References\n    ----------\n    .. [1] : G. H. Golub and C. F. van Loan, *Matrix Computations*, 3rd\n             ed., Baltimore, MD, Johns Hopkins University Press, 1996,\n             pg. 8.\n\n    Examples\n    --------\n    Make a (*very* coarse) grid for computing a Mandelbrot set:\n\n    >>> rl = np.outer(np.ones((5,)), np.linspace(-2, 2, 5))\n    >>> rl\n    array([[-2., -1.,  0.,  1.,  2.],\n           [-2., -1.,  0.,  1.,  2.],\n           [-2., -1.,  0.,  1.,  2.],\n           [-2., -1.,  0.,  1.,  2.],\n           [-2., -1.,  0.,  1.,  2.]])\n    >>> im = np.outer(1j*np.linspace(2, -2, 5), np.ones((5,)))\n    >>> im\n    array([[ 0.+2.j,  0.+2.j,  0.+2.j,  0.+2.j,  0.+2.j],\n           [ 0.+1.j,  0.+1.j,  0.+1.j,  0.+1.j,  0.+1.j],\n           [ 0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j],\n           [ 0.-1.j,  0.-1.j,  0.-1.j,  0.-1.j,  0.-1.j],\n           [ 0.-2.j,  0.-2.j,  0.-2.j,  0.-2.j,  0.-2.j]])\n    >>> grid = rl + im\n    >>> grid\n    array([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],\n           [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],\n           [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],\n           [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],\n           [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])\n\n    An example using a \"vector\" of letters:\n\n    >>> x = np.array(['a', 'b', 'c'], dtype=object)\n    >>> np.""outer(x, [1, 2, 3])\n    array([[a, aa, aaa],\n           [b, bb, bbb],\n           [c, cc, ccc]], dtype=object)\n    \n    ";
static char __pyx_k_869[] = "packbits (line 8454)";
static char __pyx_k_870[] = "packbits(myarray, axis=None)\n\n    Packs the elements of a binary-valued array into bits in a uint8 array.\n\n    The result is padded to full bytes by inserting zero bits at the end.\n\n    Parameters\n    ----------\n    myarray : array_like\n        An integer type array whose elements should be packed to bits.\n    axis : int, optional\n        The dimension over which bit-packing is done.\n        ``None`` implies packing the flattened array.\n\n    Returns\n    -------\n    packed : ndarray\n        Array of type uint8 whose elements represent bits corresponding to the\n        logical (0 or nonzero) value of the input elements. The shape of\n        `packed` has the same number of dimensions as the input (unless `axis`\n        is None, in which case the output is 1-D).\n\n    See Also\n    --------\n    unpackbits: Unpacks elements of a uint8 array into a binary-valued output\n                array.\n\n    Examples\n    --------\n    >>> a = np.array([[[1,0,1],\n    ...                [0,1,0]],\n    ...               [[1,1,0],\n    ...                [0,0,1]]])\n    >>> b = np.packbits(a, axis=-1)\n    >>> b\n    array([[[160],[64]],[[192],[32]]], dtype=uint8)\n\n    Note that in binary 160 = 1010 0000, 64 = 0100 0000, 192 = 1100 0000,\n    and 32 = 0010 0000.\n    \n    ";
static char __pyx_k_871[] = "percentile (line 8500)";
static char __pyx_k_872[] = "Compute the qth percentile of the data along the specified axis.\n\n    Returns the qth percentile of the array elements.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array or object that can be converted to an array.\n    q : float in range of [0,100] (or sequence of floats)\n        Percentile to compute which must be between 0 and 100 inclusive.\n    axis : int, optional\n        Axis along which the percentiles are computed. The default (None)\n        is to compute the median along a flattened version of the array.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must\n        have the same shape and buffer length as the expected output,\n        but the type (of the output) will be cast if necessary.\n    overwrite_input : bool, optional\n       If True, then allow use of memory of input array `a` for\n       calculations. The input array will be modified by the call to\n       median. This will save memory when you do not need to preserve\n       the contents of the input array. Treat the input as undefined,\n       but it will probably be fully or partially sorted.\n       Default is False. Note that, if `overwrite_input` is True and the\n       input is not already an array, an error will be raised.\n\n    Returns\n    -------\n    pcntile : ndarray\n        A new array holding the result (unless `out` is specified, in\n        which case that array is returned instead).  If the input contains\n        integers, or floats of smaller precision than 64, then the output\n        data-type is float64.  Otherwise, the output data-type is the same\n        as that of the input.\n\n    See Also\n    --------\n    mean, median\n\n    Notes\n    -----\n    Given a vector V of length N, the qth percentile of V is the qth ranked\n    value in a sorted copy of V.  A weighted average of the two nearest\n    neighbors is used if the normalized ranking does not match q exactly.\n    The same as the med""ian if ``q=0.5``, the same as the minimum if ``q=0``\n    and the same as the maximum if ``q=1``.\n\n    Examples\n    --------\n    >>> a = np.array([[10, 7, 4], [3, 2, 1]])\n    >>> a\n    array([[10,  7,  4],\n           [ 3,  2,  1]])\n    >>> np.percentile(a, 50)\n    3.5\n    >>> np.percentile(a, 0.5, axis=0)\n    array([ 6.5,  4.5,  2.5])\n    >>> np.percentile(a, 50, axis=1)\n    array([ 7.,  2.])\n\n    >>> m = np.percentile(a, 50, axis=0)\n    >>> out = np.zeros_like(m)\n    >>> np.percentile(a, 50, axis=0, out=m)\n    array([ 6.5,  4.5,  2.5])\n    >>> m\n    array([ 6.5,  4.5,  2.5])\n\n    >>> b = a.copy()\n    >>> np.percentile(b, 50, axis=1, overwrite_input=True)\n    array([ 7.,  2.])\n    >>> assert not np.all(a==b)\n    >>> b = a.copy()\n    >>> np.percentile(b, 50, axis=None, overwrite_input=True)\n    3.5\n    \n    ";
static char __pyx_k_873[] = "piecewise (line 8580)";
static char __pyx_k_874[] = "Evaluate a piecewise-defined function.\n\n    Given a set of conditions and corresponding functions, evaluate each\n    function on the input data wherever its condition is true.\n\n    Parameters\n    ----------\n    x : ndarray\n        The input domain.\n    condlist : list of bool arrays\n        Each boolean array corresponds to a function in `funclist`.  Wherever\n        `condlist[i]` is True, `funclist[i](x)` is used as the output value.\n\n        Each boolean array in `condlist` selects a piece of `x`,\n        and should therefore be of the same shape as `x`.\n\n        The length of `condlist` must correspond to that of `funclist`.\n        If one extra function is given, i.e. if\n        ``len(funclist) - len(condlist) == 1``, then that extra function\n        is the default value, used wherever all conditions are false.\n    funclist : list of callables, f(x,*args,**kw), or scalars\n        Each function is evaluated over `x` wherever its corresponding\n        condition is True.  It should take an array as input and give an array\n        or a scalar value as output.  If, instead of a callable,\n        a scalar is provided then a constant function (``lambda x: scalar``) is\n        assumed.\n    args : tuple, optional\n        Any further arguments given to `piecewise` are passed to the functions\n        upon execution, i.e., if called ``piecewise(..., ..., 1, 'a')``, then\n        each function is called as ``f(x, 1, 'a')``.\n    kw : dict, optional\n        Keyword arguments used in calling `piecewise` are passed to the\n        functions upon execution, i.e., if called\n        ``piecewise(..., ..., lambda=1)``, then each function is called as\n        ``f(x, lambda=1)``.\n\n    Returns\n    -------\n    out : ndarray\n        The output is the same shape and type as x and is found by\n        calling the functions in `funclist` on the appropriate portions of `x`,\n        as defined by the boolean arrays in `condlist`.  Portions not covered\n   ""     by any condition have undefined values.\n\n\n    See Also\n    --------\n    choose, select, where\n\n    Notes\n    -----\n    This is similar to choose or select, except that functions are\n    evaluated on elements of `x` that satisfy the corresponding condition from\n    `condlist`.\n\n    The result is::\n\n            |--\n            |funclist[0](x[condlist[0]])\n      out = |funclist[1](x[condlist[1]])\n            |...\n            |funclist[n2](x[condlist[n2]])\n            |--\n\n    Examples\n    --------\n    Define the sigma function, which is -1 for ``x < 0`` and +1 for ``x >= 0``.\n\n    >>> x = np.arange(6) - 2.5\n    >>> np.piecewise(x, [x < 0, x >= 0], [-1, 1])\n    array([-1., -1., -1.,  1.,  1.,  1.])\n\n    Define the absolute value, which is ``-x`` for ``x <0`` and ``x`` for\n    ``x >= 0``.\n\n    >>> np.piecewise(x, [x < 0, x >= 0], [lambda x: -x, lambda x: x])\n    array([ 2.5,  1.5,  0.5,  0.5,  1.5,  2.5])\n    \n    ";
static char __pyx_k_875[] = "place (line 8702)";
static char __pyx_k_876[] = "Change elements of an array based on conditional and input values.\n\n    Similar to ``np.putmask(arr, mask, vals)``, the difference is that `place`\n    uses the first N elements of `vals`, where N is the number of True values\n    in `mask`, while `putmask` uses the elements where `mask` is True.\n\n    Note that `extract` does the exact opposite of `place`.\n\n    Parameters\n    ----------\n    arr : array_like\n        Array to put data into.\n    mask : array_like\n        Boolean mask array. Must have the same size as `a`.\n    vals : 1-D sequence\n        Values to put into `a`. Only the first N elements are used, where\n        N is the number of True values in `mask`. If `vals` is smaller\n        than N it will be repeated.\n\n    See Also\n    --------\n    putmask, put, take, extract\n\n    Examples\n    --------\n    >>> arr = np.arange(6).reshape(2, 3)\n    >>> np.place(arr, arr>2, [44, 55])\n    >>> arr\n    array([[ 0,  1,  2],\n           [44, 55, 44]])\n    \n    ";
static char __pyx_k_877[] = "pmt (line 8738)";
static char __pyx_k_878[] = "Compute the payment against loan principal plus interest.\n\n    Given:\n     * a present value, `pv` (e.g., an amount borrowed)\n     * a future value, `fv` (e.g., 0)\n     * an interest `rate` compounded once per period, of which\n       there are\n     * `nper` total\n     * and (optional) specification of whether payment is made\n       at the beginning (`when` = {'begin', 1}) or the end\n       (`when` = {'end', 0}) of each period\n\n    Return:\n       the (fixed) periodic payment.\n\n    Parameters\n    ----------\n    rate : array_like\n        Rate of interest (per period)\n    nper : array_like\n        Number of compounding periods\n    pv : array_like\n        Present value\n    fv : array_like (optional)\n        Future value (default = 0)\n    when : {{'begin', 1}, {'end', 0}}, {string, int}\n        When payments are due ('begin' (1) or 'end' (0))\n\n    Returns\n    -------\n    out : ndarray\n        Payment against loan plus interest.  If all input is scalar, returns a\n        scalar float.  If any input is array_like, returns payment for each\n        input element. If multiple inputs are array_like, they all must have\n        the same shape.\n\n    Notes\n    -----\n    The payment is computed by solving the equation::\n\n     fv +\n     pv*(1 + rate)**nper +\n     pmt*(1 + rate*when)/rate*((1 + rate)**nper - 1) == 0\n\n    or, when ``rate == 0``::\n\n      fv + pv + pmt * nper == 0\n\n    for ``pmt``.\n\n    Note that computing a monthly mortgage payment is only\n    one use for this function.  For example, pmt returns the\n    periodic deposit one must make to achieve a specified\n    future balance given an initial deposit, a fixed,\n    periodically compounded interest rate, and the total\n    number of periods.\n\n    References\n    ----------\n    .. [WRW] Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May).\n       Open Document Format for Office Applications (OpenDocument)v1.2,\n       Part 2: Recalculated Formula (OpenFormula) F""ormat - Annotated Version,\n       Pre-Draft 12. Organization for the Advancement of Structured Information\n       Standards (OASIS). Billerica, MA, USA. [ODT Document].\n       Available:\n       http://www.oasis-open.org/committees/documents.php\n       ?wg_abbrev=office-formulaOpenDocument-formula-20090508.odt\n\n    Examples\n    --------\n    What is the monthly payment needed to pay off a $200,000 loan in 15\n    years at an annual interest rate of 7.5%?\n\n    >>> np.pmt(0.075/12, 12*15, 200000)\n    -1854.0247200054619\n\n    In order to pay-off (i.e., have a future-value of 0) the $200,000 obtained\n    today, a monthly payment of $1,854.02 would be required.  Note that this\n    example illustrates usage of `fv` having a default value of 0.\n    \n    ";
static char __pyx_k_879[] = "poly (line 8823)";
static char __pyx_k_880[] = "Find the coefficients of a polynomial with the given sequence of roots.\n\n    Returns the coefficients of the polynomial whose leading coefficient\n    is one for the given sequence of zeros (multiple roots must be included\n    in the sequence as many times as their multiplicity; see Examples).\n    A square matrix (or array, which will be treated as a matrix) can also\n    be given, in which case the coefficients of the characteristic polynomial\n    of the matrix are returned.\n\n    Parameters\n    ----------\n    seq_of_zeros : array_like, shape (N,) or (N, N)\n        A sequence of polynomial roots, or a square array or matrix object.\n\n    Returns\n    -------\n    c : ndarray\n        1D array of polynomial coefficients from highest to lowest degree:\n\n        ``c[0] * x**(N) + c[1] * x**(N-1) + ... + c[N-1] * x + c[N]``\n        where c[0] always equals 1.\n\n    Raises\n    ------\n    ValueError\n        If input is the wrong shape (the input must be a 1-D or square\n        2-D array).\n\n    See Also\n    --------\n    polyval : Evaluate a polynomial at a point.\n    roots : Return the roots of a polynomial.\n    polyfit : Least squares polynomial fit.\n    poly1d : A one-dimensional polynomial class.\n\n    Notes\n    -----\n    Specifying the roots of a polynomial still leaves one degree of\n    freedom, typically represented by an undetermined leading\n    coefficient. [1]_ In the case of this function, that coefficient -\n    the first one in the returned array - is always taken as one. (If\n    for some reason you have one other point, the only automatic way\n    presently to leverage that information is to use ``polyfit``.)\n\n    The characteristic polynomial, :math:`p_a(t)`, of an `n`-by-`n`\n    matrix **A** is given by\n\n        :math:`p_a(t) = \\mathrm{det}(t\\, \\mathbf{I} - \\mathbf{A})`,\n\n    where **I** is the `n`-by-`n` identity matrix. [2]_\n\n    References\n    ----------\n    .. [1] M. Sullivan and M. Sullivan, III, \"Algebra a""nd Trignometry,\n       Enhanced With Graphing Utilities,\" Prentice-Hall, pg. 318, 1996.\n\n    .. [2] G. Strang, \"Linear Algebra and Its Applications, 2nd Edition,\"\n       Academic Press, pg. 182, 1980.\n\n    Examples\n    --------\n    Given a sequence of a polynomial's zeros:\n\n    >>> np.poly((0, 0, 0)) # Multiple root example\n    array([1, 0, 0, 0])\n    \n    The line above represents z**3 + 0*z**2 + 0*z + 0.\n\n    >>> np.poly((-1./2, 0, 1./2))\n    array([ 1.  ,  0.  , -0.25,  0.  ])\n    \n    The line above represents z**3 - z/4\n\n    >>> np.poly((np.random.random(1.)[0], 0, np.random.random(1.)[0]))\n    array([ 1.        , -0.77086955,  0.08618131,  0.        ]) #random\n\n    Given a square array object:\n\n    >>> P = np.array([[0, 1./3], [-1./2, 0]])\n    >>> np.poly(P)\n    array([ 1.        ,  0.        ,  0.16666667])\n\n    Or a square matrix object:\n\n    >>> np.poly(np.matrix(P))\n    array([ 1.        ,  0.        ,  0.16666667])\n\n    Note how in all cases the leading coefficient is always 1.\n    \n    ";
static char __pyx_k_881[] = "polyadd (line 8917)";
static char __pyx_k_882[] = "Find the sum of two polynomials.\n\n    Returns the polynomial resulting from the sum of two input polynomials.\n    Each input must be either a poly1d object or a 1D sequence of polynomial\n    coefficients, from highest to lowest degree.\n\n    Parameters\n    ----------\n    a1, a2 : array_like or poly1d object\n        Input polynomials.\n\n    Returns\n    -------\n    out : ndarray or poly1d object\n        The sum of the inputs. If either input is a poly1d object, then the\n        output is also a poly1d object. Otherwise, it is a 1D array of\n        polynomial coefficients from highest to lowest degree.\n\n    See Also\n    --------\n    poly1d : A one-dimensional polynomial class.\n    poly, polyadd, polyder, polydiv, polyfit, polyint, polysub, polyval\n\n    Examples\n    --------\n    >>> np.polyadd([1, 2], [9, 5, 4])\n    array([9, 6, 6])\n\n    Using poly1d objects:\n\n    >>> p1 = np.poly1d([1, 2])\n    >>> p2 = np.poly1d([9, 5, 4])\n    >>> print p1\n    1 x + 2\n    >>> print p2\n       2\n    9 x + 5 x + 4\n    >>> print np.polyadd(p1, p2)\n       2\n    9 x + 6 x + 6\n    \n    ";
static char __pyx_k_883[] = "polyder (line 8963)";
static char __pyx_k_884[] = "Return the derivative of the specified order of a polynomial.\n\n    Parameters\n    ----------\n    p : poly1d or sequence\n        Polynomial to differentiate.\n        A sequence is interpreted as polynomial coefficients, see `poly1d`.\n    m : int, optional\n        Order of differentiation (default: 1)\n\n    Returns\n    -------\n    der : poly1d\n        A new polynomial representing the derivative.\n\n    See Also\n    --------\n    polyint : Anti-derivative of a polynomial.\n    poly1d : Class for one-dimensional polynomials.\n\n    Examples\n    --------\n    The derivative of the polynomial :math:`x^3 + x^2 + x^1 + 1` is:\n\n    >>> p = np.poly1d([1,1,1,1])\n    >>> p2 = np.polyder(p)\n    >>> p2\n    poly1d([3, 2, 1])\n\n    which evaluates to:\n\n    >>> p2(2.)\n    17.0\n\n    We can verify this, approximating the derivative with\n    ``(f(x + h) - f(x))/h``:\n\n    >>> (p(2. + 0.001) - p(2.)) / 0.001\n    17.007000999997857\n\n    The fourth-order derivative of a 3rd-order polynomial is zero:\n\n    >>> np.polyder(p, 2)\n    poly1d([6, 2])\n    >>> np.polyder(p, 3)\n    poly1d([6])\n    >>> np.polyder(p, 4)\n    poly1d([ 0.])\n    \n    ";
static char __pyx_k_885[] = "polydiv (line 9017)";
static char __pyx_k_886[] = "Returns the quotient and remainder of polynomial division.\n\n    The input arrays are the coefficients (including any coefficients\n    equal to zero) of the \"numerator\" (dividend) and \"denominator\"\n    (divisor) polynomials, respectively.\n\n    Parameters\n    ----------\n    u : array_like or poly1d\n        Dividend polynomial's coefficients.\n\n    v : array_like or poly1d\n        Divisor polynomial's coefficients.\n\n    Returns\n    -------\n    q : ndarray\n        Coefficients, including those equal to zero, of the quotient.\n    r : ndarray\n        Coefficients, including those equal to zero, of the remainder.\n\n    See Also\n    --------\n    poly, polyadd, polyder, polydiv, polyfit, polyint, polymul, polysub,\n    polyval\n\n    Notes\n    -----\n    Both `u` and `v` must be 0-d or 1-d (ndim = 0 or 1), but `u.ndim` need\n    not equal `v.ndim`. In other words, all four possible combinations -\n    ``u.ndim = v.ndim = 0``, ``u.ndim = v.ndim = 1``,\n    ``u.ndim = 1, v.ndim = 0``, and ``u.ndim = 0, v.ndim = 1`` - work.\n\n    Examples\n    --------\n    .. math:: \014rac{3x^2 + 5x + 2}{2x + 1} = 1.5x + 1.75, remainder 0.25\n\n    >>> x = np.array([3.0, 5.0, 2.0])\n    >>> y = np.array([2.0, 1.0])\n    >>> np.polydiv(x, y)\n    (array([ 1.5 ,  1.75]), array([ 0.25]))\n    \n    ";
static char __pyx_k_887[] = "polyfit (line 9064)";
static char __pyx_k_888[] = "Least squares polynomial fit.\n\n    Fit a polynomial ``p(x) = p[0] * x**deg + ... + p[deg]`` of degree `deg`\n    to points `(x, y)`. Returns a vector of coefficients `p` that minimises\n    the squared error.\n\n    Parameters\n    ----------\n    x : array_like, shape (M,)\n        x-coordinates of the M sample points ``(x[i], y[i])``.\n    y : array_like, shape (M,) or (M, K)\n        y-coordinates of the sample points. Several data sets of sample\n        points sharing the same x-coordinates can be fitted at once by\n        passing in a 2D-array that contains one dataset per column.\n    deg : int\n        Degree of the fitting polynomial\n    rcond : float, optional\n        Relative condition number of the fit. Singular values smaller than this\n        relative to the largest singular value will be ignored. The default\n        value is len(x)*eps, where eps is the relative precision of the float\n        type, about 2e-16 in most cases.\n    full : bool, optional\n        Switch determining nature of return value. When it is\n        False (the default) just the coefficients are returned, when True\n        diagnostic information from the singular value decomposition is also\n        returned.\n\n    Returns\n    -------\n    p : ndarray, shape (M,) or (M, K)\n        Polynomial coefficients, highest power first.\n        If `y` was 2-D, the coefficients for `k`-th data set are in ``p[:,k]``.\n\n    residuals, rank, singular_values, rcond : present only if `full` = True\n        Residuals of the least-squares fit, the effective rank of the scaled\n        Vandermonde coefficient matrix, its singular values, and the specified\n        value of `rcond`. For more details, see `linalg.lstsq`.\n\n    Warns\n    -----\n    RankWarning\n        The rank of the coefficient matrix in the least-squares fit is\n        deficient. The warning is only raised if `full` = False.\n\n        The warnings can be turned off by\n\n        >>> import warnings\n        >>> war""nings.simplefilter('ignore', np.RankWarning)\n\n    See Also\n    --------\n    polyval : Computes polynomial values.\n    linalg.lstsq : Computes a least-squares fit.\n    scipy.interpolate.UnivariateSpline : Computes spline fits.\n\n    Notes\n    -----\n    The solution minimizes the squared error\n\n    .. math ::\n        E = \\sum_{j=0}^k |p(x_j) - y_j|^2\n\n    in the equations::\n\n        x[0]**n * p[n] + ... + x[0] * p[1] + p[0] = y[0]\n        x[1]**n * p[n] + ... + x[1] * p[1] + p[0] = y[1]\n        ...\n        x[k]**n * p[n] + ... + x[k] * p[1] + p[0] = y[k]\n\n    The coefficient matrix of the coefficients `p` is a Vandermonde matrix.\n\n    `polyfit` issues a `RankWarning` when the least-squares fit is badly\n    conditioned. This implies that the best fit is not well-defined due\n    to numerical error. The results may be improved by lowering the polynomial\n    degree or by replacing `x` by `x` - `x`.mean(). The `rcond` parameter\n    can also be set to a value smaller than its default, but the resulting\n    fit may be spurious: including contributions from the small singular\n    values can add numerical noise to the result.\n\n    Note that fitting polynomial coefficients is inherently badly conditioned\n    when the degree of the polynomial is large or the interval of sample points\n    is badly centered. The quality of the fit should always be checked in these\n    cases. When polynomial fits are not satisfactory, splines may be a good\n    alternative.\n\n    References\n    ----------\n    .. [1] Wikipedia, \"Curve fitting\",\n           http://en.wikipedia.org/wiki/Curve_fitting\n    .. [2] Wikipedia, \"Polynomial interpolation\",\n           http://en.wikipedia.org/wiki/Polynomial_interpolation\n\n    Examples\n    --------\n    >>> x = np.array([0.0, 1.0, 2.0, 3.0,  4.0,  5.0])\n    >>> y = np.array([0.0, 0.8, 0.9, 0.1, -0.8, -1.0])\n    >>> z = np.polyfit(x, y, 3)\n    >>> z\n    array([ 0.08703704, -0.81349206,  1.69312169, -0.03968254]"")\n\n    It is convenient to use `poly1d` objects for dealing with polynomials:\n\n    >>> p = np.poly1d(z)\n    >>> p(0.5)\n    0.6143849206349179\n    >>> p(3.5)\n    -0.34732142857143039\n    >>> p(10)\n    22.579365079365115\n\n    High-order polynomials may oscillate wildly:\n\n    >>> p30 = np.poly1d(np.polyfit(x, y, 30))\n    /... RankWarning: Polyfit may be poorly conditioned...\n    >>> p30(4)\n    -0.80000000000000204\n    >>> p30(5)\n    -0.99999999999999445\n    >>> p30(4.5)\n    -0.10547061179440398\n\n    Illustration:\n\n    >>> import matplotlib.pyplot as plt\n    >>> xp = np.linspace(-2, 6, 100)\n    >>> plt.plot(x, y, '.', xp, p(xp), '-', xp, p30(xp), '--')\n    [<matplotlib.lines.Line2D object at 0x...>, <matplotlib.lines.Line2D object at 0x...>, <matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.ylim(-2,2)\n    (-2, 2)\n    >>> plt.show()\n    \n    ";
static char __pyx_k_889[] = "polyint (line 9200)";
static char __pyx_k_890[] = "Return an antiderivative (indefinite integral) of a polynomial.\n\n    The returned order `m` antiderivative `P` of polynomial `p` satisfies\n    :math:`\014rac{d^m}{dx^m}P(x) = p(x)` and is defined up to `m - 1`\n    integration constants `k`. The constants determine the low-order\n    polynomial part\n\n    .. math:: \014rac{k_{m-1}}{0!} x^0 + \\ldots + \014rac{k_0}{(m-1)!}x^{m-1}\n\n    of `P` so that :math:`P^{(j)}(0) = k_{m-j-1}`.\n\n    Parameters\n    ----------\n    p : {array_like, poly1d}\n        Polynomial to differentiate.\n        A sequence is interpreted as polynomial coefficients, see `poly1d`.\n    m : int, optional\n        Order of the antiderivative. (Default: 1)\n    k : {None, list of `m` scalars, scalar}, optional\n        Integration constants. They are given in the order of integration:\n        those corresponding to highest-order terms come first.\n\n        If ``None`` (default), all constants are assumed to be zero.\n        If `m = 1`, a single scalar can be given instead of a list.\n\n    See Also\n    --------\n    polyder : derivative of a polynomial\n    poly1d.integ : equivalent method\n\n    Examples\n    --------\n    The defining property of the antiderivative:\n\n    >>> p = np.poly1d([1,1,1])\n    >>> P = np.polyint(p)\n    >>> P\n    poly1d([ 0.33333333,  0.5       ,  1.        ,  0.        ])\n    >>> np.polyder(P) == p\n    True\n\n    The integration constants default to zero, but can be specified:\n\n    >>> P = np.polyint(p, 3)\n    >>> P(0)\n    0.0\n    >>> np.polyder(P)(0)\n    0.0\n    >>> np.polyder(P, 2)(0)\n    0.0\n    >>> P = np.polyint(p, 3, k=[6,5,3])\n    >>> P\n    poly1d([ 0.01666667,  0.04166667,  0.16666667,  3. ,  5. ,  3. ])\n\n    Note that 3 = 6 / 2!, and that the constants are given in the order of\n    integrations. Constant of the highest-order polynomial term comes first:\n\n    >>> np.polyder(P, 2)(0)\n    6.0\n    >>> np.polyder(P, 1)(0)\n    5.0\n    >>> P(0)\n    3.0\n    \n    ";
static char __pyx_k_891[] = "polymul (line 9269)";
static char __pyx_k_892[] = "Find the product of two polynomials.\n\n    Finds the polynomial resulting from the multiplication of the two input\n    polynomials. Each input must be either a poly1d object or a 1D sequence\n    of polynomial coefficients, from highest to lowest degree.\n\n    Parameters\n    ----------\n    a1, a2 : array_like or poly1d object\n        Input polynomials.\n\n    Returns\n    -------\n    out : ndarray or poly1d object\n        The polynomial resulting from the multiplication of the inputs. If\n        either inputs is a poly1d object, then the output is also a poly1d\n        object. Otherwise, it is a 1D array of polynomial coefficients from\n        highest to lowest degree.\n\n    See Also\n    --------\n    poly1d : A one-dimensional polynomial class.\n    poly, polyadd, polyder, polydiv, polyfit, polyint, polysub,\n    polyval\n\n    Examples\n    --------\n    >>> np.polymul([1, 2, 3], [9, 5, 1])\n    array([ 9, 23, 38, 17,  3])\n\n    Using poly1d objects:\n\n    >>> p1 = np.poly1d([1, 2, 3])\n    >>> p2 = np.poly1d([9, 5, 1])\n    >>> print p1\n       2\n    1 x + 2 x + 3\n    >>> print p2\n       2\n    9 x + 5 x + 1\n    >>> print np.polymul(p1, p2)\n       4      3      2\n    9 x + 23 x + 38 x + 17 x + 3\n    \n    ";
static char __pyx_k_893[] = "polysub (line 9318)";
static char __pyx_k_894[] = "Difference (subtraction) of two polynomials.\n\n    Given two polynomials `a1` and `a2`, returns ``a1 - a2``.\n    `a1` and `a2` can be either array_like sequences of the polynomials'\n    coefficients (including coefficients equal to zero), or `poly1d` objects.\n\n    Parameters\n    ----------\n    a1, a2 : array_like or poly1d\n        Minuend and subtrahend polynomials, respectively.\n\n    Returns\n    -------\n    out : ndarray or poly1d\n        Array or `poly1d` object of the difference polynomial's coefficients.\n\n    See Also\n    --------\n    polyval, polydiv, polymul, polyadd\n\n    Examples\n    --------\n    .. math:: (2 x^2 + 10 x - 2) - (3 x^2 + 10 x -4) = (-x^2 + 2)\n\n    >>> np.polysub([2, 10, -2], [3, 10, -4])\n    array([-1,  0,  2])\n    \n    ";
static char __pyx_k_895[] = "polyval (line 9350)";
static char __pyx_k_896[] = "Evaluate a polynomial at specific values.\n\n    If `p` is of length N, this function returns the value:\n\n        ``p[0]*x**(N-1) + p[1]*x**(N-2) + ... + p[N-2]*x + p[N-1]``\n\n    If `x` is a sequence, then `p(x)` is returned for each element of `x`.\n    If `x` is another polynomial then the composite polynomial `p(x(t))`\n    is returned.\n\n    Parameters\n    ----------\n    p : array_like or poly1d object\n       1D array of polynomial coefficients (including coefficients equal\n       to zero) from highest degree to the constant term, or an\n       instance of poly1d.\n    x : array_like or poly1d object\n       A number, a 1D array of numbers, or an instance of poly1d, \"at\"\n       which to evaluate `p`.\n\n    Returns\n    -------\n    values : ndarray or poly1d\n       If `x` is a poly1d instance, the result is the composition of the two\n       polynomials, i.e., `x` is \"substituted\" in `p` and the simplified\n       result is returned. In addition, the type of `x` - array_like or\n       poly1d - governs the type of the output: `x` array_like => `values`\n       array_like, `x` a poly1d object => `values` is also.\n\n    See Also\n    --------\n    poly1d: A polynomial class.\n\n    Notes\n    -----\n    Horner's scheme [1]_ is used to evaluate the polynomial. Even so,\n    for polynomials of high degree the values may be inaccurate due to\n    rounding errors. Use carefully.\n\n    References\n    ----------\n    .. [1] I. N. Bronshtein, K. A. Semendyayev, and K. A. Hirsch (Eng.\n       trans. Ed.), *Handbook of Mathematics*, New York, Van Nostrand\n       Reinhold Co., 1985, pg. 720.\n\n    Examples\n    --------\n    >>> np.polyval([3,0,1], 5)  # 3 * 5**2 + 0 * 5**1 + 1\n    76\n    >>> np.polyval([3,0,1], np.poly1d(5))\n    poly1d([ 76.])\n    >>> np.polyval(np.poly1d([3,0,1]), 5)\n    76\n    >>> np.polyval(np.poly1d([3,0,1]), np.poly1d(5))\n    poly1d([ 76.])\n    \n    ";
static char __pyx_k_897[] = "prod (line 9438)";
static char __pyx_k_898[] = "Return the product of array elements over a given axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    axis : int, optional\n        Axis over which the product is taken.  By default, the product\n        of all elements is calculated.\n    dtype : data-type, optional\n        The data-type of the returned array, as well as of the accumulator\n        in which the elements are multiplied.  By default, if `a` is of\n        integer type, `dtype` is the default platform integer. (Note: if\n        the type of `a` is unsigned, then so is `dtype`.)  Otherwise,\n        the dtype is the same as that of `a`.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must have\n        the same shape as the expected output, but the type of the\n        output values will be cast if necessary.\n\n    Returns\n    -------\n    product_along_axis : ndarray, see `dtype` parameter above.\n        An array shaped as `a` but with the specified axis removed.\n        Returns a reference to `out` if specified.\n\n    See Also\n    --------\n    ndarray.prod : equivalent method\n    numpy.doc.ufuncs : Section \"Output arguments\"\n\n    Notes\n    -----\n    Arithmetic is modular when using integer types, and no error is\n    raised on overflow.  That means that, on a 32-bit platform:\n\n    >>> x = np.array([536870910, 536870910, 536870910, 536870910])\n    >>> np.prod(x) #random\n    16\n\n    Examples\n    --------\n    By default, calculate the product of all elements:\n\n    >>> np.prod([1.,2.])\n    2.0\n\n    Even when the input array is two-dimensional:\n\n    >>> np.prod([[1.,2.],[3.,4.]])\n    24.0\n\n    But we can also specify the axis over which to multiply:\n\n    >>> np.prod([[1.,2.],[3.,4.]], axis=1)\n    array([  2.,  12.])\n\n    If the type of `x` is unsigned, then the output type is\n    the unsigned platform integer:\n\n    >>> x = np.array([1, 2, 3], dtype=np.uint8)\n    >>> np.prod(x).dtype ""== np.uint\n    True\n\n    If `x` is of a signed integer type, then the output type\n    is the default platform integer:\n\n    >>> x = np.array([1, 2, 3], dtype=np.int8)\n    >>> np.prod(x).dtype == np.int\n    True\n    \n    ";
static char __pyx_k_899[] = "promote_types (line 9525)";
static char __pyx_k_900[] = "promote_types(type1, type2)\n\n    Returns the data type with the smallest size and smallest scalar\n    kind to which both ``type1`` and ``type2`` may be safely cast.\n    The returned data type is always in native byte order.\n\n    This function is symmetric and associative.\n\n    Parameters\n    ----------\n    type1 : dtype or dtype specifier\n        First data type.\n    type2 : dtype or dtype specifier\n        Second data type.\n\n    Returns\n    -------\n    out : dtype\n        The promoted data type.\n\n    Notes\n    -----\n    .. versionadded:: 1.6.0\n\n    See Also\n    --------\n    result_type, dtype, can_cast\n\n    Examples\n    --------\n    >>> np.promote_types('f4', 'f8')\n    dtype('float64')\n\n    >>> np.promote_types('i8', 'f4')\n    dtype('float64')\n\n    >>> np.promote_types('>i8', '<c8')\n    dtype('complex128')\n\n    >>> np.promote_types('i1', 'S8')\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    TypeError: invalid type promotion\n    \n    ";
static char __pyx_k_901[] = "ptp (line 9575)";
static char __pyx_k_902[] = "Range of values (maximum - minimum) along an axis.\n\n    The name of the function comes from the acronym for 'peak to peak'.\n\n    Parameters\n    ----------\n    a : array_like\n        Input values.\n    axis : int, optional\n        Axis along which to find the peaks.  By default, flatten the\n        array.\n    out : array_like\n        Alternative output array in which to place the result. It must\n        have the same shape and buffer length as the expected output,\n        but the type of the output values will be cast if necessary.\n\n    Returns\n    -------\n    ptp : ndarray\n        A new array holding the result, unless `out` was\n        specified, in which case a reference to `out` is returned.\n\n    Examples\n    --------\n    >>> x = np.arange(4).reshape((2,2))\n    >>> x\n    array([[0, 1],\n           [2, 3]])\n\n    >>> np.ptp(x, axis=0)\n    array([2, 2])\n\n    >>> np.ptp(x, axis=1)\n    array([1, 1])\n    \n    ";
static char __pyx_k_903[] = "put (line 9615)";
static char __pyx_k_904[] = "Replaces specified elements of an array with given values.\n\n    The indexing works on the flattened target array. `put` is roughly\n    equivalent to:\n\n    ::\n\n        a.flat[ind] = v\n\n    Parameters\n    ----------\n    a : ndarray\n        Target array.\n    ind : array_like\n        Target indices, interpreted as integers.\n    v : array_like\n        Values to place in `a` at target indices. If `v` is shorter than\n        `ind` it will be repeated as necessary.\n    mode : {'raise', 'wrap', 'clip'}, optional\n        Specifies how out-of-bounds indices will behave.\n\n        * 'raise' -- raise an error (default)\n        * 'wrap' -- wrap around\n        * 'clip' -- clip to the range\n\n        'clip' mode means that all indices that are too large are replaced\n        by the index that addresses the last element along that axis. Note\n        that this disables indexing with negative numbers.\n\n    See Also\n    --------\n    putmask, place\n\n    Examples\n    --------\n    >>> a = np.arange(5)\n    >>> np.put(a, [0, 2], [-44, -55])\n    >>> a\n    array([-44,   1, -55,   3,   4])\n\n    >>> a = np.arange(5)\n    >>> np.put(a, 22, -5, mode='clip')\n    >>> a\n    array([ 0,  1,  2,  3, -5])\n    \n    ";
static char __pyx_k_905[] = "putmask (line 9665)";
static char __pyx_k_906[] = "putmask(a, mask, values)\n\n    Changes elements of an array based on conditional and input values.\n\n    Sets ``a.flat[n] = values[n]`` for each n where ``mask.flat[n]==True``.\n\n    If `values` is not the same size as `a` and `mask` then it will repeat.\n    This gives behavior different from ``a[mask] = values``.\n\n    Parameters\n    ----------\n    a : array_like\n        Target array.\n    mask : array_like\n        Boolean mask array. It has to be the same shape as `a`.\n    values : array_like\n        Values to put into `a` where `mask` is True. If `values` is smaller\n        than `a` it will be repeated.\n\n    See Also\n    --------\n    place, put, take\n\n    Examples\n    --------\n    >>> x = np.arange(6).reshape(2, 3)\n    >>> np.putmask(x, x>2, x**2)\n    >>> x\n    array([[ 0,  1,  2],\n           [ 9, 16, 25]])\n\n    If `values` is smaller than `a` it is repeated:\n\n    >>> x = np.arange(5)\n    >>> np.putmask(x, x>1, [-33, -44])\n    >>> x\n    array([  0,   1, -33, -44, -33])\n    \n    ";
static char __pyx_k_907[] = "pv (line 9709)";
static char __pyx_k_908[] = "Compute the present value.\n\n    Given:\n     * a future value, `fv`\n     * an interest `rate` compounded once per period, of which\n       there are\n     * `nper` total\n     * a (fixed) payment, `pmt`, paid either\n     * at the beginning (`when` = {'begin', 1}) or the end\n       (`when` = {'end', 0}) of each period\n\n    Return:\n       the value now\n\n    Parameters\n    ----------\n    rate : array_like\n        Rate of interest (per period)\n    nper : array_like\n        Number of compounding periods\n    pmt : array_like\n        Payment\n    fv : array_like, optional\n        Future value\n    when : {{'begin', 1}, {'end', 0}}, {string, int}, optional\n        When payments are due ('begin' (1) or 'end' (0))\n\n    Returns\n    -------\n    out : ndarray, float\n        Present value of a series of payments or investments.\n\n    Notes\n    -----\n    The present value is computed by solving the equation::\n\n     fv +\n     pv*(1 + rate)**nper +\n     pmt*(1 + rate*when)/rate*((1 + rate)**nper - 1) = 0\n\n    or, when ``rate = 0``::\n\n     fv + pv + pmt * nper = 0\n\n    for `pv`, which is then returned.\n\n    References\n    ----------\n    .. [WRW] Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May).\n       Open Document Format for Office Applications (OpenDocument)v1.2,\n       Part 2: Recalculated Formula (OpenFormula) Format - Annotated Version,\n       Pre-Draft 12. Organization for the Advancement of Structured Information\n       Standards (OASIS). Billerica, MA, USA. [ODT Document].\n       Available:\n       http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula\n       OpenDocument-formula-20090508.odt\n\n    Examples\n    --------\n    What is the present value (e.g., the initial investment)\n    of an investment that needs to total $15692.93\n    after 10 years of saving $100 every month?  Assume the\n    interest rate is 5% (annually) compounded monthly.\n\n    >>> np.pv(0.05/12, 10*12, -100, 15692.93)\n   "" -100.00067131625819\n\n    By convention, the negative sign represents cash flow out\n    (i.e., money not available today).  Thus, to end up with\n    $15,692.93 in 10 years saving $100 a month at 5% annual\n    interest, one's initial deposit should also be $100.\n\n    If any input is array_like, ``pv`` returns an array of equal shape.\n    Let's compare different interest rates in the example above:\n\n    >>> a = np.array((0.05, 0.04, 0.03))/12\n    >>> np.pv(a, 10*12, -100, 15692.93)\n    array([ -100.00067132,  -649.26771385, -1273.78633713])\n\n    So, to end up with the same $15692.93 under the same $100 per month\n    \"savings plan,\" for annual interest rates of 4% and 3%, one would\n    need initial investments of $649.27 and $1273.79, respectively.\n    \n    ";
static char __pyx_k_909[] = "rank (line 9797)";
static char __pyx_k_910[] = "Return the number of dimensions of an array.\n\n    If `a` is not already an array, a conversion is attempted.\n    Scalars are zero dimensional.\n\n    Parameters\n    ----------\n    a : array_like\n        Array whose number of dimensions is desired. If `a` is not an array,\n        a conversion is attempted.\n\n    Returns\n    -------\n    number_of_dimensions : int\n        The number of dimensions in the array.\n\n    See Also\n    --------\n    ndim : equivalent function\n    ndarray.ndim : equivalent property\n    shape : dimensions of array\n    ndarray.shape : dimensions of array\n\n    Notes\n    -----\n    In the old Numeric package, `rank` was the term used for the number of\n    dimensions, but in Numpy `ndim` is used instead.\n\n    Examples\n    --------\n    >>> np.rank([1,2,3])\n    1\n    >>> np.rank(np.array([[1,2,3],[4,5,6]]))\n    2\n    >>> np.rank(1)\n    0\n    \n    ";
static char __pyx_k_911[] = "ravel (line 9884)";
static char __pyx_k_912[] = "Return a flattened array.\n\n    A 1-D array, containing the elements of the input, is returned.  A copy is\n    made only if needed.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.  The elements in ``a`` are read in the order specified by\n        `order`, and packed as a 1-D array.\n    order : {'C','F', 'A', 'K'}, optional\n        The elements of ``a`` are read in this order. 'C' means to view\n        the elements in C (row-major) order. 'F' means to view the elements\n        in Fortran (column-major) order. 'A' means to view the elements\n        in 'F' order if a is Fortran contiguous, 'C' order otherwise.\n        'K' means to view the elements in the order they occur in memory,\n        except for reversing the data when strides are negative.\n        By default, 'C' order is used.\n\n    Returns\n    -------\n    1d_array : ndarray\n        Output of the same dtype as `a`, and of shape ``(a.size(),)``.\n\n    See Also\n    --------\n    ndarray.flat : 1-D iterator over an array.\n    ndarray.flatten : 1-D array copy of the elements of an array\n                      in row-major order.\n\n    Notes\n    -----\n    In row-major order, the row index varies the slowest, and the column\n    index the quickest.  This can be generalized to multiple dimensions,\n    where row-major order implies that the index along the first axis\n    varies slowest, and the index along the last quickest.  The opposite holds\n    for Fortran-, or column-major, mode.\n\n    Examples\n    --------\n    It is equivalent to ``reshape(-1, order=order)``.\n\n    >>> x = np.array([[1, 2, 3], [4, 5, 6]])\n    >>> print np.ravel(x)\n    [1 2 3 4 5 6]\n\n    >>> print x.reshape(-1)\n    [1 2 3 4 5 6]\n\n    >>> print np.ravel(x, order='F')\n    [1 4 2 5 3 6]\n\n    When ``order`` is 'A', it will preserve the array's 'C' or 'F' ordering:\n\n    >>> print np.ravel(x.T)\n    [1 4 2 5 3 6]\n    >>> print np.ravel(x.T, order='A')\n    [1 2 3 4 5 6]\n\n    When ``or""der`` is 'K', it will preserve orderings that are neither 'C'\n    nor 'F', but won't reverse axes:\n\n    >>> a = np.arange(3)[::-1]; a\n    array([2, 1, 0])\n    >>> a.ravel(order='C')\n    array([2, 1, 0])\n    >>> a.ravel(order='K')\n    array([2, 1, 0])\n\n    >>> a = np.arange(12).reshape(2,3,2).swapaxes(1,2); a\n    array([[[ 0,  2,  4],\n            [ 1,  3,  5]],\n           [[ 6,  8, 10],\n            [ 7,  9, 11]]])\n    >>> a.ravel(order='C')\n    array([ 0,  2,  4,  1,  3,  5,  6,  8, 10,  7,  9, 11])\n    >>> a.ravel(order='K')\n    array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])\n    \n    ";
static char __pyx_k_913[] = "ravel_multi_index (line 9968)";
static char __pyx_k_914[] = "ravel_multi_index(multi_index, dims, mode='raise', order='C')\n\n    Converts a tuple of index arrays into an array of flat\n    indices, applying boundary modes to the multi-index.\n\n    Parameters\n    ----------\n    multi_index : tuple of array_like\n        A tuple of integer arrays, one array for each dimension.\n    dims : tuple of ints\n        The shape of array into which the indices from ``multi_index`` apply.\n    mode : {'raise', 'wrap', 'clip'}, optional\n        Specifies how out-of-bounds indices are handled.  Can specify\n        either one mode or a tuple of modes, one mode per index.\n\n        * 'raise' -- raise an error (default)\n        * 'wrap' -- wrap around\n        * 'clip' -- clip to the range\n\n        In 'clip' mode, a negative index which would normally\n        wrap will clip to 0 instead.\n    order : {'C', 'F'}, optional\n        Determines whether the multi-index should be viewed as indexing in\n        C (row-major) order or FORTRAN (column-major) order.\n\n    Returns\n    -------\n    raveled_indices : ndarray\n        An array of indices into the flattened version of an array\n        of dimensions ``dims``.\n\n    See Also\n    --------\n    unravel_index\n\n    Notes\n    -----\n    .. versionadded:: 1.6.0\n\n    Examples\n    --------\n    >>> arr = np.array([[3,6,6],[4,5,1]])\n    >>> np.ravel_multi_index(arr, (7,6))\n    array([22, 41, 37])\n    >>> np.ravel_multi_index(arr, (7,6), order='F')\n    array([31, 41, 13])\n    >>> np.ravel_multi_index(arr, (4,6), mode='clip')\n    array([22, 23, 19])\n    >>> np.ravel_multi_index(arr, (4,4), mode=('clip','wrap'))\n    array([12, 13, 13])\n\n    >>> np.ravel_multi_index((3,1,4,1), (6,7,8,9))\n    1621\n    \n    ";
static char __pyx_k_915[] = "real (line 10028)";
static char __pyx_k_916[] = "Return the real part of the elements of the array.\n\n    Parameters\n    ----------\n    val : array_like\n        Input array.\n\n    Returns\n    -------\n    out : ndarray\n        Output array. If `val` is real, the type of `val` is used for the\n        output.  If `val` has complex elements, the returned type is float.\n\n    See Also\n    --------\n    real_if_close, imag, angle\n\n    Examples\n    --------\n    >>> a = np.array([1+2j, 3+4j, 5+6j])\n    >>> a.real\n    array([ 1.,  3.,  5.])\n    >>> a.real = 9\n    >>> a\n    array([ 9.+2.j,  9.+4.j,  9.+6.j])\n    >>> a.real = np.array([9, 8, 7])\n    >>> a\n    array([ 9.+2.j,  8.+4.j,  7.+6.j])\n    \n    ";
static char __pyx_k_917[] = "real_if_close (line 10062)";
static char __pyx_k_918[] = "If complex input returns a real array if complex parts are close to zero.\n\n    \"Close to zero\" is defined as `tol` * (machine epsilon of the type for\n    `a`).\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    tol : float\n        Tolerance in machine epsilons for the complex part of the elements\n        in the array.\n\n    Returns\n    -------\n    out : ndarray\n        If `a` is real, the type of `a` is used for the output.  If `a`\n        has complex elements, the returned type is float.\n\n    See Also\n    --------\n    real, imag, angle\n\n    Notes\n    -----\n    Machine epsilon varies from machine to machine and between data types\n    but Python floats on most platforms have a machine epsilon equal to\n    2.2204460492503131e-16.  You can use 'np.finfo(np.float).eps' to print\n    out the machine epsilon for floats.\n\n    Examples\n    --------\n    >>> np.finfo(np.float).eps\n    2.2204460492503131e-16\n\n    >>> np.real_if_close([2.1 + 4e-14j], tol=1000)\n    array([ 2.1])\n    >>> np.real_if_close([2.1 + 4e-13j], tol=1000)\n    array([ 2.1 +4.00000000e-13j])\n    \n    ";
static char __pyx_k_919[] = "repeat (line 10146)";
static char __pyx_k_920[] = "Repeat elements of an array.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    repeats : {int, array of ints}\n        The number of repetitions for each element.  `repeats` is broadcasted\n        to fit the shape of the given axis.\n    axis : int, optional\n        The axis along which to repeat values.  By default, use the\n        flattened input array, and return a flat output array.\n\n    Returns\n    -------\n    repeated_array : ndarray\n        Output array which has the same shape as `a`, except along\n        the given axis.\n\n    See Also\n    --------\n    tile : Tile an array.\n\n    Examples\n    --------\n    >>> x = np.array([[1,2],[3,4]])\n    >>> np.repeat(x, 2)\n    array([1, 1, 2, 2, 3, 3, 4, 4])\n    >>> np.repeat(x, 3, axis=1)\n    array([[1, 1, 1, 2, 2, 2],\n           [3, 3, 3, 4, 4, 4]])\n    >>> np.repeat(x, [1, 2], axis=0)\n    array([[1, 2],\n           [3, 4],\n           [3, 4]])\n    \n    ";
static char __pyx_k_921[] = "require (line 10187)";
static char __pyx_k_922[] = "Return an ndarray of the provided type that satisfies requirements.\n\n    This function is useful to be sure that an array with the correct flags\n    is returned for passing to compiled code (perhaps through ctypes).\n\n    Parameters\n    ----------\n    a : array_like\n       The object to be converted to a type-and-requirement-satisfying array.\n    dtype : data-type\n       The required data-type, the default data-type is float64).\n    requirements : str or list of str\n       The requirements list can be any of the following\n\n       * 'F_CONTIGUOUS' ('F') - ensure a Fortran-contiguous array\n       * 'C_CONTIGUOUS' ('C') - ensure a C-contiguous array\n       * 'ALIGNED' ('A')      - ensure a data-type aligned array\n       * 'WRITEABLE' ('W')    - ensure a writable array\n       * 'OWNDATA' ('O')      - ensure an array that owns its own data\n\n    See Also\n    --------\n    asarray : Convert input to an ndarray.\n    asanyarray : Convert to an ndarray, but pass through ndarray subclasses.\n    ascontiguousarray : Convert input to a contiguous array.\n    asfortranarray : Convert input to an ndarray with column-major\n                     memory order.\n    ndarray.flags : Information about the memory layout of the array.\n\n    Notes\n    -----\n    The returned array will be guaranteed to have the listed requirements\n    by making a copy if needed.\n\n    Examples\n    --------\n    >>> x = np.arange(6).reshape(2,3)\n    >>> x.flags\n      C_CONTIGUOUS : True\n      F_CONTIGUOUS : False\n      OWNDATA : False\n      WRITEABLE : True\n      ALIGNED : True\n      UPDATEIFCOPY : False\n\n    >>> y = np.require(x, dtype=np.float32, requirements=['A', 'O', 'W', 'F'])\n    >>> y.flags\n      C_CONTIGUOUS : False\n      F_CONTIGUOUS : True\n      OWNDATA : True\n      WRITEABLE : True\n      ALIGNED : True\n      UPDATEIFCOPY : False\n    \n    ";
static char __pyx_k_923[] = "reshape (line 10246)";
static char __pyx_k_924[] = "Gives a new shape to an array without changing its data.\n\n    Parameters\n    ----------\n    a : array_like\n        Array to be reshaped.\n    newshape : int or tuple of ints\n        The new shape should be compatible with the original shape. If\n        an integer, then the result will be a 1-D array of that length.\n        One shape dimension can be -1. In this case, the value is inferred\n        from the length of the array and remaining dimensions.\n    order : {'C', 'F', 'A'}, optional\n        Determines whether the array data should be viewed as in C\n        (row-major) order, FORTRAN (column-major) order, or the C/FORTRAN\n        order should be preserved.\n\n    Returns\n    -------\n    reshaped_array : ndarray\n        This will be a new view object if possible; otherwise, it will\n        be a copy.\n\n\n    See Also\n    --------\n    ndarray.reshape : Equivalent method.\n\n    Notes\n    -----\n\n    It is not always possible to change the shape of an array without\n    copying the data. If you want an error to be raise if the data is copied,\n    you should assign the new shape to the shape attribute of the array::\n\n     >>> a = np.zeros((10, 2))\n     # A transpose make the array non-contiguous\n     >>> b = a.T\n     # Taking a view makes it possible to modify the shape without modiying the\n     # initial object.\n     >>> c = b.view()\n     >>> c.shape = (20)\n     AttributeError: incompatible shape for a non-contiguous array\n\n\n    Examples\n    --------\n    >>> a = np.array([[1,2,3], [4,5,6]])\n    >>> np.reshape(a, 6)\n    array([1, 2, 3, 4, 5, 6])\n    >>> np.reshape(a, 6, order='F')\n    array([1, 4, 2, 5, 3, 6])\n\n    >>> np.reshape(a, (3,-1))       # the unspecified value is inferred to be 2\n    array([[1, 2],\n           [3, 4],\n           [5, 6]])\n    \n    ";
static char __pyx_k_925[] = "resize (line 10308)";
static char __pyx_k_926[] = "Return a new array with the specified shape.\n\n    If the new array is larger than the original array, then the new\n    array is filled with repeated copies of `a`.  Note that this behavior\n    is different from a.resize(new_shape) which fills with zeros instead\n    of repeated copies of `a`.\n\n    Parameters\n    ----------\n    a : array_like\n        Array to be resized.\n\n    new_shape : int or tuple of int\n        Shape of resized array.\n\n    Returns\n    -------\n    reshaped_array : ndarray\n        The new array is formed from the data in the old array, repeated\n        if necessary to fill out the required number of elements.  The\n        data are repeated in the order that they are stored in memory.\n\n    See Also\n    --------\n    ndarray.resize : resize an array in-place.\n\n    Examples\n    --------\n    >>> a=np.array([[0,1],[2,3]])\n    >>> np.resize(a,(1,4))\n    array([[0, 1, 2, 3]])\n    >>> np.resize(a,(2,4))\n    array([[0, 1, 2, 3],\n           [0, 1, 2, 3]])\n    \n    ";
static char __pyx_k_927[] = "result_type (line 10366)";
static char __pyx_k_928[] = "result_type(*arrays_and_dtypes)\n\n    Returns the type that results from applying the NumPy\n    type promotion rules to the arguments.\n\n    Type promotion in NumPy works similarly to the rules in languages\n    like C++, with some slight differences.  When both scalars and\n    arrays are used, the array's type takes precedence and the actual value\n    of the scalar is taken into account.\n\n    For example, calculating 3*a, where a is an array of 32-bit floats,\n    intuitively should result in a 32-bit float output.  If the 3 is a\n    32-bit integer, the NumPy rules indicate it can't convert losslessly\n    into a 32-bit float, so a 64-bit float should be the result type.\n    By examining the value of the constant, '3', we see that it fits in\n    an 8-bit integer, which can be cast losslessly into the 32-bit float.\n\n    Parameters\n    ----------\n    arrays_and_dtypes : list of arrays and dtypes\n        The operands of some operation whose result type is needed.\n\n    Returns\n    -------\n    out : dtype\n        The result type.\n\n    See also\n    --------\n    dtype, promote_types, min_scalar_type, can_cast\n\n    Notes\n    -----\n    .. versionadded:: 1.6.0\n\n    The specific algorithm used is as follows.\n\n    Categories are determined by first checking which of boolean,\n    integer (int/uint), or floating point (float/complex) the maximum\n    kind of all the arrays and the scalars are.\n    \n    If there are only scalars or the maximum category of the scalars\n    is higher than the maximum category of the arrays,\n    the data types are combined with :func:`promote_types`\n    to produce the return value.\n\n    Otherwise, `min_scalar_type` is called on each array, and\n    the resulting data types are all combined with :func:`promote_types`\n    to produce the return value.\n\n    The set of int values is not a subset of the uint values for types\n    with the same number of bits, something not reflected in\n    :func:`min_scalar_type`"", but handled as a special case in `result_type`.\n\n    Examples\n    --------\n    >>> np.result_type(3, np.arange(7, dtype='i1'))\n    dtype('int8')\n\n    >>> np.result_type('i4', 'c8')\n    dtype('complex128')\n\n    >>> np.result_type(3.0, -2)\n    dtype('float64')\n    \n    ";
static char __pyx_k_929[] = "roll (line 10437)";
static char __pyx_k_930[] = "Roll array elements along a given axis.\n\n    Elements that roll beyond the last position are re-introduced at\n    the first.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    shift : int\n        The number of places by which elements are shifted.\n    axis : int, optional\n        The axis along which elements are shifted.  By default, the array\n        is flattened before shifting, after which the original\n        shape is restored.\n\n    Returns\n    -------\n    res : ndarray\n        Output array, with the same shape as `a`.\n\n    See Also\n    --------\n    rollaxis : Roll the specified axis backwards, until it lies in a\n               given position.\n\n    Examples\n    --------\n    >>> x = np.arange(10)\n    >>> np.roll(x, 2)\n    array([8, 9, 0, 1, 2, 3, 4, 5, 6, 7])\n\n    >>> x2 = np.reshape(x, (2,5))\n    >>> x2\n    array([[0, 1, 2, 3, 4],\n           [5, 6, 7, 8, 9]])\n    >>> np.roll(x2, 1)\n    array([[9, 0, 1, 2, 3],\n           [4, 5, 6, 7, 8]])\n    >>> np.roll(x2, 1, axis=0)\n    array([[5, 6, 7, 8, 9],\n           [0, 1, 2, 3, 4]])\n    >>> np.roll(x2, 1, axis=1)\n    array([[4, 0, 1, 2, 3],\n           [9, 5, 6, 7, 8]])\n    \n    ";
static char __pyx_k_931[] = "rollaxis (line 10488)";
static char __pyx_k_932[] = "Roll the specified axis backwards, until it lies in a given position.\n\n    Parameters\n    ----------\n    a : ndarray\n        Input array.\n    axis : int\n        The axis to roll backwards.  The positions of the other axes do not\n        change relative to one another.\n    start : int, optional\n        The axis is rolled until it lies before this position.  The default,\n        0, results in a \"complete\" roll.\n\n    Returns\n    -------\n    res : ndarray\n        Output array.\n\n    See Also\n    --------\n    roll : Roll the elements of an array by a number of positions along a\n        given axis.\n\n    Examples\n    --------\n    >>> a = np.ones((3,4,5,6))\n    >>> np.rollaxis(a, 3, 1).shape\n    (3, 6, 4, 5)\n    >>> np.rollaxis(a, 2).shape\n    (5, 3, 4, 6)\n    >>> np.rollaxis(a, 1, 4).shape\n    (3, 5, 6, 4)\n    \n    ";
static char __pyx_k_933[] = "roots (line 10526)";
static char __pyx_k_934[] = "Return the roots of a polynomial with coefficients given in p.\n\n    The values in the rank-1 array `p` are coefficients of a polynomial.\n    If the length of `p` is n+1 then the polynomial is described by::\n\n      p[0] * x**n + p[1] * x**(n-1) + ... + p[n-1]*x + p[n]\n\n    Parameters\n    ----------\n    p : array_like\n        Rank-1 array of polynomial coefficients.\n\n    Returns\n    -------\n    out : ndarray\n        An array containing the complex roots of the polynomial.\n\n    Raises\n    ------\n    ValueError :\n        When `p` cannot be converted to a rank-1 array.\n\n    See also\n    --------\n    poly : Find the coefficients of a polynomial with a given sequence\n           of roots.\n    polyval : Evaluate a polynomial at a point.\n    polyfit : Least squares polynomial fit.\n    poly1d : A one-dimensional polynomial class.\n\n    Notes\n    -----\n    The algorithm relies on computing the eigenvalues of the\n    companion matrix [1]_.\n\n    References\n    ----------\n    .. [1] R. A. Horn & C. R. Johnson, *Matrix Analysis*.  Cambridge, UK:\n        Cambridge University Press, 1999, pp. 146-7.\n\n    Examples\n    --------\n    >>> coeff = [3.2, 2, 1]\n    >>> np.roots(coeff)\n    array([-0.3125+0.46351241j, -0.3125-0.46351241j])\n    \n    ";
static char __pyx_k_935[] = "rot90 (line 10577)";
static char __pyx_k_936[] = "Rotate an array by 90 degrees in the counter-clockwise direction.\n\n    The first two dimensions are rotated; therefore, the array must be at\n    least 2-D.\n\n    Parameters\n    ----------\n    m : array_like\n        Array of two or more dimensions.\n    k : integer\n        Number of times the array is rotated by 90 degrees.\n\n    Returns\n    -------\n    y : ndarray\n        Rotated array.\n\n    See Also\n    --------\n    fliplr : Flip an array horizontally.\n    flipud : Flip an array vertically.\n\n    Examples\n    --------\n    >>> m = np.array([[1,2],[3,4]], int)\n    >>> m\n    array([[1, 2],\n           [3, 4]])\n    >>> np.rot90(m)\n    array([[2, 4],\n           [1, 3]])\n    >>> np.rot90(m, 2)\n    array([[4, 3],\n           [2, 1]])\n    \n    ";
static char __pyx_k_937[] = "row_stack (line 10643)";
static char __pyx_k_938[] = "Stack arrays in sequence vertically (row wise).\n\n    Take a sequence of arrays and stack them vertically to make a single\n    array. Rebuild arrays divided by `vsplit`.\n\n    Parameters\n    ----------\n    tup : sequence of ndarrays\n        Tuple containing arrays to be stacked. The arrays must have the same\n        shape along all but the first axis.\n\n    Returns\n    -------\n    stacked : ndarray\n        The array formed by stacking the given arrays.\n\n    See Also\n    --------\n    hstack : Stack arrays in sequence horizontally (column wise).\n    dstack : Stack arrays in sequence depth wise (along third dimension).\n    concatenate : Join a sequence of arrays together.\n    vsplit : Split array into a list of multiple sub-arrays vertically.\n\n\n    Notes\n    -----\n    Equivalent to ``np.concatenate(tup, axis=0)``\n\n    Examples\n    --------\n    >>> a = np.array([1, 2, 3])\n    >>> b = np.array([2, 3, 4])\n    >>> np.vstack((a,b))\n    array([[1, 2, 3],\n           [2, 3, 4]])\n\n    >>> a = np.array([[1], [2], [3]])\n    >>> b = np.array([[2], [3], [4]])\n    >>> np.vstack((a,b))\n    array([[1],\n           [2],\n           [3],\n           [2],\n           [3],\n           [4]])\n    \n    ";
static char __pyx_k_939[] = "safe_eval (line 10694)";
static char __pyx_k_940[] = "Protected string evaluation.\n\n    Evaluate a string containing a Python literal expression without\n    allowing the execution of arbitrary non-literal code.\n\n    Parameters\n    ----------\n    source : str\n        The string to evaluate.\n\n    Returns\n    -------\n    obj : object\n       The result of evaluating `source`.\n\n    Raises\n    ------\n    SyntaxError\n        If the code has invalid Python syntax, or if it contains non-literal\n        code.\n\n    Examples\n    --------\n    >>> np.safe_eval('1')\n    1\n    >>> np.safe_eval('[1, 2, 3]')\n    [1, 2, 3]\n    >>> np.safe_eval('{\"foo\": (\"bar\", 10.0)}')\n    {'foo': ('bar', 10.0)}\n\n    >>> np.safe_eval('import os')\n    Traceback (most recent call last):\n      ...\n    SyntaxError: invalid syntax\n\n    >>> np.safe_eval('open(\"/home/user/.ssh/id_dsa\").read()')\n    Traceback (most recent call last):\n      ...\n    SyntaxError: Unsupported source construct: compiler.ast.CallFunc\n    \n    ";
static char __pyx_k_941[] = "save (line 10739)";
static char __pyx_k_942[] = "Save an array to a binary file in NumPy ``.npy`` format.\n\n    Parameters\n    ----------\n    file : file or str\n        File or filename to which the data is saved.  If file is a file-object,\n        then the filename is unchanged.  If file is a string, a ``.npy``\n        extension will be appended to the file name if it does not already\n        have one.\n    arr : array_like\n        Array data to be saved.\n\n    See Also\n    --------\n    savez : Save several arrays into a ``.npz`` archive\n    savetxt, load\n\n    Notes\n    -----\n    For a description of the ``.npy`` format, see `format`.\n\n    Examples\n    --------\n    >>> from tempfile import TemporaryFile\n    >>> outfile = TemporaryFile()\n\n    >>> x = np.arange(10)\n    >>> np.save(outfile, x)\n\n    >>> outfile.seek(0) # Only needed here to simulate closing & reopening file\n    >>> np.load(outfile)\n    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n    \n    ";
static char __pyx_k_943[] = "savetxt (line 10777)";
static char __pyx_k_944[] = "Save an array to a text file.\n\n    Parameters\n    ----------\n    fname : filename or file handle\n        If the filename ends in ``.gz``, the file is automatically saved in\n        compressed gzip format.  `loadtxt` understands gzipped files\n        transparently.\n    X : array_like\n        Data to be saved to a text file.\n    fmt : str or sequence of strs\n        A single format (%10.5f), a sequence of formats, or a\n        multi-format string, e.g. 'Iteration %d -- %10.5f', in which\n        case `delimiter` is ignored.\n    delimiter : str\n        Character separating columns.\n    newline : str\n        .. versionadded:: 1.5.0\n\n        Character separating lines.\n\n\n    See Also\n    --------\n    save : Save an array to a binary file in NumPy ``.npy`` format\n    savez : Save several arrays into a ``.npz`` compressed archive\n\n    Notes\n    -----\n    Further explanation of the `fmt` parameter\n    (``%[flag]width[.precision]specifier``):\n\n    flags:\n        ``-`` : left justify\n\n        ``+`` : Forces to preceed result with + or -.\n\n        ``0`` : Left pad the number with zeros instead of space (see width).\n\n    width:\n        Minimum number of characters to be printed. The value is not truncated\n        if it has more characters.\n\n    precision:\n        - For integer specifiers (eg. ``d,i,o,x``), the minimum number of\n          digits.\n        - For ``e, E`` and ``f`` specifiers, the number of digits to print\n          after the decimal point.\n        - For ``g`` and ``G``, the maximum number of significant digits.\n        - For ``s``, the maximum number of characters.\n\n    specifiers:\n        ``c`` : character\n\n        ``d`` or ``i`` : signed decimal integer\n\n        ``e`` or ``E`` : scientific notation with ``e`` or ``E``.\n\n        ``f`` : decimal floating point\n\n        ``g,G`` : use the shorter of ``e,E`` or ``f``\n\n        ``o`` : signed octal\n\n        ``s`` : string of characters\n\n        ``u`` : un""signed decimal integer\n\n        ``x,X`` : unsigned hexadecimal integer\n\n    This explanation of ``fmt`` is not complete, for an exhaustive\n    specification see [1]_.\n\n    References\n    ----------\n    .. [1] `Format Specification Mini-Language\n           <http://docs.python.org/library/string.html#\n           format-specification-mini-language>`_, Python Documentation.\n\n    Examples\n    --------\n    >>> x = y = z = np.arange(0.0,5.0,1.0)\n    >>> np.savetxt('test.out', x, delimiter=',')   # X is an array\n    >>> np.savetxt('test.out', (x,y,z))   # x,y,z equal sized 1D arrays\n    >>> np.savetxt('test.out', x, fmt='%1.4e')   # use exponential notation\n    \n    ";
static char __pyx_k_945[] = "savez (line 10868)";
static char __pyx_k_946[] = "Save several arrays into a single file in uncompressed ``.npz`` format.\n\n    If arguments are passed in with no keywords, the corresponding variable\n    names, in the .npz file, are 'arr_0', 'arr_1', etc. If keyword arguments\n    are given, the corresponding variable names, in the ``.npz`` file will\n    match the keyword names.\n\n    Parameters\n    ----------\n    file : str or file\n        Either the file name (string) or an open file (file-like object)\n        where the data will be saved. If file is a string, the ``.npz``\n        extension will be appended to the file name if it is not already there.\n    *args : Arguments, optional\n        Arrays to save to the file. Since it is not possible for Python to\n        know the names of the arrays outside `savez`, the arrays will be saved\n        with names \"arr_0\", \"arr_1\", and so on. These arguments can be any\n        expression.\n    **kwds : Keyword arguments, optional\n        Arrays to save to the file. Arrays will be saved in the file with the\n        keyword names.\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    save : Save a single array to a binary file in NumPy format.\n    savetxt : Save an array to a file as plain text.\n\n    Notes\n    -----\n    The ``.npz`` file format is a zipped archive of files named after the\n    variables they contain.  The archive is not compressed and each file\n    in the archive contains one variable in ``.npy`` format. For a\n    description of the ``.npy`` format, see `format`.\n\n    When opening the saved ``.npz`` file with `load` a `NpzFile` object is\n    returned. This is a dictionary-like object which can be queried for\n    its list of arrays (with the ``.files`` attribute), and for the arrays\n    themselves.\n\n    Examples\n    --------\n    >>> from tempfile import TemporaryFile\n    >>> outfile = TemporaryFile()\n    >>> x = np.arange(10)\n    >>> y = np.sin(x)\n\n    Using `savez` with *args, the arrays are saved wit""h default names.\n\n    >>> np.savez(outfile, x, y)\n    >>> outfile.seek(0) # Only needed here to simulate closing & reopening file\n    >>> npzfile = np.load(outfile)\n    >>> npzfile.files\n    ['arr_1', 'arr_0']\n    >>> npzfile['arr_0']\n    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n    Using `savez` with **kwds, the arrays are saved with the keyword names.\n\n    >>> outfile = TemporaryFile()\n    >>> np.savez(outfile, x=x, y=y)\n    >>> outfile.seek(0)\n    >>> npzfile = np.load(outfile)\n    >>> npzfile.files\n    ['y', 'x']\n    >>> npzfile['x']\n    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n    See Also\n    --------\n    numpy.savez_compressed : Save several arrays into a compressed .npz file format\n    \n    ";
static char __pyx_k_947[] = "sctype2char (line 10972)";
static char __pyx_k_948[] = "Return the string representation of a scalar dtype.\n\n    Parameters\n    ----------\n    sctype : scalar dtype or object\n        If a scalar dtype, the corresponding string character is\n        returned. If an object, `sctype2char` tries to infer its scalar type\n        and then return the corresponding string character.\n\n    Returns\n    -------\n    typechar : str\n        The string character corresponding to the scalar type.\n\n    Raises\n    ------\n    ValueError\n        If `sctype` is an object for which the type can not be inferred.\n\n    See Also\n    --------\n    obj2sctype, issctype, issubsctype, mintypecode\n\n    Examples\n    --------\n    >>> for sctype in [np.int32, np.float, np.complex, np.string_, np.ndarray]:\n    ...     print np.sctype2char(sctype)\n    l\n    d\n    D\n    S\n    O\n\n    >>> x = np.array([1., 2-1.j])\n    >>> np.sctype2char(x)\n    'D'\n    >>> np.sctype2char(list)\n    'O'\n    \n    ";
static char __pyx_k_949[] = "searchsorted (line 11016)";
static char __pyx_k_950[] = "Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `a` such that, if the corresponding\n    elements in `v` were inserted before the indices, the order of `a` would\n    be preserved.\n\n    Parameters\n    ----------\n    a : 1-D array_like\n        Input array, sorted in ascending order.\n    v : array_like\n        Values to insert into `a`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.  If\n        'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `a`).\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `v`.\n\n    See Also\n    --------\n    sort : Return a sorted copy of an array.\n    histogram : Produce histogram from 1-D data.\n\n    Notes\n    -----\n    Binary search is used to find the required insertion points.\n\n    As of Numpy 1.4.0 `searchsorted` works with real/complex arrays containing\n    `nan` values. The enhanced sort order is documented in `sort`.\n\n    Examples\n    --------\n    >>> np.searchsorted([1,2,3,4,5], 3)\n    2\n    >>> np.searchsorted([1,2,3,4,5], 3, side='right')\n    3\n    >>> np.searchsorted([1,2,3,4,5], [-10, 10, 2, 3])\n    array([0, 5, 1, 2])\n    \n    ";
static char __pyx_k_951[] = "select (line 11064)";
static char __pyx_k_952[] = "Return an array drawn from elements in choicelist, depending on conditions.\n\n    Parameters\n    ----------\n    condlist : list of bool ndarrays\n        The list of conditions which determine from which array in `choicelist`\n        the output elements are taken. When multiple conditions are satisfied,\n        the first one encountered in `condlist` is used.\n    choicelist : list of ndarrays\n        The list of arrays from which the output elements are taken. It has\n        to be of the same length as `condlist`.\n    default : scalar, optional\n        The element inserted in `output` when all conditions evaluate to False.\n\n    Returns\n    -------\n    output : ndarray\n        The output at position m is the m-th element of the array in\n        `choicelist` where the m-th element of the corresponding array in\n        `condlist` is True.\n\n    See Also\n    --------\n    where : Return elements from one of two arrays depending on condition.\n    take, choose, compress, diag, diagonal\n\n    Examples\n    --------\n    >>> x = np.arange(10)\n    >>> condlist = [x<3, x>5]\n    >>> choicelist = [x, x**2]\n    >>> np.select(condlist, choicelist)\n    array([ 0,  1,  2,  0,  0,  0, 36, 49, 64, 81])\n    \n    ";
static char __pyx_k_953[] = "set_numeric_ops (line 11103)";
static char __pyx_k_954[] = "set_numeric_ops(op1=func1, op2=func2, ...)\n\n    Set numerical operators for array objects.\n\n    Parameters\n    ----------\n    op1, op2, ... : callable\n        Each ``op = func`` pair describes an operator to be replaced.\n        For example, ``add = lambda x, y: np.add(x, y) % 5`` would replace\n        addition by modulus 5 addition.\n\n    Returns\n    -------\n    saved_ops : list of callables\n        A list of all operators, stored before making replacements.\n\n    Notes\n    -----\n    .. WARNING::\n       Use with care!  Incorrect usage may lead to memory errors.\n\n    A function replacing an operator cannot make use of that operator.\n    For example, when replacing add, you may not use ``+``.  Instead,\n    directly call ufuncs.\n\n    Examples\n    --------\n    >>> def add_mod5(x, y):\n    ...     return np.add(x, y) % 5\n    ...\n    >>> old_funcs = np.set_numeric_ops(add=add_mod5)\n\n    >>> x = np.arange(12).reshape((3, 4))\n    >>> x + x\n    array([[0, 2, 4, 1],\n           [3, 0, 2, 4],\n           [1, 3, 0, 2]])\n\n    >>> ignore = np.set_numeric_ops(**old_funcs) # restore operators\n    \n    ";
static char __pyx_k_955[] = "set_printoptions (line 11149)";
static char __pyx_k_956[] = "Set printing options.\n\n    These options determine the way floating point numbers, arrays and\n    other NumPy objects are displayed.\n\n    Parameters\n    ----------\n    precision : int, optional\n        Number of digits of precision for floating point output (default 8).\n    threshold : int, optional\n        Total number of array elements which trigger summarization\n        rather than full repr (default 1000).\n    edgeitems : int, optional\n        Number of array items in summary at beginning and end of\n        each dimension (default 3).\n    linewidth : int, optional\n        The number of characters per line for the purpose of inserting\n        line breaks (default 75).\n    suppress : bool, optional\n        Whether or not suppress printing of small floating point values\n        using scientific notation (default False).\n    nanstr : str, optional\n        String representation of floating point not-a-number (default nan).\n    infstr : str, optional\n        String representation of floating point infinity (default inf).\n\n    See Also\n    --------\n    get_printoptions, set_string_function\n\n    Examples\n    --------\n    Floating point precision can be set:\n\n    >>> np.set_printoptions(precision=4)\n    >>> print np.array([1.123456789])\n    [ 1.1235]\n\n    Long arrays can be summarised:\n\n    >>> np.set_printoptions(threshold=5)\n    >>> print np.arange(10)\n    [0 1 2 ..., 7 8 9]\n\n    Small results can be suppressed:\n\n    >>> eps = np.finfo(float).eps\n    >>> x = np.arange(4.)\n    >>> x**2 - (x + eps)**2\n    array([ -4.9304e-32,  -4.4409e-16,   0.0000e+00,   0.0000e+00])\n    >>> np.set_printoptions(suppress=True)\n    >>> x**2 - (x + eps)**2\n    array([-0., -0.,  0.,  0.])\n\n    To put back the default options, you can use:\n\n    >>> np.set_printoptions(edgeitems=3,infstr='Inf',\n    ... linewidth=75, nanstr='NaN', precision=8,\n    ... suppress=False, threshold=1000)\n    \n    ";
static char __pyx_k_957[] = "set_string_function (line 11214)";
static char __pyx_k_958[] = "Set a Python function to be used when pretty printing arrays.\n\n    Parameters\n    ----------\n    f : function or None\n        Function to be used to pretty print arrays. The function should expect\n        a single array argument and return a string of the representation of\n        the array. If None, the function is reset to the default NumPy function\n        to print arrays.\n    repr : bool, optional\n        If True (default), the function for pretty printing (``__repr__``)\n        is set, if False the function that returns the default string\n        representation (``__str__``) is set.\n\n    See Also\n    --------\n    set_printoptions, get_printoptions\n\n    Examples\n    --------\n    >>> def pprint(arr):\n    ...     return 'HA! - What are you going to do now?'\n    ...\n    >>> np.set_string_function(pprint)\n    >>> a = np.arange(10)\n    >>> a\n    HA! - What are you going to do now?\n    >>> print a\n    [0 1 2 3 4 5 6 7 8 9]\n\n    We can reset the function to the default:\n\n    >>> np.set_string_function(None)\n    >>> a\n    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n    `repr` affects either pretty printing or normal string representation.\n    Note that ``__repr__`` is still affected by setting ``__str__``\n    because the width of each array element in the returned string becomes\n    equal to the length of the result of ``__str__()``.\n\n    >>> x = np.arange(4)\n    >>> np.set_string_function(lambda x:'random', repr=False)\n    >>> x.__str__()\n    'random'\n    >>> x.__repr__()\n    'array([     0,      1,      2,      3])'\n    \n    ";
static char __pyx_k_959[] = "setdiff1d (line 11279)";
static char __pyx_k_960[] = "Find the set difference of two arrays.\n\n    Return the sorted, unique values in `ar1` that are not in `ar2`.\n\n    Parameters\n    ----------\n    ar1 : array_like\n        Input array.\n    ar2 : array_like\n        Input comparison array.\n    assume_unique : bool\n        If True, the input arrays are both assumed to be unique, which\n        can speed up the calculation.  Default is False.\n\n    Returns\n    -------\n    difference : ndarray\n        Sorted 1D array of values in `ar1` that are not in `ar2`.\n\n    See Also\n    --------\n    numpy.lib.arraysetops : Module with a number of other functions for\n                            performing set operations on arrays.\n\n    Examples\n    --------\n    >>> a = np.array([1, 2, 3, 2, 4, 1])\n    >>> b = np.array([3, 4, 5, 6])\n    >>> np.setdiff1d(a, b)\n    array([1, 2])\n    \n    ";
static char __pyx_k_961[] = "seterr (line 11315)";
static char __pyx_k_962[] = "Set how floating-point errors are handled.\n\n    Note that operations on integer scalar types (such as `int16`) are\n    handled like floating point, and are affected by these settings.\n\n    Parameters\n    ----------\n    all : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional\n        Set treatment for all types of floating-point errors at once:\n\n        - ignore: Take no action when the exception occurs.\n        - warn: Print a `RuntimeWarning` (via the Python `warnings` module).\n        - raise: Raise a `FloatingPointError`.\n        - call: Call a function specified using the `seterrcall` function.\n        - print: Print a warning directly to ``stdout``.\n        - log: Record error in a Log object specified by `seterrcall`.\n\n        The default is not to change the current behavior.\n    divide : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional\n        Treatment for division by zero.\n    over : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional\n        Treatment for floating-point overflow.\n    under : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional\n        Treatment for floating-point underflow.\n    invalid : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional\n        Treatment for invalid floating-point operation.\n\n    Returns\n    -------\n    old_settings : dict\n        Dictionary containing the old settings.\n\n    See also\n    --------\n    seterrcall : Set a callback function for the 'call' mode.\n    geterr, geterrcall\n\n    Notes\n    -----\n    The floating-point exceptions are defined in the IEEE 754 standard [1]:\n\n    - Division by zero: infinite result obtained from finite numbers.\n    - Overflow: result too large to be expressed.\n    - Underflow: result so close to zero that some precision\n      was lost.\n    - Invalid operation: result is not an expressible number, typically\n      indicates that a NaN was produced.\n\n    .. [1] http://en.wikipedia.org/wiki/""IEEE_754\n\n    Examples\n    --------\n    >>> old_settings = np.seterr(all='ignore')  #seterr to known value\n    >>> np.seterr(over='raise')\n    {'over': 'ignore', 'divide': 'ignore', 'invalid': 'ignore',\n     'under': 'ignore'}\n    >>> np.seterr(all='ignore')  # reset to default\n    {'over': 'raise', 'divide': 'ignore', 'invalid': 'ignore', 'under': 'ignore'}\n\n    >>> np.int16(32000) * np.int16(3)\n    30464\n    >>> old_settings = np.seterr(all='warn', over='raise')\n    >>> np.int16(32000) * np.int16(3)\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    FloatingPointError: overflow encountered in short_scalars\n\n    >>> old_settings = np.seterr(all='print')\n    >>> np.geterr()\n    {'over': 'print', 'divide': 'print', 'invalid': 'print', 'under': 'print'}\n    >>> np.int16(32000) * np.int16(3)\n    Warning: overflow encountered in short_scalars\n    30464\n    \n    ";
static char __pyx_k_963[] = "seterrcall (line 11394)";
static char __pyx_k_964[] = "Set the floating-point error callback function or log object.\n\n    There are two ways to capture floating-point error messages.  The first\n    is to set the error-handler to 'call', using `seterr`.  Then, set\n    the function to call using this function.\n\n    The second is to set the error-handler to 'log', using `seterr`.\n    Floating-point errors then trigger a call to the 'write' method of\n    the provided object.\n\n    Parameters\n    ----------\n    func : callable f(err, flag) or object with write method\n        Function to call upon floating-point errors ('call'-mode) or\n        object whose 'write' method is used to log such message ('log'-mode).\n\n        The call function takes two arguments. The first is the\n        type of error (one of \"divide\", \"over\", \"under\", or \"invalid\"),\n        and the second is the status flag.  The flag is a byte, whose\n        least-significant bits indicate the status::\n\n          [0 0 0 0 invalid over under invalid]\n\n        In other words, ``flags = divide + 2*over + 4*under + 8*invalid``.\n\n        If an object is provided, its write method should take one argument,\n        a string.\n\n    Returns\n    -------\n    h : callable, log instance or None\n        The old error handler.\n\n    See Also\n    --------\n    seterr, geterr, geterrcall\n\n    Examples\n    --------\n    Callback upon error:\n\n    >>> def err_handler(type, flag):\n    ...     print \"Floating point error (%s), with flag %s\" % (type, flag)\n    ...\n\n    >>> saved_handler = np.seterrcall(err_handler)\n    >>> save_err = np.seterr(all='call')\n\n    >>> np.array([1, 2, 3]) / 0.0\n    Floating point error (divide by zero), with flag 1\n    array([ Inf,  Inf,  Inf])\n\n    >>> np.seterrcall(saved_handler)\n    <function err_handler at 0x...>\n    >>> np.seterr(**save_err)\n    {'over': 'call', 'divide': 'call', 'invalid': 'call', 'under': 'call'}\n\n    Log error message:\n\n    >>> class Log(object):\n    ...     def writ""e(self, msg):\n    ...         print \"LOG: %s\" % msg\n    ...\n\n    >>> log = Log()\n    >>> saved_handler = np.seterrcall(log)\n    >>> save_err = np.seterr(all='log')\n\n    >>> np.array([1, 2, 3]) / 0.0\n    LOG: Warning: divide by zero encountered in divide\n    <BLANKLINE>\n    array([ Inf,  Inf,  Inf])\n\n    >>> np.seterrcall(saved_handler)\n    <__main__.Log object at 0x...>\n    >>> np.seterr(**save_err)\n    {'over': 'log', 'divide': 'log', 'invalid': 'log', 'under': 'log'}\n    \n    ";
static char __pyx_k_965[] = "seterrobj (line 11477)";
static char __pyx_k_966[] = "seterrobj(errobj)\n\n    Set the object that defines floating-point error handling.\n\n    The error object contains all information that defines the error handling\n    behavior in Numpy. `seterrobj` is used internally by the other\n    functions that set error handling behavior (`seterr`, `seterrcall`).\n\n    Parameters\n    ----------\n    errobj : list\n        The error object, a list containing three elements:\n        [internal numpy buffer size, error mask, error callback function].\n\n        The error mask is a single integer that holds the treatment information\n        on all four floating point errors. The information for each error type\n        is contained in three bits of the integer. If we print it in base 8, we\n        can see what treatment is set for \"invalid\", \"under\", \"over\", and\n        \"divide\" (in that order). The printed string can be interpreted with\n\n        * 0 : 'ignore'\n        * 1 : 'warn'\n        * 2 : 'raise'\n        * 3 : 'call'\n        * 4 : 'print'\n        * 5 : 'log'\n\n    See Also\n    --------\n    geterrobj, seterr, geterr, seterrcall, geterrcall\n    getbufsize, setbufsize\n\n    Notes\n    -----\n    For complete documentation of the types of floating-point exceptions and\n    treatment options, see `seterr`.\n\n    Examples\n    --------\n    >>> old_errobj = np.geterrobj()  # first get the defaults\n    >>> old_errobj\n    [10000, 0, None]\n\n    >>> def err_handler(type, flag):\n    ...     print \"Floating point error (%s), with flag %s\" % (type, flag)\n    ...\n    >>> new_errobj = [20000, 12, err_handler]\n    >>> np.seterrobj(new_errobj)\n    >>> np.base_repr(12, 8)  # int for divide=4 ('print') and over=1 ('warn')\n    '14'\n    >>> np.geterr()\n    {'over': 'warn', 'divide': 'print', 'invalid': 'ignore', 'under': 'ignore'}\n    >>> np.geterrcall() is err_handler\n    True\n    \n    ";
static char __pyx_k_967[] = "setxor1d (line 11538)";
static char __pyx_k_968[] = "Find the set exclusive-or of two arrays.\n\n    Return the sorted, unique values that are in only one (not both) of the\n    input arrays.\n\n    Parameters\n    ----------\n    ar1, ar2 : array_like\n        Input arrays.\n    assume_unique : bool\n        If True, the input arrays are both assumed to be unique, which\n        can speed up the calculation.  Default is False.\n\n    Returns\n    -------\n    xor : ndarray\n        Sorted 1D array of unique values that are in only one of the input\n        arrays.\n\n    Examples\n    --------\n    >>> a = np.array([1, 2, 3, 2, 4])\n    >>> b = np.array([2, 3, 5, 7, 5])\n    >>> np.setxor1d(a,b)\n    array([1, 4, 5, 7])\n    \n    ";
static char __pyx_k_969[] = "sinc (line 11576)";
static char __pyx_k_970[] = "Return the sinc function.\n\n    The sinc function is :math:`\\sin(\\pi x)/(\\pi x)`.\n\n    Parameters\n    ----------\n    x : ndarray\n        Array (possibly multi-dimensional) of values for which to to\n        calculate ``sinc(x)``.\n\n    Returns\n    -------\n    out : ndarray\n        ``sinc(x)``, which has the same shape as the input.\n\n    Notes\n    -----\n    ``sinc(0)`` is the limit value 1.\n\n    The name sinc is short for \"sine cardinal\" or \"sinus cardinalis\".\n\n    The sinc function is used in various signal processing applications,\n    including in anti-aliasing, in the construction of a\n    Lanczos resampling filter, and in interpolation.\n\n    For bandlimited interpolation of discrete-time signals, the ideal\n    interpolation kernel is proportional to the sinc function.\n\n    References\n    ----------\n    .. [1] Weisstein, Eric W. \"Sinc Function.\" From MathWorld--A Wolfram Web\n           Resource. http://mathworld.wolfram.com/SincFunction.html\n    .. [2] Wikipedia, \"Sinc function\",\n           http://en.wikipedia.org/wiki/Sinc_function\n\n    Examples\n    --------\n    >>> x = np.arange(-20., 21.)/5.\n    >>> np.sinc(x)\n    array([ -3.89804309e-17,  -4.92362781e-02,  -8.40918587e-02,\n            -8.90384387e-02,  -5.84680802e-02,   3.89804309e-17,\n             6.68206631e-02,   1.16434881e-01,   1.26137788e-01,\n             8.50444803e-02,  -3.89804309e-17,  -1.03943254e-01,\n            -1.89206682e-01,  -2.16236208e-01,  -1.55914881e-01,\n             3.89804309e-17,   2.33872321e-01,   5.04551152e-01,\n             7.56826729e-01,   9.35489284e-01,   1.00000000e+00,\n             9.35489284e-01,   7.56826729e-01,   5.04551152e-01,\n             2.33872321e-01,   3.89804309e-17,  -1.55914881e-01,\n            -2.16236208e-01,  -1.89206682e-01,  -1.03943254e-01,\n            -3.89804309e-17,   8.50444803e-02,   1.26137788e-01,\n             1.16434881e-01,   6.68206631e-02,   3.89804309e-17,\n            -5.84680802e-02,""  -8.90384387e-02,  -8.40918587e-02,\n            -4.92362781e-02,  -3.89804309e-17])\n\n    >>> import matplotlib.pyplot as plt\n    >>> plt.plot(x, np.sinc(x))\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Sinc Function\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.ylabel(\"Amplitude\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.xlabel(\"X\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.show()\n\n    It works in 2-D as well:\n\n    >>> x = np.arange(-200., 201.)/50.\n    >>> xx = np.outer(x, x)\n    >>> plt.imshow(np.sinc(xx))\n    <matplotlib.image.AxesImage object at 0x...>\n    \n    ";
static char __pyx_k_971[] = "size (line 11653)";
static char __pyx_k_972[] = "Return the number of elements along a given axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    axis : int, optional\n        Axis along which the elements are counted.  By default, give\n        the total number of elements.\n\n    Returns\n    -------\n    element_count : int\n        Number of elements along the specified axis.\n\n    See Also\n    --------\n    shape : dimensions of array\n    ndarray.shape : dimensions of array\n    ndarray.size : number of elements in array\n\n    Examples\n    --------\n    >>> a = np.array([[1,2,3],[4,5,6]])\n    >>> np.size(a)\n    6\n    >>> np.size(a,1)\n    3\n    >>> np.size(a,0)\n    2\n    \n    ";
static char __pyx_k_973[] = "sort (line 11702)";
static char __pyx_k_974[] = "Return a sorted copy of an array.\n\n    Parameters\n    ----------\n    a : array_like\n        Array to be sorted.\n    axis : int or None, optional\n        Axis along which to sort. If None, the array is flattened before\n        sorting. The default is -1, which sorts along the last axis.\n    kind : {'quicksort', 'mergesort', 'heapsort'}, optional\n        Sorting algorithm. Default is 'quicksort'.\n    order : list, optional\n        When `a` is a structured array, this argument specifies which fields\n        to compare first, second, and so on.  This list does not need to\n        include all of the fields.\n\n    Returns\n    -------\n    sorted_array : ndarray\n        Array of the same type and shape as `a`.\n\n    See Also\n    --------\n    ndarray.sort : Method to sort an array in-place.\n    argsort : Indirect sort.\n    lexsort : Indirect stable sort on multiple keys.\n    searchsorted : Find elements in a sorted array.\n\n    Notes\n    -----\n    The various sorting algorithms are characterized by their average speed,\n    worst case performance, work space size, and whether they are stable. A\n    stable sort keeps items with the same key in the same relative\n    order. The three available algorithms have the following\n    properties:\n\n    =========== ======= ============= ============ =======\n       kind      speed   worst case    work space  stable\n    =========== ======= ============= ============ =======\n    'quicksort'    1     O(n^2)            0          no\n    'mergesort'    2     O(n*log(n))      ~n/2        yes\n    'heapsort'     3     O(n*log(n))       0          no\n    =========== ======= ============= ============ =======\n\n    All the sort algorithms make temporary copies of the data when\n    sorting along any but the last axis.  Consequently, sorting along\n    the last axis is faster and uses less space than sorting along\n    any other axis.\n\n    The sort order for complex numbers is lexicographic. If both the real""\n    and imaginary parts are non-nan then the order is determined by the\n    real parts except when they are equal, in which case the order is\n    determined by the imaginary parts.\n\n    Previous to numpy 1.4.0 sorting real and complex arrays containing nan\n    values led to undefined behaviour. In numpy versions >= 1.4.0 nan\n    values are sorted to the end. The extended sort order is:\n\n      * Real: [R, nan]\n      * Complex: [R + Rj, R + nanj, nan + Rj, nan + nanj]\n\n    where R is a non-nan real value. Complex values with the same nan\n    placements are sorted according to the non-nan part if it exists.\n    Non-nan values are sorted as before.\n\n    Examples\n    --------\n    >>> a = np.array([[1,4],[3,1]])\n    >>> np.sort(a)                # sort along the last axis\n    array([[1, 4],\n           [1, 3]])\n    >>> np.sort(a, axis=None)     # sort the flattened array\n    array([1, 1, 3, 4])\n    >>> np.sort(a, axis=0)        # sort along the first axis\n    array([[1, 1],\n           [3, 4]])\n\n    Use the `order` keyword to specify a field to use when sorting a\n    structured array:\n\n    >>> dtype = [('name', 'S10'), ('height', float), ('age', int)]\n    >>> values = [('Arthur', 1.8, 41), ('Lancelot', 1.9, 38),\n    ...           ('Galahad', 1.7, 38)]\n    >>> a = np.array(values, dtype=dtype)       # create a structured array\n    >>> np.sort(a, order='height')                        # doctest: +SKIP\n    array([('Galahad', 1.7, 38), ('Arthur', 1.8, 41),\n           ('Lancelot', 1.8999999999999999, 38)],\n          dtype=[('name', '|S10'), ('height', '<f8'), ('age', '<i4')])\n\n    Sort by age, then height if ages are equal:\n\n    >>> np.sort(a, order=['age', 'height'])               # doctest: +SKIP\n    array([('Galahad', 1.7, 38), ('Lancelot', 1.8999999999999999, 38),\n           ('Arthur', 1.8, 41)],\n          dtype=[('name', '|S10'), ('height', '<f8'), ('age', '<i4')])\n    \n    ";
static char __pyx_k_975[] = "sort_complex (line 11803)";
static char __pyx_k_976[] = "Sort a complex array using the real part first, then the imaginary part.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array\n\n    Returns\n    -------\n    out : complex ndarray\n        Always returns a sorted complex array.\n\n    Examples\n    --------\n    >>> np.sort_complex([5, 3, 6, 2, 1])\n    array([ 1.+0.j,  2.+0.j,  3.+0.j,  5.+0.j,  6.+0.j])\n\n    >>> np.sort_complex([1 + 2j, 2 - 1j, 3 - 2j, 3 - 3j, 3 + 5j])\n    array([ 1.+2.j,  2.-1.j,  3.-3.j,  3.-2.j,  3.+5.j])\n    \n    ";
static char __pyx_k_977[] = "source (line 11828)";
static char __pyx_k_978[] = "Print or write to a file the source code for a Numpy object.\n\n    The source code is only returned for objects written in Python. Many\n    functions and classes are defined in C and will therefore not return\n    useful information.\n\n    Parameters\n    ----------\n    object : numpy object\n        Input object. This can be any object (function, class, module, ...).\n    output : file object, optional\n        If `output` not supplied then source code is printed to screen\n        (sys.stdout).  File object must be created with either write 'w' or\n        append 'a' modes.\n\n    See Also\n    --------\n    lookfor, info\n\n    Examples\n    --------\n    >>> np.source(np.interp)                        #doctest: +SKIP\n    In file: /usr/lib/python2.6/dist-packages/numpy/lib/function_base.py\n    def interp(x, xp, fp, left=None, right=None):\n        '''.... (full docstring printed)'''\n        if isinstance(x, (float, int, number)):\n            return compiled_interp([x], xp, fp, left, right).item()\n        else:\n            return compiled_interp(x, xp, fp, left, right)\n\n    The source code is only returned for objects written in Python.\n\n    >>> np.source(np.array)                         #doctest: +SKIP\n    Not available for this object.\n    \n    ";
static char __pyx_k_979[] = "split (line 11868)";
static char __pyx_k_980[] = "Split an array into multiple sub-arrays of equal size.\n\n    Parameters\n    ----------\n    ary : ndarray\n        Array to be divided into sub-arrays.\n    indices_or_sections : int or 1-D array\n        If `indices_or_sections` is an integer, N, the array will be divided\n        into N equal arrays along `axis`.  If such a split is not possible,\n        an error is raised.\n\n        If `indices_or_sections` is a 1-D array of sorted integers, the entries\n        indicate where along `axis` the array is split.  For example,\n        ``[2, 3]`` would, for ``axis=0``, result in\n\n          - ary[:2]\n          - ary[2:3]\n          - ary[3:]\n\n        If an index exceeds the dimension of the array along `axis`,\n        an empty sub-array is returned correspondingly.\n    axis : int, optional\n        The axis along which to split, default is 0.\n\n    Returns\n    -------\n    sub-arrays : list of ndarrays\n        A list of sub-arrays.\n\n    Raises\n    ------\n    ValueError\n        If `indices_or_sections` is given as an integer, but\n        a split does not result in equal division.\n\n    See Also\n    --------\n    array_split : Split an array into multiple sub-arrays of equal or\n                  near-equal size.  Does not raise an exception if\n                  an equal division cannot be made.\n    hsplit : Split array into multiple sub-arrays horizontally (column-wise).\n    vsplit : Split array into multiple sub-arrays vertically (row wise).\n    dsplit : Split array into multiple sub-arrays along the 3rd axis (depth).\n    concatenate : Join arrays together.\n    hstack : Stack arrays in sequence horizontally (column wise).\n    vstack : Stack arrays in sequence vertically (row wise).\n    dstack : Stack arrays in sequence depth wise (along third dimension).\n\n    Examples\n    --------\n    >>> x = np.arange(9.0)\n    >>> np.split(x, 3)\n    [array([ 0.,  1.,  2.]), array([ 3.,  4.,  5.]), array([ 6.,  7.,  8.])]\n\n    >>> x = np.arange(8.""0)\n    >>> np.split(x, [3, 5, 6, 10])\n    [array([ 0.,  1.,  2.]),\n     array([ 3.,  4.]),\n     array([ 5.]),\n     array([ 6.,  7.]),\n     array([], dtype=float64)]\n    \n    ";
static char __pyx_k_981[] = "squeeze (line 11935)";
static char __pyx_k_982[] = "Remove single-dimensional entries from the shape of an array.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n\n    Returns\n    -------\n    squeezed : ndarray\n        The input array, but with with all dimensions of length 1\n        removed.  Whenever possible, a view on `a` is returned.\n\n    Examples\n    --------\n    >>> x = np.array([[[0], [1], [2]]])\n    >>> x.shape\n    (1, 3, 1)\n    >>> np.squeeze(x).shape\n    (3,)\n    \n    ";
static char __pyx_k_983[] = "std (line 11961)";
static char __pyx_k_984[] = "Compute the standard deviation along the specified axis.\n\n    Returns the standard deviation, a measure of the spread of a distribution,\n    of the array elements. The standard deviation is computed for the\n    flattened array by default, otherwise over the specified axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Calculate the standard deviation of these values.\n    axis : int, optional\n        Axis along which the standard deviation is computed. The default is\n        to compute the standard deviation of the flattened array.\n    dtype : dtype, optional\n        Type to use in computing the standard deviation. For arrays of\n        integer type the default is float64, for arrays of float types it is\n        the same as the array type.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must have\n        the same shape as the expected output but the type (of the calculated\n        values) will be cast if necessary.\n    ddof : int, optional\n        Means Delta Degrees of Freedom.  The divisor used in calculations\n        is ``N - ddof``, where ``N`` represents the number of elements.\n        By default `ddof` is zero.\n\n    Returns\n    -------\n    standard_deviation : ndarray, see dtype parameter above.\n        If `out` is None, return a new array containing the standard deviation,\n        otherwise return a reference to the output array.\n\n    See Also\n    --------\n    var, mean\n    numpy.doc.ufuncs : Section \"Output arguments\"\n\n    Notes\n    -----\n    The standard deviation is the square root of the average of the squared\n    deviations from the mean, i.e., ``std = sqrt(mean(abs(x - x.mean())**2))``.\n\n    The average squared deviation is normally calculated as ``x.sum() / N``, where\n    ``N = len(x)``.  If, however, `ddof` is specified, the divisor ``N - ddof``\n    is used instead. In standard statistical practice, ``ddof=1`` provides an\n    unbiased estimator of t""he variance of the infinite population. ``ddof=0``\n    provides a maximum likelihood estimate of the variance for normally\n    distributed variables. The standard deviation computed in this function\n    is the square root of the estimated variance, so even with ``ddof=1``, it\n    will not be an unbiased estimate of the standard deviation per se.\n\n    Note that, for complex numbers, `std` takes the absolute\n    value before squaring, so that the result is always real and nonnegative.\n\n    For floating-point input, the *std* is computed using the same\n    precision the input has. Depending on the input data, this can cause\n    the results to be inaccurate, especially for float32 (see example below).\n    Specifying a higher-accuracy accumulator using the `dtype` keyword can\n    alleviate this issue.\n\n    Examples\n    --------\n    >>> a = np.array([[1, 2], [3, 4]])\n    >>> np.std(a)\n    1.1180339887498949\n    >>> np.std(a, axis=0)\n    array([ 1.,  1.])\n    >>> np.std(a, axis=1)\n    array([ 0.5,  0.5])\n\n    In single precision, std() can be inaccurate:\n\n    >>> a = np.zeros((2,512*512), dtype=np.float32)\n    >>> a[0,:] = 1.0\n    >>> a[1,:] = 0.1\n    >>> np.std(a)\n    0.45172946707416706\n\n    Computing the standard deviation in float64 is more accurate:\n\n    >>> np.std(a, dtype=np.float64)\n    0.44999999925552653\n    \n    ";
static char __pyx_k_985[] = "sum (line 12049)";
static char __pyx_k_986[] = "Sum of array elements over a given axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Elements to sum.\n    axis : integer, optional\n        Axis over which the sum is taken. By default `axis` is None,\n        and all elements are summed.\n    dtype : dtype, optional\n        The type of the returned array and of the accumulator in which\n        the elements are summed.  By default, the dtype of `a` is used.\n        An exception is when `a` has an integer type with less precision\n        than the default platform integer.  In that case, the default\n        platform integer is used instead.\n    out : ndarray, optional\n        Array into which the output is placed.  By default, a new array is\n        created.  If `out` is given, it must be of the appropriate shape\n        (the shape of `a` with `axis` removed, i.e.,\n        ``numpy.delete(a.shape, axis)``).  Its type is preserved. See\n        `doc.ufuncs` (Section \"Output arguments\") for more details.\n\n    Returns\n    -------\n    sum_along_axis : ndarray\n        An array with the same shape as `a`, with the specified\n        axis removed.   If `a` is a 0-d array, or if `axis` is None, a scalar\n        is returned.  If an output array is specified, a reference to\n        `out` is returned.\n\n    See Also\n    --------\n    ndarray.sum : Equivalent method.\n\n    cumsum : Cumulative sum of array elements.\n\n    trapz : Integration of array values using the composite trapezoidal rule.\n\n    mean, average\n\n    Notes\n    -----\n    Arithmetic is modular when using integer types, and no error is\n    raised on overflow.\n\n    Examples\n    --------\n    >>> np.sum([0.5, 1.5])\n    2.0\n    >>> np.sum([0.5, 0.7, 0.2, 1.5], dtype=np.int32)\n    1\n    >>> np.sum([[0, 1], [0, 5]])\n    6\n    >>> np.sum([[0, 1], [0, 5]], axis=0)\n    array([0, 6])\n    >>> np.sum([[0, 1], [0, 5]], axis=1)\n    array([1, 5])\n\n    If the accumulator is too small, overflow occurs:\n\n    >>> np.one""s(128, dtype=np.int8).sum(dtype=np.int8)\n    -128\n    \n    ";
static char __pyx_k_987[] = "swapaxes (line 12117)";
static char __pyx_k_988[] = "Interchange two axes of an array.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    axis1 : int\n        First axis.\n    axis2 : int\n        Second axis.\n\n    Returns\n    -------\n    a_swapped : ndarray\n        If `a` is an ndarray, then a view of `a` is returned; otherwise\n        a new array is created.\n\n    Examples\n    --------\n    >>> x = np.array([[1,2,3]])\n    >>> np.swapaxes(x,0,1)\n    array([[1],\n           [2],\n           [3]])\n\n    >>> x = np.array([[[0,1],[2,3]],[[4,5],[6,7]]])\n    >>> x\n    array([[[0, 1],\n            [2, 3]],\n           [[4, 5],\n            [6, 7]]])\n\n    >>> np.swapaxes(x,0,2)\n    array([[[0, 4],\n            [2, 6]],\n           [[1, 5],\n            [3, 7]]])\n    \n    ";
static char __pyx_k_989[] = "take (line 12160)";
static char __pyx_k_990[] = "Take elements from an array along an axis.\n\n    This function does the same thing as \"fancy\" indexing (indexing arrays\n    using arrays); however, it can be easier to use if you need elements\n    along a given axis.\n\n    Parameters\n    ----------\n    a : array_like\n        The source array.\n    indices : array_like\n        The indices of the values to extract.\n    axis : int, optional\n        The axis over which to select values. By default, the flattened\n        input array is used.\n    out : ndarray, optional\n        If provided, the result will be placed in this array. It should\n        be of the appropriate shape and dtype.\n    mode : {'raise', 'wrap', 'clip'}, optional\n        Specifies how out-of-bounds indices will behave.\n\n        * 'raise' -- raise an error (default)\n        * 'wrap' -- wrap around\n        * 'clip' -- clip to the range\n\n        'clip' mode means that all indices that are too large are replaced\n        by the index that addresses the last element along that axis. Note\n        that this disables indexing with negative numbers.\n\n    Returns\n    -------\n    subarray : ndarray\n        The returned array has the same type as `a`.\n\n    See Also\n    --------\n    ndarray.take : equivalent method\n\n    Examples\n    --------\n    >>> a = [4, 3, 5, 7, 6, 8]\n    >>> indices = [0, 1, 4]\n    >>> np.take(a, indices)\n    array([4, 3, 6])\n\n    In this example if `a` is an ndarray, \"fancy\" indexing can be used.\n\n    >>> a = np.array(a)\n    >>> a[indices]\n    array([4, 3, 6])\n    \n    ";
static char __pyx_k_991[] = "tensordot (line 12216)";
static char __pyx_k_992[] = "Compute tensor dot product along specified axes for arrays >= 1-D.\n\n    Given two tensors (arrays of dimension greater than or equal to one),\n    ``a`` and ``b``, and an array_like object containing two array_like\n    objects, ``(a_axes, b_axes)``, sum the products of ``a``'s and ``b``'s\n    elements (components) over the axes specified by ``a_axes`` and\n    ``b_axes``. The third argument can be a single non-negative\n    integer_like scalar, ``N``; if it is such, then the last ``N``\n    dimensions of ``a`` and the first ``N`` dimensions of ``b`` are summed\n    over.\n\n    Parameters\n    ----------\n    a, b : array_like, len(shape) >= 1\n        Tensors to \"dot\".\n\n    axes : variable type\n\n    * integer_like scalar\n      Number of axes to sum over (applies to both arrays); or\n\n    * array_like, shape = (2,), both elements array_like\n      Axes to be summed over, first sequence applying to ``a``, second\n      to ``b``.\n\n    See Also\n    --------\n    dot, einsum\n\n    Notes\n    -----\n    When there is more than one axis to sum over - and they are not the last\n    (first) axes of ``a`` (``b``) - the argument ``axes`` should consist of\n    two sequences of the same length, with the first axis to sum over given\n    first in both sequences, the second axis second, and so forth.\n\n    Examples\n    --------\n    A \"traditional\" example:\n\n    >>> a = np.arange(60.).reshape(3,4,5)\n    >>> b = np.arange(24.).reshape(4,3,2)\n    >>> c = np.tensordot(a,b, axes=([1,0],[0,1]))\n    >>> c.shape\n    (5, 2)\n    >>> c\n    array([[ 4400.,  4730.],\n           [ 4532.,  4874.],\n           [ 4664.,  5018.],\n           [ 4796.,  5162.],\n           [ 4928.,  5306.]])\n    >>> # A slower but equivalent way of computing the same...\n    >>> d = np.zeros((5,2))\n    >>> for i in range(5):\n    ...   for j in range(2):\n    ...     for k in range(3):\n    ...       for n in range(4):\n    ...         d[i,j] += a[k,n,i] * b[n,k,j]\n    >>> c == d""\n    array([[ True,  True],\n           [ True,  True],\n           [ True,  True],\n           [ True,  True],\n           [ True,  True]], dtype=bool)\n\n    An extended example taking advantage of the overloading of + and \\*:\n\n    >>> a = np.array(range(1, 9))\n    >>> a.shape = (2, 2, 2)\n    >>> A = np.array(('a', 'b', 'c', 'd'), dtype=object)\n    >>> A.shape = (2, 2)\n    >>> a; A\n    array([[[1, 2],\n            [3, 4]],\n           [[5, 6],\n            [7, 8]]])\n    array([[a, b],\n           [c, d]], dtype=object)\n\n    >>> np.tensordot(a, A) # third argument default is 2\n    array([abbcccdddd, aaaaabbbbbbcccccccdddddddd], dtype=object)\n\n    >>> np.tensordot(a, A, 1)\n    array([[[acc, bdd],\n            [aaacccc, bbbdddd]],\n           [[aaaaacccccc, bbbbbdddddd],\n            [aaaaaaacccccccc, bbbbbbbdddddddd]]], dtype=object)\n\n    >>> np.tensordot(a, A, 0) # \"Left for reader\" (result too long to incl.)\n    array([[[[[a, b],\n              [c, d]],\n              ...\n\n    >>> np.tensordot(a, A, (0, 1))\n    array([[[abbbbb, cddddd],\n            [aabbbbbb, ccdddddd]],\n           [[aaabbbbbbb, cccddddddd],\n            [aaaabbbbbbbb, ccccdddddddd]]], dtype=object)\n\n    >>> np.tensordot(a, A, (2, 1))\n    array([[[abb, cdd],\n            [aaabbbb, cccdddd]],\n           [[aaaaabbbbbb, cccccdddddd],\n            [aaaaaaabbbbbbbb, cccccccdddddddd]]], dtype=object)\n\n    >>> np.tensordot(a, A, ((0, 1), (0, 1)))\n    array([abbbcccccddddddd, aabbbbccccccdddddddd], dtype=object)\n\n    >>> np.tensordot(a, A, ((2, 1), (1, 0)))\n    array([acccbbdddd, aaaaacccccccbbbbbbdddddddd], dtype=object)\n    \n    ";
static char __pyx_k_993[] = "tile (line 12332)";
static char __pyx_k_994[] = "Construct an array by repeating A the number of times given by reps.\n\n    If `reps` has length ``d``, the result will have dimension of\n    ``max(d, A.ndim)``.\n\n    If ``A.ndim < d``, `A` is promoted to be d-dimensional by prepending new\n    axes. So a shape (3,) array is promoted to (1, 3) for 2-D replication,\n    or shape (1, 1, 3) for 3-D replication. If this is not the desired\n    behavior, promote `A` to d-dimensions manually before calling this\n    function.\n\n    If ``A.ndim > d``, `reps` is promoted to `A`.ndim by pre-pending 1's to it.\n    Thus for an `A` of shape (2, 3, 4, 5), a `reps` of (2, 2) is treated as\n    (1, 1, 2, 2).\n\n    Parameters\n    ----------\n    A : array_like\n        The input array.\n    reps : array_like\n        The number of repetitions of `A` along each axis.\n\n    Returns\n    -------\n    c : ndarray\n        The tiled output array.\n\n    See Also\n    --------\n    repeat : Repeat elements of an array.\n\n    Examples\n    --------\n    >>> a = np.array([0, 1, 2])\n    >>> np.tile(a, 2)\n    array([0, 1, 2, 0, 1, 2])\n    >>> np.tile(a, (2, 2))\n    array([[0, 1, 2, 0, 1, 2],\n           [0, 1, 2, 0, 1, 2]])\n    >>> np.tile(a, (2, 1, 2))\n    array([[[0, 1, 2, 0, 1, 2]],\n           [[0, 1, 2, 0, 1, 2]]])\n\n    >>> b = np.array([[1, 2], [3, 4]])\n    >>> np.tile(b, 2)\n    array([[1, 2, 1, 2],\n           [3, 4, 3, 4]])\n    >>> np.tile(b, (2, 1))\n    array([[1, 2],\n           [3, 4],\n           [1, 2],\n           [3, 4]])\n    \n    ";
static char __pyx_k_995[] = "trace (line 12390)";
static char __pyx_k_996[] = "Return the sum along diagonals of the array.\n\n    If `a` is 2-D, the sum along its diagonal with the given offset\n    is returned, i.e., the sum of elements ``a[i,i+offset]`` for all i.\n\n    If `a` has more than two dimensions, then the axes specified by axis1 and\n    axis2 are used to determine the 2-D sub-arrays whose traces are returned.\n    The shape of the resulting array is the same as that of `a` with `axis1`\n    and `axis2` removed.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array, from which the diagonals are taken.\n    offset : int, optional\n        Offset of the diagonal from the main diagonal. Can be both positive\n        and negative. Defaults to 0.\n    axis1, axis2 : int, optional\n        Axes to be used as the first and second axis of the 2-D sub-arrays\n        from which the diagonals should be taken. Defaults are the first two\n        axes of `a`.\n    dtype : dtype, optional\n        Determines the data-type of the returned array and of the accumulator\n        where the elements are summed. If dtype has the value None and `a` is\n        of integer type of precision less than the default integer\n        precision, then the default integer precision is used. Otherwise,\n        the precision is the same as that of `a`.\n    out : ndarray, optional\n        Array into which the output is placed. Its type is preserved and\n        it must be of the right shape to hold the output.\n\n    Returns\n    -------\n    sum_along_diagonals : ndarray\n        If `a` is 2-D, the sum along the diagonal is returned.  If `a` has\n        larger dimensions, then an array of sums along diagonals is returned.\n\n    See Also\n    --------\n    diag, diagonal, diagflat\n\n    Examples\n    --------\n    >>> np.trace(np.eye(3))\n    3.0\n    >>> a = np.arange(8).reshape((2,2,2))\n    >>> np.trace(a)\n    array([6, 8])\n\n    >>> a = np.arange(24).reshape((2,2,2,3))\n    >>> np.trace(a).shape\n    (2, 3)\n    \n    ";
static char __pyx_k_997[] = "transpose (line 12448)";
static char __pyx_k_998[] = "Permute the dimensions of an array.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    axes : list of ints, optional\n        By default, reverse the dimensions, otherwise permute the axes\n        according to the values given.\n\n    Returns\n    -------\n    p : ndarray\n        `a` with its axes permuted.  A view is returned whenever\n        possible.\n\n    See Also\n    --------\n    rollaxis\n\n    Examples\n    --------\n    >>> x = np.arange(4).reshape((2,2))\n    >>> x\n    array([[0, 1],\n           [2, 3]])\n\n    >>> np.transpose(x)\n    array([[0, 2],\n           [1, 3]])\n\n    >>> x = np.ones((1, 2, 3))\n    >>> np.transpose(x, (1, 0, 2)).shape\n    (2, 1, 3)\n    \n    ";
static char __pyx_k_999[] = "trapz (line 12488)";
static char __pyx_k__Zd[] = "Zd";
static char __pyx_k__Zf[] = "Zf";
static char __pyx_k__Zg[] = "Zg";
static char __pyx_k__a1[] = "a1";
static char __pyx_k__a2[] = "a2";
static char __pyx_k__ar[] = "ar";
static char __pyx_k__dx[] = "dx";
static char __pyx_k__fb[] = "fb";
static char __pyx_k__fp[] = "fp";
static char __pyx_k__fv[] = "fv";
static char __pyx_k__i0[] = "i0";
static char __pyx_k__np[] = "np";
static char __pyx_k__pv[] = "pv";
static char __pyx_k__xp[] = "xp";
static char __pyx_k_1000[] = "Integrate along the given axis using the composite trapezoidal rule.\n\n    Integrate `y` (`x`) along given axis.\n\n    Parameters\n    ----------\n    y : array_like\n        Input array to integrate.\n    x : array_like, optional\n        If `x` is None, then spacing between all `y` elements is `dx`.\n    dx : scalar, optional\n        If `x` is None, spacing given by `dx` is assumed. Default is 1.\n    axis : int, optional\n        Specify the axis.\n\n    Returns\n    -------\n    out : float\n        Definite integral as approximated by trapezoidal rule.\n\n    See Also\n    --------\n    sum, cumsum\n\n    Notes\n    -----\n    Image [2]_ illustrates trapezoidal rule -- y-axis locations of points will\n    be taken from `y` array, by default x-axis distances between points will be\n    1.0, alternatively they can be provided with `x` array or with `dx` scalar.\n    Return value will be equal to combined area under the red lines.\n\n\n    References\n    ----------\n    .. [1] Wikipedia page: http://en.wikipedia.org/wiki/Trapezoidal_rule\n\n    .. [2] Illustration image:\n           http://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png\n\n    Examples\n    --------\n    >>> np.trapz([1,2,3])\n    4.0\n    >>> np.trapz([1,2,3], x=[4,6,8])\n    8.0\n    >>> np.trapz([1,2,3], dx=2)\n    8.0\n    >>> a = np.arange(6).reshape(2, 3)\n    >>> a\n    array([[0, 1, 2],\n           [3, 4, 5]])\n    >>> np.trapz(a, axis=0)\n    array([ 1.5,  2.5,  3.5])\n    >>> np.trapz(a, axis=1)\n    array([ 2.,  8.])\n    \n    ";
static char __pyx_k_1001[] = "tri (line 12549)";
static char __pyx_k_1002[] = "An array with ones at and below the given diagonal and zeros elsewhere.\n\n    Parameters\n    ----------\n    N : int\n        Number of rows in the array.\n    M : int, optional\n        Number of columns in the array.\n        By default, `M` is taken equal to `N`.\n    k : int, optional\n        The sub-diagonal at and below which the array is filled.\n        `k` = 0 is the main diagonal, while `k` < 0 is below it,\n        and `k` > 0 is above.  The default is 0.\n    dtype : dtype, optional\n        Data type of the returned array.  The default is float.\n\n    Returns\n    -------\n    T : ndarray of shape (N, M)\n        Array with its lower triangle filled with ones and zero elsewhere;\n        in other words ``T[i,j] == 1`` for ``i <= j + k``, 0 otherwise.\n\n    Examples\n    --------\n    >>> np.tri(3, 5, 2, dtype=int)\n    array([[1, 1, 1, 0, 0],\n           [1, 1, 1, 1, 0],\n           [1, 1, 1, 1, 1]])\n\n    >>> np.tri(3, 5, -1)\n    array([[ 0.,  0.,  0.,  0.,  0.],\n           [ 1.,  0.,  0.,  0.,  0.],\n           [ 1.,  1.,  0.,  0.,  0.]])\n    \n    ";
static char __pyx_k_1003[] = "tril (line 12588)";
static char __pyx_k_1004[] = "Lower triangle of an array.\n\n    Return a copy of an array with elements above the `k`-th diagonal zeroed.\n\n    Parameters\n    ----------\n    m : array_like, shape (M, N)\n        Input array.\n    k : int, optional\n        Diagonal above which to zero elements.  `k = 0` (the default) is the\n        main diagonal, `k < 0` is below it and `k > 0` is above.\n\n    Returns\n    -------\n    L : ndarray, shape (M, N)\n        Lower triangle of `m`, of same shape and data-type as `m`.\n\n    See Also\n    --------\n    triu : same thing, only for the upper triangle\n\n    Examples\n    --------\n    >>> np.tril([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)\n    array([[ 0,  0,  0],\n           [ 4,  0,  0],\n           [ 7,  8,  0],\n           [10, 11, 12]])\n    \n    ";
static char __pyx_k_1005[] = "tril_indices (line 12622)";
static char __pyx_k_1006[] = "Return the indices for the lower-triangle of an (n, n) array.\n\n    Parameters\n    ----------\n    n : int\n        The row dimension of the square arrays for which the returned\n        indices will be valid.\n    k : int, optional\n        Diagonal offset (see `tril` for details).\n\n    Returns\n    -------\n    inds : tuple of arrays\n        The indices for the triangle. The returned tuple contains two arrays,\n        each with the indices along one dimension of the array.\n\n    See also\n    --------\n    triu_indices : similar function, for upper-triangular.\n    mask_indices : generic function accepting an arbitrary mask function.\n    tril, triu\n\n    Notes\n    -----\n    .. versionadded:: 1.4.0\n\n    Examples\n    --------\n    Compute two different sets of indices to access 4x4 arrays, one for the\n    lower triangular part starting at the main diagonal, and one starting two\n    diagonals further right:\n\n    >>> il1 = np.tril_indices(4)\n    >>> il2 = np.tril_indices(4, 2)\n\n    Here is how they can be used with a sample array:\n\n    >>> a = np.arange(16).reshape(4, 4)\n    >>> a\n    array([[ 0,  1,  2,  3],\n           [ 4,  5,  6,  7],\n           [ 8,  9, 10, 11],\n           [12, 13, 14, 15]])\n\n    Both for indexing:\n\n    >>> a[il1]\n    array([ 0,  4,  5,  8,  9, 10, 12, 13, 14, 15])\n\n    And for assigning values:\n\n    >>> a[il1] = -1\n    >>> a\n    array([[-1,  1,  2,  3],\n           [-1, -1,  6,  7],\n           [-1, -1, -1, 11],\n           [-1, -1, -1, -1]])\n\n    These cover almost the whole array (two diagonals right of the main one):\n\n    >>> a[il2] = -10\n    >>> a\n    array([[-10, -10, -10,   3],\n           [-10, -10, -10, -10],\n           [-10, -10, -10, -10],\n           [-10, -10, -10, -10]])\n    \n    ";
static char __pyx_k_1007[] = "trim_zeros (line 12719)";
static char __pyx_k_1008[] = "Trim the leading and/or trailing zeros from a 1-D array or sequence.\n\n    Parameters\n    ----------\n    filt : 1-D array or sequence\n        Input array.\n    trim : str, optional\n        A string with 'f' representing trim from front and 'b' to trim from\n        back. Default is 'fb', trim zeros from both front and back of the\n        array.\n\n    Returns\n    -------\n    trimmed : 1-D array or sequence\n        The result of trimming the input. The input data type is preserved.\n\n    Examples\n    --------\n    >>> a = np.array((0, 0, 0, 1, 2, 3, 0, 2, 1, 0))\n    >>> np.trim_zeros(a)\n    array([1, 2, 3, 0, 2, 1])\n\n    >>> np.trim_zeros(a, 'b')\n    array([0, 0, 0, 1, 2, 3, 0, 2, 1])\n\n    The input data type is preserved, list/tuple in means list/tuple out.\n\n    >>> np.trim_zeros([0, 1, 2, 0])\n    [1, 2]\n    \n    ";
static char __pyx_k_1009[] = "triu (line 12754)";
static char __pyx_k_1010[] = "Upper triangle of an array.\n\n    Return a copy of a matrix with the elements below the `k`-th diagonal\n    zeroed.\n\n    Please refer to the documentation for `tril` for further details.\n\n    See Also\n    --------\n    tril : lower triangle of an array\n\n    Examples\n    --------\n    >>> np.triu([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)\n    array([[ 1,  2,  3],\n           [ 4,  5,  6],\n           [ 0,  8,  9],\n           [ 0,  0, 12]])\n    \n    ";
static char __pyx_k_1011[] = "triu_indices (line 12778)";
static char __pyx_k_1012[] = "Return the indices for the upper-triangle of an (n, n) array.\n\n    Parameters\n    ----------\n    n : int\n        The size of the arrays for which the returned indices will\n        be valid.\n    k : int, optional\n        Diagonal offset (see `triu` for details).\n\n    Returns\n    -------\n    inds : tuple of arrays\n        The indices for the triangle. The returned tuple contains two arrays,\n        each with the indices along one dimension of the array.\n\n    See also\n    --------\n    tril_indices : similar function, for lower-triangular.\n    mask_indices : generic function accepting an arbitrary mask function.\n    triu, tril\n\n    Notes\n    -----\n    .. versionadded:: 1.4.0\n\n    Examples\n    --------\n    Compute two different sets of indices to access 4x4 arrays, one for the\n    upper triangular part starting at the main diagonal, and one starting two\n    diagonals further right:\n\n    >>> iu1 = np.triu_indices(4)\n    >>> iu2 = np.triu_indices(4, 2)\n\n    Here is how they can be used with a sample array:\n\n    >>> a = np.arange(16).reshape(4, 4)\n    >>> a\n    array([[ 0,  1,  2,  3],\n           [ 4,  5,  6,  7],\n           [ 8,  9, 10, 11],\n           [12, 13, 14, 15]])\n\n    Both for indexing:\n\n    >>> a[iu1]\n    array([ 0,  1,  2,  3,  5,  6,  7, 10, 11, 15])\n\n    And for assigning values:\n\n    >>> a[iu1] = -1\n    >>> a\n    array([[-1, -1, -1, -1],\n           [ 4, -1, -1, -1],\n           [ 8,  9, -1, -1],\n           [12, 13, 14, -1]])\n\n    These cover only a small part of the whole array (two diagonals right\n    of the main one):\n\n    >>> a[iu2] = -10\n    >>> a\n    array([[ -1,  -1, -10, -10],\n           [  4,  -1,  -1, -10],\n           [  8,   9,  -1,  -1],\n           [ 12,  13,  14,  -1]])\n    \n    ";
static char __pyx_k_1013[] = "typename (line 12876)";
static char __pyx_k_1014[] = "Return a description for the given data type code.\n\n    Parameters\n    ----------\n    char : str\n        Data type code.\n\n    Returns\n    -------\n    out : str\n        Description of the input data type code.\n\n    See Also\n    --------\n    dtype, typecodes\n\n    Examples\n    --------\n    >>> typechars = ['S1', '?', 'B', 'D', 'G', 'F', 'I', 'H', 'L', 'O', 'Q',\n    ...              'S', 'U', 'V', 'b', 'd', 'g', 'f', 'i', 'h', 'l', 'q']\n    >>> for typechar in typechars:\n    ...     print typechar, ' : ', np.typename(typechar)\n    ...\n    S1  :  character\n    ?  :  bool\n    B  :  unsigned char\n    D  :  complex double precision\n    G  :  complex long double precision\n    F  :  complex single precision\n    I  :  unsigned integer\n    H  :  unsigned short\n    L  :  unsigned long integer\n    O  :  object\n    Q  :  unsigned long long integer\n    S  :  string\n    U  :  unicode\n    V  :  void\n    b  :  signed char\n    d  :  double precision\n    g  :  long precision\n    f  :  single precision\n    i  :  integer\n    h  :  short\n    l  :  long integer\n    q  :  long long integer\n    \n    ";
static char __pyx_k_1015[] = "union1d (line 12927)";
static char __pyx_k_1016[] = "Find the union of two arrays.\n\n    Return the unique, sorted array of values that are in either of the two\n    input arrays.\n\n    Parameters\n    ----------\n    ar1, ar2 : array_like\n        Input arrays. They are flattened if they are not already 1D.\n\n    Returns\n    -------\n    union : ndarray\n        Unique, sorted union of the input arrays.\n\n    See Also\n    --------\n    numpy.lib.arraysetops : Module with a number of other functions for\n                            performing set operations on arrays.\n\n    Examples\n    --------\n    >>> np.union1d([-1, 0, 1], [-2, 0, 2])\n    array([-2, -1,  0,  1,  2])\n    \n    ";
static char __pyx_k_1017[] = "unique (line 12957)";
static char __pyx_k_1018[] = "Find the unique elements of an array.\n\n    Returns the sorted unique elements of an array. There are two optional\n    outputs in addition to the unique elements: the indices of the input array\n    that give the unique values, and the indices of the unique array that\n    reconstruct the input array.\n\n    Parameters\n    ----------\n    ar : array_like\n        Input array. This will be flattened if it is not already 1-D.\n    return_index : bool, optional\n        If True, also return the indices of `ar` that result in the unique\n        array.\n    return_inverse : bool, optional\n        If True, also return the indices of the unique array that can be used\n        to reconstruct `ar`.\n\n    Returns\n    -------\n    unique : ndarray\n        The sorted unique values.\n    unique_indices : ndarray, optional\n        The indices of the unique values in the (flattened) original array.\n        Only provided if `return_index` is True.\n    unique_inverse : ndarray, optional\n        The indices to reconstruct the (flattened) original array from the\n        unique array. Only provided if `return_inverse` is True.\n\n    See Also\n    --------\n    numpy.lib.arraysetops : Module with a number of other functions for\n                            performing set operations on arrays.\n\n    Examples\n    --------\n    >>> np.unique([1, 1, 2, 2, 3, 3])\n    array([1, 2, 3])\n    >>> a = np.array([[1, 1], [2, 3]])\n    >>> np.unique(a)\n    array([1, 2, 3])\n\n    Return the indices of the original array that give the unique values:\n\n    >>> a = np.array(['a', 'b', 'b', 'c', 'a'])\n    >>> u, indices = np.unique(a, return_index=True)\n    >>> u\n    array(['a', 'b', 'c'],\n           dtype='|S1')\n    >>> indices\n    array([0, 1, 3])\n    >>> a[indices]\n    array(['a', 'b', 'c'],\n           dtype='|S1')\n\n    Reconstruct the input array from the unique values:\n\n    >>> a = np.array([1, 2, 6, 4, 2, 3, 2])\n    >>> u, indices = np.unique(a, return_inverse=True"")\n    >>> u\n    array([1, 2, 3, 4, 6])\n    >>> indices\n    array([0, 1, 4, 3, 1, 2, 1])\n    >>> u[indices]\n    array([1, 2, 6, 4, 2, 3, 2])\n    \n    ";
static char __pyx_k_1019[] = "unpackbits (line 13028)";
static char __pyx_k_1020[] = "unpackbits(myarray, axis=None)\n\n    Unpacks elements of a uint8 array into a binary-valued output array.\n\n    Each element of `myarray` represents a bit-field that should be unpacked\n    into a binary-valued output array. The shape of the output array is either\n    1-D (if `axis` is None) or the same shape as the input array with unpacking\n    done along the axis specified.\n\n    Parameters\n    ----------\n    myarray : ndarray, uint8 type\n       Input array.\n    axis : int, optional\n       Unpacks along this axis.\n\n    Returns\n    -------\n    unpacked : ndarray, uint8 type\n       The elements are binary-valued (0 or 1).\n\n    See Also\n    --------\n    packbits : Packs the elements of a binary-valued array into bits in a uint8\n               array.\n\n    Examples\n    --------\n    >>> a = np.array([[2], [7], [23]], dtype=np.uint8)\n    >>> a\n    array([[ 2],\n           [ 7],\n           [23]], dtype=uint8)\n    >>> b = np.unpackbits(a, axis=1)\n    >>> b\n    array([[0, 0, 0, 0, 0, 0, 1, 0],\n           [0, 0, 0, 0, 0, 1, 1, 1],\n           [0, 0, 0, 1, 0, 1, 1, 1]], dtype=uint8)\n    \n    ";
static char __pyx_k_1021[] = "unravel_index (line 13073)";
static char __pyx_k_1022[] = "unravel_index(indices, dims, order='C')\n\n    Converts a flat index or array of flat indices into a tuple\n    of coordinate arrays.\n\n    Parameters\n    ----------\n    indices : array_like\n        An integer array whose elements are indices into the flattened\n        version of an array of dimensions ``dims``. Before version 1.6.0,\n        this function accepted just one index value.\n    dims : tuple of ints\n        The shape of the array to use for unraveling ``indices``.\n    order : {'C', 'F'}, optional\n        .. versionadded:: 1.6.0\n\n        Determines whether the indices should be viewed as indexing in\n        C (row-major) order or FORTRAN (column-major) order.\n\n    Returns\n    -------\n    unraveled_coords : tuple of ndarray\n        Each array in the tuple has the same shape as the ``indices``\n        array.\n\n    See Also\n    --------\n    ravel_multi_index\n\n    Examples\n    --------\n    >>> np.unravel_index([22, 41, 37], (7,6))\n    (array([3, 6, 6]), array([4, 5, 1]))\n    >>> np.unravel_index([31, 41, 13], (7,6), order='F')\n    (array([3, 6, 6]), array([4, 5, 1]))\n\n    >>> np.unravel_index(1621, (6,7,8,9))\n    (3, 1, 4, 1)\n    \n    ";
static char __pyx_k_1023[] = "unwrap (line 13118)";
static char __pyx_k_1024[] = "Unwrap by changing deltas between values to 2*pi complement.\n\n    Unwrap radian phase `p` by changing absolute jumps greater than\n    `discont` to their 2*pi complement along the given axis.\n\n    Parameters\n    ----------\n    p : array_like\n        Input array.\n    discont : float, optional\n        Maximum discontinuity between values, default is ``pi``.\n    axis : int, optional\n        Axis along which unwrap will operate, default is the last axis.\n\n    Returns\n    -------\n    out : ndarray\n        Output array.\n\n    See Also\n    --------\n    rad2deg, deg2rad\n\n    Notes\n    -----\n    If the discontinuity in `p` is smaller than ``pi``, but larger than\n    `discont`, no unwrapping is done because taking the 2*pi complement\n    would only make the discontinuity larger.\n\n    Examples\n    --------\n    >>> phase = np.linspace(0, np.pi, num=5)\n    >>> phase[3:] += np.pi\n    >>> phase\n    array([ 0.        ,  0.78539816,  1.57079633,  5.49778714,  6.28318531])\n    >>> np.unwrap(phase)\n    array([ 0.        ,  0.78539816,  1.57079633, -0.78539816,  0.        ])\n    \n    ";
static char __pyx_k_1025[] = "vander (line 13161)";
static char __pyx_k_1026[] = "Generate a Van der Monde matrix.\n\n    The columns of the output matrix are decreasing powers of the input\n    vector.  Specifically, the `i`-th output column is the input vector\n    raised element-wise to the power of ``N - i - 1``.  Such a matrix with\n    a geometric progression in each row is named for Alexandre-Theophile\n    Vandermonde.\n\n    Parameters\n    ----------\n    x : array_like\n        1-D input array.\n    N : int, optional\n        Order of (number of columns in) the output.  If `N` is not specified,\n        a square array is returned (``N = len(x)``).\n\n    Returns\n    -------\n    out : ndarray\n        Van der Monde matrix of order `N`.  The first column is ``x^(N-1)``,\n        the second ``x^(N-2)`` and so forth.\n\n    Examples\n    --------\n    >>> x = np.array([1, 2, 3, 5])\n    >>> N = 3\n    >>> np.vander(x, N)\n    array([[ 1,  1,  1],\n           [ 4,  2,  1],\n           [ 9,  3,  1],\n           [25,  5,  1]])\n\n    >>> np.column_stack([x**(N-1-i) for i in range(N)])\n    array([[ 1,  1,  1],\n           [ 4,  2,  1],\n           [ 9,  3,  1],\n           [25,  5,  1]])\n\n    >>> x = np.array([1, 2, 3, 5])\n    >>> np.vander(x)\n    array([[  1,   1,   1,   1],\n           [  8,   4,   2,   1],\n           [ 27,   9,   3,   1],\n           [125,  25,   5,   1]])\n\n    The determinant of a square Vandermonde matrix is the product\n    of the differences between the values of the input vector:\n\n    >>> np.linalg.det(np.vander(x))\n    48.000000000000043\n    >>> (5-3)*(5-2)*(5-1)*(3-2)*(3-1)*(2-1)\n    48\n    \n    ";
static char __pyx_k_1027[] = "var (line 13219)";
static char __pyx_k_1028[] = "Compute the variance along the specified axis.\n\n    Returns the variance of the array elements, a measure of the spread of a\n    distribution.  The variance is computed for the flattened array by\n    default, otherwise over the specified axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Array containing numbers whose variance is desired.  If `a` is not an\n        array, a conversion is attempted.\n    axis : int, optional\n        Axis along which the variance is computed.  The default is to compute\n        the variance of the flattened array.\n    dtype : data-type, optional\n        Type to use in computing the variance.  For arrays of integer type\n        the default is `float32`; for arrays of float types it is the same as\n        the array type.\n    out : ndarray, optional\n        Alternate output array in which to place the result.  It must have\n        the same shape as the expected output, but the type is cast if\n        necessary.\n    ddof : int, optional\n        \"Delta Degrees of Freedom\": the divisor used in the calculation is\n        ``N - ddof``, where ``N`` represents the number of elements. By\n        default `ddof` is zero.\n\n    Returns\n    -------\n    variance : ndarray, see dtype parameter above\n        If ``out=None``, returns a new array containing the variance;\n        otherwise, a reference to the output array is returned.\n\n    See Also\n    --------\n    std : Standard deviation\n    mean : Average\n    numpy.doc.ufuncs : Section \"Output arguments\"\n\n    Notes\n    -----\n    The variance is the average of the squared deviations from the mean,\n    i.e.,  ``var = mean(abs(x - x.mean())**2)``.\n\n    The mean is normally calculated as ``x.sum() / N``, where ``N = len(x)``.\n    If, however, `ddof` is specified, the divisor ``N - ddof`` is used\n    instead.  In standard statistical practice, ``ddof=1`` provides an\n    unbiased estimator of the variance of a hypothetical infinite population.\n    ""``ddof=0`` provides a maximum likelihood estimate of the variance for\n    normally distributed variables.\n\n    Note that for complex numbers, the absolute value is taken before\n    squaring, so that the result is always real and nonnegative.\n\n    For floating-point input, the variance is computed using the same\n    precision the input has.  Depending on the input data, this can cause\n    the results to be inaccurate, especially for `float32` (see example\n    below).  Specifying a higher-accuracy accumulator using the ``dtype``\n    keyword can alleviate this issue.\n\n    Examples\n    --------\n    >>> a = np.array([[1,2],[3,4]])\n    >>> np.var(a)\n    1.25\n    >>> np.var(a,0)\n    array([ 1.,  1.])\n    >>> np.var(a,1)\n    array([ 0.25,  0.25])\n\n    In single precision, var() can be inaccurate:\n\n    >>> a = np.zeros((2,512*512), dtype=np.float32)\n    >>> a[0,:] = 1.0\n    >>> a[1,:] = 0.1\n    >>> np.var(a)\n    0.20405951142311096\n\n    Computing the standard deviation in float64 is more accurate:\n\n    >>> np.var(a, dtype=np.float64)\n    0.20249999932997387\n    >>> ((1-0.55)**2 + (0.1-0.55)**2)/2\n    0.20250000000000001\n    \n    ";
static char __pyx_k_1029[] = "vdot (line 13309)";
static char __pyx_k_1030[] = "Return the dot product of two vectors.\n\n    The vdot(`a`, `b`) function handles complex numbers differently than\n    dot(`a`, `b`).  If the first argument is complex the complex conjugate\n    of the first argument is used for the calculation of the dot product.\n\n    Note that `vdot` handles multidimensional arrays differently than `dot`:\n    it does *not* perform a matrix product, but flattens input arguments\n    to 1-D vectors first. Consequently, it should only be used for vectors.\n\n    Parameters\n    ----------\n    a : array_like\n        If `a` is complex the complex conjugate is taken before calculation\n        of the dot product.\n    b : array_like\n        Second argument to the dot product.\n\n    Returns\n    -------\n    output : ndarray\n        Dot product of `a` and `b`.  Can be an int, float, or\n        complex depending on the types of `a` and `b`.\n\n    See Also\n    --------\n    dot : Return the dot product without using the complex conjugate of the\n          first argument.\n\n    Examples\n    --------\n    >>> a = np.array([1+2j,3+4j])\n    >>> b = np.array([5+6j,7+8j])\n    >>> np.vdot(a, b)\n    (70-8j)\n    >>> np.vdot(b, a)\n    (70+8j)\n\n    Note that higher-dimensional arrays are flattened!\n\n    >>> a = np.array([[1, 4], [5, 6]])\n    >>> b = np.array([[4, 1], [2, 2]])\n    >>> np.vdot(a, b)\n    30\n    >>> np.vdot(b, a)\n    30\n    >>> 1*4 + 4*1 + 5*2 + 6*2\n    30\n    \n    ";
static char __pyx_k_1031[] = "vsplit (line 13364)";
static char __pyx_k_1032[] = "Split an array into multiple sub-arrays vertically (row-wise).\n\n    Please refer to the ``split`` documentation.  ``vsplit`` is equivalent\n    to ``split`` with `axis=0` (default), the array is always split along the\n    first axis regardless of the array dimension.\n\n    See Also\n    --------\n    split : Split an array into multiple sub-arrays of equal size.\n\n    Examples\n    --------\n    >>> x = np.arange(16.0).reshape(4, 4)\n    >>> x\n    array([[  0.,   1.,   2.,   3.],\n           [  4.,   5.,   6.,   7.],\n           [  8.,   9.,  10.,  11.],\n           [ 12.,  13.,  14.,  15.]])\n    >>> np.vsplit(x, 2)\n    [array([[ 0.,  1.,  2.,  3.],\n           [ 4.,  5.,  6.,  7.]]),\n     array([[  8.,   9.,  10.,  11.],\n           [ 12.,  13.,  14.,  15.]])]\n    >>> np.vsplit(x, np.array([3, 6]))\n    [array([[  0.,   1.,   2.,   3.],\n           [  4.,   5.,   6.,   7.],\n           [  8.,   9.,  10.,  11.]]),\n     array([[ 12.,  13.,  14.,  15.]]),\n     array([], dtype=float64)]\n\n    With a higher dimensional array the split is still along the first axis.\n\n    >>> x = np.arange(8.0).reshape(2, 2, 2)\n    >>> x\n    array([[[ 0.,  1.],\n            [ 2.,  3.]],\n           [[ 4.,  5.],\n            [ 6.,  7.]]])\n    >>> np.vsplit(x, 2)\n    [array([[[ 0.,  1.],\n            [ 2.,  3.]]]),\n     array([[[ 4.,  5.],\n            [ 6.,  7.]]])]\n    \n    ";
static char __pyx_k_1033[] = "vstack (line 13413)";
static char __pyx_k_1034[] = "where (line 13464)";
static char __pyx_k_1035[] = "where(condition, [x, y])\n\n    Return elements, either from `x` or `y`, depending on `condition`.\n\n    If only `condition` is given, return ``condition.nonzero()``.\n\n    Parameters\n    ----------\n    condition : array_like, bool\n        When True, yield `x`, otherwise yield `y`.\n    x, y : array_like, optional\n        Values from which to choose. `x` and `y` need to have the same\n        shape as `condition`.\n\n    Returns\n    -------\n    out : ndarray or tuple of ndarrays\n        If both `x` and `y` are specified, the output array contains\n        elements of `x` where `condition` is True, and elements from\n        `y` elsewhere.\n\n        If only `condition` is given, return the tuple\n        ``condition.nonzero()``, the indices where `condition` is True.\n\n    See Also\n    --------\n    nonzero, choose\n\n    Notes\n    -----\n    If `x` and `y` are given and input arrays are 1-D, `where` is\n    equivalent to::\n\n        [xv if c else yv for (c,xv,yv) in zip(condition,x,y)]\n\n    Examples\n    --------\n    >>> np.where([[True, False], [True, True]],\n    ...          [[1, 2], [3, 4]],\n    ...          [[9, 8], [7, 6]])\n    array([[1, 8],\n           [3, 4]])\n\n    >>> np.where([[0, 1], [1, 0]])\n    (array([0, 1]), array([1, 0]))\n\n    >>> x = np.arange(9.).reshape(3, 3)\n    >>> np.where( x > 5 )\n    (array([2, 2, 2]), array([0, 1, 2]))\n    >>> x[np.where( x > 3.0 )]               # Note: result is 1D.\n    array([ 4.,  5.,  6.,  7.,  8.])\n    >>> np.where(x < 5, x, -1)               # Note: broadcasting.\n    array([[ 0.,  1.,  2.],\n           [ 3.,  4., -1.],\n           [-1., -1., -1.]])\n    \n    ";
static char __pyx_k_1036[] = "who (line 13526)";
static char __pyx_k_1037[] = "Print the Numpy arrays in the given dictionary.\n\n    If there is no dictionary passed in or `vardict` is None then returns\n    Numpy arrays in the globals() dictionary (all Numpy arrays in the\n    namespace).\n\n    Parameters\n    ----------\n    vardict : dict, optional\n        A dictionary possibly containing ndarrays.  Default is globals().\n\n    Returns\n    -------\n    out : None\n        Returns 'None'.\n\n    Notes\n    -----\n    Prints out the name, shape, bytes and type of all of the ndarrays present\n    in `vardict`.\n\n    Examples\n    --------\n    >>> a = np.arange(10)\n    >>> b = np.ones(20)\n    >>> np.who()\n    Name            Shape            Bytes            Type\n    ===========================================================\n    a               10               40               int32\n    b               20               160              float64\n    Upper bound on total bytes  =       200\n\n    >>> d = {'x': np.arange(2.0), 'y': np.arange(3.0), 'txt': 'Some str',\n    ... 'idx':5}\n    >>> np.who(d)\n    Name            Shape            Bytes            Type\n    ===========================================================\n    y               3                24               float64\n    x               2                16               float64\n    Upper bound on total bytes  =       40\n    \n    ";
static char __pyx_k__all[] = "all";
static char __pyx_k__any[] = "any";
static char __pyx_k__ar1[] = "ar1";
static char __pyx_k__ar2[] = "ar2";
static char __pyx_k__arr[] = "arr";
static char __pyx_k__ary[] = "ary";
static char __pyx_k__cov[] = "cov";
static char __pyx_k__deg[] = "deg";
static char __pyx_k__doc[] = "doc";
static char __pyx_k__end[] = "end";
static char __pyx_k__fix[] = "fix";
static char __pyx_k__fmt[] = "fmt";
static char __pyx_k__ind[] = "ind";
static char __pyx_k__irr[] = "irr";
static char __pyx_k__ix_[] = "ix_";
static char __pyx_k__mat[] = "mat";
static char __pyx_k__max[] = "max";
static char __pyx_k__min[] = "min";
static char __pyx_k__msg[] = "msg";
static char __pyx_k__nin[] = "nin";
static char __pyx_k__npv[] = "npv";
static char __pyx_k__num[] = "num";
static char __pyx_k__obj[] = "obj";
static char __pyx_k__out[] = "out";
static char __pyx_k__per[] = "per";
static char __pyx_k__pmt[] = "pmt";
static char __pyx_k__ptp[] = "ptp";
static char __pyx_k__put[] = "put";
static char __pyx_k__rep[] = "rep";
static char __pyx_k__sep[] = "sep";
static char __pyx_k__std[] = "std";
static char __pyx_k__sum[] = "sum";
static char __pyx_k__sys[] = "sys";
static char __pyx_k__tol[] = "tol";
static char __pyx_k__tri[] = "tri";
static char __pyx_k__tup[] = "tup";
static char __pyx_k__val[] = "val";
static char __pyx_k__var[] = "var";
static char __pyx_k__who[] = "who";
static char __pyx_k__amax[] = "amax";
static char __pyx_k__amin[] = "amin";
static char __pyx_k__arg1[] = "arg1";
static char __pyx_k__arg2[] = "arg2";
static char __pyx_k__atol[] = "atol";
static char __pyx_k__axes[] = "axes";
static char __pyx_k__axis[] = "axis";
static char __pyx_k__base[] = "base";
static char __pyx_k__beta[] = "beta";
static char __pyx_k__bias[] = "bias";
static char __pyx_k__bins[] = "bins";
static char __pyx_k__bmat[] = "bmat";
static char __pyx_k__copy[] = "copy";
static char __pyx_k__data[] = "data";
static char __pyx_k__ddof[] = "ddof";
static char __pyx_k__diff[] = "diff";
static char __pyx_k__dims[] = "dims";
static char __pyx_k__disp[] = "disp";
static char __pyx_k__file[] = "file";
static char __pyx_k__filt[] = "filt";
static char __pyx_k__full[] = "full";
static char __pyx_k__func[] = "func";
static char __pyx_k__imag[] = "imag";
static char __pyx_k__in1d[] = "in1d";
static char __pyx_k__info[] = "info";
static char __pyx_k__ipmt[] = "ipmt";
static char __pyx_k__keys[] = "keys";
static char __pyx_k__kind[] = "kind";
static char __pyx_k__kron[] = "kron";
static char __pyx_k__left[] = "left";
static char __pyx_k__load[] = "load";
static char __pyx_k__mask[] = "mask";
static char __pyx_k__mean[] = "mean";
static char __pyx_k__mesg[] = "mesg";
static char __pyx_k__mirr[] = "mirr";
static char __pyx_k__mode[] = "mode";
static char __pyx_k__ndim[] = "ndim";
static char __pyx_k__nout[] = "nout";
static char __pyx_k__nper[] = "nper";
static char __pyx_k__over[] = "over";
static char __pyx_k__poly[] = "poly";
static char __pyx_k__ppmt[] = "ppmt";
static char __pyx_k__prod[] = "prod";
static char __pyx_k__rank[] = "rank";
static char __pyx_k__rate[] = "rate";
static char __pyx_k__real[] = "real";
static char __pyx_k__repr[] = "repr";
static char __pyx_k__reps[] = "reps";
static char __pyx_k__roll[] = "roll";
static char __pyx_k__rtol[] = "rtol";
static char __pyx_k__save[] = "save";
static char __pyx_k__side[] = "side";
static char __pyx_k__sinc[] = "sinc";
static char __pyx_k__size[] = "size";
static char __pyx_k__sort[] = "sort";
static char __pyx_k__take[] = "take";
static char __pyx_k__tile[] = "tile";
static char __pyx_k__tril[] = "tril";
static char __pyx_k__trim[] = "trim";
static char __pyx_k__triu[] = "triu";
static char __pyx_k__type[] = "type";
static char __pyx_k__vals[] = "vals";
static char __pyx_k__vdot[] = "vdot";
static char __pyx_k__what[] = "what";
static char __pyx_k__when[] = "when";
static char __pyx_k__angle[] = "angle";
static char __pyx_k__array[] = "array";
static char __pyx_k__axis1[] = "axis1";
static char __pyx_k__axis2[] = "axis2";
static char __pyx_k__axisa[] = "axisa";
static char __pyx_k__axisb[] = "axisb";
static char __pyx_k__axisc[] = "axisc";
static char __pyx_k__char_[] = "char_";
static char __pyx_k__count[] = "count";
static char __pyx_k__cross[] = "cross";
static char __pyx_k__dtype[] = "dtype";
static char __pyx_k__fname[] = "fname";
static char __pyx_k__gdict[] = "gdict";
static char __pyx_k__guess[] = "guess";
static char __pyx_k__inner[] = "inner";
static char __pyx_k__ldict[] = "ldict";
static char __pyx_k__loads[] = "loads";
static char __pyx_k__loose[] = "loose";
static char __pyx_k__msort[] = "msort";
static char __pyx_k__names[] = "names";
static char __pyx_k__ndmin[] = "ndmin";
static char __pyx_k__numpy[] = "numpy";
static char __pyx_k__order[] = "order";
static char __pyx_k__outer[] = "outer";
static char __pyx_k__place[] = "place";
static char __pyx_k__raise[] = "raise";
static char __pyx_k__range[] = "range";
static char __pyx_k__ravel[] = "ravel";
static char __pyx_k__rcond[] = "rcond";
static char __pyx_k__right[] = "right";
static char __pyx_k__roots[] = "roots";
static char __pyx_k__rot90[] = "rot90";
static char __pyx_k__round[] = "round";
static char __pyx_k__savez[] = "savez";
static char __pyx_k__shift[] = "shift";
static char __pyx_k__split[] = "split";
static char __pyx_k__start[] = "start";
static char __pyx_k__style[] = "style";
static char __pyx_k__subok[] = "subok";
static char __pyx_k__trace[] = "trace";
static char __pyx_k__trapz[] = "trapz";
static char __pyx_k__type1[] = "type1";
static char __pyx_k__type2[] = "type2";
static char __pyx_k__under[] = "under";
static char __pyx_k__valid[] = "valid";
static char __pyx_k__where[] = "where";
static char __pyx_k__width[] = "width";
static char __pyx_k__GDFgdf[] = "GDFgdf";
static char __pyx_k__append[] = "append";
static char __pyx_k__argmax[] = "argmax";
static char __pyx_k__argmin[] = "argmin";
static char __pyx_k__around[] = "around";
static char __pyx_k__buffer[] = "buffer";
static char __pyx_k__choose[] = "choose";
static char __pyx_k__cumsum[] = "cumsum";
static char __pyx_k__delete[] = "delete";
static char __pyx_k__device[] = "device";
static char __pyx_k__divide[] = "divide";
static char __pyx_k__dsplit[] = "dsplit";
static char __pyx_k__dstack[] = "dstack";
static char __pyx_k__einsum[] = "einsum";
static char __pyx_k__errobj[] = "errobj";
static char __pyx_k__fliplr[] = "fliplr";
static char __pyx_k__flipud[] = "flipud";
static char __pyx_k__func1d[] = "func1d";
static char __pyx_k__geterr[] = "geterr";
static char __pyx_k__hsplit[] = "hsplit";
static char __pyx_k__hstack[] = "hstack";
static char __pyx_k__infstr[] = "infstr";
static char __pyx_k__insert[] = "insert";
static char __pyx_k__interp[] = "interp";
static char __pyx_k__isreal[] = "isreal";
static char __pyx_k__kaiser[] = "kaiser";
static char __pyx_k__median[] = "median";
static char __pyx_k__module[] = "module";
static char __pyx_k__nanmax[] = "nanmax";
static char __pyx_k__nanmin[] = "nanmin";
static char __pyx_k__nanstr[] = "nanstr";
static char __pyx_k__nansum[] = "nansum";
static char __pyx_k__normed[] = "normed";
static char __pyx_k__number[] = "number";
static char __pyx_k__object[] = "object";
static char __pyx_k__offset[] = "offset";
static char __pyx_k__output[] = "output";
static char __pyx_k__prefix[] = "prefix";
static char __pyx_k__regexp[] = "regexp";
static char __pyx_k__repeat[] = "repeat";
static char __pyx_k__resize[] = "resize";
static char __pyx_k__round_[] = "round_";
static char __pyx_k__rowvar[] = "rowvar";
static char __pyx_k__sample[] = "sample";
static char __pyx_k__sctype[] = "sctype";
static char __pyx_k__select[] = "select";
static char __pyx_k__seterr[] = "seterr";
static char __pyx_k__source[] = "source";
static char __pyx_k__stdout[] = "stdout";
static char __pyx_k__string[] = "string";
static char __pyx_k__to_end[] = "to_end";
static char __pyx_k__unique[] = "unique";
static char __pyx_k__unpack[] = "unpack";
static char __pyx_k__unwrap[] = "unwrap";
static char __pyx_k__values[] = "values";
static char __pyx_k__vander[] = "vander";
static char __pyx_k__vsplit[] = "vsplit";
static char __pyx_k__vstack[] = "vstack";
static char __pyx_k__alltrue[] = "alltrue";
static char __pyx_k__argsort[] = "argsort";
static char __pyx_k__average[] = "average";
static char __pyx_k__choices[] = "choices";
static char __pyx_k__cumprod[] = "cumprod";
static char __pyx_k__default[] = "default";
static char __pyx_k__density[] = "density";
static char __pyx_k__discont[] = "discont";
static char __pyx_k__ediff1d[] = "ediff1d";
static char __pyx_k__extract[] = "extract";
static char __pyx_k__float64[] = "float64";
static char __pyx_k__hamming[] = "hamming";
static char __pyx_k__hanning[] = "hanning";
static char __pyx_k__indices[] = "indices";
static char __pyx_k__invalid[] = "invalid";
static char __pyx_k__lexsort[] = "lexsort";
static char __pyx_k__loadtxt[] = "loadtxt";
static char __pyx_k__lookfor[] = "lookfor";
static char __pyx_k__maxiter[] = "maxiter";
static char __pyx_k__missing[] = "missing";
static char __pyx_k__myarray[] = "myarray";
static char __pyx_k__newline[] = "newline";
static char __pyx_k__nonzero[] = "nonzero";
static char __pyx_k__padding[] = "padding";
static char __pyx_k__pkgload[] = "pkgload";
static char __pyx_k__polyadd[] = "polyadd";
static char __pyx_k__polyder[] = "polyder";
static char __pyx_k__polydiv[] = "polydiv";
static char __pyx_k__polyfit[] = "polyfit";
static char __pyx_k__polyint[] = "polyint";
static char __pyx_k__polymul[] = "polymul";
static char __pyx_k__polysub[] = "polysub";
static char __pyx_k__polyval[] = "polyval";
static char __pyx_k__product[] = "product";
static char __pyx_k__putmask[] = "putmask";
static char __pyx_k__repeats[] = "repeats";
static char __pyx_k__require[] = "require";
static char __pyx_k__reshape[] = "reshape";
static char __pyx_k__savetxt[] = "savetxt";
static char __pyx_k__squeeze[] = "squeeze";
static char __pyx_k__typeset[] = "typeset";
static char __pyx_k__union1d[] = "union1d";
static char __pyx_k__usecols[] = "usecols";
static char __pyx_k__usemask[] = "usemask";
static char __pyx_k__vardict[] = "vardict";
static char __pyx_k__weights[] = "weights";
static char __pyx_k____main__[] = "__main__";
static char __pyx_k____test__[] = "__test__";
static char __pyx_k__allclose[] = "allclose";
static char __pyx_k__alterdot[] = "alterdot";
static char __pyx_k__argwhere[] = "argwhere";
static char __pyx_k__asfarray[] = "asfarray";
static char __pyx_k__asmatrix[] = "asmatrix";
static char __pyx_k__asscalar[] = "asscalar";
static char __pyx_k__bartlett[] = "bartlett";
static char __pyx_k__bincount[] = "bincount";
static char __pyx_k__blackman[] = "blackman";
static char __pyx_k__can_cast[] = "can_cast";
static char __pyx_k__comments[] = "comments";
static char __pyx_k__compress[] = "compress";
static char __pyx_k__condlist[] = "condlist";
static char __pyx_k__convolve[] = "convolve";
static char __pyx_k__corrcoef[] = "corrcoef";
static char __pyx_k__decimals[] = "decimals";
static char __pyx_k__diagflat[] = "diagflat";
static char __pyx_k__digitize[] = "digitize";
static char __pyx_k__fromfile[] = "fromfile";
static char __pyx_k__fromiter[] = "fromiter";
static char __pyx_k__funclist[] = "funclist";
static char __pyx_k__gradient[] = "gradient";
static char __pyx_k__isneginf[] = "isneginf";
static char __pyx_k__isposinf[] = "isposinf";
static char __pyx_k__isscalar[] = "isscalar";
static char __pyx_k__issctype[] = "issctype";
static char __pyx_k__iterable[] = "iterable";
static char __pyx_k__linefeed[] = "linefeed";
static char __pyx_k__maxwidth[] = "maxwidth";
static char __pyx_k__meshgrid[] = "meshgrid";
static char __pyx_k__newshape[] = "newshape";
static char __pyx_k__packbits[] = "packbits";
static char __pyx_k__returned[] = "returned";
static char __pyx_k__rollaxis[] = "rollaxis";
static char __pyx_k__setxor1d[] = "setxor1d";
static char __pyx_k__skiprows[] = "skiprows";
static char __pyx_k__sometrue[] = "sometrue";
static char __pyx_k__suppress[] = "suppress";
static char __pyx_k__swapaxes[] = "swapaxes";
static char __pyx_k__to_begin[] = "to_begin";
static char __pyx_k__toplevel[] = "toplevel";
static char __pyx_k__typename[] = "typename";
static char __pyx_k__array_str[] = "array_str";
static char __pyx_k__autostrip[] = "autostrip";
static char __pyx_k__base_repr[] = "base_repr";
static char __pyx_k__condition[] = "condition";
static char __pyx_k__correlate[] = "correlate";
static char __pyx_k__delimiter[] = "delimiter";
static char __pyx_k__deprecate[] = "deprecate";
static char __pyx_k__docstring[] = "docstring";
static char __pyx_k__edgeitems[] = "edgeitems";
static char __pyx_k__fromregex[] = "fromregex";
static char __pyx_k__getbuffer[] = "getbuffer";
static char __pyx_k__geterrobj[] = "geterrobj";
static char __pyx_k__histogram[] = "histogram";
static char __pyx_k__iscomplex[] = "iscomplex";
static char __pyx_k__isfortran[] = "isfortran";
static char __pyx_k__isrealobj[] = "isrealobj";
static char __pyx_k__linewidth[] = "linewidth";
static char __pyx_k__mafromtxt[] = "mafromtxt";
static char __pyx_k__mask_func[] = "mask_func";
static char __pyx_k__minlength[] = "minlength";
static char __pyx_k__mmap_mode[] = "mmap_mode";
static char __pyx_k__nanargmax[] = "nanargmax";
static char __pyx_k__nanargmin[] = "nanargmin";
static char __pyx_k__ndfromtxt[] = "ndfromtxt";
static char __pyx_k__new_shape[] = "new_shape";
static char __pyx_k__newbuffer[] = "newbuffer";
static char __pyx_k__piecewise[] = "piecewise";
static char __pyx_k__precision[] = "precision";
static char __pyx_k__quicksort[] = "quicksort";
static char __pyx_k__row_stack[] = "row_stack";
static char __pyx_k__safe_eval[] = "safe_eval";
static char __pyx_k__separator[] = "separator";
static char __pyx_k__setdiff1d[] = "setdiff1d";
static char __pyx_k__seterrobj[] = "seterrobj";
static char __pyx_k__tensordot[] = "tensordot";
static char __pyx_k__threshold[] = "threshold";
static char __pyx_k__transpose[] = "transpose";
static char __pyx_k__typechars[] = "typechars";
static char __pyx_k__ValueError[] = "ValueError";
static char __pyx_k____import__[] = "__import__";
static char __pyx_k__add_newdoc[] = "add_newdoc";
static char __pyx_k__array_repr[] = "array_repr";
static char __pyx_k__asanyarray[] = "asanyarray";
static char __pyx_k__atleast_1d[] = "atleast_1d";
static char __pyx_k__atleast_2d[] = "atleast_2d";
static char __pyx_k__atleast_3d[] = "atleast_3d";
static char __pyx_k__choicelist[] = "choicelist";
static char __pyx_k__converters[] = "converters";
static char __pyx_k__cumproduct[] = "cumproduct";
static char __pyx_k__defaultfmt[] = "defaultfmt";
static char __pyx_k__dimensions[] = "dimensions";
static char __pyx_k__frombuffer[] = "frombuffer";
static char __pyx_k__frompyfunc[] = "frompyfunc";
static char __pyx_k__fromstring[] = "fromstring";
static char __pyx_k__genfromtxt[] = "genfromtxt";
static char __pyx_k__getbufsize[] = "getbufsize";
static char __pyx_k__geterrcall[] = "geterrcall";
static char __pyx_k__issubdtype[] = "issubdtype";
static char __pyx_k__nan_to_num[] = "nan_to_num";
static char __pyx_k__obj2sctype[] = "obj2sctype";
static char __pyx_k__percentile[] = "percentile";
static char __pyx_k__recfromcsv[] = "recfromcsv";
static char __pyx_k__recfromtxt[] = "recfromtxt";
static char __pyx_k__regenerate[] = "regenerate";
static char __pyx_k__restoredot[] = "restoredot";
static char __pyx_k__setbufsize[] = "setbufsize";
static char __pyx_k__seterrcall[] = "seterrcall";
static char __pyx_k__trim_zeros[] = "trim_zeros";
static char __pyx_k__unpackbits[] = "unpackbits";
static char __pyx_k__array_equal[] = "array_equal";
static char __pyx_k__array_equiv[] = "array_equiv";
static char __pyx_k__array_split[] = "array_split";
static char __pyx_k__array_types[] = "array_types";
static char __pyx_k__binary_repr[] = "binary_repr";
static char __pyx_k__byte_bounds[] = "byte_bounds";
static char __pyx_k__common_type[] = "common_type";
static char __pyx_k__concatenate[] = "concatenate";
static char __pyx_k__deletechars[] = "deletechars";
static char __pyx_k__excludelist[] = "excludelist";
static char __pyx_k__expand_dims[] = "expand_dims";
static char __pyx_k__flatnonzero[] = "flatnonzero";
static char __pyx_k__get_include[] = "get_include";
static char __pyx_k__histogram2d[] = "histogram2d";
static char __pyx_k__histogramdd[] = "histogramdd";
static char __pyx_k__intersect1d[] = "intersect1d";
static char __pyx_k__issubclass_[] = "issubclass_";
static char __pyx_k__issubsctype[] = "issubsctype";
static char __pyx_k__mintypecode[] = "mintypecode";
static char __pyx_k__multi_index[] = "multi_index";
static char __pyx_k__result_type[] = "result_type";
static char __pyx_k__sctype2char[] = "sctype2char";
static char __pyx_k__show_config[] = "show_config";
static char __pyx_k__skip_footer[] = "skip_footer";
static char __pyx_k__skip_header[] = "skip_header";
static char __pyx_k__RuntimeError[] = "RuntimeError";
static char __pyx_k__array2string[] = "array2string";
static char __pyx_k__column_stack[] = "column_stack";
static char __pyx_k__diag_indices[] = "diag_indices";
static char __pyx_k__finance_rate[] = "finance_rate";
static char __pyx_k__int_asbuffer[] = "int_asbuffer";
static char __pyx_k__iscomplexobj[] = "iscomplexobj";
static char __pyx_k__mask_indices[] = "mask_indices";
static char __pyx_k__nested_iters[] = "nested_iters";
static char __pyx_k__old_behavior[] = "old_behavior";
static char __pyx_k__requirements[] = "requirements";
static char __pyx_k__return_index[] = "return_index";
static char __pyx_k__scalar_types[] = "scalar_types";
static char __pyx_k__searchsorted[] = "searchsorted";
static char __pyx_k__seq_of_zeros[] = "seq_of_zeros";
static char __pyx_k__sort_complex[] = "sort_complex";
static char __pyx_k__tril_indices[] = "tril_indices";
static char __pyx_k__triu_indices[] = "triu_indices";
static char __pyx_k__assume_unique[] = "assume_unique";
static char __pyx_k__count_nonzero[] = "count_nonzero";
static char __pyx_k__datetime_data[] = "datetime_data";
static char __pyx_k__fill_diagonal[] = "fill_diagonal";
static char __pyx_k__invalid_raise[] = "invalid_raise";
static char __pyx_k__promote_types[] = "promote_types";
static char __pyx_k__real_if_close[] = "real_if_close";
static char __pyx_k__reinvest_rate[] = "reinvest_rate";
static char __pyx_k__replace_space[] = "replace_space";
static char __pyx_k__unravel_index[] = "unravel_index";
static char __pyx_k__asfortranarray[] = "asfortranarray";
static char __pyx_k__case_sensitive[] = "case_sensitive";
static char __pyx_k__filling_values[] = "filling_values";
static char __pyx_k__get_array_wrap[] = "get_array_wrap";
static char __pyx_k__import_modules[] = "import_modules";
static char __pyx_k__max_line_width[] = "max_line_width";
static char __pyx_k__maximum_sctype[] = "maximum_sctype";
static char __pyx_k__missing_values[] = "missing_values";
static char __pyx_k__return_inverse[] = "return_inverse";
static char __pyx_k__suppress_small[] = "suppress_small";
static char __pyx_k__apply_over_axes[] = "apply_over_axes";
static char __pyx_k__min_scalar_type[] = "min_scalar_type";
static char __pyx_k__overwrite_input[] = "overwrite_input";
static char __pyx_k__set_numeric_ops[] = "set_numeric_ops";
static char __pyx_k__apply_along_axis[] = "apply_along_axis";
static char __pyx_k__broadcast_arrays[] = "broadcast_arrays";
static char __pyx_k__find_common_type[] = "find_common_type";
static char __pyx_k__get_printoptions[] = "get_printoptions";
static char __pyx_k__may_share_memory[] = "may_share_memory";
static char __pyx_k__savez_compressed[] = "savez_compressed";
static char __pyx_k__set_printoptions[] = "set_printoptions";
static char __pyx_k__arrays_and_dtypes[] = "arrays_and_dtypes";
static char __pyx_k__asarray_chkfinite[] = "asarray_chkfinite";
static char __pyx_k__ascontiguousarray[] = "ascontiguousarray";
static char __pyx_k__diag_indices_from[] = "diag_indices_from";
static char __pyx_k__ravel_multi_index[] = "ravel_multi_index";
static char __pyx_k__tril_indices_from[] = "tril_indices_from";
static char __pyx_k__triu_indices_from[] = "triu_indices_from";
static char __pyx_k__compare_chararrays[] = "compare_chararrays";
static char __pyx_k__deprecate_with_doc[] = "deprecate_with_doc";
static char __pyx_k__NotImplementedError[] = "NotImplementedError";
static char __pyx_k__indices_or_sections[] = "indices_or_sections";
static char __pyx_k__set_string_function[] = "set_string_function";
static PyObject *__pyx_kp_u_1000;
static PyObject *__pyx_kp_u_1001;
static PyObject *__pyx_kp_u_1002;
static PyObject *__pyx_kp_u_1003;
static PyObject *__pyx_kp_u_1004;
static PyObject *__pyx_kp_u_1005;
static PyObject *__pyx_kp_u_1006;
static PyObject *__pyx_kp_u_1007;
static PyObject *__pyx_kp_u_1008;
static PyObject *__pyx_kp_u_1009;
static PyObject *__pyx_kp_u_1010;
static PyObject *__pyx_kp_u_1011;
static PyObject *__pyx_kp_u_1012;
static PyObject *__pyx_kp_u_1013;
static PyObject *__pyx_kp_u_1014;
static PyObject *__pyx_kp_u_1015;
static PyObject *__pyx_kp_u_1016;
static PyObject *__pyx_kp_u_1017;
static PyObject *__pyx_kp_u_1018;
static PyObject *__pyx_kp_u_1019;
static PyObject *__pyx_kp_u_1020;
static PyObject *__pyx_kp_u_1021;
static PyObject *__pyx_kp_u_1022;
static PyObject *__pyx_kp_u_1023;
static PyObject *__pyx_kp_u_1024;
static PyObject *__pyx_kp_u_1025;
static PyObject *__pyx_kp_u_1026;
static PyObject *__pyx_kp_u_1027;
static PyObject *__pyx_kp_u_1028;
static PyObject *__pyx_kp_u_1029;
static PyObject *__pyx_kp_u_1030;
static PyObject *__pyx_kp_u_1031;
static PyObject *__pyx_kp_u_1032;
static PyObject *__pyx_kp_u_1033;
static PyObject *__pyx_kp_u_1034;
static PyObject *__pyx_kp_u_1035;
static PyObject *__pyx_kp_u_1036;
static PyObject *__pyx_kp_u_1037;
static PyObject *__pyx_kp_s_16;
static PyObject *__pyx_kp_s_19;
static PyObject *__pyx_n_s_212;
static PyObject *__pyx_n_s_245;
static PyObject *__pyx_kp_s_42;
static PyObject *__pyx_kp_s_43;
static PyObject *__pyx_kp_s_5;
static PyObject *__pyx_kp_u_53;
static PyObject *__pyx_kp_u_55;
static PyObject *__pyx_kp_u_57;
static PyObject *__pyx_kp_u_582;
static PyObject *__pyx_kp_u_583;
static PyObject *__pyx_kp_u_584;
static PyObject *__pyx_kp_u_585;
static PyObject *__pyx_kp_u_586;
static PyObject *__pyx_kp_u_587;
static PyObject *__pyx_kp_u_588;
static PyObject *__pyx_kp_u_589;
static PyObject *__pyx_kp_u_59;
static PyObject *__pyx_kp_u_590;
static PyObject *__pyx_kp_u_591;
static PyObject *__pyx_kp_u_592;
static PyObject *__pyx_kp_u_593;
static PyObject *__pyx_kp_u_594;
static PyObject *__pyx_kp_u_595;
static PyObject *__pyx_kp_u_596;
static PyObject *__pyx_kp_u_597;
static PyObject *__pyx_kp_u_598;
static PyObject *__pyx_kp_u_599;
static PyObject *__pyx_kp_s_6;
static PyObject *__pyx_kp_u_60;
static PyObject *__pyx_kp_u_600;
static PyObject *__pyx_kp_u_601;
static PyObject *__pyx_kp_u_602;
static PyObject *__pyx_kp_u_603;
static PyObject *__pyx_kp_u_604;
static PyObject *__pyx_kp_u_605;
static PyObject *__pyx_kp_u_606;
static PyObject *__pyx_kp_u_607;
static PyObject *__pyx_kp_u_608;
static PyObject *__pyx_kp_u_609;
static PyObject *__pyx_kp_u_610;
static PyObject *__pyx_kp_u_611;
static PyObject *__pyx_kp_u_612;
static PyObject *__pyx_kp_u_613;
static PyObject *__pyx_kp_u_614;
static PyObject *__pyx_kp_u_615;
static PyObject *__pyx_kp_u_616;
static PyObject *__pyx_kp_u_617;
static PyObject *__pyx_kp_u_618;
static PyObject *__pyx_kp_u_619;
static PyObject *__pyx_kp_u_620;
static PyObject *__pyx_kp_u_621;
static PyObject *__pyx_kp_u_622;
static PyObject *__pyx_kp_u_623;
static PyObject *__pyx_kp_u_624;
static PyObject *__pyx_kp_u_625;
static PyObject *__pyx_kp_u_626;
static PyObject *__pyx_kp_u_627;
static PyObject *__pyx_kp_u_628;
static PyObject *__pyx_kp_u_629;
static PyObject *__pyx_kp_u_63;
static PyObject *__pyx_kp_u_630;
static PyObject *__pyx_kp_u_631;
static PyObject *__pyx_kp_u_632;
static PyObject *__pyx_kp_u_633;
static PyObject *__pyx_kp_u_634;
static PyObject *__pyx_kp_u_635;
static PyObject *__pyx_kp_u_636;
static PyObject *__pyx_kp_u_637;
static PyObject *__pyx_kp_u_638;
static PyObject *__pyx_kp_u_639;
static PyObject *__pyx_kp_u_640;
static PyObject *__pyx_kp_u_641;
static PyObject *__pyx_kp_u_642;
static PyObject *__pyx_kp_u_643;
static PyObject *__pyx_kp_u_644;
static PyObject *__pyx_kp_u_645;
static PyObject *__pyx_kp_u_646;
static PyObject *__pyx_kp_u_647;
static PyObject *__pyx_kp_u_648;
static PyObject *__pyx_kp_u_649;
static PyObject *__pyx_kp_u_650;
static PyObject *__pyx_kp_u_651;
static PyObject *__pyx_kp_u_652;
static PyObject *__pyx_kp_u_653;
static PyObject *__pyx_kp_u_654;
static PyObject *__pyx_kp_u_655;
static PyObject *__pyx_kp_u_656;
static PyObject *__pyx_kp_u_657;
static PyObject *__pyx_kp_u_658;
static PyObject *__pyx_kp_u_659;
static PyObject *__pyx_kp_u_660;
static PyObject *__pyx_kp_u_661;
static PyObject *__pyx_kp_u_662;
static PyObject *__pyx_kp_u_663;
static PyObject *__pyx_kp_u_664;
static PyObject *__pyx_kp_u_665;
static PyObject *__pyx_kp_u_666;
static PyObject *__pyx_kp_u_667;
static PyObject *__pyx_kp_u_668;
static PyObject *__pyx_kp_u_669;
static PyObject *__pyx_kp_s_67;
static PyObject *__pyx_kp_u_670;
static PyObject *__pyx_kp_u_671;
static PyObject *__pyx_kp_u_672;
static PyObject *__pyx_kp_u_673;
static PyObject *__pyx_kp_u_674;
static PyObject *__pyx_kp_u_675;
static PyObject *__pyx_kp_u_676;
static PyObject *__pyx_kp_u_677;
static PyObject *__pyx_kp_u_678;
static PyObject *__pyx_kp_u_679;
static PyObject *__pyx_n_s_68;
static PyObject *__pyx_kp_u_680;
static PyObject *__pyx_kp_u_681;
static PyObject *__pyx_kp_u_682;
static PyObject *__pyx_kp_u_683;
static PyObject *__pyx_kp_u_684;
static PyObject *__pyx_kp_u_685;
static PyObject *__pyx_kp_u_686;
static PyObject *__pyx_kp_u_687;
static PyObject *__pyx_kp_u_688;
static PyObject *__pyx_kp_u_689;
static PyObject *__pyx_kp_u_690;
static PyObject *__pyx_kp_u_691;
static PyObject *__pyx_kp_u_692;
static PyObject *__pyx_kp_u_693;
static PyObject *__pyx_kp_u_694;
static PyObject *__pyx_kp_u_695;
static PyObject *__pyx_kp_u_696;
static PyObject *__pyx_kp_u_697;
static PyObject *__pyx_kp_u_698;
static PyObject *__pyx_kp_u_699;
static PyObject *__pyx_kp_u_700;
static PyObject *__pyx_kp_u_701;
static PyObject *__pyx_kp_u_702;
static PyObject *__pyx_kp_u_703;
static PyObject *__pyx_kp_u_704;
static PyObject *__pyx_kp_u_705;
static PyObject *__pyx_kp_u_706;
static PyObject *__pyx_kp_u_707;
static PyObject *__pyx_kp_u_708;
static PyObject *__pyx_kp_u_709;
static PyObject *__pyx_kp_u_710;
static PyObject *__pyx_kp_u_711;
static PyObject *__pyx_kp_u_712;
static PyObject *__pyx_kp_u_713;
static PyObject *__pyx_kp_u_714;
static PyObject *__pyx_kp_u_715;
static PyObject *__pyx_kp_u_716;
static PyObject *__pyx_kp_u_717;
static PyObject *__pyx_kp_u_718;
static PyObject *__pyx_kp_u_719;
static PyObject *__pyx_kp_u_720;
static PyObject *__pyx_kp_u_721;
static PyObject *__pyx_kp_u_722;
static PyObject *__pyx_kp_u_723;
static PyObject *__pyx_kp_u_724;
static PyObject *__pyx_kp_u_725;
static PyObject *__pyx_kp_u_726;
static PyObject *__pyx_kp_u_727;
static PyObject *__pyx_kp_u_728;
static PyObject *__pyx_kp_u_729;
static PyObject *__pyx_kp_u_730;
static PyObject *__pyx_kp_u_731;
static PyObject *__pyx_kp_u_732;
static PyObject *__pyx_kp_u_733;
static PyObject *__pyx_kp_u_734;
static PyObject *__pyx_kp_u_735;
static PyObject *__pyx_kp_u_736;
static PyObject *__pyx_kp_u_737;
static PyObject *__pyx_kp_u_738;
static PyObject *__pyx_kp_u_739;
static PyObject *__pyx_kp_u_740;
static PyObject *__pyx_kp_u_741;
static PyObject *__pyx_kp_u_742;
static PyObject *__pyx_kp_u_743;
static PyObject *__pyx_kp_u_744;
static PyObject *__pyx_kp_u_745;
static PyObject *__pyx_kp_u_746;
static PyObject *__pyx_kp_u_747;
static PyObject *__pyx_kp_u_748;
static PyObject *__pyx_kp_u_749;
static PyObject *__pyx_kp_u_750;
static PyObject *__pyx_kp_u_751;
static PyObject *__pyx_kp_u_752;
static PyObject *__pyx_kp_u_753;
static PyObject *__pyx_kp_u_754;
static PyObject *__pyx_kp_u_755;
static PyObject *__pyx_kp_u_756;
static PyObject *__pyx_kp_u_757;
static PyObject *__pyx_kp_u_758;
static PyObject *__pyx_kp_u_759;
static PyObject *__pyx_kp_u_760;
static PyObject *__pyx_kp_u_761;
static PyObject *__pyx_kp_u_762;
static PyObject *__pyx_kp_u_763;
static PyObject *__pyx_kp_u_764;
static PyObject *__pyx_kp_u_765;
static PyObject *__pyx_kp_u_766;
static PyObject *__pyx_kp_u_767;
static PyObject *__pyx_kp_u_768;
static PyObject *__pyx_kp_u_769;
static PyObject *__pyx_kp_u_770;
static PyObject *__pyx_kp_u_771;
static PyObject *__pyx_kp_u_772;
static PyObject *__pyx_kp_u_773;
static PyObject *__pyx_kp_u_774;
static PyObject *__pyx_kp_u_775;
static PyObject *__pyx_kp_u_776;
static PyObject *__pyx_kp_u_777;
static PyObject *__pyx_kp_u_778;
static PyObject *__pyx_kp_u_779;
static PyObject *__pyx_kp_u_780;
static PyObject *__pyx_kp_u_781;
static PyObject *__pyx_kp_u_782;
static PyObject *__pyx_kp_u_783;
static PyObject *__pyx_kp_u_784;
static PyObject *__pyx_kp_u_785;
static PyObject *__pyx_kp_u_786;
static PyObject *__pyx_kp_u_787;
static PyObject *__pyx_kp_u_788;
static PyObject *__pyx_kp_u_789;
static PyObject *__pyx_kp_u_790;
static PyObject *__pyx_kp_u_791;
static PyObject *__pyx_kp_u_792;
static PyObject *__pyx_kp_u_793;
static PyObject *__pyx_kp_u_794;
static PyObject *__pyx_kp_u_795;
static PyObject *__pyx_kp_u_796;
static PyObject *__pyx_kp_u_797;
static PyObject *__pyx_kp_u_798;
static PyObject *__pyx_kp_u_799;
static PyObject *__pyx_kp_u_800;
static PyObject *__pyx_kp_u_801;
static PyObject *__pyx_kp_u_802;
static PyObject *__pyx_kp_u_803;
static PyObject *__pyx_kp_u_804;
static PyObject *__pyx_kp_u_805;
static PyObject *__pyx_kp_u_806;
static PyObject *__pyx_kp_u_807;
static PyObject *__pyx_kp_u_808;
static PyObject *__pyx_kp_u_809;
static PyObject *__pyx_kp_u_810;
static PyObject *__pyx_kp_u_811;
static PyObject *__pyx_kp_u_812;
static PyObject *__pyx_kp_u_813;
static PyObject *__pyx_kp_u_814;
static PyObject *__pyx_kp_u_815;
static PyObject *__pyx_kp_u_816;
static PyObject *__pyx_kp_u_817;
static PyObject *__pyx_kp_u_818;
static PyObject *__pyx_kp_u_819;
static PyObject *__pyx_kp_u_820;
static PyObject *__pyx_kp_u_821;
static PyObject *__pyx_kp_u_822;
static PyObject *__pyx_kp_u_823;
static PyObject *__pyx_kp_u_824;
static PyObject *__pyx_kp_u_825;
static PyObject *__pyx_kp_u_826;
static PyObject *__pyx_kp_u_827;
static PyObject *__pyx_kp_u_828;
static PyObject *__pyx_kp_u_829;
static PyObject *__pyx_kp_u_830;
static PyObject *__pyx_kp_u_831;
static PyObject *__pyx_kp_u_832;
static PyObject *__pyx_kp_u_833;
static PyObject *__pyx_kp_u_834;
static PyObject *__pyx_kp_u_835;
static PyObject *__pyx_kp_u_836;
static PyObject *__pyx_kp_u_837;
static PyObject *__pyx_kp_u_838;
static PyObject *__pyx_kp_u_839;
static PyObject *__pyx_kp_u_840;
static PyObject *__pyx_kp_u_841;
static PyObject *__pyx_kp_u_842;
static PyObject *__pyx_kp_u_843;
static PyObject *__pyx_kp_u_844;
static PyObject *__pyx_kp_u_845;
static PyObject *__pyx_kp_u_846;
static PyObject *__pyx_kp_u_847;
static PyObject *__pyx_kp_u_848;
static PyObject *__pyx_kp_u_849;
static PyObject *__pyx_kp_u_850;
static PyObject *__pyx_kp_u_851;
static PyObject *__pyx_kp_u_852;
static PyObject *__pyx_kp_u_853;
static PyObject *__pyx_kp_u_854;
static PyObject *__pyx_kp_u_855;
static PyObject *__pyx_kp_u_856;
static PyObject *__pyx_kp_u_857;
static PyObject *__pyx_kp_u_858;
static PyObject *__pyx_kp_u_859;
static PyObject *__pyx_kp_u_860;
static PyObject *__pyx_kp_u_861;
static PyObject *__pyx_kp_u_862;
static PyObject *__pyx_kp_u_863;
static PyObject *__pyx_kp_u_864;
static PyObject *__pyx_kp_u_865;
static PyObject *__pyx_kp_u_866;
static PyObject *__pyx_kp_u_867;
static PyObject *__pyx_kp_u_868;
static PyObject *__pyx_kp_u_869;
static PyObject *__pyx_kp_u_870;
static PyObject *__pyx_kp_u_871;
static PyObject *__pyx_kp_u_872;
static PyObject *__pyx_kp_u_873;
static PyObject *__pyx_kp_u_874;
static PyObject *__pyx_kp_u_875;
static PyObject *__pyx_kp_u_876;
static PyObject *__pyx_kp_u_877;
static PyObject *__pyx_kp_u_878;
static PyObject *__pyx_kp_u_879;
static PyObject *__pyx_kp_u_880;
static PyObject *__pyx_kp_u_881;
static PyObject *__pyx_kp_u_882;
static PyObject *__pyx_kp_u_883;
static PyObject *__pyx_kp_u_884;
static PyObject *__pyx_kp_u_885;
static PyObject *__pyx_kp_u_886;
static PyObject *__pyx_kp_u_887;
static PyObject *__pyx_kp_u_888;
static PyObject *__pyx_kp_u_889;
static PyObject *__pyx_kp_u_890;
static PyObject *__pyx_kp_u_891;
static PyObject *__pyx_kp_u_892;
static PyObject *__pyx_kp_u_893;
static PyObject *__pyx_kp_u_894;
static PyObject *__pyx_kp_u_895;
static PyObject *__pyx_kp_u_896;
static PyObject *__pyx_kp_u_897;
static PyObject *__pyx_kp_u_898;
static PyObject *__pyx_kp_u_899;
static PyObject *__pyx_kp_u_900;
static PyObject *__pyx_kp_u_901;
static PyObject *__pyx_kp_u_902;
static PyObject *__pyx_kp_u_903;
static PyObject *__pyx_kp_u_904;
static PyObject *__pyx_kp_u_905;
static PyObject *__pyx_kp_u_906;
static PyObject *__pyx_kp_u_907;
static PyObject *__pyx_kp_u_908;
static PyObject *__pyx_kp_u_909;
static PyObject *__pyx_kp_u_910;
static PyObject *__pyx_kp_u_911;
static PyObject *__pyx_kp_u_912;
static PyObject *__pyx_kp_u_913;
static PyObject *__pyx_kp_u_914;
static PyObject *__pyx_kp_u_915;
static PyObject *__pyx_kp_u_916;
static PyObject *__pyx_kp_u_917;
static PyObject *__pyx_kp_u_918;
static PyObject *__pyx_kp_u_919;
static PyObject *__pyx_kp_u_920;
static PyObject *__pyx_kp_u_921;
static PyObject *__pyx_kp_u_922;
static PyObject *__pyx_kp_u_923;
static PyObject *__pyx_kp_u_924;
static PyObject *__pyx_kp_u_925;
static PyObject *__pyx_kp_u_926;
static PyObject *__pyx_kp_u_927;
static PyObject *__pyx_kp_u_928;
static PyObject *__pyx_kp_u_929;
static PyObject *__pyx_kp_u_930;
static PyObject *__pyx_kp_u_931;
static PyObject *__pyx_kp_u_932;
static PyObject *__pyx_kp_u_933;
static PyObject *__pyx_kp_u_934;
static PyObject *__pyx_kp_u_935;
static PyObject *__pyx_kp_u_936;
static PyObject *__pyx_kp_u_937;
static PyObject *__pyx_kp_u_938;
static PyObject *__pyx_kp_u_939;
static PyObject *__pyx_kp_u_940;
static PyObject *__pyx_kp_u_941;
static PyObject *__pyx_kp_u_942;
static PyObject *__pyx_kp_u_943;
static PyObject *__pyx_kp_u_944;
static PyObject *__pyx_kp_u_945;
static PyObject *__pyx_kp_u_946;
static PyObject *__pyx_kp_u_947;
static PyObject *__pyx_kp_u_948;
static PyObject *__pyx_kp_u_949;
static PyObject *__pyx_kp_u_950;
static PyObject *__pyx_kp_u_951;
static PyObject *__pyx_kp_u_952;
static PyObject *__pyx_kp_u_953;
static PyObject *__pyx_kp_u_954;
static PyObject *__pyx_kp_u_955;
static PyObject *__pyx_kp_u_956;
static PyObject *__pyx_kp_u_957;
static PyObject *__pyx_kp_u_958;
static PyObject *__pyx_kp_u_959;
static PyObject *__pyx_kp_u_960;
static PyObject *__pyx_kp_u_961;
static PyObject *__pyx_kp_u_962;
static PyObject *__pyx_kp_u_963;
static PyObject *__pyx_kp_u_964;
static PyObject *__pyx_kp_u_965;
static PyObject *__pyx_kp_u_966;
static PyObject *__pyx_kp_u_967;
static PyObject *__pyx_kp_u_968;
static PyObject *__pyx_kp_u_969;
static PyObject *__pyx_kp_u_970;
static PyObject *__pyx_kp_u_971;
static PyObject *__pyx_kp_u_972;
static PyObject *__pyx_kp_u_973;
static PyObject *__pyx_kp_u_974;
static PyObject *__pyx_kp_u_975;
static PyObject *__pyx_kp_u_976;
static PyObject *__pyx_kp_u_977;
static PyObject *__pyx_kp_u_978;
static PyObject *__pyx_kp_u_979;
static PyObject *__pyx_kp_u_980;
static PyObject *__pyx_kp_u_981;
static PyObject *__pyx_kp_u_982;
static PyObject *__pyx_kp_u_983;
static PyObject *__pyx_kp_u_984;
static PyObject *__pyx_kp_u_985;
static PyObject *__pyx_kp_u_986;
static PyObject *__pyx_kp_u_987;
static PyObject *__pyx_kp_u_988;
static PyObject *__pyx_kp_u_989;
static PyObject *__pyx_kp_u_990;
static PyObject *__pyx_kp_u_991;
static PyObject *__pyx_kp_u_992;
static PyObject *__pyx_kp_u_993;
static PyObject *__pyx_kp_u_994;
static PyObject *__pyx_kp_u_995;
static PyObject *__pyx_kp_u_996;
static PyObject *__pyx_kp_u_997;
static PyObject *__pyx_kp_u_998;
static PyObject *__pyx_kp_u_999;
static PyObject *__pyx_n_s__A;
static PyObject *__pyx_n_s__C;
static PyObject *__pyx_n_s__GDFgdf;
static PyObject *__pyx_n_s__M;
static PyObject *__pyx_n_s__N;
static PyObject *__pyx_n_s__NotImplementedError;
static PyObject *__pyx_n_s__RuntimeError;
static PyObject *__pyx_n_s__ValueError;
static PyObject *__pyx_n_s__X;
static PyObject *__pyx_n_s___;
static PyObject *__pyx_n_s____import__;
static PyObject *__pyx_n_s____main__;
static PyObject *__pyx_n_s____test__;
static PyObject *__pyx_n_s__a;
static PyObject *__pyx_n_s__a1;
static PyObject *__pyx_n_s__a2;
static PyObject *__pyx_n_s__add_newdoc;
static PyObject *__pyx_n_s__all;
static PyObject *__pyx_n_s__allclose;
static PyObject *__pyx_n_s__alltrue;
static PyObject *__pyx_n_s__alterdot;
static PyObject *__pyx_n_s__amax;
static PyObject *__pyx_n_s__amin;
static PyObject *__pyx_n_s__angle;
static PyObject *__pyx_n_s__any;
static PyObject *__pyx_n_s__append;
static PyObject *__pyx_n_s__apply_along_axis;
static PyObject *__pyx_n_s__apply_over_axes;
static PyObject *__pyx_n_s__ar;
static PyObject *__pyx_n_s__ar1;
static PyObject *__pyx_n_s__ar2;
static PyObject *__pyx_n_s__arg1;
static PyObject *__pyx_n_s__arg2;
static PyObject *__pyx_n_s__argmax;
static PyObject *__pyx_n_s__argmin;
static PyObject *__pyx_n_s__argsort;
static PyObject *__pyx_n_s__argwhere;
static PyObject *__pyx_n_s__around;
static PyObject *__pyx_n_s__arr;
static PyObject *__pyx_n_s__array;
static PyObject *__pyx_n_s__array2string;
static PyObject *__pyx_n_s__array_equal;
static PyObject *__pyx_n_s__array_equiv;
static PyObject *__pyx_n_s__array_repr;
static PyObject *__pyx_n_s__array_split;
static PyObject *__pyx_n_s__array_str;
static PyObject *__pyx_n_s__array_types;
static PyObject *__pyx_n_s__arrays_and_dtypes;
static PyObject *__pyx_n_s__ary;
static PyObject *__pyx_n_s__asanyarray;
static PyObject *__pyx_n_s__asarray_chkfinite;
static PyObject *__pyx_n_s__ascontiguousarray;
static PyObject *__pyx_n_s__asfarray;
static PyObject *__pyx_n_s__asfortranarray;
static PyObject *__pyx_n_s__asmatrix;
static PyObject *__pyx_n_s__asscalar;
static PyObject *__pyx_n_s__assume_unique;
static PyObject *__pyx_n_s__atleast_1d;
static PyObject *__pyx_n_s__atleast_2d;
static PyObject *__pyx_n_s__atleast_3d;
static PyObject *__pyx_n_s__atol;
static PyObject *__pyx_n_s__autostrip;
static PyObject *__pyx_n_s__average;
static PyObject *__pyx_n_s__axes;
static PyObject *__pyx_n_s__axis;
static PyObject *__pyx_n_s__axis1;
static PyObject *__pyx_n_s__axis2;
static PyObject *__pyx_n_s__axisa;
static PyObject *__pyx_n_s__axisb;
static PyObject *__pyx_n_s__axisc;
static PyObject *__pyx_n_s__b;
static PyObject *__pyx_n_s__bartlett;
static PyObject *__pyx_n_s__base;
static PyObject *__pyx_n_s__base_repr;
static PyObject *__pyx_n_s__beta;
static PyObject *__pyx_n_s__bias;
static PyObject *__pyx_n_s__binary_repr;
static PyObject *__pyx_n_s__bincount;
static PyObject *__pyx_n_s__bins;
static PyObject *__pyx_n_s__blackman;
static PyObject *__pyx_n_s__bmat;
static PyObject *__pyx_n_s__broadcast_arrays;
static PyObject *__pyx_n_s__buffer;
static PyObject *__pyx_n_s__byte_bounds;
static PyObject *__pyx_n_s__can_cast;
static PyObject *__pyx_n_s__case_sensitive;
static PyObject *__pyx_n_s__char_;
static PyObject *__pyx_n_s__choicelist;
static PyObject *__pyx_n_s__choices;
static PyObject *__pyx_n_s__choose;
static PyObject *__pyx_n_s__column_stack;
static PyObject *__pyx_n_s__comments;
static PyObject *__pyx_n_s__common_type;
static PyObject *__pyx_n_s__compare_chararrays;
static PyObject *__pyx_n_s__compress;
static PyObject *__pyx_n_s__concatenate;
static PyObject *__pyx_n_s__condition;
static PyObject *__pyx_n_s__condlist;
static PyObject *__pyx_n_s__converters;
static PyObject *__pyx_n_s__convolve;
static PyObject *__pyx_n_s__copy;
static PyObject *__pyx_n_s__corrcoef;
static PyObject *__pyx_n_s__correlate;
static PyObject *__pyx_n_s__count;
static PyObject *__pyx_n_s__count_nonzero;
static PyObject *__pyx_n_s__cov;
static PyObject *__pyx_n_s__cross;
static PyObject *__pyx_n_s__cumprod;
static PyObject *__pyx_n_s__cumproduct;
static PyObject *__pyx_n_s__cumsum;
static PyObject *__pyx_n_s__d;
static PyObject *__pyx_n_s__data;
static PyObject *__pyx_n_s__datetime_data;
static PyObject *__pyx_n_s__ddof;
static PyObject *__pyx_n_s__decimals;
static PyObject *__pyx_n_s__default;
static PyObject *__pyx_n_s__defaultfmt;
static PyObject *__pyx_n_s__deg;
static PyObject *__pyx_n_s__delete;
static PyObject *__pyx_n_s__deletechars;
static PyObject *__pyx_n_s__delimiter;
static PyObject *__pyx_n_s__density;
static PyObject *__pyx_n_s__deprecate;
static PyObject *__pyx_n_s__deprecate_with_doc;
static PyObject *__pyx_n_s__device;
static PyObject *__pyx_n_s__diag_indices;
static PyObject *__pyx_n_s__diag_indices_from;
static PyObject *__pyx_n_s__diagflat;
static PyObject *__pyx_n_s__diff;
static PyObject *__pyx_n_s__digitize;
static PyObject *__pyx_n_s__dimensions;
static PyObject *__pyx_n_s__dims;
static PyObject *__pyx_n_s__discont;
static PyObject *__pyx_n_s__disp;
static PyObject *__pyx_n_s__divide;
static PyObject *__pyx_n_s__doc;
static PyObject *__pyx_n_s__docstring;
static PyObject *__pyx_n_s__dsplit;
static PyObject *__pyx_n_s__dstack;
static PyObject *__pyx_n_s__dtype;
static PyObject *__pyx_n_s__dx;
static PyObject *__pyx_n_s__edgeitems;
static PyObject *__pyx_n_s__ediff1d;
static PyObject *__pyx_n_s__einsum;
static PyObject *__pyx_n_s__end;
static PyObject *__pyx_n_s__errobj;
static PyObject *__pyx_n_s__excludelist;
static PyObject *__pyx_n_s__expand_dims;
static PyObject *__pyx_n_s__extract;
static PyObject *__pyx_n_s__f;
static PyObject *__pyx_n_s__fb;
static PyObject *__pyx_n_s__file;
static PyObject *__pyx_n_s__fill_diagonal;
static PyObject *__pyx_n_s__filling_values;
static PyObject *__pyx_n_s__filt;
static PyObject *__pyx_n_s__finance_rate;
static PyObject *__pyx_n_s__find_common_type;
static PyObject *__pyx_n_s__fix;
static PyObject *__pyx_n_s__flatnonzero;
static PyObject *__pyx_n_s__fliplr;
static PyObject *__pyx_n_s__flipud;
static PyObject *__pyx_n_s__float64;
static PyObject *__pyx_n_s__fmt;
static PyObject *__pyx_n_s__fname;
static PyObject *__pyx_n_s__fp;
static PyObject *__pyx_n_s__frombuffer;
static PyObject *__pyx_n_s__fromfile;
static PyObject *__pyx_n_s__fromiter;
static PyObject *__pyx_n_s__frompyfunc;
static PyObject *__pyx_n_s__fromregex;
static PyObject *__pyx_n_s__fromstring;
static PyObject *__pyx_n_s__full;
static PyObject *__pyx_n_s__func;
static PyObject *__pyx_n_s__func1d;
static PyObject *__pyx_n_s__funclist;
static PyObject *__pyx_n_s__fv;
static PyObject *__pyx_n_s__gdict;
static PyObject *__pyx_n_s__genfromtxt;
static PyObject *__pyx_n_s__get_array_wrap;
static PyObject *__pyx_n_s__get_include;
static PyObject *__pyx_n_s__get_printoptions;
static PyObject *__pyx_n_s__getbuffer;
static PyObject *__pyx_n_s__getbufsize;
static PyObject *__pyx_n_s__geterr;
static PyObject *__pyx_n_s__geterrcall;
static PyObject *__pyx_n_s__geterrobj;
static PyObject *__pyx_n_s__gradient;
static PyObject *__pyx_n_s__guess;
static PyObject *__pyx_n_s__hamming;
static PyObject *__pyx_n_s__hanning;
static PyObject *__pyx_n_s__histogram;
static PyObject *__pyx_n_s__histogram2d;
static PyObject *__pyx_n_s__histogramdd;
static PyObject *__pyx_n_s__hsplit;
static PyObject *__pyx_n_s__hstack;
static PyObject *__pyx_n_s__i0;
static PyObject *__pyx_n_s__imag;
static PyObject *__pyx_n_s__import_modules;
static PyObject *__pyx_n_s__in1d;
static PyObject *__pyx_n_s__ind;
static PyObject *__pyx_n_s__indices;
static PyObject *__pyx_n_s__indices_or_sections;
static PyObject *__pyx_n_s__info;
static PyObject *__pyx_n_s__infstr;
static PyObject *__pyx_n_s__inner;
static PyObject *__pyx_n_s__insert;
static PyObject *__pyx_n_s__int_asbuffer;
static PyObject *__pyx_n_s__interp;
static PyObject *__pyx_n_s__intersect1d;
static PyObject *__pyx_n_s__invalid;
static PyObject *__pyx_n_s__invalid_raise;
static PyObject *__pyx_n_s__ipmt;
static PyObject *__pyx_n_s__irr;
static PyObject *__pyx_n_s__iscomplex;
static PyObject *__pyx_n_s__iscomplexobj;
static PyObject *__pyx_n_s__isfortran;
static PyObject *__pyx_n_s__isneginf;
static PyObject *__pyx_n_s__isposinf;
static PyObject *__pyx_n_s__isreal;
static PyObject *__pyx_n_s__isrealobj;
static PyObject *__pyx_n_s__isscalar;
static PyObject *__pyx_n_s__issctype;
static PyObject *__pyx_n_s__issubclass_;
static PyObject *__pyx_n_s__issubdtype;
static PyObject *__pyx_n_s__issubsctype;
static PyObject *__pyx_n_s__iterable;
static PyObject *__pyx_n_s__ix_;
static PyObject *__pyx_n_s__k;
static PyObject *__pyx_n_s__kaiser;
static PyObject *__pyx_n_s__keys;
static PyObject *__pyx_n_s__kind;
static PyObject *__pyx_n_s__kron;
static PyObject *__pyx_n_s__ldict;
static PyObject *__pyx_n_s__left;
static PyObject *__pyx_n_s__lexsort;
static PyObject *__pyx_n_s__linefeed;
static PyObject *__pyx_n_s__linewidth;
static PyObject *__pyx_n_s__load;
static PyObject *__pyx_n_s__loads;
static PyObject *__pyx_n_s__loadtxt;
static PyObject *__pyx_n_s__lookfor;
static PyObject *__pyx_n_s__loose;
static PyObject *__pyx_n_s__m;
static PyObject *__pyx_n_s__mafromtxt;
static PyObject *__pyx_n_s__mask;
static PyObject *__pyx_n_s__mask_func;
static PyObject *__pyx_n_s__mask_indices;
static PyObject *__pyx_n_s__mat;
static PyObject *__pyx_n_s__max;
static PyObject *__pyx_n_s__max_line_width;
static PyObject *__pyx_n_s__maximum_sctype;
static PyObject *__pyx_n_s__maxiter;
static PyObject *__pyx_n_s__maxwidth;
static PyObject *__pyx_n_s__may_share_memory;
static PyObject *__pyx_n_s__mean;
static PyObject *__pyx_n_s__median;
static PyObject *__pyx_n_s__mesg;
static PyObject *__pyx_n_s__meshgrid;
static PyObject *__pyx_n_s__min;
static PyObject *__pyx_n_s__min_scalar_type;
static PyObject *__pyx_n_s__minlength;
static PyObject *__pyx_n_s__mintypecode;
static PyObject *__pyx_n_s__mirr;
static PyObject *__pyx_n_s__missing;
static PyObject *__pyx_n_s__missing_values;
static PyObject *__pyx_n_s__mmap_mode;
static PyObject *__pyx_n_s__mode;
static PyObject *__pyx_n_s__module;
static PyObject *__pyx_n_s__msg;
static PyObject *__pyx_n_s__msort;
static PyObject *__pyx_n_s__multi_index;
static PyObject *__pyx_n_s__myarray;
static PyObject *__pyx_n_s__n;
static PyObject *__pyx_n_s__names;
static PyObject *__pyx_n_s__nan_to_num;
static PyObject *__pyx_n_s__nanargmax;
static PyObject *__pyx_n_s__nanargmin;
static PyObject *__pyx_n_s__nanmax;
static PyObject *__pyx_n_s__nanmin;
static PyObject *__pyx_n_s__nanstr;
static PyObject *__pyx_n_s__nansum;
static PyObject *__pyx_n_s__ndfromtxt;
static PyObject *__pyx_n_s__ndim;
static PyObject *__pyx_n_s__ndmin;
static PyObject *__pyx_n_s__nested_iters;
static PyObject *__pyx_n_s__new_shape;
static PyObject *__pyx_n_s__newbuffer;
static PyObject *__pyx_n_s__newline;
static PyObject *__pyx_n_s__newshape;
static PyObject *__pyx_n_s__nin;
static PyObject *__pyx_n_s__nonzero;
static PyObject *__pyx_n_s__normed;
static PyObject *__pyx_n_s__nout;
static PyObject *__pyx_n_s__np;
static PyObject *__pyx_n_s__nper;
static PyObject *__pyx_n_s__npv;
static PyObject *__pyx_n_s__num;
static PyObject *__pyx_n_s__number;
static PyObject *__pyx_n_s__numpy;
static PyObject *__pyx_n_s__obj;
static PyObject *__pyx_n_s__obj2sctype;
static PyObject *__pyx_n_s__object;
static PyObject *__pyx_n_s__offset;
static PyObject *__pyx_n_s__old_behavior;
static PyObject *__pyx_n_s__order;
static PyObject *__pyx_n_s__out;
static PyObject *__pyx_n_s__outer;
static PyObject *__pyx_n_s__output;
static PyObject *__pyx_n_s__over;
static PyObject *__pyx_n_s__overwrite_input;
static PyObject *__pyx_n_s__p;
static PyObject *__pyx_n_s__packbits;
static PyObject *__pyx_n_s__padding;
static PyObject *__pyx_n_s__per;
static PyObject *__pyx_n_s__percentile;
static PyObject *__pyx_n_s__piecewise;
static PyObject *__pyx_n_s__pkgload;
static PyObject *__pyx_n_s__place;
static PyObject *__pyx_n_s__pmt;
static PyObject *__pyx_n_s__poly;
static PyObject *__pyx_n_s__polyadd;
static PyObject *__pyx_n_s__polyder;
static PyObject *__pyx_n_s__polydiv;
static PyObject *__pyx_n_s__polyfit;
static PyObject *__pyx_n_s__polyint;
static PyObject *__pyx_n_s__polymul;
static PyObject *__pyx_n_s__polysub;
static PyObject *__pyx_n_s__polyval;
static PyObject *__pyx_n_s__ppmt;
static PyObject *__pyx_n_s__precision;
static PyObject *__pyx_n_s__prefix;
static PyObject *__pyx_n_s__prod;
static PyObject *__pyx_n_s__product;
static PyObject *__pyx_n_s__promote_types;
static PyObject *__pyx_n_s__ptp;
static PyObject *__pyx_n_s__put;
static PyObject *__pyx_n_s__putmask;
static PyObject *__pyx_n_s__pv;
static PyObject *__pyx_n_s__q;
static PyObject *__pyx_n_s__quicksort;
static PyObject *__pyx_n_s__raise;
static PyObject *__pyx_n_s__range;
static PyObject *__pyx_n_s__rank;
static PyObject *__pyx_n_s__rate;
static PyObject *__pyx_n_s__ravel;
static PyObject *__pyx_n_s__ravel_multi_index;
static PyObject *__pyx_n_s__rcond;
static PyObject *__pyx_n_s__real;
static PyObject *__pyx_n_s__real_if_close;
static PyObject *__pyx_n_s__recfromcsv;
static PyObject *__pyx_n_s__recfromtxt;
static PyObject *__pyx_n_s__regenerate;
static PyObject *__pyx_n_s__regexp;
static PyObject *__pyx_n_s__reinvest_rate;
static PyObject *__pyx_n_s__rep;
static PyObject *__pyx_n_s__repeat;
static PyObject *__pyx_n_s__repeats;
static PyObject *__pyx_n_s__replace_space;
static PyObject *__pyx_n_s__repr;
static PyObject *__pyx_n_s__reps;
static PyObject *__pyx_n_s__require;
static PyObject *__pyx_n_s__requirements;
static PyObject *__pyx_n_s__reshape;
static PyObject *__pyx_n_s__resize;
static PyObject *__pyx_n_s__restoredot;
static PyObject *__pyx_n_s__result_type;
static PyObject *__pyx_n_s__return_index;
static PyObject *__pyx_n_s__return_inverse;
static PyObject *__pyx_n_s__returned;
static PyObject *__pyx_n_s__right;
static PyObject *__pyx_n_s__roll;
static PyObject *__pyx_n_s__rollaxis;
static PyObject *__pyx_n_s__roots;
static PyObject *__pyx_n_s__rot90;
static PyObject *__pyx_n_s__round;
static PyObject *__pyx_n_s__round_;
static PyObject *__pyx_n_s__row_stack;
static PyObject *__pyx_n_s__rowvar;
static PyObject *__pyx_n_s__rtol;
static PyObject *__pyx_n_s__safe_eval;
static PyObject *__pyx_n_s__sample;
static PyObject *__pyx_n_s__save;
static PyObject *__pyx_n_s__savetxt;
static PyObject *__pyx_n_s__savez;
static PyObject *__pyx_n_s__savez_compressed;
static PyObject *__pyx_n_s__scalar_types;
static PyObject *__pyx_n_s__sctype;
static PyObject *__pyx_n_s__sctype2char;
static PyObject *__pyx_n_s__searchsorted;
static PyObject *__pyx_n_s__select;
static PyObject *__pyx_n_s__sep;
static PyObject *__pyx_n_s__separator;
static PyObject *__pyx_n_s__seq_of_zeros;
static PyObject *__pyx_n_s__set_numeric_ops;
static PyObject *__pyx_n_s__set_printoptions;
static PyObject *__pyx_n_s__set_string_function;
static PyObject *__pyx_n_s__setbufsize;
static PyObject *__pyx_n_s__setdiff1d;
static PyObject *__pyx_n_s__seterr;
static PyObject *__pyx_n_s__seterrcall;
static PyObject *__pyx_n_s__seterrobj;
static PyObject *__pyx_n_s__setxor1d;
static PyObject *__pyx_n_s__shift;
static PyObject *__pyx_n_s__show_config;
static PyObject *__pyx_n_s__side;
static PyObject *__pyx_n_s__sinc;
static PyObject *__pyx_n_s__size;
static PyObject *__pyx_n_s__skip_footer;
static PyObject *__pyx_n_s__skip_header;
static PyObject *__pyx_n_s__skiprows;
static PyObject *__pyx_n_s__sometrue;
static PyObject *__pyx_n_s__sort;
static PyObject *__pyx_n_s__sort_complex;
static PyObject *__pyx_n_s__source;
static PyObject *__pyx_n_s__split;
static PyObject *__pyx_n_s__squeeze;
static PyObject *__pyx_n_s__start;
static PyObject *__pyx_n_s__std;
static PyObject *__pyx_n_s__stdout;
static PyObject *__pyx_n_s__string;
static PyObject *__pyx_n_s__style;
static PyObject *__pyx_n_s__subok;
static PyObject *__pyx_n_s__sum;
static PyObject *__pyx_n_s__suppress;
static PyObject *__pyx_n_s__suppress_small;
static PyObject *__pyx_n_s__swapaxes;
static PyObject *__pyx_n_s__sys;
static PyObject *__pyx_n_s__t;
static PyObject *__pyx_n_s__take;
static PyObject *__pyx_n_s__tensordot;
static PyObject *__pyx_n_s__threshold;
static PyObject *__pyx_n_s__tile;
static PyObject *__pyx_n_s__to_begin;
static PyObject *__pyx_n_s__to_end;
static PyObject *__pyx_n_s__tol;
static PyObject *__pyx_n_s__toplevel;
static PyObject *__pyx_n_s__trace;
static PyObject *__pyx_n_s__transpose;
static PyObject *__pyx_n_s__trapz;
static PyObject *__pyx_n_s__tri;
static PyObject *__pyx_n_s__tril;
static PyObject *__pyx_n_s__tril_indices;
static PyObject *__pyx_n_s__tril_indices_from;
static PyObject *__pyx_n_s__trim;
static PyObject *__pyx_n_s__trim_zeros;
static PyObject *__pyx_n_s__triu;
static PyObject *__pyx_n_s__triu_indices;
static PyObject *__pyx_n_s__triu_indices_from;
static PyObject *__pyx_n_s__tup;
static PyObject *__pyx_n_s__type;
static PyObject *__pyx_n_s__type1;
static PyObject *__pyx_n_s__type2;
static PyObject *__pyx_n_s__typechars;
static PyObject *__pyx_n_s__typename;
static PyObject *__pyx_n_s__typeset;
static PyObject *__pyx_n_s__u;
static PyObject *__pyx_n_s__under;
static PyObject *__pyx_n_s__union1d;
static PyObject *__pyx_n_s__unique;
static PyObject *__pyx_n_s__unpack;
static PyObject *__pyx_n_s__unpackbits;
static PyObject *__pyx_n_s__unravel_index;
static PyObject *__pyx_n_s__unwrap;
static PyObject *__pyx_n_s__usecols;
static PyObject *__pyx_n_s__usemask;
static PyObject *__pyx_n_s__v;
static PyObject *__pyx_n_s__val;
static PyObject *__pyx_n_s__valid;
static PyObject *__pyx_n_s__vals;
static PyObject *__pyx_n_s__values;
static PyObject *__pyx_n_s__vander;
static PyObject *__pyx_n_s__var;
static PyObject *__pyx_n_s__vardict;
static PyObject *__pyx_n_s__vdot;
static PyObject *__pyx_n_s__vsplit;
static PyObject *__pyx_n_s__vstack;
static PyObject *__pyx_n_s__weights;
static PyObject *__pyx_n_s__what;
static PyObject *__pyx_n_s__when;
static PyObject *__pyx_n_s__where;
static PyObject *__pyx_n_s__who;
static PyObject *__pyx_n_s__width;
static PyObject *__pyx_n_s__x;
static PyObject *__pyx_n_s__xp;
static PyObject *__pyx_n_s__y;
static PyObject *__pyx_n_s__z;
static PyObject *__pyx_int_0;
static PyObject *__pyx_int_1;
static PyObject *__pyx_int_2;
static PyObject *__pyx_int_neg_1;
static PyObject *__pyx_int_10;
static PyObject *__pyx_int_15;
static PyObject *__pyx_int_76;
static PyObject *__pyx_int_100;
static PyObject *__pyx_k_1;
static PyObject *__pyx_k_2;
static PyObject *__pyx_k_3;
static PyObject *__pyx_k_4;
static PyObject *__pyx_k_7;
static PyObject *__pyx_k_8;
static PyObject *__pyx_k_9;
static PyObject *__pyx_k_10;
static PyObject *__pyx_k_11;
static PyObject *__pyx_k_12;
static PyObject *__pyx_k_13;
static PyObject *__pyx_k_14;
static PyObject *__pyx_k_15;
static PyObject *__pyx_k_17;
static PyObject *__pyx_k_18;
static PyObject *__pyx_k_20;
static PyObject *__pyx_k_21;
static PyObject *__pyx_k_22;
static PyObject *__pyx_k_23;
static PyObject *__pyx_k_24;
static PyObject *__pyx_k_25;
static PyObject *__pyx_k_26;
static PyObject *__pyx_k_27;
static PyObject *__pyx_k_28;
static PyObject *__pyx_k_29;
static PyObject *__pyx_k_30;
static PyObject *__pyx_k_31;
static PyObject *__pyx_k_32;
static PyObject *__pyx_k_33;
static PyObject *__pyx_k_34;
static PyObject *__pyx_k_35;
static PyObject *__pyx_k_36;
static PyObject *__pyx_k_37;
static PyObject *__pyx_k_38;
static PyObject *__pyx_k_39;
static PyObject *__pyx_k_40;
static PyObject *__pyx_k_41;
static PyObject *__pyx_k_44;
static PyObject *__pyx_k_45;
static PyObject *__pyx_k_46;
static PyObject *__pyx_k_47;
static PyObject *__pyx_k_48;
static PyObject *__pyx_k_49;
static PyObject *__pyx_k_50;
static PyObject *__pyx_k_51;
static PyObject *__pyx_k_52;
static PyObject *__pyx_k_tuple_54;
static PyObject *__pyx_k_tuple_56;
static PyObject *__pyx_k_tuple_58;
static PyObject *__pyx_k_tuple_61;
static PyObject *__pyx_k_tuple_62;
static PyObject *__pyx_k_tuple_64;
static PyObject *__pyx_k_tuple_65;
static PyObject *__pyx_k_tuple_69;
static PyObject *__pyx_k_tuple_71;
static PyObject *__pyx_k_tuple_73;
static PyObject *__pyx_k_tuple_75;
static PyObject *__pyx_k_tuple_78;
static PyObject *__pyx_k_tuple_80;
static PyObject *__pyx_k_tuple_82;
static PyObject *__pyx_k_tuple_84;
static PyObject *__pyx_k_tuple_86;
static PyObject *__pyx_k_tuple_88;
static PyObject *__pyx_k_tuple_90;
static PyObject *__pyx_k_tuple_92;
static PyObject *__pyx_k_tuple_94;
static PyObject *__pyx_k_tuple_96;
static PyObject *__pyx_k_tuple_98;
static PyObject *__pyx_k_tuple_100;
static PyObject *__pyx_k_tuple_102;
static PyObject *__pyx_k_tuple_104;
static PyObject *__pyx_k_tuple_106;
static PyObject *__pyx_k_tuple_108;
static PyObject *__pyx_k_tuple_110;
static PyObject *__pyx_k_tuple_112;
static PyObject *__pyx_k_tuple_114;
static PyObject *__pyx_k_tuple_116;
static PyObject *__pyx_k_tuple_118;
static PyObject *__pyx_k_tuple_120;
static PyObject *__pyx_k_tuple_122;
static PyObject *__pyx_k_tuple_124;
static PyObject *__pyx_k_tuple_126;
static PyObject *__pyx_k_tuple_128;
static PyObject *__pyx_k_tuple_133;
static PyObject *__pyx_k_tuple_135;
static PyObject *__pyx_k_tuple_137;
static PyObject *__pyx_k_tuple_139;
static PyObject *__pyx_k_tuple_141;
static PyObject *__pyx_k_tuple_143;
static PyObject *__pyx_k_tuple_145;
static PyObject *__pyx_k_tuple_148;
static PyObject *__pyx_k_tuple_151;
static PyObject *__pyx_k_tuple_153;
static PyObject *__pyx_k_tuple_157;
static PyObject *__pyx_k_tuple_160;
static PyObject *__pyx_k_tuple_162;
static PyObject *__pyx_k_tuple_164;
static PyObject *__pyx_k_tuple_166;
static PyObject *__pyx_k_tuple_168;
static PyObject *__pyx_k_tuple_170;
static PyObject *__pyx_k_tuple_172;
static PyObject *__pyx_k_tuple_174;
static PyObject *__pyx_k_tuple_176;
static PyObject *__pyx_k_tuple_178;
static PyObject *__pyx_k_tuple_180;
static PyObject *__pyx_k_tuple_182;
static PyObject *__pyx_k_tuple_185;
static PyObject *__pyx_k_tuple_187;
static PyObject *__pyx_k_tuple_189;
static PyObject *__pyx_k_tuple_191;
static PyObject *__pyx_k_tuple_193;
static PyObject *__pyx_k_tuple_195;
static PyObject *__pyx_k_tuple_197;
static PyObject *__pyx_k_tuple_199;
static PyObject *__pyx_k_tuple_201;
static PyObject *__pyx_k_tuple_203;
static PyObject *__pyx_k_tuple_206;
static PyObject *__pyx_k_tuple_208;
static PyObject *__pyx_k_tuple_210;
static PyObject *__pyx_k_tuple_213;
static PyObject *__pyx_k_tuple_215;
static PyObject *__pyx_k_tuple_217;
static PyObject *__pyx_k_tuple_219;
static PyObject *__pyx_k_tuple_221;
static PyObject *__pyx_k_tuple_223;
static PyObject *__pyx_k_tuple_225;
static PyObject *__pyx_k_tuple_227;
static PyObject *__pyx_k_tuple_229;
static PyObject *__pyx_k_tuple_231;
static PyObject *__pyx_k_tuple_233;
static PyObject *__pyx_k_tuple_235;
static PyObject *__pyx_k_tuple_237;
static PyObject *__pyx_k_tuple_239;
static PyObject *__pyx_k_tuple_243;
static PyObject *__pyx_k_tuple_252;
static PyObject *__pyx_k_tuple_254;
static PyObject *__pyx_k_tuple_256;
static PyObject *__pyx_k_tuple_258;
static PyObject *__pyx_k_tuple_260;
static PyObject *__pyx_k_tuple_262;
static PyObject *__pyx_k_tuple_264;
static PyObject *__pyx_k_tuple_266;
static PyObject *__pyx_k_tuple_268;
static PyObject *__pyx_k_tuple_270;
static PyObject *__pyx_k_tuple_272;
static PyObject *__pyx_k_tuple_274;
static PyObject *__pyx_k_tuple_276;
static PyObject *__pyx_k_tuple_278;
static PyObject *__pyx_k_tuple_280;
static PyObject *__pyx_k_tuple_283;
static PyObject *__pyx_k_tuple_285;
static PyObject *__pyx_k_tuple_287;
static PyObject *__pyx_k_tuple_289;
static PyObject *__pyx_k_tuple_291;
static PyObject *__pyx_k_tuple_293;
static PyObject *__pyx_k_tuple_295;
static PyObject *__pyx_k_tuple_297;
static PyObject *__pyx_k_tuple_299;
static PyObject *__pyx_k_tuple_301;
static PyObject *__pyx_k_tuple_303;
static PyObject *__pyx_k_tuple_305;
static PyObject *__pyx_k_tuple_307;
static PyObject *__pyx_k_tuple_309;
static PyObject *__pyx_k_tuple_311;
static PyObject *__pyx_k_tuple_313;
static PyObject *__pyx_k_tuple_315;
static PyObject *__pyx_k_tuple_318;
static PyObject *__pyx_k_tuple_320;
static PyObject *__pyx_k_tuple_322;
static PyObject *__pyx_k_tuple_324;
static PyObject *__pyx_k_tuple_327;
static PyObject *__pyx_k_tuple_329;
static PyObject *__pyx_k_tuple_331;
static PyObject *__pyx_k_tuple_333;
static PyObject *__pyx_k_tuple_335;
static PyObject *__pyx_k_tuple_337;
static PyObject *__pyx_k_tuple_339;
static PyObject *__pyx_k_tuple_341;
static PyObject *__pyx_k_tuple_343;
static PyObject *__pyx_k_tuple_345;
static PyObject *__pyx_k_tuple_347;
static PyObject *__pyx_k_tuple_349;
static PyObject *__pyx_k_tuple_351;
static PyObject *__pyx_k_tuple_353;
static PyObject *__pyx_k_tuple_355;
static PyObject *__pyx_k_tuple_357;
static PyObject *__pyx_k_tuple_359;
static PyObject *__pyx_k_tuple_361;
static PyObject *__pyx_k_tuple_363;
static PyObject *__pyx_k_tuple_365;
static PyObject *__pyx_k_tuple_367;
static PyObject *__pyx_k_tuple_369;
static PyObject *__pyx_k_tuple_371;
static PyObject *__pyx_k_tuple_373;
static PyObject *__pyx_k_tuple_376;
static PyObject *__pyx_k_tuple_378;
static PyObject *__pyx_k_tuple_380;
static PyObject *__pyx_k_tuple_382;
static PyObject *__pyx_k_tuple_384;
static PyObject *__pyx_k_tuple_386;
static PyObject *__pyx_k_tuple_388;
static PyObject *__pyx_k_tuple_390;
static PyObject *__pyx_k_tuple_392;
static PyObject *__pyx_k_tuple_395;
static PyObject *__pyx_k_tuple_397;
static PyObject *__pyx_k_tuple_399;
static PyObject *__pyx_k_tuple_401;
static PyObject *__pyx_k_tuple_403;
static PyObject *__pyx_k_tuple_405;
static PyObject *__pyx_k_tuple_407;
static PyObject *__pyx_k_tuple_409;
static PyObject *__pyx_k_tuple_411;
static PyObject *__pyx_k_tuple_413;
static PyObject *__pyx_k_tuple_415;
static PyObject *__pyx_k_tuple_417;
static PyObject *__pyx_k_tuple_419;
static PyObject *__pyx_k_tuple_421;
static PyObject *__pyx_k_tuple_423;
static PyObject *__pyx_k_tuple_425;
static PyObject *__pyx_k_tuple_427;
static PyObject *__pyx_k_tuple_429;
static PyObject *__pyx_k_tuple_431;
static PyObject *__pyx_k_tuple_433;
static PyObject *__pyx_k_tuple_435;
static PyObject *__pyx_k_tuple_437;
static PyObject *__pyx_k_tuple_439;
static PyObject *__pyx_k_tuple_441;
static PyObject *__pyx_k_tuple_443;
static PyObject *__pyx_k_tuple_445;
static PyObject *__pyx_k_tuple_447;
static PyObject *__pyx_k_tuple_449;
static PyObject *__pyx_k_tuple_451;
static PyObject *__pyx_k_tuple_453;
static PyObject *__pyx_k_tuple_455;
static PyObject *__pyx_k_tuple_458;
static PyObject *__pyx_k_tuple_460;
static PyObject *__pyx_k_tuple_462;
static PyObject *__pyx_k_tuple_464;
static PyObject *__pyx_k_tuple_466;
static PyObject *__pyx_k_tuple_468;
static PyObject *__pyx_k_tuple_470;
static PyObject *__pyx_k_tuple_472;
static PyObject *__pyx_k_tuple_474;
static PyObject *__pyx_k_tuple_476;
static PyObject *__pyx_k_tuple_478;
static PyObject *__pyx_k_tuple_480;
static PyObject *__pyx_k_tuple_482;
static PyObject *__pyx_k_tuple_484;
static PyObject *__pyx_k_tuple_486;
static PyObject *__pyx_k_tuple_488;
static PyObject *__pyx_k_tuple_491;
static PyObject *__pyx_k_tuple_493;
static PyObject *__pyx_k_tuple_495;
static PyObject *__pyx_k_tuple_497;
static PyObject *__pyx_k_tuple_499;
static PyObject *__pyx_k_tuple_501;
static PyObject *__pyx_k_tuple_503;
static PyObject *__pyx_k_tuple_505;
static PyObject *__pyx_k_tuple_508;
static PyObject *__pyx_k_tuple_510;
static PyObject *__pyx_k_tuple_512;
static PyObject *__pyx_k_tuple_514;
static PyObject *__pyx_k_tuple_516;
static PyObject *__pyx_k_tuple_518;
static PyObject *__pyx_k_tuple_520;
static PyObject *__pyx_k_tuple_522;
static PyObject *__pyx_k_tuple_524;
static PyObject *__pyx_k_tuple_526;
static PyObject *__pyx_k_tuple_528;
static PyObject *__pyx_k_tuple_530;
static PyObject *__pyx_k_tuple_532;
static PyObject *__pyx_k_tuple_534;
static PyObject *__pyx_k_tuple_536;
static PyObject *__pyx_k_tuple_538;
static PyObject *__pyx_k_tuple_540;
static PyObject *__pyx_k_tuple_542;
static PyObject *__pyx_k_tuple_544;
static PyObject *__pyx_k_tuple_546;
static PyObject *__pyx_k_tuple_548;
static PyObject *__pyx_k_tuple_550;
static PyObject *__pyx_k_tuple_552;
static PyObject *__pyx_k_tuple_554;
static PyObject *__pyx_k_tuple_556;
static PyObject *__pyx_k_tuple_558;
static PyObject *__pyx_k_tuple_560;
static PyObject *__pyx_k_tuple_562;
static PyObject *__pyx_k_tuple_564;
static PyObject *__pyx_k_tuple_566;
static PyObject *__pyx_k_tuple_568;
static PyObject *__pyx_k_tuple_570;
static PyObject *__pyx_k_tuple_572;
static PyObject *__pyx_k_tuple_575;
static PyObject *__pyx_k_tuple_577;
static PyObject *__pyx_k_tuple_580;
static PyObject *__pyx_k_codeobj_66;
static PyObject *__pyx_k_codeobj_70;
static PyObject *__pyx_k_codeobj_72;
static PyObject *__pyx_k_codeobj_74;
static PyObject *__pyx_k_codeobj_76;
static PyObject *__pyx_k_codeobj_77;
static PyObject *__pyx_k_codeobj_79;
static PyObject *__pyx_k_codeobj_81;
static PyObject *__pyx_k_codeobj_83;
static PyObject *__pyx_k_codeobj_85;
static PyObject *__pyx_k_codeobj_87;
static PyObject *__pyx_k_codeobj_89;
static PyObject *__pyx_k_codeobj_91;
static PyObject *__pyx_k_codeobj_93;
static PyObject *__pyx_k_codeobj_95;
static PyObject *__pyx_k_codeobj_97;
static PyObject *__pyx_k_codeobj_99;
static PyObject *__pyx_k_codeobj_101;
static PyObject *__pyx_k_codeobj_103;
static PyObject *__pyx_k_codeobj_105;
static PyObject *__pyx_k_codeobj_107;
static PyObject *__pyx_k_codeobj_109;
static PyObject *__pyx_k_codeobj_111;
static PyObject *__pyx_k_codeobj_113;
static PyObject *__pyx_k_codeobj_115;
static PyObject *__pyx_k_codeobj_117;
static PyObject *__pyx_k_codeobj_119;
static PyObject *__pyx_k_codeobj_121;
static PyObject *__pyx_k_codeobj_123;
static PyObject *__pyx_k_codeobj_125;
static PyObject *__pyx_k_codeobj_127;
static PyObject *__pyx_k_codeobj_129;
static PyObject *__pyx_k_codeobj_130;
static PyObject *__pyx_k_codeobj_131;
static PyObject *__pyx_k_codeobj_132;
static PyObject *__pyx_k_codeobj_134;
static PyObject *__pyx_k_codeobj_136;
static PyObject *__pyx_k_codeobj_138;
static PyObject *__pyx_k_codeobj_140;
static PyObject *__pyx_k_codeobj_142;
static PyObject *__pyx_k_codeobj_144;
static PyObject *__pyx_k_codeobj_146;
static PyObject *__pyx_k_codeobj_147;
static PyObject *__pyx_k_codeobj_149;
static PyObject *__pyx_k_codeobj_150;
static PyObject *__pyx_k_codeobj_152;
static PyObject *__pyx_k_codeobj_154;
static PyObject *__pyx_k_codeobj_155;
static PyObject *__pyx_k_codeobj_156;
static PyObject *__pyx_k_codeobj_158;
static PyObject *__pyx_k_codeobj_159;
static PyObject *__pyx_k_codeobj_161;
static PyObject *__pyx_k_codeobj_163;
static PyObject *__pyx_k_codeobj_165;
static PyObject *__pyx_k_codeobj_167;
static PyObject *__pyx_k_codeobj_169;
static PyObject *__pyx_k_codeobj_171;
static PyObject *__pyx_k_codeobj_173;
static PyObject *__pyx_k_codeobj_175;
static PyObject *__pyx_k_codeobj_177;
static PyObject *__pyx_k_codeobj_179;
static PyObject *__pyx_k_codeobj_181;
static PyObject *__pyx_k_codeobj_183;
static PyObject *__pyx_k_codeobj_184;
static PyObject *__pyx_k_codeobj_186;
static PyObject *__pyx_k_codeobj_188;
static PyObject *__pyx_k_codeobj_190;
static PyObject *__pyx_k_codeobj_192;
static PyObject *__pyx_k_codeobj_194;
static PyObject *__pyx_k_codeobj_196;
static PyObject *__pyx_k_codeobj_198;
static PyObject *__pyx_k_codeobj_200;
static PyObject *__pyx_k_codeobj_202;
static PyObject *__pyx_k_codeobj_204;
static PyObject *__pyx_k_codeobj_205;
static PyObject *__pyx_k_codeobj_207;
static PyObject *__pyx_k_codeobj_209;
static PyObject *__pyx_k_codeobj_211;
static PyObject *__pyx_k_codeobj_214;
static PyObject *__pyx_k_codeobj_216;
static PyObject *__pyx_k_codeobj_218;
static PyObject *__pyx_k_codeobj_220;
static PyObject *__pyx_k_codeobj_222;
static PyObject *__pyx_k_codeobj_224;
static PyObject *__pyx_k_codeobj_226;
static PyObject *__pyx_k_codeobj_228;
static PyObject *__pyx_k_codeobj_230;
static PyObject *__pyx_k_codeobj_232;
static PyObject *__pyx_k_codeobj_234;
static PyObject *__pyx_k_codeobj_236;
static PyObject *__pyx_k_codeobj_238;
static PyObject *__pyx_k_codeobj_240;
static PyObject *__pyx_k_codeobj_241;
static PyObject *__pyx_k_codeobj_242;
static PyObject *__pyx_k_codeobj_244;
static PyObject *__pyx_k_codeobj_246;
static PyObject *__pyx_k_codeobj_247;
static PyObject *__pyx_k_codeobj_248;
static PyObject *__pyx_k_codeobj_249;
static PyObject *__pyx_k_codeobj_250;
static PyObject *__pyx_k_codeobj_251;
static PyObject *__pyx_k_codeobj_253;
static PyObject *__pyx_k_codeobj_255;
static PyObject *__pyx_k_codeobj_257;
static PyObject *__pyx_k_codeobj_259;
static PyObject *__pyx_k_codeobj_261;
static PyObject *__pyx_k_codeobj_263;
static PyObject *__pyx_k_codeobj_265;
static PyObject *__pyx_k_codeobj_267;
static PyObject *__pyx_k_codeobj_269;
static PyObject *__pyx_k_codeobj_271;
static PyObject *__pyx_k_codeobj_273;
static PyObject *__pyx_k_codeobj_275;
static PyObject *__pyx_k_codeobj_277;
static PyObject *__pyx_k_codeobj_279;
static PyObject *__pyx_k_codeobj_281;
static PyObject *__pyx_k_codeobj_282;
static PyObject *__pyx_k_codeobj_284;
static PyObject *__pyx_k_codeobj_286;
static PyObject *__pyx_k_codeobj_288;
static PyObject *__pyx_k_codeobj_290;
static PyObject *__pyx_k_codeobj_292;
static PyObject *__pyx_k_codeobj_294;
static PyObject *__pyx_k_codeobj_296;
static PyObject *__pyx_k_codeobj_298;
static PyObject *__pyx_k_codeobj_300;
static PyObject *__pyx_k_codeobj_302;
static PyObject *__pyx_k_codeobj_304;
static PyObject *__pyx_k_codeobj_306;
static PyObject *__pyx_k_codeobj_308;
static PyObject *__pyx_k_codeobj_310;
static PyObject *__pyx_k_codeobj_312;
static PyObject *__pyx_k_codeobj_314;
static PyObject *__pyx_k_codeobj_316;
static PyObject *__pyx_k_codeobj_317;
static PyObject *__pyx_k_codeobj_319;
static PyObject *__pyx_k_codeobj_321;
static PyObject *__pyx_k_codeobj_323;
static PyObject *__pyx_k_codeobj_325;
static PyObject *__pyx_k_codeobj_326;
static PyObject *__pyx_k_codeobj_328;
static PyObject *__pyx_k_codeobj_330;
static PyObject *__pyx_k_codeobj_332;
static PyObject *__pyx_k_codeobj_334;
static PyObject *__pyx_k_codeobj_336;
static PyObject *__pyx_k_codeobj_338;
static PyObject *__pyx_k_codeobj_340;
static PyObject *__pyx_k_codeobj_342;
static PyObject *__pyx_k_codeobj_344;
static PyObject *__pyx_k_codeobj_346;
static PyObject *__pyx_k_codeobj_348;
static PyObject *__pyx_k_codeobj_350;
static PyObject *__pyx_k_codeobj_352;
static PyObject *__pyx_k_codeobj_354;
static PyObject *__pyx_k_codeobj_356;
static PyObject *__pyx_k_codeobj_358;
static PyObject *__pyx_k_codeobj_360;
static PyObject *__pyx_k_codeobj_362;
static PyObject *__pyx_k_codeobj_364;
static PyObject *__pyx_k_codeobj_366;
static PyObject *__pyx_k_codeobj_368;
static PyObject *__pyx_k_codeobj_370;
static PyObject *__pyx_k_codeobj_372;
static PyObject *__pyx_k_codeobj_374;
static PyObject *__pyx_k_codeobj_375;
static PyObject *__pyx_k_codeobj_377;
static PyObject *__pyx_k_codeobj_379;
static PyObject *__pyx_k_codeobj_381;
static PyObject *__pyx_k_codeobj_383;
static PyObject *__pyx_k_codeobj_385;
static PyObject *__pyx_k_codeobj_387;
static PyObject *__pyx_k_codeobj_389;
static PyObject *__pyx_k_codeobj_391;
static PyObject *__pyx_k_codeobj_393;
static PyObject *__pyx_k_codeobj_394;
static PyObject *__pyx_k_codeobj_396;
static PyObject *__pyx_k_codeobj_398;
static PyObject *__pyx_k_codeobj_400;
static PyObject *__pyx_k_codeobj_402;
static PyObject *__pyx_k_codeobj_404;
static PyObject *__pyx_k_codeobj_406;
static PyObject *__pyx_k_codeobj_408;
static PyObject *__pyx_k_codeobj_410;
static PyObject *__pyx_k_codeobj_412;
static PyObject *__pyx_k_codeobj_414;
static PyObject *__pyx_k_codeobj_416;
static PyObject *__pyx_k_codeobj_418;
static PyObject *__pyx_k_codeobj_420;
static PyObject *__pyx_k_codeobj_422;
static PyObject *__pyx_k_codeobj_424;
static PyObject *__pyx_k_codeobj_426;
static PyObject *__pyx_k_codeobj_428;
static PyObject *__pyx_k_codeobj_430;
static PyObject *__pyx_k_codeobj_432;
static PyObject *__pyx_k_codeobj_434;
static PyObject *__pyx_k_codeobj_436;
static PyObject *__pyx_k_codeobj_438;
static PyObject *__pyx_k_codeobj_440;
static PyObject *__pyx_k_codeobj_442;
static PyObject *__pyx_k_codeobj_444;
static PyObject *__pyx_k_codeobj_446;
static PyObject *__pyx_k_codeobj_448;
static PyObject *__pyx_k_codeobj_450;
static PyObject *__pyx_k_codeobj_452;
static PyObject *__pyx_k_codeobj_454;
static PyObject *__pyx_k_codeobj_456;
static PyObject *__pyx_k_codeobj_457;
static PyObject *__pyx_k_codeobj_459;
static PyObject *__pyx_k_codeobj_461;
static PyObject *__pyx_k_codeobj_463;
static PyObject *__pyx_k_codeobj_465;
static PyObject *__pyx_k_codeobj_467;
static PyObject *__pyx_k_codeobj_469;
static PyObject *__pyx_k_codeobj_471;
static PyObject *__pyx_k_codeobj_473;
static PyObject *__pyx_k_codeobj_475;
static PyObject *__pyx_k_codeobj_477;
static PyObject *__pyx_k_codeobj_479;
static PyObject *__pyx_k_codeobj_481;
static PyObject *__pyx_k_codeobj_483;
static PyObject *__pyx_k_codeobj_485;
static PyObject *__pyx_k_codeobj_487;
static PyObject *__pyx_k_codeobj_489;
static PyObject *__pyx_k_codeobj_490;
static PyObject *__pyx_k_codeobj_492;
static PyObject *__pyx_k_codeobj_494;
static PyObject *__pyx_k_codeobj_496;
static PyObject *__pyx_k_codeobj_498;
static PyObject *__pyx_k_codeobj_500;
static PyObject *__pyx_k_codeobj_502;
static PyObject *__pyx_k_codeobj_504;
static PyObject *__pyx_k_codeobj_506;
static PyObject *__pyx_k_codeobj_507;
static PyObject *__pyx_k_codeobj_509;
static PyObject *__pyx_k_codeobj_511;
static PyObject *__pyx_k_codeobj_513;
static PyObject *__pyx_k_codeobj_515;
static PyObject *__pyx_k_codeobj_517;
static PyObject *__pyx_k_codeobj_519;
static PyObject *__pyx_k_codeobj_521;
static PyObject *__pyx_k_codeobj_523;
static PyObject *__pyx_k_codeobj_525;
static PyObject *__pyx_k_codeobj_527;
static PyObject *__pyx_k_codeobj_529;
static PyObject *__pyx_k_codeobj_531;
static PyObject *__pyx_k_codeobj_533;
static PyObject *__pyx_k_codeobj_535;
static PyObject *__pyx_k_codeobj_537;
static PyObject *__pyx_k_codeobj_539;
static PyObject *__pyx_k_codeobj_541;
static PyObject *__pyx_k_codeobj_543;
static PyObject *__pyx_k_codeobj_545;
static PyObject *__pyx_k_codeobj_547;
static PyObject *__pyx_k_codeobj_549;
static PyObject *__pyx_k_codeobj_551;
static PyObject *__pyx_k_codeobj_553;
static PyObject *__pyx_k_codeobj_555;
static PyObject *__pyx_k_codeobj_557;
static PyObject *__pyx_k_codeobj_559;
static PyObject *__pyx_k_codeobj_561;
static PyObject *__pyx_k_codeobj_563;
static PyObject *__pyx_k_codeobj_565;
static PyObject *__pyx_k_codeobj_567;
static PyObject *__pyx_k_codeobj_569;
static PyObject *__pyx_k_codeobj_571;
static PyObject *__pyx_k_codeobj_573;
static PyObject *__pyx_k_codeobj_574;
static PyObject *__pyx_k_codeobj_576;
static PyObject *__pyx_k_codeobj_578;
static PyObject *__pyx_k_codeobj_579;
static PyObject *__pyx_k_codeobj_581;

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_1docstring(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_docstring[] = "docstring(obj, docstring)\n\n    Add a docstring to a built-in obj if possible.\n    If the obj already has a docstring raise a RuntimeError\n    If this routine does not know how to add a docstring to the object\n    raise a TypeError\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_1docstring = {__Pyx_NAMESTR("docstring"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_1docstring, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_docstring)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_1docstring(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_obj = 0;
  CYTHON_UNUSED PyObject *__pyx_v_docstring = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("docstring (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__obj,&__pyx_n_s__docstring,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__obj)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__docstring)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("docstring", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "docstring") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_obj = values[0];
    __pyx_v_docstring = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("docstring", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.docstring", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_docstring(__pyx_self, __pyx_v_obj, __pyx_v_docstring);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":8
 * 
 * 
 * def docstring(obj, docstring):             # <<<<<<<<<<<<<<
 *     """docstring(obj, docstring)
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_docstring(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_obj, CYTHON_UNUSED PyObject *__pyx_v_docstring) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("docstring", 0);

  /* "ga4py/gain/notimplemented.pyx":18
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 18; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.docstring", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_3add_newdoc(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_2add_newdoc[] = "Adds documentation to obj which is in module place.\n\n    If doc is a string add it to obj as a docstring\n\n    If doc is a tuple, then the first element is interpreted as\n       an attribute of obj and the second as the docstring\n          (method, docstring)\n\n    If doc is a list, then each element of the list should be a\n       sequence of length two --> [(method1, docstring1),\n       (method2, docstring2), ...]\n\n    This routine never raises an error.\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_3add_newdoc = {__Pyx_NAMESTR("add_newdoc"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_3add_newdoc, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_2add_newdoc)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_3add_newdoc(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_place = 0;
  CYTHON_UNUSED PyObject *__pyx_v_obj = 0;
  CYTHON_UNUSED PyObject *__pyx_v_doc = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("add_newdoc (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__place,&__pyx_n_s__obj,&__pyx_n_s__doc,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__place)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__obj)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("add_newdoc", 1, 3, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 21; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__doc)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("add_newdoc", 1, 3, 3, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 21; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "add_newdoc") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 21; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_place = values[0];
    __pyx_v_obj = values[1];
    __pyx_v_doc = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("add_newdoc", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 21; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.add_newdoc", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_2add_newdoc(__pyx_self, __pyx_v_place, __pyx_v_obj, __pyx_v_doc);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":21
 * 
 * 
 * def add_newdoc(place, obj, doc):             # <<<<<<<<<<<<<<
 *     """Adds documentation to obj which is in module place.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_2add_newdoc(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_place, CYTHON_UNUSED PyObject *__pyx_v_obj, CYTHON_UNUSED PyObject *__pyx_v_doc) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("add_newdoc", 0);

  /* "ga4py/gain/notimplemented.pyx":37
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 37; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.add_newdoc", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_5all(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_4all[] = "Test whether all array elements along a given axis evaluate to True.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array or object that can be converted to an array.\n    axis : int, optional\n        Axis along which a logical AND is performed.\n        The default (`axis` = `None`) is to perform a logical AND\n        over a flattened input array.  `axis` may be negative, in which\n        case it counts from the last to the first axis.\n    out : ndarray, optional\n        Alternate output array in which to place the result.\n        It must have the same shape as the expected output and its\n        type is preserved (e.g., if ``dtype(out)`` is float, the result\n        will consist of 0.0's and 1.0's).  See `doc.ufuncs` (Section\n        \"Output arguments\") for more details.\n\n    Returns\n    -------\n    all : ndarray, bool\n        A new boolean or array is returned unless `out` is specified,\n        in which case a reference to `out` is returned.\n\n    See Also\n    --------\n    ndarray.all : equivalent method\n\n    any : Test whether any element along a given axis evaluates to True.\n\n    Notes\n    -----\n    Not a Number (NaN), positive infinity and negative infinity\n    evaluate to `True` because these are not equal to zero.\n\n    Examples\n    --------\n    >>> np.all([[True,False],[True,True]])\n    False\n\n    >>> np.all([[True,False],[True,True]], axis=0)\n    array([ True, False], dtype=bool)\n\n    >>> np.all([-1, 4, 5])\n    True\n\n    >>> np.all([1.0, np.nan])\n    True\n\n    >>> o=np.array([False])\n    >>> z=np.all([-1, 4, 5], out=o)\n    >>> id(z), id(o), z                             # doctest: +SKIP\n    (28293632, 28293632, array([ True], dtype=bool))\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_5all = {__Pyx_NAMESTR("all"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_5all, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_4all)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_5all(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("all (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__axis,&__pyx_n_s__out,0};
    PyObject* values[3] = {0,0,0};

    /* "ga4py/gain/notimplemented.pyx":40
 * 
 * 
 * def all(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Test whether all array elements along a given axis evaluate to True.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__out);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "all") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 40; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
    __pyx_v_out = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("all", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 40; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.all", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_4all(__pyx_self, __pyx_v_a, __pyx_v_axis, __pyx_v_out);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_4all(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("all", 0);

  /* "ga4py/gain/notimplemented.pyx":96
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 96; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.all", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_7allclose(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_6allclose[] = "Returns True if two arrays are element-wise equal within a tolerance.\n\n    The tolerance values are positive, typically very small numbers.  The\n    relative difference (`rtol` * abs(`b`)) and the absolute difference\n    `atol` are added together to compare against the absolute difference\n    between `a` and `b`.\n\n    Parameters\n    ----------\n    a, b : array_like\n        Input arrays to compare.\n    rtol : float\n        The relative tolerance parameter (see Notes).\n    atol : float\n        The absolute tolerance parameter (see Notes).\n\n    Returns\n    -------\n    y : bool\n        Returns True if the two arrays are equal within the given\n        tolerance; False otherwise. If either array contains NaN, then\n        False is returned.\n\n    See Also\n    --------\n    all, any, alltrue, sometrue\n\n    Notes\n    -----\n    If the following equation is element-wise True, then allclose returns\n    True.\n\n     absolute(`a` - `b`) <= (`atol` + `rtol` * absolute(`b`))\n\n    The above equation is not symmetric in `a` and `b`, so that\n    `allclose(a, b)` might be different from `allclose(b, a)` in\n    some rare cases.\n\n    Examples\n    --------\n    >>> np.allclose([1e10,1e-7], [1.00001e10,1e-8])\n    False\n    >>> np.allclose([1e10,1e-8], [1.00001e10,1e-9])\n    True\n    >>> np.allclose([1e10,1e-8], [1.0001e10,1e-9])\n    False\n    >>> np.allclose([1.0, np.nan], [1.0, np.nan])\n    False\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_7allclose = {__Pyx_NAMESTR("allclose"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_7allclose, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_6allclose)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_7allclose(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_b = 0;
  CYTHON_UNUSED PyObject *__pyx_v_rtol = 0;
  CYTHON_UNUSED PyObject *__pyx_v_atol = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("allclose (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__b,&__pyx_n_s__rtol,&__pyx_n_s__atol,0};
    PyObject* values[4] = {0,0,0,0};
    values[2] = __pyx_k_1;
    values[3] = __pyx_k_2;
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__b)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("allclose", 0, 2, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 99; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__rtol);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__atol);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "allclose") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 99; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_b = values[1];
    __pyx_v_rtol = values[2];
    __pyx_v_atol = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("allclose", 0, 2, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 99; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.allclose", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_6allclose(__pyx_self, __pyx_v_a, __pyx_v_b, __pyx_v_rtol, __pyx_v_atol);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":99
 * 
 * 
 * def allclose(a, b, rtol=1e-05, atol=1e-08):             # <<<<<<<<<<<<<<
 *     """Returns True if two arrays are element-wise equal within a tolerance.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_6allclose(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_b, CYTHON_UNUSED PyObject *__pyx_v_rtol, CYTHON_UNUSED PyObject *__pyx_v_atol) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("allclose", 0);

  /* "ga4py/gain/notimplemented.pyx":150
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 150; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.allclose", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_9alltrue(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_8alltrue[] = "Check if all elements of input array are true.\n\n    See Also\n    --------\n    numpy.all : Equivalent function; see for details.\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_9alltrue = {__Pyx_NAMESTR("alltrue"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_9alltrue, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_8alltrue)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_9alltrue(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("alltrue (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__axis,&__pyx_n_s__out,0};
    PyObject* values[3] = {0,0,0};

    /* "ga4py/gain/notimplemented.pyx":153
 * 
 * 
 * def alltrue(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Check if all elements of input array are true.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__out);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "alltrue") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 153; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
    __pyx_v_out = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("alltrue", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 153; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.alltrue", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_8alltrue(__pyx_self, __pyx_v_a, __pyx_v_axis, __pyx_v_out);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_8alltrue(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("alltrue", 0);

  /* "ga4py/gain/notimplemented.pyx":161
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 161; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.alltrue", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_11alterdot(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_10alterdot[] = "Change `dot`, `vdot`, and `innerproduct` to use accelerated BLAS functions.\n\n    Typically, as a user of Numpy, you do not explicitly call this function. If\n    Numpy is built with an accelerated BLAS, this function is automatically\n    called when Numpy is imported.\n\n    When Numpy is built with an accelerated BLAS like ATLAS, these functions\n    are replaced to make use of the faster implementations.  The faster\n    implementations only affect float32, float64, complex64, and complex128\n    arrays. Furthermore, the BLAS API only includes matrix-matrix,\n    matrix-vector, and vector-vector products. Products of arrays with larger\n    dimensionalities use the built in functions and are not accelerated.\n\n    See Also\n    --------\n    restoredot : `restoredot` undoes the effects of `alterdot`.\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_11alterdot = {__Pyx_NAMESTR("alterdot"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_11alterdot, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_10alterdot)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_11alterdot(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("alterdot (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_10alterdot(__pyx_self);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":164
 * 
 * 
 * def alterdot():             # <<<<<<<<<<<<<<
 *     """Change `dot`, `vdot`, and `innerproduct` to use accelerated BLAS functions.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_10alterdot(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("alterdot", 0);

  /* "ga4py/gain/notimplemented.pyx":184
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 184; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.alterdot", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_13amax(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_12amax[] = "Return the maximum of an array or maximum along an axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    axis : int, optional\n        Axis along which to operate.  By default flattened input is used.\n    out : ndarray, optional\n        Alternate output array in which to place the result.  Must be of\n        the same shape and buffer length as the expected output.  See\n        `doc.ufuncs` (Section \"Output arguments\") for more details.\n\n    Returns\n    -------\n    amax : ndarray or scalar\n        Maximum of `a`. If `axis` is None, the result is a scalar value.\n        If `axis` is given, the result is an array of dimension\n        ``a.ndim - 1``.\n\n    See Also\n    --------\n    nanmax : NaN values are ignored instead of being propagated.\n    fmax : same behavior as the C99 fmax function.\n    argmax : indices of the maximum values.\n\n    Notes\n    -----\n    NaN values are propagated, that is if at least one item is NaN, the\n    corresponding max value will be NaN as well.  To ignore NaN values\n    (MATLAB behavior), please use nanmax.\n\n    Examples\n    --------\n    >>> a = np.arange(4).reshape((2,2))\n    >>> a\n    array([[0, 1],\n           [2, 3]])\n    >>> np.amax(a)\n    3\n    >>> np.amax(a, axis=0)\n    array([2, 3])\n    >>> np.amax(a, axis=1)\n    array([1, 3])\n\n    >>> b = np.arange(5, dtype=np.float)\n    >>> b[2] = np.NaN\n    >>> np.amax(b)\n    nan\n    >>> np.nanmax(b)\n    4.0\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_13amax = {__Pyx_NAMESTR("amax"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_13amax, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_12amax)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_13amax(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("amax (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__axis,&__pyx_n_s__out,0};
    PyObject* values[3] = {0,0,0};

    /* "ga4py/gain/notimplemented.pyx":187
 * 
 * 
 * def amax(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the maximum of an array or maximum along an axis.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__out);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "amax") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 187; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
    __pyx_v_out = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("amax", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 187; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.amax", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_12amax(__pyx_self, __pyx_v_a, __pyx_v_axis, __pyx_v_out);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_12amax(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("amax", 0);

  /* "ga4py/gain/notimplemented.pyx":241
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 241; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.amax", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_15amin(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_14amin[] = "Return the minimum of an array or minimum along an axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    axis : int, optional\n        Axis along which to operate.  By default a flattened input is used.\n    out : ndarray, optional\n        Alternative output array in which to place the result.  Must\n        be of the same shape and buffer length as the expected output.\n        See `doc.ufuncs` (Section \"Output arguments\") for more details.\n\n    Returns\n    -------\n    amin : ndarray\n        A new array or a scalar array with the result.\n\n    See Also\n    --------\n    nanmin: nan values are ignored instead of being propagated\n    fmin: same behavior as the C99 fmin function\n    argmin: Return the indices of the minimum values.\n\n    amax, nanmax, fmax\n\n    Notes\n    -----\n    NaN values are propagated, that is if at least one item is nan, the\n    corresponding min value will be nan as well. To ignore NaN values (matlab\n    behavior), please use nanmin.\n\n    Examples\n    --------\n    >>> a = np.arange(4).reshape((2,2))\n    >>> a\n    array([[0, 1],\n           [2, 3]])\n    >>> np.amin(a)           # Minimum of the flattened array\n    0\n    >>> np.amin(a, axis=0)         # Minima along the first axis\n    array([0, 1])\n    >>> np.amin(a, axis=1)         # Minima along the second axis\n    array([0, 2])\n\n    >>> b = np.arange(5, dtype=np.float)\n    >>> b[2] = np.NaN\n    >>> np.amin(b)\n    nan\n    >>> np.nanmin(b)\n    0.0\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_15amin = {__Pyx_NAMESTR("amin"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_15amin, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_14amin)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_15amin(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("amin (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__axis,&__pyx_n_s__out,0};
    PyObject* values[3] = {0,0,0};

    /* "ga4py/gain/notimplemented.pyx":244
 * 
 * 
 * def amin(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the minimum of an array or minimum along an axis.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__out);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "amin") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 244; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
    __pyx_v_out = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("amin", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 244; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.amin", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_14amin(__pyx_self, __pyx_v_a, __pyx_v_axis, __pyx_v_out);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_14amin(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("amin", 0);

  /* "ga4py/gain/notimplemented.pyx":298
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 298; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.amin", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_17angle(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_16angle[] = "Return the angle of the complex argument.\n\n    Parameters\n    ----------\n    z : array_like\n        A complex number or sequence of complex numbers.\n    deg : bool, optional\n        Return angle in degrees if True, radians if False (default).\n\n    Returns\n    -------\n    angle : {ndarray, scalar}\n        The counterclockwise angle from the positive real axis on\n        the complex plane, with dtype as numpy.float64.\n\n    See Also\n    --------\n    arctan2\n    absolute\n\n\n\n    Examples\n    --------\n    >>> np.angle([1.0, 1.0j, 1+1j])               # in radians\n    array([ 0.        ,  1.57079633,  0.78539816])\n    >>> np.angle(1+1j, deg=True)                  # in degrees\n    45.0\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_17angle = {__Pyx_NAMESTR("angle"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_17angle, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_16angle)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_17angle(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_z = 0;
  CYTHON_UNUSED PyObject *__pyx_v_deg = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("angle (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__z,&__pyx_n_s__deg,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)__pyx_int_0);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__z)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__deg);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "angle") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 301; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_z = values[0];
    __pyx_v_deg = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("angle", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 301; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.angle", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_16angle(__pyx_self, __pyx_v_z, __pyx_v_deg);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":301
 * 
 * 
 * def angle(z, deg=0):             # <<<<<<<<<<<<<<
 *     """Return the angle of the complex argument.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_16angle(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_z, CYTHON_UNUSED PyObject *__pyx_v_deg) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("angle", 0);

  /* "ga4py/gain/notimplemented.pyx":332
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 332; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.angle", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_19any(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_18any[] = "Test whether any array element along a given axis evaluates to True.\n\n    Returns single boolean unless `axis` is not ``None``\n\n    Parameters\n    ----------\n    a : array_like\n        Input array or object that can be converted to an array.\n    axis : int, optional\n        Axis along which a logical OR is performed.  The default\n        (`axis` = `None`) is to perform a logical OR over a flattened\n        input array. `axis` may be negative, in which case it counts\n        from the last to the first axis.\n    out : ndarray, optional\n        Alternate output array in which to place the result.  It must have\n        the same shape as the expected output and its type is preserved\n        (e.g., if it is of type float, then it will remain so, returning\n        1.0 for True and 0.0 for False, regardless of the type of `a`).\n        See `doc.ufuncs` (Section \"Output arguments\") for details.\n\n    Returns\n    -------\n    any : bool or ndarray\n        A new boolean or `ndarray` is returned unless `out` is specified,\n        in which case a reference to `out` is returned.\n\n    See Also\n    --------\n    ndarray.any : equivalent method\n\n    all : Test whether all elements along a given axis evaluate to True.\n\n    Notes\n    -----\n    Not a Number (NaN), positive infinity and negative infinity evaluate\n    to `True` because these are not equal to zero.\n\n    Examples\n    --------\n    >>> np.any([[True, False], [True, True]])\n    True\n\n    >>> np.any([[True, False], [False, False]], axis=0)\n    array([ True, False], dtype=bool)\n\n    >>> np.any([-1, 0, 5])\n    True\n\n    >>> np.any(np.nan)\n    True\n\n    >>> o=np.array([False])\n    >>> z=np.any([-1, 4, 5], out=o)\n    >>> z, o\n    (array([ True], dtype=bool), array([ True], dtype=bool))\n    >>> # Check now that z is a reference to o\n    >>> z is o\n    True\n    >>> id(z), id(o) # identity of z and o              # doctest: +SKIP\n    (191614240, 191614240)\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_19any = {__Pyx_NAMESTR("any"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_19any, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_18any)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_19any(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("any (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__axis,&__pyx_n_s__out,0};
    PyObject* values[3] = {0,0,0};

    /* "ga4py/gain/notimplemented.pyx":335
 * 
 * 
 * def any(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Test whether any array element along a given axis evaluates to True.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__out);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "any") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 335; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
    __pyx_v_out = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("any", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 335; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.any", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_18any(__pyx_self, __pyx_v_a, __pyx_v_axis, __pyx_v_out);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_18any(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("any", 0);

  /* "ga4py/gain/notimplemented.pyx":398
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 398; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.any", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_21append(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_20append[] = "Append values to the end of an array.\n\n    Parameters\n    ----------\n    arr : array_like\n        Values are appended to a copy of this array.\n    values : array_like\n        These values are appended to a copy of `arr`.  It must be of the\n        correct shape (the same shape as `arr`, excluding `axis`).  If `axis`\n        is not specified, `values` can be any shape and will be flattened\n        before use.\n    axis : int, optional\n        The axis along which `values` are appended.  If `axis` is not given,\n        both `arr` and `values` are flattened before use.\n\n    Returns\n    -------\n    out : ndarray\n        A copy of `arr` with `values` appended to `axis`.  Note that `append`\n        does not occur in-place: a new array is allocated and filled.  If\n        `axis` is None, `out` is a flattened array.\n\n    See Also\n    --------\n    insert : Insert elements into an array.\n    delete : Delete elements from an array.\n\n    Examples\n    --------\n    >>> np.append([1, 2, 3], [[4, 5, 6], [7, 8, 9]])\n    array([1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n    When `axis` is specified, `values` must have the correct shape.\n\n    >>> np.append([[1, 2, 3], [4, 5, 6]], [[7, 8, 9]], axis=0)\n    array([[1, 2, 3],\n           [4, 5, 6],\n           [7, 8, 9]])\n    >>> np.append([[1, 2, 3], [4, 5, 6]], [7, 8, 9], axis=0)\n    Traceback (most recent call last):\n    ...\n    ValueError: arrays must have same number of dimensions\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_21append = {__Pyx_NAMESTR("append"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_21append, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_20append)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_21append(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_arr = 0;
  CYTHON_UNUSED PyObject *__pyx_v_values = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("append (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__arr,&__pyx_n_s__values,&__pyx_n_s__axis,0};
    PyObject* values[3] = {0,0,0};

    /* "ga4py/gain/notimplemented.pyx":401
 * 
 * 
 * def append(arr, values, axis=None):             # <<<<<<<<<<<<<<
 *     """Append values to the end of an array.
 * 
 */
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__arr)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__values)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("append", 0, 2, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 401; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "append") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 401; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_arr = values[0];
    __pyx_v_values = values[1];
    __pyx_v_axis = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("append", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 401; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.append", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_20append(__pyx_self, __pyx_v_arr, __pyx_v_values, __pyx_v_axis);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_20append(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_arr, CYTHON_UNUSED PyObject *__pyx_v_values, CYTHON_UNUSED PyObject *__pyx_v_axis) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("append", 0);

  /* "ga4py/gain/notimplemented.pyx":446
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 446; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.append", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_23apply_along_axis(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_22apply_along_axis[] = "Apply a function to 1-D slices along the given axis.\n\n    Execute `func1d(a, *args)` where `func1d` operates on 1-D arrays and `a`\n    is a 1-D slice of `arr` along `axis`.\n\n    Parameters\n    ----------\n    func1d : function\n        This function should accept 1-D arrays. It is applied to 1-D\n        slices of `arr` along the specified axis.\n    axis : integer\n        Axis along which `arr` is sliced.\n    arr : ndarray\n        Input array.\n    args : any\n        Additional arguments to `func1d`.\n\n    Returns\n    -------\n    outarr : ndarray\n        The output array. The shape of `outarr` is identical to the shape of\n        `arr`, except along the `axis` dimension, where the length of `outarr`\n        is equal to the size of the return value of `func1d`.  If `func1d`\n        returns a scalar `outarr` will have one fewer dimensions than `arr`.\n\n    See Also\n    --------\n    apply_over_axes : Apply a function repeatedly over multiple axes.\n\n    Examples\n    --------\n    >>> def my_func(a):\n    ...     '''Average first and last element of a 1-D array'''\n    ...     return (a[0] + a[-1]) * 0.5\n    >>> b = np.array([[1,2,3], [4,5,6], [7,8,9]])\n    >>> np.apply_along_axis(my_func, 0, b)\n    array([ 4.,  5.,  6.])\n    >>> np.apply_along_axis(my_func, 1, b)\n    array([ 2.,  5.,  8.])\n\n    For a function that doesn't return a scalar, the number of dimensions in\n    `outarr` is the same as `arr`.\n\n    >>> def new_func(a):\n    ...     '''Divide elements of a by 2.'''\n    ...     return a * 0.5\n    >>> b = np.array([[1,2,3], [4,5,6], [7,8,9]])\n    >>> np.apply_along_axis(new_func, 0, b)\n    array([[ 0.5,  1. ,  1.5],\n           [ 2. ,  2.5,  3. ],\n           [ 3.5,  4. ,  4.5]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_23apply_along_axis = {__Pyx_NAMESTR("apply_along_axis"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_23apply_along_axis, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_22apply_along_axis)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_23apply_along_axis(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_func1d = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_arr = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("apply_along_axis (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__func1d,&__pyx_n_s__axis,&__pyx_n_s__arr,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__func1d)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("apply_along_axis", 1, 3, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 449; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__arr)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("apply_along_axis", 1, 3, 3, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 449; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "apply_along_axis") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 449; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_func1d = values[0];
    __pyx_v_axis = values[1];
    __pyx_v_arr = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("apply_along_axis", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 449; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.apply_along_axis", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_22apply_along_axis(__pyx_self, __pyx_v_func1d, __pyx_v_axis, __pyx_v_arr);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":449
 * 
 * 
 * def apply_along_axis(func1d, axis, arr):             # <<<<<<<<<<<<<<
 *     """Apply a function to 1-D slices along the given axis.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_22apply_along_axis(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_func1d, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_arr) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("apply_along_axis", 0);

  /* "ga4py/gain/notimplemented.pyx":503
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 503; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.apply_along_axis", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_25apply_over_axes(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_24apply_over_axes[] = "Apply a function repeatedly over multiple axes.\n\n    `func` is called as `res = func(a, axis)`, where `axis` is the first\n    element of `axes`.  The result `res` of the function call must have\n    either the same dimensions as `a` or one less dimension.  If `res`\n    has one less dimension than `a`, a dimension is inserted before\n    `axis`.  The call to `func` is then repeated for each axis in `axes`,\n    with `res` as the first argument.\n\n    Parameters\n    ----------\n    func : function\n        This function must take two arguments, `func(a, axis)`.\n    a : array_like\n        Input array.\n    axes : array_like\n        Axes over which `func` is applied; the elements must be integers.\n\n    Returns\n    -------\n    val : ndarray\n        The output array.  The number of dimensions is the same as `a`,\n        but the shape can be different.  This depends on whether `func`\n        changes the shape of its output with respect to its input.\n\n    See Also\n    --------\n    apply_along_axis :\n        Apply a function to 1-D slices of an array along the given axis.\n\n    Examples\n    --------\n    >>> a = np.arange(24).reshape(2,3,4)\n    >>> a\n    array([[[ 0,  1,  2,  3],\n            [ 4,  5,  6,  7],\n            [ 8,  9, 10, 11]],\n           [[12, 13, 14, 15],\n            [16, 17, 18, 19],\n            [20, 21, 22, 23]]])\n\n    Sum over axes 0 and 2. The result has same number of dimensions\n    as the original array:\n\n    >>> np.apply_over_axes(np.sum, a, [0,2])\n    array([[[ 60],\n            [ 92],\n            [124]]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_25apply_over_axes = {__Pyx_NAMESTR("apply_over_axes"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_25apply_over_axes, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_24apply_over_axes)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_25apply_over_axes(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_func = 0;
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axes = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("apply_over_axes (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__func,&__pyx_n_s__a,&__pyx_n_s__axes,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__func)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("apply_over_axes", 1, 3, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 506; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axes)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("apply_over_axes", 1, 3, 3, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 506; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "apply_over_axes") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 506; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_func = values[0];
    __pyx_v_a = values[1];
    __pyx_v_axes = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("apply_over_axes", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 506; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.apply_over_axes", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_24apply_over_axes(__pyx_self, __pyx_v_func, __pyx_v_a, __pyx_v_axes);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":506
 * 
 * 
 * def apply_over_axes(func, a, axes):             # <<<<<<<<<<<<<<
 *     """Apply a function repeatedly over multiple axes.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_24apply_over_axes(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_func, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axes) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("apply_over_axes", 0);

  /* "ga4py/gain/notimplemented.pyx":557
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 557; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.apply_over_axes", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_27argmax(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_26argmax[] = "Indices of the maximum values along an axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    axis : int, optional\n        By default, the index is into the flattened array, otherwise\n        along the specified axis.\n\n    Returns\n    -------\n    index_array : ndarray of ints\n        Array of indices into the array. It has the same shape as `a.shape`\n        with the dimension along `axis` removed.\n\n    See Also\n    --------\n    ndarray.argmax, argmin\n    amax : The maximum value along a given axis.\n    unravel_index : Convert a flat index into an index tuple.\n\n    Notes\n    -----\n    In case of multiple occurrences of the maximum values, the indices\n    corresponding to the first occurrence are returned.\n\n    Examples\n    --------\n    >>> a = np.arange(6).reshape(2,3)\n    >>> a\n    array([[0, 1, 2],\n           [3, 4, 5]])\n    >>> np.argmax(a)\n    5\n    >>> np.argmax(a, axis=0)\n    array([1, 1, 1])\n    >>> np.argmax(a, axis=1)\n    array([2, 2])\n\n    >>> b = np.arange(6)\n    >>> b[1] = 5\n    >>> b\n    array([0, 5, 2, 3, 4, 5])\n    >>> np.argmax(b) # Only the first occurrence is returned.\n    1\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_27argmax = {__Pyx_NAMESTR("argmax"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_27argmax, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_26argmax)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_27argmax(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("argmax (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__axis,0};
    PyObject* values[2] = {0,0};

    /* "ga4py/gain/notimplemented.pyx":560
 * 
 * 
 * def argmax(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Indices of the maximum values along an axis.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "argmax") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 560; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("argmax", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 560; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.argmax", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_26argmax(__pyx_self, __pyx_v_a, __pyx_v_axis);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_26argmax(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("argmax", 0);

  /* "ga4py/gain/notimplemented.pyx":609
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 609; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.argmax", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_29argmin(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_28argmin[] = "Return the indices of the minimum values along an axis.\n\n    See Also\n    --------\n    argmax : Similar function.  Please refer to `numpy.argmax` for detailed\n        documentation.\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_29argmin = {__Pyx_NAMESTR("argmin"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_29argmin, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_28argmin)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_29argmin(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("argmin (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__axis,0};
    PyObject* values[2] = {0,0};

    /* "ga4py/gain/notimplemented.pyx":612
 * 
 * 
 * def argmin(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Return the indices of the minimum values along an axis.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "argmin") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 612; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("argmin", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 612; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.argmin", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_28argmin(__pyx_self, __pyx_v_a, __pyx_v_axis);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_28argmin(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("argmin", 0);

  /* "ga4py/gain/notimplemented.pyx":621
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 621; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.argmin", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_31argsort(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_30argsort[] = "Returns the indices that would sort an array.\n\n    Perform an indirect sort along the given axis using the algorithm specified\n    by the `kind` keyword. It returns an array of indices of the same shape as\n    `a` that index data along the given axis in sorted order.\n\n    Parameters\n    ----------\n    a : array_like\n        Array to sort.\n    axis : int or None, optional\n        Axis along which to sort.  The default is -1 (the last axis). If None,\n        the flattened array is used.\n    kind : {'quicksort', 'mergesort', 'heapsort'}, optional\n        Sorting algorithm.\n    order : list, optional\n        When `a` is an array with fields defined, this argument specifies\n        which fields to compare first, second, etc.  Not all fields need be\n        specified.\n\n    Returns\n    -------\n    index_array : ndarray, int\n        Array of indices that sort `a` along the specified axis.\n        In other words, ``a[index_array]`` yields a sorted `a`.\n\n    See Also\n    --------\n    sort : Describes sorting algorithms used.\n    lexsort : Indirect stable sort with multiple keys.\n    ndarray.sort : Inplace sort.\n\n    Notes\n    -----\n    See `sort` for notes on the different sorting algorithms.\n\n    As of NumPy 1.4.0 `argsort` works with real/complex arrays containing\n    nan values. The enhanced sort order is documented in `sort`.\n\n    Examples\n    --------\n    One dimensional array:\n\n    >>> x = np.array([3, 1, 2])\n    >>> np.argsort(x)\n    array([1, 2, 0])\n\n    Two-dimensional array:\n\n    >>> x = np.array([[0, 3], [2, 2]])\n    >>> x\n    array([[0, 3],\n           [2, 2]])\n\n    >>> np.argsort(x, axis=0)\n    array([[0, 1],\n           [1, 0]])\n\n    >>> np.argsort(x, axis=1)\n    array([[0, 1],\n           [0, 1]])\n\n    Sorting with keys:\n\n    >>> x = np.array([(1, 0), (0, 1)], dtype=[('x', '<i4'), ('y', '<i4')])\n    >>> x\n    array([(1, 0), (0, 1)],\n          dtype=[('x', '<i4'), ('y', '<i4')])\n\n    >>> np.argsor""t(x, order=('x','y'))\n    array([1, 0])\n\n    >>> np.argsort(x, order=('y','x'))\n    array([0, 1])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_31argsort = {__Pyx_NAMESTR("argsort"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_31argsort, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_30argsort)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_31argsort(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_kind = 0;
  CYTHON_UNUSED PyObject *__pyx_v_order = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("argsort (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__axis,&__pyx_n_s__kind,&__pyx_n_s__order,0};
    PyObject* values[4] = {0,0,0,0};
    values[1] = ((PyObject *)__pyx_int_neg_1);
    values[2] = ((PyObject *)__pyx_n_s__quicksort);

    /* "ga4py/gain/notimplemented.pyx":624
 * 
 * 
 * def argsort(a, axis=-1, kind='quicksort', order=None):             # <<<<<<<<<<<<<<
 *     """Returns the indices that would sort an array.
 * 
 */
    values[3] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__kind);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__order);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "argsort") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 624; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
    __pyx_v_kind = values[2];
    __pyx_v_order = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("argsort", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 624; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.argsort", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_30argsort(__pyx_self, __pyx_v_a, __pyx_v_axis, __pyx_v_kind, __pyx_v_order);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_30argsort(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_kind, CYTHON_UNUSED PyObject *__pyx_v_order) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("argsort", 0);

  /* "ga4py/gain/notimplemented.pyx":701
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 701; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.argsort", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_33argwhere(PyObject *__pyx_self, PyObject *__pyx_v_a); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_32argwhere[] = "Find the indices of array elements that are non-zero, grouped by element.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n\n    Returns\n    -------\n    index_array : ndarray\n        Indices of elements that are non-zero. Indices are grouped by element.\n\n    See Also\n    --------\n    where, nonzero\n\n    Notes\n    -----\n    ``np.argwhere(a)`` is the same as ``np.transpose(np.nonzero(a))``.\n\n    The output of ``argwhere`` is not suitable for indexing arrays.\n    For this purpose use ``where(a)`` instead.\n\n    Examples\n    --------\n    >>> x = np.arange(6).reshape(2,3)\n    >>> x\n    array([[0, 1, 2],\n           [3, 4, 5]])\n    >>> np.argwhere(x>1)\n    array([[0, 2],\n           [1, 0],\n           [1, 1],\n           [1, 2]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_33argwhere = {__Pyx_NAMESTR("argwhere"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_33argwhere, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_32argwhere)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_33argwhere(PyObject *__pyx_self, PyObject *__pyx_v_a) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("argwhere (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_32argwhere(__pyx_self, ((PyObject *)__pyx_v_a));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":704
 * 
 * 
 * def argwhere(a):             # <<<<<<<<<<<<<<
 *     """Find the indices of array elements that are non-zero, grouped by element.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_32argwhere(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("argwhere", 0);

  /* "ga4py/gain/notimplemented.pyx":741
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 741; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.argwhere", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_35around(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_34around[] = "Evenly round to the given number of decimals.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    decimals : int, optional\n        Number of decimal places to round to (default: 0).  If\n        decimals is negative, it specifies the number of positions to\n        the left of the decimal point.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must have\n        the same shape as the expected output, but the type of the output\n        values will be cast if necessary. See `doc.ufuncs` (Section\n        \"Output arguments\") for details.\n\n    Returns\n    -------\n    rounded_array : ndarray\n        An array of the same type as `a`, containing the rounded values.\n        Unless `out` was specified, a new array is created.  A reference to\n        the result is returned.\n\n        The real and imaginary parts of complex numbers are rounded\n        separately.  The result of rounding a float is a float.\n\n    See Also\n    --------\n    ndarray.round : equivalent method\n\n    ceil, fix, floor, rint, trunc\n\n\n    Notes\n    -----\n    For values exactly halfway between rounded decimal values, Numpy\n    rounds to the nearest even value. Thus 1.5 and 2.5 round to 2.0,\n    -0.5 and 0.5 round to 0.0, etc. Results may also be surprising due\n    to the inexact representation of decimal fractions in the IEEE\n    floating point standard [1]_ and errors introduced when scaling\n    by powers of ten.\n\n    References\n    ----------\n    .. [1] \"Lecture Notes on the Status of  IEEE 754\", William Kahan,\n           http://www.cs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF\n    .. [2] \"How Futile are Mindless Assessments of\n           Roundoff in Floating-Point Computation?\", William Kahan,\n           http://www.cs.berkeley.edu/~wkahan/Mindless.pdf\n\n    Examples\n    --------\n    >>> np.around([0.37, 1.64])\n    array([ 0.,  2.])\n    >>> np.around([0.37, 1.64], decimals=1)\n    ""array([ 0.4,  1.6])\n    >>> np.around([.5, 1.5, 2.5, 3.5, 4.5]) # rounds to nearest even value\n    array([ 0.,  2.,  2.,  4.,  4.])\n    >>> np.around([1,2,3,11], decimals=1) # ndarray of ints is returned\n    array([ 1,  2,  3, 11])\n    >>> np.around([1,2,3,11], decimals=-1)\n    array([ 0,  0,  0, 10])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_35around = {__Pyx_NAMESTR("around"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_35around, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_34around)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_35around(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_decimals = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("around (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__decimals,&__pyx_n_s__out,0};
    PyObject* values[3] = {0,0,0};
    values[1] = ((PyObject *)__pyx_int_0);

    /* "ga4py/gain/notimplemented.pyx":744
 * 
 * 
 * def around(a, decimals=0, out=None):             # <<<<<<<<<<<<<<
 *     """Evenly round to the given number of decimals.
 * 
 */
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__decimals);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__out);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "around") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 744; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_decimals = values[1];
    __pyx_v_out = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("around", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 744; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.around", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_34around(__pyx_self, __pyx_v_a, __pyx_v_decimals, __pyx_v_out);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_34around(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_decimals, CYTHON_UNUSED PyObject *__pyx_v_out) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("around", 0);

  /* "ga4py/gain/notimplemented.pyx":809
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 809; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.around", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_37array(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_36array[] = "array(object, dtype=None, copy=True, order=None, subok=False, ndmin=0)\n\n    Create an array.\n\n    Parameters\n    ----------\n    object : array_like\n        An array, any object exposing the array interface, an\n        object whose __array__ method returns an array, or any\n        (nested) sequence.\n    dtype : data-type, optional\n        The desired data-type for the array.  If not given, then\n        the type will be determined as the minimum type required\n        to hold the objects in the sequence.  This argument can only\n        be used to 'upcast' the array.  For downcasting, use the\n        .astype(t) method.\n    copy : bool, optional\n        If true (default), then the object is copied.  Otherwise, a copy\n        will only be made if __array__ returns a copy, if obj is a\n        nested sequence, or if a copy is needed to satisfy any of the other\n        requirements (`dtype`, `order`, etc.).\n    order : {'C', 'F', 'A'}, optional\n        Specify the order of the array.  If order is 'C' (default), then the\n        array will be in C-contiguous order (last-index varies the\n        fastest).  If order is 'F', then the returned array\n        will be in Fortran-contiguous order (first-index varies the\n        fastest).  If order is 'A', then the returned array may\n        be in any order (either C-, Fortran-contiguous, or even\n        discontiguous).\n    subok : bool, optional\n        If True, then sub-classes will be passed-through, otherwise\n        the returned array will be forced to be a base-class array (default).\n    ndmin : int, optional\n        Specifies the minimum number of dimensions that the resulting\n        array should have.  Ones will be pre-pended to the shape as\n        needed to meet this requirement.\n\n    Returns\n    -------\n    out : ndarray\n        An array object satisfying the specified requirements.\n\n    See Also\n    --------\n    empty, empty_like, zeros, zeros_like, ones, ones_like, fill\n\n    ""Examples\n    --------\n    >>> np.array([1, 2, 3])\n    array([1, 2, 3])\n\n    Upcasting:\n\n    >>> np.array([1, 2, 3.0])\n    array([ 1.,  2.,  3.])\n\n    More than one dimension:\n\n    >>> np.array([[1, 2], [3, 4]])\n    array([[1, 2],\n           [3, 4]])\n\n    Minimum dimensions 2:\n\n    >>> np.array([1, 2, 3], ndmin=2)\n    array([[1, 2, 3]])\n\n    Type provided:\n\n    >>> np.array([1, 2, 3], dtype=complex)\n    array([ 1.+0.j,  2.+0.j,  3.+0.j])\n\n    Data-type consisting of more than one element:\n\n    >>> x = np.array([(1,2),(3,4)],dtype=[('a','<i4'),('b','<i4')])\n    >>> x['a']\n    array([1, 3])\n\n    Creating an array from sub-classes:\n\n    >>> np.array(np.mat('1 2; 3 4'))\n    array([[1, 2],\n           [3, 4]])\n\n    >>> np.array(np.mat('1 2; 3 4'), subok=True)\n    matrix([[1, 2],\n            [3, 4]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_37array = {__Pyx_NAMESTR("array"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_37array, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_36array)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_37array(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_object = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  CYTHON_UNUSED PyObject *__pyx_v_copy = 0;
  CYTHON_UNUSED PyObject *__pyx_v_order = 0;
  CYTHON_UNUSED PyObject *__pyx_v_subok = 0;
  CYTHON_UNUSED PyObject *__pyx_v_ndmin = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("array (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__object,&__pyx_n_s__dtype,&__pyx_n_s__copy,&__pyx_n_s__order,&__pyx_n_s__subok,&__pyx_n_s__ndmin,0};
    PyObject* values[6] = {0,0,0,0,0,0};

    /* "ga4py/gain/notimplemented.pyx":812
 * 
 * 
 * def array(object, dtype=None, copy=True, order=None, subok=False, ndmin=0):             # <<<<<<<<<<<<<<
 *     """array(object, dtype=None, copy=True, order=None, subok=False, ndmin=0)
 * 
 */
    values[1] = ((PyObject *)Py_None);
    values[2] = __pyx_k_3;
    values[3] = ((PyObject *)Py_None);
    values[4] = __pyx_k_4;
    values[5] = ((PyObject *)__pyx_int_0);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__object)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__dtype);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__copy);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__order);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__subok);
          if (value) { values[4] = value; kw_args--; }
        }
        case  5:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__ndmin);
          if (value) { values[5] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "array") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 812; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_object = values[0];
    __pyx_v_dtype = values[1];
    __pyx_v_copy = values[2];
    __pyx_v_order = values[3];
    __pyx_v_subok = values[4];
    __pyx_v_ndmin = values[5];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("array", 0, 1, 6, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 812; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.array", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_36array(__pyx_self, __pyx_v_object, __pyx_v_dtype, __pyx_v_copy, __pyx_v_order, __pyx_v_subok, __pyx_v_ndmin);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_36array(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_object, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_copy, CYTHON_UNUSED PyObject *__pyx_v_order, CYTHON_UNUSED PyObject *__pyx_v_subok, CYTHON_UNUSED PyObject *__pyx_v_ndmin) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("array", 0);

  /* "ga4py/gain/notimplemented.pyx":903
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 903; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.array", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_39array2string(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_38array2string[] = "Return a string representation of an array.\n\n    Parameters\n    ----------\n    a : ndarray\n        Input array.\n    max_line_width : int, optional\n        The maximum number of columns the string should span. Newline\n        characters splits the string appropriately after array elements.\n    precision : int, optional\n        Floating point precision. Default is the current printing\n        precision (usually 8), which can be altered using `set_printoptions`.\n    suppress_small : bool, optional\n        Represent very small numbers as zero. A number is \"very small\" if it\n        is smaller than the current printing precision.\n    separator : str, optional\n        Inserted between elements.\n    prefix : str, optional\n        An array is typically printed as::\n\n          'prefix(' + array2string(a) + ')'\n\n        The length of the prefix string is used to align the\n        output correctly.\n    style : function, optional\n        A function that accepts an ndarray and returns a string.  Used only\n        when the shape of `a` is equal to ().\n\n    Returns\n    -------\n    array_str : str\n        String representation of the array.\n\n    See Also\n    --------\n    array_str, array_repr, set_printoptions\n\n    Examples\n    --------\n    >>> x = np.array([1e-16,1,2,3])\n    >>> print np.array2string(x, precision=2, separator=',',\n    ...                       suppress_small=True)\n    [ 0., 1., 2., 3.]\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_39array2string = {__Pyx_NAMESTR("array2string"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_39array2string, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_38array2string)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_39array2string(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_max_line_width = 0;
  CYTHON_UNUSED PyObject *__pyx_v_precision = 0;
  CYTHON_UNUSED PyObject *__pyx_v_suppress_small = 0;
  CYTHON_UNUSED PyObject *__pyx_v_separator = 0;
  CYTHON_UNUSED PyObject *__pyx_v_prefix = 0;
  CYTHON_UNUSED PyObject *__pyx_v_style = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("array2string (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__max_line_width,&__pyx_n_s__precision,&__pyx_n_s__suppress_small,&__pyx_n_s__separator,&__pyx_n_s__prefix,&__pyx_n_s__style,0};
    PyObject* values[7] = {0,0,0,0,0,0,0};

    /* "ga4py/gain/notimplemented.pyx":906
 * 
 * 
 * def array2string(a, max_line_width=None, precision=None, suppress_small=None, separator=' ', prefix='', style=repr):             # <<<<<<<<<<<<<<
 *     """Return a string representation of an array.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    values[3] = ((PyObject *)Py_None);
    values[4] = ((PyObject *)__pyx_kp_s_5);
    values[5] = ((PyObject *)__pyx_kp_s_6);
    values[6] = __pyx_k_7;
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__max_line_width);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__precision);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__suppress_small);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__separator);
          if (value) { values[4] = value; kw_args--; }
        }
        case  5:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__prefix);
          if (value) { values[5] = value; kw_args--; }
        }
        case  6:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__style);
          if (value) { values[6] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "array2string") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 906; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_max_line_width = values[1];
    __pyx_v_precision = values[2];
    __pyx_v_suppress_small = values[3];
    __pyx_v_separator = values[4];
    __pyx_v_prefix = values[5];
    __pyx_v_style = values[6];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("array2string", 0, 1, 7, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 906; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.array2string", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_38array2string(__pyx_self, __pyx_v_a, __pyx_v_max_line_width, __pyx_v_precision, __pyx_v_suppress_small, __pyx_v_separator, __pyx_v_prefix, __pyx_v_style);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_38array2string(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_max_line_width, CYTHON_UNUSED PyObject *__pyx_v_precision, CYTHON_UNUSED PyObject *__pyx_v_suppress_small, CYTHON_UNUSED PyObject *__pyx_v_separator, CYTHON_UNUSED PyObject *__pyx_v_prefix, CYTHON_UNUSED PyObject *__pyx_v_style) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("array2string", 0);

  /* "ga4py/gain/notimplemented.pyx":952
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 952; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.array2string", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_41array_equal(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_40array_equal[] = "True if two arrays have the same shape and elements, False otherwise.\n\n    Parameters\n    ----------\n    a1, a2 : array_like\n        Input arrays.\n\n    Returns\n    -------\n    b : bool\n        Returns True if the arrays are equal.\n\n    See Also\n    --------\n    allclose: Returns True if two arrays are element-wise equal within a\n              tolerance.\n    array_equiv: Returns True if input arrays are shape consistent and all\n                 elements equal.\n\n    Examples\n    --------\n    >>> np.array_equal([1, 2], [1, 2])\n    True\n    >>> np.array_equal(np.array([1, 2]), np.array([1, 2]))\n    True\n    >>> np.array_equal([1, 2], [1, 2, 3])\n    False\n    >>> np.array_equal([1, 2], [1, 4])\n    False\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_41array_equal = {__Pyx_NAMESTR("array_equal"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_41array_equal, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_40array_equal)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_41array_equal(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a1 = 0;
  CYTHON_UNUSED PyObject *__pyx_v_a2 = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("array_equal (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a1,&__pyx_n_s__a2,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a1)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a2)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("array_equal", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 955; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "array_equal") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 955; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_a1 = values[0];
    __pyx_v_a2 = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("array_equal", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 955; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.array_equal", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_40array_equal(__pyx_self, __pyx_v_a1, __pyx_v_a2);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":955
 * 
 * 
 * def array_equal(a1, a2):             # <<<<<<<<<<<<<<
 *     """True if two arrays have the same shape and elements, False otherwise.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_40array_equal(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a1, CYTHON_UNUSED PyObject *__pyx_v_a2) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("array_equal", 0);

  /* "ga4py/gain/notimplemented.pyx":987
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 987; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.array_equal", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_43array_equiv(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_42array_equiv[] = "Returns True if input arrays are shape consistent and all elements equal.\n\n    Shape consistent means they are either the same shape, or one input array\n    can be broadcasted to create the same shape as the other one.\n\n    Parameters\n    ----------\n    a1, a2 : array_like\n        Input arrays.\n\n    Returns\n    -------\n    out : bool\n        True if equivalent, False otherwise.\n\n    Examples\n    --------\n    >>> np.array_equiv([1, 2], [1, 2])\n    True\n    >>> np.array_equiv([1, 2], [1, 3])\n    False\n\n    Showing the shape equivalence:\n\n    >>> np.array_equiv([1, 2], [[1, 2], [1, 2]])\n    True\n    >>> np.array_equiv([1, 2], [[1, 2, 1, 2], [1, 2, 1, 2]])\n    False\n\n    >>> np.array_equiv([1, 2], [[1, 2], [1, 3]])\n    False\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_43array_equiv = {__Pyx_NAMESTR("array_equiv"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_43array_equiv, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_42array_equiv)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_43array_equiv(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a1 = 0;
  CYTHON_UNUSED PyObject *__pyx_v_a2 = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("array_equiv (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a1,&__pyx_n_s__a2,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a1)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a2)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("array_equiv", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 990; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "array_equiv") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 990; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_a1 = values[0];
    __pyx_v_a2 = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("array_equiv", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 990; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.array_equiv", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_42array_equiv(__pyx_self, __pyx_v_a1, __pyx_v_a2);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":990
 * 
 * 
 * def array_equiv(a1, a2):             # <<<<<<<<<<<<<<
 *     """Returns True if input arrays are shape consistent and all elements equal.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_42array_equiv(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a1, CYTHON_UNUSED PyObject *__pyx_v_a2) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("array_equiv", 0);

  /* "ga4py/gain/notimplemented.pyx":1024
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1024; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.array_equiv", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_45array_repr(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_44array_repr[] = "Return the string representation of an array.\n\n    Parameters\n    ----------\n    arr : ndarray\n        Input array.\n    max_line_width : int, optional\n        The maximum number of columns the string should span. Newline\n        characters split the string appropriately after array elements.\n    precision : int, optional\n        Floating point precision. Default is the current printing precision\n        (usually 8), which can be altered using `set_printoptions`.\n    suppress_small : bool, optional\n        Represent very small numbers as zero, default is False. Very small\n        is defined by `precision`, if the precision is 8 then\n        numbers smaller than 5e-9 are represented as zero.\n\n    Returns\n    -------\n    string : str\n      The string representation of an array.\n\n    See Also\n    --------\n    array_str, array2string, set_printoptions\n\n    Examples\n    --------\n    >>> np.array_repr(np.array([1,2]))\n    'array([1, 2])'\n    >>> np.array_repr(np.ma.array([0.]))\n    'MaskedArray([ 0.])'\n    >>> np.array_repr(np.array([], np.int32))\n    'array([], dtype=int32)'\n\n    >>> x = np.array([1e-6, 4e-7, 2, 3])\n    >>> np.array_repr(x, precision=6, suppress_small=True)\n    'array([ 0.000001,  0.      ,  2.      ,  3.      ])'\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_45array_repr = {__Pyx_NAMESTR("array_repr"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_45array_repr, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_44array_repr)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_45array_repr(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_arr = 0;
  CYTHON_UNUSED PyObject *__pyx_v_max_line_width = 0;
  CYTHON_UNUSED PyObject *__pyx_v_precision = 0;
  CYTHON_UNUSED PyObject *__pyx_v_suppress_small = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("array_repr (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__arr,&__pyx_n_s__max_line_width,&__pyx_n_s__precision,&__pyx_n_s__suppress_small,0};
    PyObject* values[4] = {0,0,0,0};

    /* "ga4py/gain/notimplemented.pyx":1027
 * 
 * 
 * def array_repr(arr, max_line_width=None, precision=None, suppress_small=None):             # <<<<<<<<<<<<<<
 *     """Return the string representation of an array.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    values[3] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__arr)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__max_line_width);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__precision);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__suppress_small);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "array_repr") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1027; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_arr = values[0];
    __pyx_v_max_line_width = values[1];
    __pyx_v_precision = values[2];
    __pyx_v_suppress_small = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("array_repr", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1027; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.array_repr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_44array_repr(__pyx_self, __pyx_v_arr, __pyx_v_max_line_width, __pyx_v_precision, __pyx_v_suppress_small);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_44array_repr(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_arr, CYTHON_UNUSED PyObject *__pyx_v_max_line_width, CYTHON_UNUSED PyObject *__pyx_v_precision, CYTHON_UNUSED PyObject *__pyx_v_suppress_small) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("array_repr", 0);

  /* "ga4py/gain/notimplemented.pyx":1068
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1068; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.array_repr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_47array_split(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_46array_split[] = "Split an array into multiple sub-arrays of equal or near-equal size.\n\n    Please refer to the ``split`` documentation.  The only difference\n    between these functions is that ``array_split`` allows\n    `indices_or_sections` to be an integer that does *not* equally\n    divide the axis.\n\n    See Also\n    --------\n    split : Split array into multiple sub-arrays of equal size.\n\n    Examples\n    --------\n    >>> x = np.arange(8.0)\n    >>> np.array_split(x, 3)\n        [array([ 0.,  1.,  2.]), array([ 3.,  4.,  5.]), array([ 6.,  7.])]\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_47array_split = {__Pyx_NAMESTR("array_split"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_47array_split, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_46array_split)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_47array_split(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_ary = 0;
  CYTHON_UNUSED PyObject *__pyx_v_indices_or_sections = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("array_split (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__ary,&__pyx_n_s__indices_or_sections,&__pyx_n_s__axis,0};
    PyObject* values[3] = {0,0,0};
    values[2] = ((PyObject *)__pyx_int_0);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__ary)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__indices_or_sections)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("array_split", 0, 2, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1071; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "array_split") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1071; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_ary = values[0];
    __pyx_v_indices_or_sections = values[1];
    __pyx_v_axis = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("array_split", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1071; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.array_split", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_46array_split(__pyx_self, __pyx_v_ary, __pyx_v_indices_or_sections, __pyx_v_axis);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":1071
 * 
 * 
 * def array_split(ary, indices_or_sections, axis=0):             # <<<<<<<<<<<<<<
 *     """Split an array into multiple sub-arrays of equal or near-equal size.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_46array_split(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_ary, CYTHON_UNUSED PyObject *__pyx_v_indices_or_sections, CYTHON_UNUSED PyObject *__pyx_v_axis) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("array_split", 0);

  /* "ga4py/gain/notimplemented.pyx":1090
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1090; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.array_split", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_49array_str(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_48array_str[] = "Return a string representation of the data in an array.\n\n    The data in the array is returned as a single string.  This function is\n    similar to `array_repr`, the difference being that `array_repr` also\n    returns information on the kind of array and its data type.\n\n    Parameters\n    ----------\n    a : ndarray\n        Input array.\n    max_line_width : int, optional\n        Inserts newlines if text is longer than `max_line_width`.  The\n        default is, indirectly, 75.\n    precision : int, optional\n        Floating point precision.  Default is the current printing precision\n        (usually 8), which can be altered using `set_printoptions`.\n    suppress_small : bool, optional\n        Represent numbers \"very close\" to zero as zero; default is False.\n        Very close is defined by precision: if the precision is 8, e.g.,\n        numbers smaller (in absolute value) than 5e-9 are represented as\n        zero.\n\n    See Also\n    --------\n    array2string, array_repr, set_printoptions\n\n    Examples\n    --------\n    >>> np.array_str(np.arange(3))\n    '[0 1 2]'\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_49array_str = {__Pyx_NAMESTR("array_str"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_49array_str, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_48array_str)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_49array_str(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_max_line_width = 0;
  CYTHON_UNUSED PyObject *__pyx_v_precision = 0;
  CYTHON_UNUSED PyObject *__pyx_v_suppress_small = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("array_str (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__max_line_width,&__pyx_n_s__precision,&__pyx_n_s__suppress_small,0};
    PyObject* values[4] = {0,0,0,0};

    /* "ga4py/gain/notimplemented.pyx":1093
 * 
 * 
 * def array_str(a, max_line_width=None, precision=None, suppress_small=None):             # <<<<<<<<<<<<<<
 *     """Return a string representation of the data in an array.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    values[3] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__max_line_width);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__precision);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__suppress_small);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "array_str") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1093; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_max_line_width = values[1];
    __pyx_v_precision = values[2];
    __pyx_v_suppress_small = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("array_str", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1093; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.array_str", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_48array_str(__pyx_self, __pyx_v_a, __pyx_v_max_line_width, __pyx_v_precision, __pyx_v_suppress_small);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_48array_str(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_max_line_width, CYTHON_UNUSED PyObject *__pyx_v_precision, CYTHON_UNUSED PyObject *__pyx_v_suppress_small) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("array_str", 0);

  /* "ga4py/gain/notimplemented.pyx":1126
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1126; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.array_str", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_51asanyarray(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_50asanyarray[] = "Convert the input to an ndarray, but pass ndarray subclasses through.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data, in any form that can be converted to an array.  This\n        includes scalars, lists, lists of tuples, tuples, tuples of tuples,\n        tuples of lists, and ndarrays.\n    dtype : data-type, optional\n        By default, the data-type is inferred from the input data.\n    order : {'C', 'F'}, optional\n        Whether to use row-major ('C') or column-major ('F') memory\n        representation.  Defaults to 'C'.\n\n    Returns\n    -------\n    out : ndarray or an ndarray subclass\n        Array interpretation of `a`.  If `a` is an ndarray or a subclass\n        of ndarray, it is returned as-is and no copy is performed.\n\n    See Also\n    --------\n    asarray : Similar function which always returns ndarrays.\n    ascontiguousarray : Convert input to a contiguous array.\n    asfarray : Convert input to a floating point ndarray.\n    asfortranarray : Convert input to an ndarray with column-major\n                     memory order.\n    asarray_chkfinite : Similar function which checks input for NaNs and\n                        Infs.\n    fromiter : Create an array from an iterator.\n    fromfunction : Construct an array by executing a function on grid\n                   positions.\n\n    Examples\n    --------\n    Convert a list into an array:\n\n    >>> a = [1, 2]\n    >>> np.asanyarray(a)\n    array([1, 2])\n\n    Instances of `ndarray` subclasses are passed through as-is:\n\n    >>> a = np.matrix([1, 2])\n    >>> np.asanyarray(a) is a\n    True\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_51asanyarray = {__Pyx_NAMESTR("asanyarray"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_51asanyarray, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_50asanyarray)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_51asanyarray(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  CYTHON_UNUSED PyObject *__pyx_v_order = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("asanyarray (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__dtype,&__pyx_n_s__order,0};
    PyObject* values[3] = {0,0,0};

    /* "ga4py/gain/notimplemented.pyx":1129
 * 
 * 
 * def asanyarray(a, dtype=None, order=None):             # <<<<<<<<<<<<<<
 *     """Convert the input to an ndarray, but pass ndarray subclasses through.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__dtype);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__order);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "asanyarray") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1129; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_dtype = values[1];
    __pyx_v_order = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("asanyarray", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1129; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.asanyarray", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_50asanyarray(__pyx_self, __pyx_v_a, __pyx_v_dtype, __pyx_v_order);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_50asanyarray(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_order) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("asanyarray", 0);

  /* "ga4py/gain/notimplemented.pyx":1178
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1178; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.asanyarray", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_53asarray_chkfinite(PyObject *__pyx_self, PyObject *__pyx_v_a); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_52asarray_chkfinite[] = "Convert the input to an array, checking for NaNs or Infs.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data, in any form that can be converted to an array.  This\n        includes lists, lists of tuples, tuples, tuples of tuples, tuples\n        of lists and ndarrays.  Success requires no NaNs or Infs.\n    dtype : data-type, optional\n        By default, the data-type is inferred from the input data.\n    order : {'C', 'F'}, optional\n        Whether to use row-major ('C') or column-major ('FORTRAN') memory\n        representation.  Defaults to 'C'.\n\n    Returns\n    -------\n    out : ndarray\n        Array interpretation of `a`.  No copy is performed if the input\n        is already an ndarray.  If `a` is a subclass of ndarray, a base\n        class ndarray is returned.\n\n    Raises\n    ------\n    ValueError\n        Raises ValueError if `a` contains NaN (Not a Number) or Inf (Infinity).\n\n    See Also\n    --------\n    asarray : Create and array.\n    asanyarray : Similar function which passes through subclasses.\n    ascontiguousarray : Convert input to a contiguous array.\n    asfarray : Convert input to a floating point ndarray.\n    asfortranarray : Convert input to an ndarray with column-major\n                     memory order.\n    fromiter : Create an array from an iterator.\n    fromfunction : Construct an array by executing a function on grid\n                   positions.\n\n    Examples\n    --------\n    Convert a list into an array.  If all elements are finite\n    ``asarray_chkfinite`` is identical to ``asarray``.\n\n    >>> a = [1, 2]\n    >>> np.asarray_chkfinite(a)\n    array([1, 2])\n\n    Raises ValueError if array_like contains Nans or Infs.\n\n    >>> a = [1, 2, np.inf]\n    >>> try:\n    ...     np.asarray_chkfinite(a)\n    ... except ValueError:\n    ...     print 'ValueError'\n    ...\n    ValueError\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_53asarray_chkfinite = {__Pyx_NAMESTR("asarray_chkfinite"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_53asarray_chkfinite, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_52asarray_chkfinite)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_53asarray_chkfinite(PyObject *__pyx_self, PyObject *__pyx_v_a) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("asarray_chkfinite (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_52asarray_chkfinite(__pyx_self, ((PyObject *)__pyx_v_a));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":1181
 * 
 * 
 * def asarray_chkfinite(a):             # <<<<<<<<<<<<<<
 *     """Convert the input to an array, checking for NaNs or Infs.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_52asarray_chkfinite(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("asarray_chkfinite", 0);

  /* "ga4py/gain/notimplemented.pyx":1240
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1240; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.asarray_chkfinite", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_55ascontiguousarray(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_54ascontiguousarray[] = "Return a contiguous array in memory (C order).\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    dtype : str or dtype object, optional\n        Data-type of returned array.\n\n    Returns\n    -------\n    out : ndarray\n        Contiguous array of same shape and content as `a`, with type `dtype`\n        if specified.\n\n    See Also\n    --------\n    asfortranarray : Convert input to an ndarray with column-major\n                     memory order.\n    require : Return an ndarray that satisfies requirements.\n    ndarray.flags : Information about the memory layout of the array.\n\n    Examples\n    --------\n    >>> x = np.arange(6).reshape(2,3)\n    >>> np.ascontiguousarray(x, dtype=np.float32)\n    array([[ 0.,  1.,  2.],\n           [ 3.,  4.,  5.]], dtype=float32)\n    >>> x.flags['C_CONTIGUOUS']\n    True\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_55ascontiguousarray = {__Pyx_NAMESTR("ascontiguousarray"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_55ascontiguousarray, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_54ascontiguousarray)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_55ascontiguousarray(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ascontiguousarray (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__dtype,0};
    PyObject* values[2] = {0,0};

    /* "ga4py/gain/notimplemented.pyx":1243
 * 
 * 
 * def ascontiguousarray(a, dtype=None):             # <<<<<<<<<<<<<<
 *     """Return a contiguous array in memory (C order).
 * 
 */
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__dtype);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "ascontiguousarray") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1243; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_dtype = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("ascontiguousarray", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1243; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.ascontiguousarray", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_54ascontiguousarray(__pyx_self, __pyx_v_a, __pyx_v_dtype);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_54ascontiguousarray(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_dtype) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("ascontiguousarray", 0);

  /* "ga4py/gain/notimplemented.pyx":1276
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1276; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.ascontiguousarray", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_57asfarray(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_56asfarray[] = "Return an array converted to a float type.\n\n    Parameters\n    ----------\n    a : array_like\n        The input array.\n    dtype : str or dtype object, optional\n        Float type code to coerce input array `a`.  If `dtype` is one of the\n        'int' dtypes, it is replaced with float64.\n\n    Returns\n    -------\n    out : ndarray\n        The input `a` as a float ndarray.\n\n    Examples\n    --------\n    >>> np.asfarray([2, 3])\n    array([ 2.,  3.])\n    >>> np.asfarray([2, 3], dtype='float')\n    array([ 2.,  3.])\n    >>> np.asfarray([2, 3], dtype='int8')\n    array([ 2.,  3.])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_57asfarray = {__Pyx_NAMESTR("asfarray"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_57asfarray, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_56asfarray)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_57asfarray(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("asfarray (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__dtype,0};
    PyObject* values[2] = {0,0};
    values[1] = __pyx_k_8;
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__dtype);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "asfarray") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1279; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_dtype = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("asfarray", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1279; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.asfarray", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_56asfarray(__pyx_self, __pyx_v_a, __pyx_v_dtype);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":1279
 * 
 * 
 * def asfarray(a, dtype=np.float64):             # <<<<<<<<<<<<<<
 *     """Return an array converted to a float type.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_56asfarray(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_dtype) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("asfarray", 0);

  /* "ga4py/gain/notimplemented.pyx":1305
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1305; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.asfarray", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_59asfortranarray(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_58asfortranarray[] = "Return an array laid out in Fortran order in memory.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    dtype : str or dtype object, optional\n        By default, the data-type is inferred from the input data.\n\n    Returns\n    -------\n    out : ndarray\n        The input `a` in Fortran, or column-major, order.\n\n    See Also\n    --------\n    ascontiguousarray : Convert input to a contiguous (C order) array.\n    asanyarray : Convert input to an ndarray with either row or\n        column-major memory order.\n    require : Return an ndarray that satisfies requirements.\n    ndarray.flags : Information about the memory layout of the array.\n\n    Examples\n    --------\n    >>> x = np.arange(6).reshape(2,3)\n    >>> y = np.asfortranarray(x)\n    >>> x.flags['F_CONTIGUOUS']\n    False\n    >>> y.flags['F_CONTIGUOUS']\n    True\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_59asfortranarray = {__Pyx_NAMESTR("asfortranarray"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_59asfortranarray, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_58asfortranarray)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_59asfortranarray(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("asfortranarray (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__dtype,0};
    PyObject* values[2] = {0,0};

    /* "ga4py/gain/notimplemented.pyx":1308
 * 
 * 
 * def asfortranarray(a, dtype=None):             # <<<<<<<<<<<<<<
 *     """Return an array laid out in Fortran order in memory.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__dtype);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "asfortranarray") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1308; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_dtype = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("asfortranarray", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1308; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.asfortranarray", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_58asfortranarray(__pyx_self, __pyx_v_a, __pyx_v_dtype);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_58asfortranarray(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_dtype) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("asfortranarray", 0);

  /* "ga4py/gain/notimplemented.pyx":1341
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1341; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.asfortranarray", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_61asmatrix(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_60asmatrix[] = "Interpret the input as a matrix.\n\n    Unlike `matrix`, `asmatrix` does not make a copy if the input is already\n    a matrix or an ndarray.  Equivalent to ``matrix(data, copy=False)``.\n\n    Parameters\n    ----------\n    data : array_like\n        Input data.\n\n    Returns\n    -------\n    mat : matrix\n        `data` interpreted as a matrix.\n\n    Examples\n    --------\n    >>> x = np.array([[1, 2], [3, 4]])\n\n    >>> m = np.asmatrix(x)\n\n    >>> x[0,0] = 5\n\n    >>> m\n    matrix([[5, 2],\n            [3, 4]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_61asmatrix = {__Pyx_NAMESTR("asmatrix"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_61asmatrix, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_60asmatrix)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_61asmatrix(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_data = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("asmatrix (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__data,&__pyx_n_s__dtype,0};
    PyObject* values[2] = {0,0};

    /* "ga4py/gain/notimplemented.pyx":1344
 * 
 * 
 * def asmatrix(data, dtype=None):             # <<<<<<<<<<<<<<
 *     """Interpret the input as a matrix.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__data)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__dtype);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "asmatrix") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1344; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_data = values[0];
    __pyx_v_dtype = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("asmatrix", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1344; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.asmatrix", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_60asmatrix(__pyx_self, __pyx_v_data, __pyx_v_dtype);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_60asmatrix(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_data, CYTHON_UNUSED PyObject *__pyx_v_dtype) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("asmatrix", 0);

  /* "ga4py/gain/notimplemented.pyx":1373
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1373; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.asmatrix", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_63asscalar(PyObject *__pyx_self, PyObject *__pyx_v_a); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_62asscalar[] = "Convert an array of size 1 to its scalar equivalent.\n\n    Parameters\n    ----------\n    a : ndarray\n        Input array of size 1.\n\n    Returns\n    -------\n    out : scalar\n        Scalar representation of `a`. The input data type is preserved.\n\n    Examples\n    --------\n    >>> np.asscalar(np.array([24]))\n    24\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_63asscalar = {__Pyx_NAMESTR("asscalar"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_63asscalar, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_62asscalar)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_63asscalar(PyObject *__pyx_self, PyObject *__pyx_v_a) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("asscalar (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_62asscalar(__pyx_self, ((PyObject *)__pyx_v_a));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":1376
 * 
 * 
 * def asscalar(a):             # <<<<<<<<<<<<<<
 *     """Convert an array of size 1 to its scalar equivalent.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_62asscalar(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("asscalar", 0);

  /* "ga4py/gain/notimplemented.pyx":1395
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1395; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.asscalar", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_65atleast_1d(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_64atleast_1d[] = "Convert inputs to arrays with at least one dimension.\n\n    Scalar inputs are converted to 1-dimensional arrays, whilst\n    higher-dimensional inputs are preserved.\n\n    Parameters\n    ----------\n    array1, array2, ... : array_like\n        One or more input arrays.\n\n    Returns\n    -------\n    ret : ndarray\n        An array, or sequence of arrays, each with ``a.ndim >= 1``.\n        Copies are made only if necessary.\n\n    See Also\n    --------\n    atleast_2d, atleast_3d\n\n    Examples\n    --------\n    >>> np.atleast_1d(1.0)\n    array([ 1.])\n\n    >>> x = np.arange(9.0).reshape(3,3)\n    >>> np.atleast_1d(x)\n    array([[ 0.,  1.,  2.],\n           [ 3.,  4.,  5.],\n           [ 6.,  7.,  8.]])\n    >>> np.atleast_1d(x) is x\n    True\n\n    >>> np.atleast_1d(1, [3, 4])\n    [array([1]), array([3, 4])]\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_65atleast_1d = {__Pyx_NAMESTR("atleast_1d"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_65atleast_1d, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_64atleast_1d)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_65atleast_1d(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("atleast_1d (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_64atleast_1d(__pyx_self);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":1398
 * 
 * 
 * def atleast_1d():             # <<<<<<<<<<<<<<
 *     """Convert inputs to arrays with at least one dimension.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_64atleast_1d(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("atleast_1d", 0);

  /* "ga4py/gain/notimplemented.pyx":1436
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1436; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.atleast_1d", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_67atleast_2d(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_66atleast_2d[] = "View inputs as arrays with at least two dimensions.\n\n    Parameters\n    ----------\n    array1, array2, ... : array_like\n        One or more array-like sequences.  Non-array inputs are converted\n        to arrays.  Arrays that already have two or more dimensions are\n        preserved.\n\n    Returns\n    -------\n    res, res2, ... : ndarray\n        An array, or tuple of arrays, each with ``a.ndim >= 2``.\n        Copies are avoided where possible, and views with two or more\n        dimensions are returned.\n\n    See Also\n    --------\n    atleast_1d, atleast_3d\n\n    Examples\n    --------\n    >>> np.atleast_2d(3.0)\n    array([[ 3.]])\n\n    >>> x = np.arange(3.0)\n    >>> np.atleast_2d(x)\n    array([[ 0.,  1.,  2.]])\n    >>> np.atleast_2d(x).base is x\n    True\n\n    >>> np.atleast_2d(1, [1, 2], [[1, 2]])\n    [array([[1]]), array([[1, 2]]), array([[1, 2]])]\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_67atleast_2d = {__Pyx_NAMESTR("atleast_2d"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_67atleast_2d, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_66atleast_2d)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_67atleast_2d(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("atleast_2d (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_66atleast_2d(__pyx_self);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":1439
 * 
 * 
 * def atleast_2d():             # <<<<<<<<<<<<<<
 *     """View inputs as arrays with at least two dimensions.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_66atleast_2d(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("atleast_2d", 0);

  /* "ga4py/gain/notimplemented.pyx":1475
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1475; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.atleast_2d", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_69atleast_3d(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_68atleast_3d[] = "View inputs as arrays with at least three dimensions.\n\n    Parameters\n    ----------\n    array1, array2, ... : array_like\n        One or more array-like sequences.  Non-array inputs are converted to\n        arrays.  Arrays that already have three or more dimensions are\n        preserved.\n\n    Returns\n    -------\n    res1, res2, ... : ndarray\n        An array, or tuple of arrays, each with ``a.ndim >= 3``.  Copies are\n        avoided where possible, and views with three or more dimensions are\n        returned.  For example, a 1-D array of shape ``(N,)`` becomes a view\n        of shape ``(1, N, 1)``, and a 2-D array of shape ``(M, N)`` becomes a\n        view of shape ``(M, N, 1)``.\n\n    See Also\n    --------\n    atleast_1d, atleast_2d\n\n    Examples\n    --------\n    >>> np.atleast_3d(3.0)\n    array([[[ 3.]]])\n\n    >>> x = np.arange(3.0)\n    >>> np.atleast_3d(x).shape\n    (1, 3, 1)\n\n    >>> x = np.arange(12.0).reshape(4,3)\n    >>> np.atleast_3d(x).shape\n    (4, 3, 1)\n    >>> np.atleast_3d(x).base is x\n    True\n\n    >>> for arr in np.atleast_3d([1, 2], [[1, 2]], [[[1, 2]]]):\n    ...     print arr, arr.shape\n    ...\n    [[[1]\n      [2]]] (1, 2, 1)\n    [[[1]\n      [2]]] (1, 2, 1)\n    [[[1 2]]] (1, 1, 2)\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_69atleast_3d = {__Pyx_NAMESTR("atleast_3d"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_69atleast_3d, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_68atleast_3d)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_69atleast_3d(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("atleast_3d (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_68atleast_3d(__pyx_self);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":1478
 * 
 * 
 * def atleast_3d():             # <<<<<<<<<<<<<<
 *     """View inputs as arrays with at least three dimensions.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_68atleast_3d(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("atleast_3d", 0);

  /* "ga4py/gain/notimplemented.pyx":1526
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1526; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.atleast_3d", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_71average(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_70average[] = "Compute the weighted average along the specified axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Array containing data to be averaged. If `a` is not an array, a\n        conversion is attempted.\n    axis : int, optional\n        Axis along which to average `a`. If `None`, averaging is done over\n        the flattened array.\n    weights : array_like, optional\n        An array of weights associated with the values in `a`. Each value in\n        `a` contributes to the average according to its associated weight.\n        The weights array can either be 1-D (in which case its length must be\n        the size of `a` along the given axis) or of the same shape as `a`.\n        If `weights=None`, then all data in `a` are assumed to have a\n        weight equal to one.\n    returned : bool, optional\n        Default is `False`. If `True`, the tuple (`average`, `sum_of_weights`)\n        is returned, otherwise only the average is returned.\n        If `weights=None`, `sum_of_weights` is equivalent to the number of\n        elements over which the average is taken.\n\n\n    Returns\n    -------\n    average, [sum_of_weights] : {array_type, double}\n        Return the average along the specified axis. When returned is `True`,\n        return a tuple with the average as the first element and the sum\n        of the weights as the second element. The return type is `Float`\n        if `a` is of integer type, otherwise it is of the same type as `a`.\n        `sum_of_weights` is of the same type as `average`.\n\n    Raises\n    ------\n    ZeroDivisionError\n        When all weights along axis are zero. See `numpy.ma.average` for a\n        version robust to this type of error.\n    TypeError\n        When the length of 1D `weights` is not the same as the shape of `a`\n        along axis.\n\n    See Also\n    --------\n    mean\n\n    ma.average : average for masked arrays\n\n    Examples\n    --------\n    >>> data = range(1,5)\n    >>> data\n    [1, 2, 3, 4""]\n    >>> np.average(data)\n    2.5\n    >>> np.average(range(1,11), weights=range(10,0,-1))\n    4.0\n\n    >>> data = np.arange(6).reshape((3,2))\n    >>> data\n    array([[0, 1],\n           [2, 3],\n           [4, 5]])\n    >>> np.average(data, axis=1, weights=[1./4, 3./4])\n    array([ 0.75,  2.75,  4.75])\n    >>> np.average(data, weights=[1./4, 3./4])\n    Traceback (most recent call last):\n    ...\n    TypeError: Axis must be specified when shapes of a and weights differ.\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_71average = {__Pyx_NAMESTR("average"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_71average, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_70average)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_71average(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_weights = 0;
  CYTHON_UNUSED PyObject *__pyx_v_returned = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("average (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__axis,&__pyx_n_s__weights,&__pyx_n_s__returned,0};
    PyObject* values[4] = {0,0,0,0};

    /* "ga4py/gain/notimplemented.pyx":1529
 * 
 * 
 * def average(a, axis=None, weights=None, returned=False):             # <<<<<<<<<<<<<<
 *     """Compute the weighted average along the specified axis.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    values[3] = __pyx_k_9;
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__weights);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__returned);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "average") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1529; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
    __pyx_v_weights = values[2];
    __pyx_v_returned = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("average", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1529; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.average", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_70average(__pyx_self, __pyx_v_a, __pyx_v_axis, __pyx_v_weights, __pyx_v_returned);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_70average(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_weights, CYTHON_UNUSED PyObject *__pyx_v_returned) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("average", 0);

  /* "ga4py/gain/notimplemented.pyx":1601
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1601; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.average", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_73bartlett(PyObject *__pyx_self, PyObject *__pyx_v_M); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_72bartlett[] = "Return the Bartlett window.\n\n    The Bartlett window is very similar to a triangular window, except\n    that the end points are at zero.  It is often used in signal\n    processing for tapering a signal, without generating too much\n    ripple in the frequency domain.\n\n    Parameters\n    ----------\n    M : int\n        Number of points in the output window. If zero or less, an\n        empty array is returned.\n\n    Returns\n    -------\n    out : array\n        The triangular window, normalized to one (the value one\n        appears only if the number of samples is odd), with the first\n        and last samples equal to zero.\n\n    See Also\n    --------\n    blackman, hamming, hanning, kaiser\n\n    Notes\n    -----\n    The Bartlett window is defined as\n\n    .. math:: w(n) = \014rac{2}{M-1} \\left(\n              \014rac{M-1}{2} - \\left|n - \014rac{M-1}{2}\right|\n              \right)\n\n    Most references to the Bartlett window come from the signal\n    processing literature, where it is used as one of many windowing\n    functions for smoothing values.  Note that convolution with this\n    window produces linear interpolation.  It is also known as an\n    apodization (which means\"removing the foot\", i.e. smoothing\n    discontinuities at the beginning and end of the sampled signal) or\n    tapering function. The fourier transform of the Bartlett is the product\n    of two sinc functions.\n    Note the excellent discussion in Kanasewich.\n\n    References\n    ----------\n    .. [1] M.S. Bartlett, \"Periodogram Analysis and Continuous Spectra\",\n           Biometrika 37, 1-16, 1950.\n    .. [2] E.R. Kanasewich, \"Time Sequence Analysis in Geophysics\",\n           The University of Alberta Press, 1975, pp. 109-110.\n    .. [3] A.V. Oppenheim and R.W. Schafer, \"Discrete-Time Signal\n           Processing\", Prentice-Hall, 1999, pp. 468-471.\n    .. [4] Wikipedia, \"Window function\",\n           http://en.wikipedia.org/wiki/Window_function\n    "".. [5] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,\n           \"Numerical Recipes\", Cambridge University Press, 1986, page 429.\n\n\n    Examples\n    --------\n    >>> np.bartlett(12)\n    array([ 0.        ,  0.18181818,  0.36363636,  0.54545455,  0.72727273,\n            0.90909091,  0.90909091,  0.72727273,  0.54545455,  0.36363636,\n            0.18181818,  0.        ])\n\n    Plot the window and its frequency response (requires SciPy and matplotlib):\n\n    >>> from numpy import clip, log10, array, bartlett, linspace\n    >>> from numpy.fft import fft, fftshift\n    >>> import matplotlib.pyplot as plt\n\n    >>> window = bartlett(51)\n    >>> plt.plot(window)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Bartlett window\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.ylabel(\"Amplitude\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.xlabel(\"Sample\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.show()\n\n    >>> plt.figure()\n    <matplotlib.figure.Figure object at 0x...>\n    >>> A = fft(window, 2048) / 25.5\n    >>> mag = abs(fftshift(A))\n    >>> freq = linspace(-0.5,0.5,len(A))\n    >>> response = 20*log10(mag)\n    >>> response = clip(response,-100,100)\n    >>> plt.plot(freq, response)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Frequency response of Bartlett window\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.ylabel(\"Magnitude [dB]\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.xlabel(\"Normalized frequency [cycles per sample]\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.axis('tight')\n    (-0.5, 0.5, -100.0, ...)\n    >>> plt.show()\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_73bartlett = {__Pyx_NAMESTR("bartlett"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_73bartlett, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_72bartlett)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_73bartlett(PyObject *__pyx_self, PyObject *__pyx_v_M) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("bartlett (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_72bartlett(__pyx_self, ((PyObject *)__pyx_v_M));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":1604
 * 
 * 
 * def bartlett(M):             # <<<<<<<<<<<<<<
 *     """Return the Bartlett window.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_72bartlett(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_M) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("bartlett", 0);

  /* "ga4py/gain/notimplemented.pyx":1705
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1705; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.bartlett", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_75base_repr(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_74base_repr[] = "Return a string representation of a number in the given base system.\n\n    Parameters\n    ----------\n    number : int\n        The value to convert. Only positive values are handled.\n    base : int, optional\n        Convert `number` to the `base` number system. The valid range is 2-36,\n        the default value is 2.\n    padding : int, optional\n        Number of zeros padded on the left. Default is 0 (no padding).\n\n    Returns\n    -------\n    out : str\n        String representation of `number` in `base` system.\n\n    See Also\n    --------\n    binary_repr : Faster version of `base_repr` for base 2.\n\n    Examples\n    --------\n    >>> np.base_repr(5)\n    '101'\n    >>> np.base_repr(6, 5)\n    '11'\n    >>> np.base_repr(7, base=5, padding=3)\n    '00012'\n\n    >>> np.base_repr(10, base=16)\n    'A'\n    >>> np.base_repr(32, base=16)\n    '20'\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_75base_repr = {__Pyx_NAMESTR("base_repr"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_75base_repr, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_74base_repr)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_75base_repr(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_number = 0;
  CYTHON_UNUSED PyObject *__pyx_v_base = 0;
  CYTHON_UNUSED PyObject *__pyx_v_padding = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("base_repr (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__number,&__pyx_n_s__base,&__pyx_n_s__padding,0};
    PyObject* values[3] = {0,0,0};
    values[1] = ((PyObject *)__pyx_int_2);
    values[2] = ((PyObject *)__pyx_int_0);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__number)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__base);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__padding);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "base_repr") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1708; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_number = values[0];
    __pyx_v_base = values[1];
    __pyx_v_padding = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("base_repr", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1708; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.base_repr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_74base_repr(__pyx_self, __pyx_v_number, __pyx_v_base, __pyx_v_padding);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":1708
 * 
 * 
 * def base_repr(number, base=2, padding=0):             # <<<<<<<<<<<<<<
 *     """Return a string representation of a number in the given base system.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_74base_repr(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_number, CYTHON_UNUSED PyObject *__pyx_v_base, CYTHON_UNUSED PyObject *__pyx_v_padding) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("base_repr", 0);

  /* "ga4py/gain/notimplemented.pyx":1745
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1745; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.base_repr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_77binary_repr(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_76binary_repr[] = "Return the binary representation of the input number as a string.\n\n    For negative numbers, if width is not given, a minus sign is added to the\n    front. If width is given, the two's complement of the number is\n    returned, with respect to that width.\n\n    In a two's-complement system negative numbers are represented by the two's\n    complement of the absolute value. This is the most common method of\n    representing signed integers on computers [1]_. A N-bit two's-complement\n    system can represent every integer in the range\n    :math:`-2^{N-1}` to :math:`+2^{N-1}-1`.\n\n    Parameters\n    ----------\n    num : int\n        Only an integer decimal number can be used.\n    width : int, optional\n        The length of the returned string if `num` is positive, the length of\n        the two's complement if `num` is negative.\n\n    Returns\n    -------\n    bin : str\n        Binary representation of `num` or two's complement of `num`.\n\n    See Also\n    --------\n    base_repr: Return a string representation of a number in the given base\n               system.\n\n    Notes\n    -----\n    `binary_repr` is equivalent to using `base_repr` with base 2, but about 25x\n    faster.\n\n    References\n    ----------\n    .. [1] Wikipedia, \"Two's complement\",\n        http://en.wikipedia.org/wiki/Two's_complement\n\n    Examples\n    --------\n    >>> np.binary_repr(3)\n    '11'\n    >>> np.binary_repr(-3)\n    '-11'\n    >>> np.binary_repr(3, width=4)\n    '0011'\n\n    The two's complement is returned when the input number is negative and\n    width is specified:\n\n    >>> np.binary_repr(-3, width=4)\n    '1101'\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_77binary_repr = {__Pyx_NAMESTR("binary_repr"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_77binary_repr, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_76binary_repr)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_77binary_repr(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_num = 0;
  CYTHON_UNUSED PyObject *__pyx_v_width = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("binary_repr (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__num,&__pyx_n_s__width,0};
    PyObject* values[2] = {0,0};

    /* "ga4py/gain/notimplemented.pyx":1748
 * 
 * 
 * def binary_repr(num, width=None):             # <<<<<<<<<<<<<<
 *     """Return the binary representation of the input number as a string.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__num)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__width);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "binary_repr") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1748; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_num = values[0];
    __pyx_v_width = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("binary_repr", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1748; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.binary_repr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_76binary_repr(__pyx_self, __pyx_v_num, __pyx_v_width);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_76binary_repr(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_num, CYTHON_UNUSED PyObject *__pyx_v_width) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("binary_repr", 0);

  /* "ga4py/gain/notimplemented.pyx":1805
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1805; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.binary_repr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_79bincount(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_78bincount[] = "bincount(x, weights=None, minlength=None)\n\n    Count number of occurrences of each value in array of non-negative ints.\n\n    The number of bins (of size 1) is one larger than the largest value in\n    `x`. If `minlength` is specified, there will be at least this number\n    of bins in the output array (though it will be longer if necessary,\n    depending on the contents of `x`).\n    Each bin gives the number of occurrences of its index value in `x`.\n    If `weights` is specified the input array is weighted by it, i.e. if a\n    value ``n`` is found at position ``i``, ``out[n] += weight[i]`` instead\n    of ``out[n] += 1``.\n\n    Parameters\n    ----------\n    x : array_like, 1 dimension, nonnegative ints\n        Input array.\n    weights : array_like, optional\n        Weights, array of the same shape as `x`.\n    minlength : int, optional\n        .. versionadded:: 1.6.0\n\n        A minimum number of bins for the output array.\n\n    Returns\n    -------\n    out : ndarray of ints\n        The result of binning the input array.\n        The length of `out` is equal to ``np.amax(x)+1``.\n\n    Raises\n    ------\n    ValueError\n        If the input is not 1-dimensional, or contains elements with negative\n        values, or if `minlength` is non-positive.\n    TypeError\n        If the type of the input is float or complex.\n\n    See Also\n    --------\n    histogram, digitize, unique\n\n    Examples\n    --------\n    >>> np.bincount(np.arange(5))\n    array([1, 1, 1, 1, 1])\n    >>> np.bincount(np.array([0, 1, 1, 3, 2, 1, 7]))\n    array([1, 3, 1, 1, 0, 0, 0, 1])\n\n    >>> x = np.array([0, 1, 1, 3, 2, 1, 7, 23])\n    >>> np.bincount(x).size == np.amax(x)+1\n    True\n\n    The input array needs to be of integer dtype, otherwise a\n    TypeError is raised:\n\n    >>> np.bincount(np.arange(5, dtype=np.float))\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    TypeError: array cannot be safely cast to required type""\n\n    A possible use of ``bincount`` is to perform sums over\n    variable-size chunks of an array, using the ``weights`` keyword.\n\n    >>> w = np.array([0.3, 0.5, 0.2, 0.7, 1., -0.6]) # weights\n    >>> x = np.array([0, 1, 1, 2, 2, 2])\n    >>> np.bincount(x,  weights=w)\n    array([ 0.3,  0.7,  1.1])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_79bincount = {__Pyx_NAMESTR("bincount"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_79bincount, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_78bincount)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_79bincount(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_x = 0;
  CYTHON_UNUSED PyObject *__pyx_v_weights = 0;
  CYTHON_UNUSED PyObject *__pyx_v_minlength = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("bincount (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__x,&__pyx_n_s__weights,&__pyx_n_s__minlength,0};
    PyObject* values[3] = {0,0,0};

    /* "ga4py/gain/notimplemented.pyx":1808
 * 
 * 
 * def bincount(x, weights=None, minlength=None):             # <<<<<<<<<<<<<<
 *     """bincount(x, weights=None, minlength=None)
 * 
 */
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__x)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__weights);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__minlength);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "bincount") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1808; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_x = values[0];
    __pyx_v_weights = values[1];
    __pyx_v_minlength = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("bincount", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1808; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.bincount", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_78bincount(__pyx_self, __pyx_v_x, __pyx_v_weights, __pyx_v_minlength);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_78bincount(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_weights, CYTHON_UNUSED PyObject *__pyx_v_minlength) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("bincount", 0);

  /* "ga4py/gain/notimplemented.pyx":1880
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1880; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.bincount", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_81blackman(PyObject *__pyx_self, PyObject *__pyx_v_M); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_80blackman[] = "Return the Blackman window.\n\n    The Blackman window is a taper formed by using the the first three\n    terms of a summation of cosines. It was designed to have close to the\n    minimal leakage possible.  It is close to optimal, only slightly worse\n    than a Kaiser window.\n\n    Parameters\n    ----------\n    M : int\n        Number of points in the output window. If zero or less, an empty\n        array is returned.\n\n    Returns\n    -------\n    out : ndarray\n        The window, normalized to one (the value one appears only if the\n        number of samples is odd).\n\n    See Also\n    --------\n    bartlett, hamming, hanning, kaiser\n\n    Notes\n    -----\n    The Blackman window is defined as\n\n    .. math::  w(n) = 0.42 - 0.5 \\cos(2\\pi n/M) + 0.08 \\cos(4\\pi n/M)\n\n    Most references to the Blackman window come from the signal processing\n    literature, where it is used as one of many windowing functions for\n    smoothing values.  It is also known as an apodization (which means\n    \"removing the foot\", i.e. smoothing discontinuities at the beginning\n    and end of the sampled signal) or tapering function. It is known as a\n    \"near optimal\" tapering function, almost as good (by some measures)\n    as the kaiser window.\n\n    References\n    ----------\n    Blackman, R.B. and Tukey, J.W., (1958) The measurement of power spectra,\n    Dover Publications, New York.\n\n    Oppenheim, A.V., and R.W. Schafer. Discrete-Time Signal Processing.\n    Upper Saddle River, NJ: Prentice-Hall, 1999, pp. 468-471.\n\n    Examples\n    --------\n    >>> from numpy import blackman\n    >>> blackman(12)\n    array([ -1.38777878e-17,   3.26064346e-02,   1.59903635e-01,\n             4.14397981e-01,   7.36045180e-01,   9.67046769e-01,\n             9.67046769e-01,   7.36045180e-01,   4.14397981e-01,\n             1.59903635e-01,   3.26064346e-02,  -1.38777878e-17])\n\n\n    Plot the window and the frequency response:\n\n    >>> from numpy import clip, lo""g10, array, blackman, linspace\n    >>> from numpy.fft import fft, fftshift\n    >>> import matplotlib.pyplot as plt\n\n    >>> window = blackman(51)\n    >>> plt.plot(window)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Blackman window\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.ylabel(\"Amplitude\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.xlabel(\"Sample\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.show()\n\n    >>> plt.figure()\n    <matplotlib.figure.Figure object at 0x...>\n    >>> A = fft(window, 2048) / 25.5\n    >>> mag = abs(fftshift(A))\n    >>> freq = linspace(-0.5,0.5,len(A))\n    >>> response = 20*log10(mag)\n    >>> response = clip(response,-100,100)\n    >>> plt.plot(freq, response)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Frequency response of Blackman window\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.ylabel(\"Magnitude [dB]\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.xlabel(\"Normalized frequency [cycles per sample]\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.axis('tight')\n    (-0.5, 0.5, -100.0, ...)\n    >>> plt.show()\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_81blackman = {__Pyx_NAMESTR("blackman"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_81blackman, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_80blackman)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_81blackman(PyObject *__pyx_self, PyObject *__pyx_v_M) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("blackman (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_80blackman(__pyx_self, ((PyObject *)__pyx_v_M));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":1883
 * 
 * 
 * def blackman(M):             # <<<<<<<<<<<<<<
 *     """Return the Blackman window.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_80blackman(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_M) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("blackman", 0);

  /* "ga4py/gain/notimplemented.pyx":1976
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1976; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.blackman", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_83bmat(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_82bmat[] = "Build a matrix object from a string, nested sequence, or array.\n\n    Parameters\n    ----------\n    obj : str or array_like\n        Input data.  Names of variables in the current scope may be\n        referenced, even if `obj` is a string.\n\n    Returns\n    -------\n    out : matrix\n        Returns a matrix object, which is a specialized 2-D array.\n\n    See Also\n    --------\n    matrix\n\n    Examples\n    --------\n    >>> A = np.mat('1 1; 1 1')\n    >>> B = np.mat('2 2; 2 2')\n    >>> C = np.mat('3 4; 5 6')\n    >>> D = np.mat('7 8; 9 0')\n\n    All the following expressions construct the same block matrix:\n\n    >>> np.bmat([[A, B], [C, D]])\n    matrix([[1, 1, 2, 2],\n            [1, 1, 2, 2],\n            [3, 4, 7, 8],\n            [5, 6, 9, 0]])\n    >>> np.bmat(np.r_[np.c_[A, B], np.c_[C, D]])\n    matrix([[1, 1, 2, 2],\n            [1, 1, 2, 2],\n            [3, 4, 7, 8],\n            [5, 6, 9, 0]])\n    >>> np.bmat('A,B; C,D')\n    matrix([[1, 1, 2, 2],\n            [1, 1, 2, 2],\n            [3, 4, 7, 8],\n            [5, 6, 9, 0]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_83bmat = {__Pyx_NAMESTR("bmat"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_83bmat, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_82bmat)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_83bmat(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_obj = 0;
  CYTHON_UNUSED PyObject *__pyx_v_ldict = 0;
  CYTHON_UNUSED PyObject *__pyx_v_gdict = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("bmat (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__obj,&__pyx_n_s__ldict,&__pyx_n_s__gdict,0};
    PyObject* values[3] = {0,0,0};

    /* "ga4py/gain/notimplemented.pyx":1979
 * 
 * 
 * def bmat(obj, ldict=None, gdict=None):             # <<<<<<<<<<<<<<
 *     """Build a matrix object from a string, nested sequence, or array.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__obj)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__ldict);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__gdict);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "bmat") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1979; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_obj = values[0];
    __pyx_v_ldict = values[1];
    __pyx_v_gdict = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("bmat", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1979; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.bmat", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_82bmat(__pyx_self, __pyx_v_obj, __pyx_v_ldict, __pyx_v_gdict);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_82bmat(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_obj, CYTHON_UNUSED PyObject *__pyx_v_ldict, CYTHON_UNUSED PyObject *__pyx_v_gdict) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("bmat", 0);

  /* "ga4py/gain/notimplemented.pyx":2023
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2023; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.bmat", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_85broadcast_arrays(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_84broadcast_arrays[] = "Broadcast any number of arrays against each other.\n\n    Parameters\n    ----------\n    `*args` : array_likes\n        The arrays to broadcast.\n\n    Returns\n    -------\n    broadcasted : list of arrays\n        These arrays are views on the original arrays.  They are typically\n        not contiguous.  Furthermore, more than one element of a\n        broadcasted array may refer to a single memory location.  If you\n        need to write to the arrays, make copies first.\n\n    Examples\n    --------\n    >>> x = np.array([[1,2,3]])\n    >>> y = np.array([[1],[2],[3]])\n    >>> np.broadcast_arrays(x, y)\n    [array([[1, 2, 3],\n           [1, 2, 3],\n           [1, 2, 3]]), array([[1, 1, 1],\n           [2, 2, 2],\n           [3, 3, 3]])]\n\n    Here is a useful idiom for getting contiguous copies instead of\n    non-contiguous views.\n\n    >>> map(np.array, np.broadcast_arrays(x, y))\n    [array([[1, 2, 3],\n           [1, 2, 3],\n           [1, 2, 3]]), array([[1, 1, 1],\n           [2, 2, 2],\n           [3, 3, 3]])]\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_85broadcast_arrays = {__Pyx_NAMESTR("broadcast_arrays"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_85broadcast_arrays, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_84broadcast_arrays)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_85broadcast_arrays(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("broadcast_arrays (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_84broadcast_arrays(__pyx_self);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":2026
 * 
 * 
 * def broadcast_arrays():             # <<<<<<<<<<<<<<
 *     """Broadcast any number of arrays against each other.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_84broadcast_arrays(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("broadcast_arrays", 0);

  /* "ga4py/gain/notimplemented.pyx":2064
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2064; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.broadcast_arrays", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_87byte_bounds(PyObject *__pyx_self, PyObject *__pyx_v_a); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_86byte_bounds[] = "Returns pointers to the end-points of an array.\n\n    Parameters\n    ----------\n    a : ndarray\n        Input array. It must conform to the Python-side of the array interface.\n\n    Returns\n    -------\n    (low, high) : tuple of 2 integers\n        The first integer is the first byte of the array, the second integer is\n        just past the last byte of the array.  If `a` is not contiguous it\n        will not use every byte between the (`low`, `high`) values.\n\n    Examples\n    --------\n    >>> I = np.eye(2, dtype='f'); I.dtype\n    dtype('float32')\n    >>> low, high = np.byte_bounds(I)\n    >>> high - low == I.size*I.itemsize\n    True\n    >>> I = np.eye(2, dtype='G'); I.dtype\n    dtype('complex192')\n    >>> low, high = np.byte_bounds(I)\n    >>> high - low == I.size*I.itemsize\n    True\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_87byte_bounds = {__Pyx_NAMESTR("byte_bounds"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_87byte_bounds, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_86byte_bounds)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_87byte_bounds(PyObject *__pyx_self, PyObject *__pyx_v_a) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("byte_bounds (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_86byte_bounds(__pyx_self, ((PyObject *)__pyx_v_a));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":2067
 * 
 * 
 * def byte_bounds(a):             # <<<<<<<<<<<<<<
 *     """Returns pointers to the end-points of an array.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_86byte_bounds(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("byte_bounds", 0);

  /* "ga4py/gain/notimplemented.pyx":2096
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2096; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.byte_bounds", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_89can_cast(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_88can_cast[] = "can_cast(from, totype, casting = 'safe')\n\n    Returns True if cast between data types can occur according to the\n    casting rule.  If from is a scalar or array scalar, also returns\n    True if the scalar value can be cast without overflow or truncation\n    to an integer.\n\n    Parameters\n    ----------\n    from : dtype, dtype specifier, scalar, or array\n        Data type, scalar, or array to cast from.\n    totype : dtype or dtype specifier\n        Data type to cast to.\n    casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional\n        Controls what kind of data casting may occur.\n\n          * 'no' means the data types should not be cast at all.\n          * 'equiv' means only byte-order changes are allowed.\n          * 'safe' means only casts which can preserve values are allowed.\n          * 'same_kind' means only safe casts or casts within a kind,\n            like float64 to float32, are allowed.\n          * 'unsafe' means any data conversions may be done.\n\n    Returns\n    -------\n    out : bool\n        True if cast can occur according to the casting rule.\n\n    See also\n    --------\n    dtype, result_type\n\n    Examples\n    --------\n\n    Basic examples\n\n    >>> np.can_cast(np.int32, np.int64)\n    True\n    >>> np.can_cast(np.float64, np.complex)\n    True\n    >>> np.can_cast(np.complex, np.float)\n    False\n\n    >>> np.can_cast('i8', 'f8')\n    True\n    >>> np.can_cast('i8', 'f4')\n    False\n    >>> np.can_cast('i4', 'S4')\n    True\n\n    Casting scalars\n\n    >>> np.can_cast(100, 'i1')\n    True\n    >>> np.can_cast(150, 'i1')\n    False\n    >>> np.can_cast(150, 'u1')\n    True\n\n    >>> np.can_cast(3.5e100, np.float32)\n    False\n    >>> np.can_cast(1000.0, np.float32)\n    True\n\n    Array scalar checks the value, array does not\n\n    >>> np.can_cast(np.array(1000.0), np.float32)\n    True\n    >>> np.can_cast(np.array([1000.0]), np.float32)\n    False\n\n    Using the casting rules\n\n    >>> np.can_c""ast('i8', 'i8', 'no')\n    True\n    >>> np.can_cast('<i8', '>i8', 'no')\n    False\n\n    >>> np.can_cast('<i8', '>i8', 'equiv')\n    True\n    >>> np.can_cast('<i4', '>i8', 'equiv')\n    False\n\n    >>> np.can_cast('<i4', '>i8', 'safe')\n    True\n    >>> np.can_cast('<i8', '>i4', 'safe')\n    False\n\n    >>> np.can_cast('<i8', '>i4', 'same_kind')\n    True\n    >>> np.can_cast('<i8', '>u4', 'same_kind')\n    False\n\n    >>> np.can_cast('<i8', '>u4', 'unsafe')\n    True\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_89can_cast = {__Pyx_NAMESTR("can_cast"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_89can_cast, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_88can_cast)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_89can_cast(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("can_cast (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_88can_cast(__pyx_self);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":2099
 * 
 * 
 * def can_cast():             # <<<<<<<<<<<<<<
 *     """can_cast(from, totype, casting = 'safe')
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_88can_cast(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("can_cast", 0);

  /* "ga4py/gain/notimplemented.pyx":2199
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2199; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.can_cast", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_91choose(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_90choose[] = "Construct an array from an index array and a set of arrays to choose from.\n\n    First of all, if confused or uncertain, definitely look at the Examples -\n    in its full generality, this function is less simple than it might\n    seem from the following code description (below ndi =\n    `numpy.lib.index_tricks`):\n\n    ``np.choose(a,c) == np.array([c[a[I]][I] for I in ndi.ndindex(a.shape)])``.\n\n    But this omits some subtleties.  Here is a fully general summary:\n\n    Given an \"index\" array (`a`) of integers and a sequence of `n` arrays\n    (`choices`), `a` and each choice array are first broadcast, as necessary,\n    to arrays of a common shape; calling these *Ba* and *Bchoices[i], i =\n    0,...,n-1* we have that, necessarily, ``Ba.shape == Bchoices[i].shape``\n    for each `i`.  Then, a new array with shape ``Ba.shape`` is created as\n    follows:\n\n    * if ``mode=raise`` (the default), then, first of all, each element of\n      `a` (and thus `Ba`) must be in the range `[0, n-1]`; now, suppose that\n      `i` (in that range) is the value at the `(j0, j1, ..., jm)` position\n      in `Ba` - then the value at the same position in the new array is the\n      value in `Bchoices[i]` at that same position;\n\n    * if ``mode=wrap``, values in `a` (and thus `Ba`) may be any (signed)\n      integer; modular arithmetic is used to map integers outside the range\n      `[0, n-1]` back into that range; and then the new array is constructed\n      as above;\n\n    * if ``mode=clip``, values in `a` (and thus `Ba`) may be any (signed)\n      integer; negative integers are mapped to 0; values greater than `n-1`\n      are mapped to `n-1`; and then the new array is constructed as above.\n\n    Parameters\n    ----------\n    a : int array\n        This array must contain integers in `[0, n-1]`, where `n` is the number\n        of choices, unless ``mode=wrap`` or ``mode=clip``, in which cases any\n        integers are permissible.\n    choices : sequence of arrays""\n        Choice arrays. `a` and all of the choices must be broadcastable to the\n        same shape.  If `choices` is itself an array (not recommended), then\n        its outermost dimension (i.e., the one corresponding to\n        ``choices.shape[0]``) is taken as defining the \"sequence\".\n    out : array, optional\n        If provided, the result will be inserted into this array. It should\n        be of the appropriate shape and dtype.\n    mode : {'raise' (default), 'wrap', 'clip'}, optional\n        Specifies how indices outside `[0, n-1]` will be treated:\n\n          * 'raise' : an exception is raised\n          * 'wrap' : value becomes value mod `n`\n          * 'clip' : values < 0 are mapped to 0, values > n-1 are mapped to n-1\n\n    Returns\n    -------\n    merged_array : array\n        The merged result.\n\n    Raises\n    ------\n    ValueError: shape mismatch\n        If `a` and each choice array are not all broadcastable to the same\n        shape.\n\n    See Also\n    --------\n    ndarray.choose : equivalent method\n\n    Notes\n    -----\n    To reduce the chance of misinterpretation, even though the following\n    \"abuse\" is nominally supported, `choices` should neither be, nor be\n    thought of as, a single array, i.e., the outermost sequence-like container\n    should be either a list or a tuple.\n\n    Examples\n    --------\n\n    >>> choices = [[0, 1, 2, 3], [10, 11, 12, 13],\n    ...   [20, 21, 22, 23], [30, 31, 32, 33]]\n    >>> np.choose([2, 3, 1, 0], choices\n    ... # the first element of the result will be the first element of the\n    ... # third (2+1) \"array\" in choices, namely, 20; the second element\n    ... # will be the second element of the fourth (3+1) choice array, i.e.,\n    ... # 31, etc.\n    ... )\n    array([20, 31, 12,  3])\n    >>> np.choose([2, 4, 1, 0], choices, mode='clip') # 4 goes to 3 (4-1)\n    array([20, 31, 12,  3])\n    >>> # because there are 4 choice arrays\n    >>> np.choose([2, 4, 1, 0], choices, m""ode='wrap') # 4 goes to (4 mod 4)\n    array([20,  1, 12,  3])\n    >>> # i.e., 0\n\n    A couple examples illustrating how choose broadcasts:\n\n    >>> a = [[1, 0, 1], [0, 1, 0], [1, 0, 1]]\n    >>> choices = [-10, 10]\n    >>> np.choose(a, choices)\n    array([[ 10, -10,  10],\n           [-10,  10, -10],\n           [ 10, -10,  10]])\n\n    >>> # With thanks to Anne Archibald\n    >>> a = np.array([0, 1]).reshape((2,1,1))\n    >>> c1 = np.array([1, 2, 3]).reshape((1,3,1))\n    >>> c2 = np.array([-1, -2, -3, -4, -5]).reshape((1,1,5))\n    >>> np.choose(a, (c1, c2)) # result is 2x3x5, res[0,:,:]=c1, res[1,:,:]=c2\n    array([[[ 1,  1,  1,  1,  1],\n            [ 2,  2,  2,  2,  2],\n            [ 3,  3,  3,  3,  3]],\n           [[-1, -2, -3, -4, -5],\n            [-1, -2, -3, -4, -5],\n            [-1, -2, -3, -4, -5]]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_91choose = {__Pyx_NAMESTR("choose"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_91choose, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_90choose)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_91choose(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_choices = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  CYTHON_UNUSED PyObject *__pyx_v_mode = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("choose (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__choices,&__pyx_n_s__out,&__pyx_n_s__mode,0};
    PyObject* values[4] = {0,0,0,0};

    /* "ga4py/gain/notimplemented.pyx":2202
 * 
 * 
 * def choose(a, choices, out=None, mode='raise'):             # <<<<<<<<<<<<<<
 *     """Construct an array from an index array and a set of arrays to choose from.
 * 
 */
    values[2] = ((PyObject *)Py_None);
    values[3] = ((PyObject *)__pyx_n_s__raise);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__choices)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("choose", 0, 2, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2202; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__out);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__mode);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "choose") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2202; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_choices = values[1];
    __pyx_v_out = values[2];
    __pyx_v_mode = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("choose", 0, 2, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2202; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.choose", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_90choose(__pyx_self, __pyx_v_a, __pyx_v_choices, __pyx_v_out, __pyx_v_mode);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_90choose(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_choices, CYTHON_UNUSED PyObject *__pyx_v_out, CYTHON_UNUSED PyObject *__pyx_v_mode) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("choose", 0);

  /* "ga4py/gain/notimplemented.pyx":2320
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2320; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.choose", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_93column_stack(PyObject *__pyx_self, PyObject *__pyx_v_tup); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_92column_stack[] = "Stack 1-D arrays as columns into a 2-D array.\n\n    Take a sequence of 1-D arrays and stack them as columns\n    to make a single 2-D array. 2-D arrays are stacked as-is,\n    just like with `hstack`.  1-D arrays are turned into 2-D columns\n    first.\n\n    Parameters\n    ----------\n    tup : sequence of 1-D or 2-D arrays.\n        Arrays to stack. All of them must have the same first dimension.\n\n    Returns\n    -------\n    stacked : 2-D array\n        The array formed by stacking the given arrays.\n\n    See Also\n    --------\n    hstack, vstack, concatenate\n\n    Notes\n    -----\n    This function is equivalent to ``np.vstack(tup).T``.\n\n    Examples\n    --------\n    >>> a = np.array((1,2,3))\n    >>> b = np.array((2,3,4))\n    >>> np.column_stack((a,b))\n    array([[1, 2],\n           [2, 3],\n           [3, 4]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_93column_stack = {__Pyx_NAMESTR("column_stack"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_93column_stack, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_92column_stack)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_93column_stack(PyObject *__pyx_self, PyObject *__pyx_v_tup) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("column_stack (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_92column_stack(__pyx_self, ((PyObject *)__pyx_v_tup));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":2323
 * 
 * 
 * def column_stack(tup):             # <<<<<<<<<<<<<<
 *     """Stack 1-D arrays as columns into a 2-D array.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_92column_stack(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_tup) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("column_stack", 0);

  /* "ga4py/gain/notimplemented.pyx":2359
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2359; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.column_stack", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_95common_type(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_94common_type[] = "Return a scalar type which is common to the input arrays.\n\n    The return type will always be an inexact (i.e. floating point) scalar\n    type, even if all the arrays are integer arrays. If one of the inputs is\n    an integer array, the minimum precision type that is returned is a\n    64-bit floating point dtype.\n\n    All input arrays can be safely cast to the returned dtype without loss\n    of information.\n\n    Parameters\n    ----------\n    array1, array2, ... : ndarrays\n        Input arrays.\n\n    Returns\n    -------\n    out : data type code\n        Data type code.\n\n    See Also\n    --------\n    dtype, mintypecode\n\n    Examples\n    --------\n    >>> np.common_type(np.arange(2, dtype=np.float32))\n    <type 'numpy.float32'>\n    >>> np.common_type(np.arange(2, dtype=np.float32), np.arange(2))\n    <type 'numpy.float64'>\n    >>> np.common_type(np.arange(4), np.array([45, 6.j]), np.array([45.0]))\n    <type 'numpy.complex128'>\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_95common_type = {__Pyx_NAMESTR("common_type"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_95common_type, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_94common_type)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_95common_type(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("common_type (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_94common_type(__pyx_self);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":2362
 * 
 * 
 * def common_type():             # <<<<<<<<<<<<<<
 *     """Return a scalar type which is common to the input arrays.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_94common_type(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("common_type", 0);

  /* "ga4py/gain/notimplemented.pyx":2397
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2397; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.common_type", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_97compare_chararrays(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_96compare_chararrays[] = "\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_97compare_chararrays = {__Pyx_NAMESTR("compare_chararrays"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_97compare_chararrays, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_96compare_chararrays)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_97compare_chararrays(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("compare_chararrays (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_96compare_chararrays(__pyx_self);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":2400
 * 
 * 
 * def compare_chararrays():             # <<<<<<<<<<<<<<
 *     """
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_96compare_chararrays(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("compare_chararrays", 0);

  /* "ga4py/gain/notimplemented.pyx":2405
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2405; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.compare_chararrays", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_99compress(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_98compress[] = "Return selected slices of an array along given axis.\n\n    When working along a given axis, a slice along that axis is returned in\n    `output` for each index where `condition` evaluates to True. When\n    working on a 1-D array, `compress` is equivalent to `extract`.\n\n    Parameters\n    ----------\n    condition : 1-D array of bools\n        Array that selects which entries to return. If len(condition)\n        is less than the size of `a` along the given axis, then output is\n        truncated to the length of the condition array.\n    a : array_like\n        Array from which to extract a part.\n    axis : int, optional\n        Axis along which to take slices. If None (default), work on the\n        flattened array.\n    out : ndarray, optional\n        Output array.  Its type is preserved and it must be of the right\n        shape to hold the output.\n\n    Returns\n    -------\n    compressed_array : ndarray\n        A copy of `a` without the slices along axis for which `condition`\n        is false.\n\n    See Also\n    --------\n    take, choose, diag, diagonal, select\n    ndarray.compress : Equivalent method.\n    numpy.doc.ufuncs : Section \"Output arguments\"\n\n    Examples\n    --------\n    >>> a = np.array([[1, 2], [3, 4], [5, 6]])\n    >>> a\n    array([[1, 2],\n           [3, 4],\n           [5, 6]])\n    >>> np.compress([0, 1], a, axis=0)\n    array([[3, 4]])\n    >>> np.compress([False, True, True], a, axis=0)\n    array([[3, 4],\n           [5, 6]])\n    >>> np.compress([False, True], a, axis=1)\n    array([[2],\n           [4],\n           [6]])\n\n    Working on the flattened array does not return slices along an axis but\n    selects elements.\n\n    >>> np.compress([False, True], a)\n    array([2])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_99compress = {__Pyx_NAMESTR("compress"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_99compress, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_98compress)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_99compress(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_condition = 0;
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("compress (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__condition,&__pyx_n_s__a,&__pyx_n_s__axis,&__pyx_n_s__out,0};
    PyObject* values[4] = {0,0,0,0};

    /* "ga4py/gain/notimplemented.pyx":2408
 * 
 * 
 * def compress(condition, a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return selected slices of an array along given axis.
 * 
 */
    values[2] = ((PyObject *)Py_None);
    values[3] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__condition)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("compress", 0, 2, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2408; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__out);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "compress") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2408; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_condition = values[0];
    __pyx_v_a = values[1];
    __pyx_v_axis = values[2];
    __pyx_v_out = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("compress", 0, 2, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2408; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.compress", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_98compress(__pyx_self, __pyx_v_condition, __pyx_v_a, __pyx_v_axis, __pyx_v_out);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_98compress(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_condition, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("compress", 0);

  /* "ga4py/gain/notimplemented.pyx":2466
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2466; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.compress", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_101concatenate(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_100concatenate[] = "concatenate((a1, a2, ...), axis=0)\n\n    Join a sequence of arrays together.\n\n    Parameters\n    ----------\n    a1, a2, ... : sequence of array_like\n        The arrays must have the same shape, except in the dimension\n        corresponding to `axis` (the first, by default).\n    axis : int, optional\n        The axis along which the arrays will be joined.  Default is 0.\n\n    Returns\n    -------\n    res : ndarray\n        The concatenated array.\n\n    See Also\n    --------\n    ma.concatenate : Concatenate function that preserves input masks.\n    array_split : Split an array into multiple sub-arrays of equal or\n                  near-equal size.\n    split : Split array into a list of multiple sub-arrays of equal size.\n    hsplit : Split array into multiple sub-arrays horizontally (column wise)\n    vsplit : Split array into multiple sub-arrays vertically (row wise)\n    dsplit : Split array into multiple sub-arrays along the 3rd axis (depth).\n    hstack : Stack arrays in sequence horizontally (column wise)\n    vstack : Stack arrays in sequence vertically (row wise)\n    dstack : Stack arrays in sequence depth wise (along third dimension)\n\n    Notes\n    -----\n    When one or more of the arrays to be concatenated is a MaskedArray,\n    this function will return a MaskedArray object instead of an ndarray,\n    but the input masks are *not* preserved. In cases where a MaskedArray\n    is expected as input, use the ma.concatenate function from the masked\n    array module instead.\n\n    Examples\n    --------\n    >>> a = np.array([[1, 2], [3, 4]])\n    >>> b = np.array([[5, 6]])\n    >>> np.concatenate((a, b), axis=0)\n    array([[1, 2],\n           [3, 4],\n           [5, 6]])\n    >>> np.concatenate((a, b.T), axis=1)\n    array([[1, 2, 5],\n           [3, 4, 6]])\n\n    This function will not preserve masking of MaskedArray inputs.\n\n    >>> a = np.ma.arange(3)\n    >>> a[1] = np.ma.masked\n    >>> b = np.arange(2, 5)\n    >>> a\n    masked_arr""ay(data = [0 -- 2],\n                 mask = [False  True False],\n           fill_value = 999999)\n    >>> b\n    array([2, 3, 4])\n    >>> np.concatenate([a, b])\n    masked_array(data = [0 1 2 2 3 4],\n                 mask = False,\n           fill_value = 999999)\n    >>> np.ma.concatenate([a, b])\n    masked_array(data = [0 -- 2 2 3 4],\n                 mask = [False  True False False False False],\n           fill_value = 999999)\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_101concatenate = {__Pyx_NAMESTR("concatenate"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_101concatenate, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_100concatenate)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_101concatenate(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("concatenate (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_100concatenate(__pyx_self);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":2469
 * 
 * 
 * def concatenate():             # <<<<<<<<<<<<<<
 *     """concatenate((a1, a2, ...), axis=0)
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_100concatenate(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("concatenate", 0);

  /* "ga4py/gain/notimplemented.pyx":2542
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2542; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.concatenate", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_103convolve(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_102convolve[] = "Returns the discrete, linear convolution of two one-dimensional sequences.\n\n    The convolution operator is often seen in signal processing, where it\n    models the effect of a linear time-invariant system on a signal [1]_.  In\n    probability theory, the sum of two independent random variables is\n    distributed according to the convolution of their individual\n    distributions.\n\n    Parameters\n    ----------\n    a : (N,) array_like\n        First one-dimensional input array.\n    v : (M,) array_like\n        Second one-dimensional input array.\n    mode : {'full', 'valid', 'same'}, optional\n        'full':\n          By default, mode is 'full'.  This returns the convolution\n          at each point of overlap, with an output shape of (N+M-1,). At\n          the end-points of the convolution, the signals do not overlap\n          completely, and boundary effects may be seen.\n\n        'same':\n          Mode `same` returns output of length ``max(M, N)``.  Boundary\n          effects are still visible.\n\n        'valid':\n          Mode `valid` returns output of length\n          ``max(M, N) - min(M, N) + 1``.  The convolution product is only given\n          for points where the signals overlap completely.  Values outside\n          the signal boundary have no effect.\n\n    Returns\n    -------\n    out : ndarray\n        Discrete, linear convolution of `a` and `v`.\n\n    See Also\n    --------\n    scipy.signal.fftconvolve : Convolve two arrays using the Fast Fourier\n                               Transform.\n    scipy.linalg.toeplitz : Used to construct the convolution operator.\n\n    Notes\n    -----\n    The discrete convolution operation is defined as\n\n    .. math:: (f * g)[n] = \\sum_{m = -\\infty}^{\\infty} f[m] g[n - m]\n\n    It can be shown that a convolution :math:`x(t) * y(t)` in time/space\n    is equivalent to the multiplication :math:`X(f) Y(f)` in the Fourier\n    domain, after appropriate padding (padding is necessary to prevent""\n    circular convolution).  Since multiplication is more efficient (faster)\n    than convolution, the function `scipy.signal.fftconvolve` exploits the\n    FFT to calculate the convolution of large data-sets.\n\n    References\n    ----------\n    .. [1] Wikipedia, \"Convolution\", http://en.wikipedia.org/wiki/Convolution.\n\n    Examples\n    --------\n    Note how the convolution operator flips the second array\n    before \"sliding\" the two across one another:\n\n    >>> np.convolve([1, 2, 3], [0, 1, 0.5])\n    array([ 0. ,  1. ,  2.5,  4. ,  1.5])\n\n    Only return the middle values of the convolution.\n    Contains boundary effects, where zeros are taken\n    into account:\n\n    >>> np.convolve([1,2,3],[0,1,0.5], 'same')\n    array([ 1. ,  2.5,  4. ])\n\n    The two arrays are of the same length, so there\n    is only one position where they completely overlap:\n\n    >>> np.convolve([1,2,3],[0,1,0.5], 'valid')\n    array([ 2.5])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_103convolve = {__Pyx_NAMESTR("convolve"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_103convolve, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_102convolve)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_103convolve(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_v = 0;
  CYTHON_UNUSED PyObject *__pyx_v_mode = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("convolve (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__v,&__pyx_n_s__mode,0};
    PyObject* values[3] = {0,0,0};
    values[2] = ((PyObject *)__pyx_n_s__full);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__v)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("convolve", 0, 2, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2545; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__mode);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "convolve") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2545; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_v = values[1];
    __pyx_v_mode = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("convolve", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2545; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.convolve", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_102convolve(__pyx_self, __pyx_v_a, __pyx_v_v, __pyx_v_mode);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":2545
 * 
 * 
 * def convolve(a, v, mode='full'):             # <<<<<<<<<<<<<<
 *     """Returns the discrete, linear convolution of two one-dimensional sequences.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_102convolve(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_v, CYTHON_UNUSED PyObject *__pyx_v_mode) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("convolve", 0);

  /* "ga4py/gain/notimplemented.pyx":2627
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2627; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.convolve", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_105copy(PyObject *__pyx_self, PyObject *__pyx_v_a); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_104copy[] = "Return an array copy of the given object.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n\n    Returns\n    -------\n    arr : ndarray\n        Array interpretation of `a`.\n\n    Notes\n    -----\n    This is equivalent to\n\n    >>> np.array(a, copy=True)                              #doctest: +SKIP\n\n    Examples\n    --------\n    Create an array x, with a reference y and a copy z:\n\n    >>> x = np.array([1, 2, 3])\n    >>> y = x\n    >>> z = np.copy(x)\n\n    Note that, when we modify x, y changes, but not z:\n\n    >>> x[0] = 10\n    >>> x[0] == y[0]\n    True\n    >>> x[0] == z[0]\n    False\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_105copy = {__Pyx_NAMESTR("copy"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_105copy, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_104copy)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_105copy(PyObject *__pyx_self, PyObject *__pyx_v_a) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("copy (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_104copy(__pyx_self, ((PyObject *)__pyx_v_a));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":2630
 * 
 * 
 * def copy(a):             # <<<<<<<<<<<<<<
 *     """Return an array copy of the given object.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_104copy(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("copy", 0);

  /* "ga4py/gain/notimplemented.pyx":2666
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2666; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.copy", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_107corrcoef(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_106corrcoef[] = "Return correlation coefficients.\n\n    Please refer to the documentation for `cov` for more detail.  The\n    relationship between the correlation coefficient matrix, `P`, and the\n    covariance matrix, `C`, is\n\n    .. math:: P_{ij} = \014rac{ C_{ij} } { \\sqrt{ C_{ii} * C_{jj} } }\n\n    The values of `P` are between -1 and 1, inclusive.\n\n    Parameters\n    ----------\n    x : array_like\n        A 1-D or 2-D array containing multiple variables and observations.\n        Each row of `m` represents a variable, and each column a single\n        observation of all those variables. Also see `rowvar` below.\n    y : array_like, optional\n        An additional set of variables and observations. `y` has the same\n        shape as `m`.\n    rowvar : int, optional\n        If `rowvar` is non-zero (default), then each row represents a\n        variable, with observations in the columns. Otherwise, the relationship\n        is transposed: each column represents a variable, while the rows\n        contain observations.\n    bias : int, optional\n        Default normalization is by ``(N - 1)``, where ``N`` is the number of\n        observations (unbiased estimate). If `bias` is 1, then\n        normalization is by ``N``. These values can be overridden by using\n        the keyword ``ddof`` in numpy versions >= 1.5.\n    ddof : {None, int}, optional\n        .. versionadded:: 1.5\n        If not ``None`` normalization is by ``(N - ddof)``, where ``N`` is\n        the number of observations; this overrides the value implied by\n        ``bias``. The default value is ``None``.\n\n    Returns\n    -------\n    out : ndarray\n        The correlation coefficient matrix of the variables.\n\n    See Also\n    --------\n    cov : Covariance matrix\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_107corrcoef = {__Pyx_NAMESTR("corrcoef"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_107corrcoef, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_106corrcoef)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_107corrcoef(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_x = 0;
  CYTHON_UNUSED PyObject *__pyx_v_y = 0;
  CYTHON_UNUSED PyObject *__pyx_v_rowvar = 0;
  CYTHON_UNUSED PyObject *__pyx_v_bias = 0;
  CYTHON_UNUSED PyObject *__pyx_v_ddof = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("corrcoef (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__x,&__pyx_n_s__y,&__pyx_n_s__rowvar,&__pyx_n_s__bias,&__pyx_n_s__ddof,0};
    PyObject* values[5] = {0,0,0,0,0};

    /* "ga4py/gain/notimplemented.pyx":2669
 * 
 * 
 * def corrcoef(x, y=None, rowvar=1, bias=0, ddof=None):             # <<<<<<<<<<<<<<
 *     """Return correlation coefficients.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)__pyx_int_1);
    values[3] = ((PyObject *)__pyx_int_0);
    values[4] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__x)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__y);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__rowvar);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__bias);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__ddof);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "corrcoef") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2669; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_x = values[0];
    __pyx_v_y = values[1];
    __pyx_v_rowvar = values[2];
    __pyx_v_bias = values[3];
    __pyx_v_ddof = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("corrcoef", 0, 1, 5, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2669; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.corrcoef", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_106corrcoef(__pyx_self, __pyx_v_x, __pyx_v_y, __pyx_v_rowvar, __pyx_v_bias, __pyx_v_ddof);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_106corrcoef(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_y, CYTHON_UNUSED PyObject *__pyx_v_rowvar, CYTHON_UNUSED PyObject *__pyx_v_bias, CYTHON_UNUSED PyObject *__pyx_v_ddof) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("corrcoef", 0);

  /* "ga4py/gain/notimplemented.pyx":2715
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2715; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.corrcoef", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_109correlate(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_108correlate[] = "Cross-correlation of two 1-dimensional sequences.\n\n    This function computes the correlation as generally defined in signal\n    processing texts::\n\n        z[k] = sum_n a[n] * conj(v[n+k])\n\n    with a and v sequences being zero-padded where necessary and conj being\n    the conjugate.\n\n    Parameters\n    ----------\n    a, v : array_like\n        Input sequences.\n    mode : {'valid', 'same', 'full'}, optional\n        Refer to the `convolve` docstring.  Note that the default\n        is `valid`, unlike `convolve`, which uses `full`.\n    old_behavior : bool\n        If True, uses the old behavior from Numeric, (correlate(a,v) == correlate(v,\n        a), and the conjugate is not taken for complex arrays). If False, uses\n        the conventional signal processing definition (see note).\n\n    See Also\n    --------\n    convolve : Discrete, linear convolution of two one-dimensional sequences.\n\n    Examples\n    --------\n    >>> np.correlate([1, 2, 3], [0, 1, 0.5])\n    array([ 3.5])\n    >>> np.correlate([1, 2, 3], [0, 1, 0.5], \"same\")\n    array([ 2. ,  3.5,  3. ])\n    >>> np.correlate([1, 2, 3], [0, 1, 0.5], \"full\")\n    array([ 0.5,  2. ,  3.5,  3. ,  0. ])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_109correlate = {__Pyx_NAMESTR("correlate"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_109correlate, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_108correlate)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_109correlate(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_v = 0;
  CYTHON_UNUSED PyObject *__pyx_v_mode = 0;
  CYTHON_UNUSED PyObject *__pyx_v_old_behavior = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("correlate (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__v,&__pyx_n_s__mode,&__pyx_n_s__old_behavior,0};
    PyObject* values[4] = {0,0,0,0};
    values[2] = ((PyObject *)__pyx_n_s__valid);
    values[3] = __pyx_k_10;
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__v)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("correlate", 0, 2, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2718; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__mode);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__old_behavior);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "correlate") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2718; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_v = values[1];
    __pyx_v_mode = values[2];
    __pyx_v_old_behavior = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("correlate", 0, 2, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2718; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.correlate", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_108correlate(__pyx_self, __pyx_v_a, __pyx_v_v, __pyx_v_mode, __pyx_v_old_behavior);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":2718
 * 
 * 
 * def correlate(a, v, mode='valid', old_behavior=False):             # <<<<<<<<<<<<<<
 *     """Cross-correlation of two 1-dimensional sequences.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_108correlate(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_v, CYTHON_UNUSED PyObject *__pyx_v_mode, CYTHON_UNUSED PyObject *__pyx_v_old_behavior) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("correlate", 0);

  /* "ga4py/gain/notimplemented.pyx":2755
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2755; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.correlate", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_111count_nonzero(PyObject *__pyx_self, PyObject *__pyx_v_a); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_110count_nonzero[] = "count_nonzero(a)\n\n    Counts the number of non-zero values in the array ``a``.\n\n    Parameters\n    ----------\n    a : array_like\n        The array for which to count non-zeros.\n\n    Returns\n    -------\n    count : int\n        Number of non-zero values in the array.\n\n    See Also\n    --------\n    nonzero : Return the coordinates of all the non-zero values.\n\n    Examples\n    --------\n    >>> np.count_nonzero(np.eye(4))\n    4\n\n    >>> np.count_nonzero([[0,1,7,0,0],[3,0,0,2,19]])\n    5\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_111count_nonzero = {__Pyx_NAMESTR("count_nonzero"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_111count_nonzero, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_110count_nonzero)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_111count_nonzero(PyObject *__pyx_self, PyObject *__pyx_v_a) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("count_nonzero (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_110count_nonzero(__pyx_self, ((PyObject *)__pyx_v_a));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":2758
 * 
 * 
 * def count_nonzero(a):             # <<<<<<<<<<<<<<
 *     """count_nonzero(a)
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_110count_nonzero(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("count_nonzero", 0);

  /* "ga4py/gain/notimplemented.pyx":2787
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2787; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.count_nonzero", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_113cov(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_112cov[] = "Estimate a covariance matrix, given data.\n\n    Covariance indicates the level to which two variables vary together.\n    If we examine N-dimensional samples, :math:`X = [x_1, x_2, ... x_N]^T`,\n    then the covariance matrix element :math:`C_{ij}` is the covariance of\n    :math:`x_i` and :math:`x_j`. The element :math:`C_{ii}` is the variance\n    of :math:`x_i`.\n\n    Parameters\n    ----------\n    m : array_like\n        A 1-D or 2-D array containing multiple variables and observations.\n        Each row of `m` represents a variable, and each column a single\n        observation of all those variables. Also see `rowvar` below.\n    y : array_like, optional\n        An additional set of variables and observations. `y` has the same\n        form as that of `m`.\n    rowvar : int, optional\n        If `rowvar` is non-zero (default), then each row represents a\n        variable, with observations in the columns. Otherwise, the relationship\n        is transposed: each column represents a variable, while the rows\n        contain observations.\n    bias : int, optional\n        Default normalization is by ``(N - 1)``, where ``N`` is the number of\n        observations given (unbiased estimate). If `bias` is 1, then\n        normalization is by ``N``. These values can be overridden by using\n        the keyword ``ddof`` in numpy versions >= 1.5.\n    ddof : int, optional\n        .. versionadded:: 1.5\n        If not ``None`` normalization is by ``(N - ddof)``, where ``N`` is\n        the number of observations; this overrides the value implied by\n        ``bias``. The default value is ``None``.\n\n    Returns\n    -------\n    out : ndarray\n        The covariance matrix of the variables.\n\n    See Also\n    --------\n    corrcoef : Normalized covariance matrix\n\n    Examples\n    --------\n    Consider two variables, :math:`x_0` and :math:`x_1`, which\n    correlate perfectly, but in opposite directions:\n\n    >>> x = np.array([[0, 2], [1, 1], [2, 0]]).T\n   "" >>> x\n    array([[0, 1, 2],\n           [2, 1, 0]])\n\n    Note how :math:`x_0` increases while :math:`x_1` decreases. The covariance\n    matrix shows this clearly:\n\n    >>> np.cov(x)\n    array([[ 1., -1.],\n           [-1.,  1.]])\n\n    Note that element :math:`C_{0,1}`, which shows the correlation between\n    :math:`x_0` and :math:`x_1`, is negative.\n\n    Further, note how `x` and `y` are combined:\n\n    >>> x = [-2.1, -1,  4.3]\n    >>> y = [3,  1.1,  0.12]\n    >>> X = np.vstack((x,y))\n    >>> print np.cov(X)\n    [[ 11.71        -4.286     ]\n     [ -4.286        2.14413333]]\n    >>> print np.cov(x, y)\n    [[ 11.71        -4.286     ]\n     [ -4.286        2.14413333]]\n    >>> print np.cov(x)\n    11.71\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_113cov = {__Pyx_NAMESTR("cov"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_113cov, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_112cov)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_113cov(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_m = 0;
  CYTHON_UNUSED PyObject *__pyx_v_y = 0;
  CYTHON_UNUSED PyObject *__pyx_v_rowvar = 0;
  CYTHON_UNUSED PyObject *__pyx_v_bias = 0;
  CYTHON_UNUSED PyObject *__pyx_v_ddof = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("cov (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__m,&__pyx_n_s__y,&__pyx_n_s__rowvar,&__pyx_n_s__bias,&__pyx_n_s__ddof,0};
    PyObject* values[5] = {0,0,0,0,0};

    /* "ga4py/gain/notimplemented.pyx":2790
 * 
 * 
 * def cov(m, y=None, rowvar=1, bias=0, ddof=None):             # <<<<<<<<<<<<<<
 *     """Estimate a covariance matrix, given data.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)__pyx_int_1);
    values[3] = ((PyObject *)__pyx_int_0);
    values[4] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__m)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__y);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__rowvar);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__bias);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__ddof);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "cov") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2790; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_m = values[0];
    __pyx_v_y = values[1];
    __pyx_v_rowvar = values[2];
    __pyx_v_bias = values[3];
    __pyx_v_ddof = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("cov", 0, 1, 5, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2790; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.cov", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_112cov(__pyx_self, __pyx_v_m, __pyx_v_y, __pyx_v_rowvar, __pyx_v_bias, __pyx_v_ddof);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_112cov(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_m, CYTHON_UNUSED PyObject *__pyx_v_y, CYTHON_UNUSED PyObject *__pyx_v_rowvar, CYTHON_UNUSED PyObject *__pyx_v_bias, CYTHON_UNUSED PyObject *__pyx_v_ddof) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("cov", 0);

  /* "ga4py/gain/notimplemented.pyx":2868
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2868; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.cov", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_115cross(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_114cross[] = "Return the cross product of two (arrays of) vectors.\n\n    The cross product of `a` and `b` in :math:`R^3` is a vector perpendicular\n    to both `a` and `b`.  If `a` and `b` are arrays of vectors, the vectors\n    are defined by the last axis of `a` and `b` by default, and these axes\n    can have dimensions 2 or 3.  Where the dimension of either `a` or `b` is\n    2, the third component of the input vector is assumed to be zero and the\n    cross product calculated accordingly.  In cases where both input vectors\n    have dimension 2, the z-component of the cross product is returned.\n\n    Parameters\n    ----------\n    a : array_like\n        Components of the first vector(s).\n    b : array_like\n        Components of the second vector(s).\n    axisa : int, optional\n        Axis of `a` that defines the vector(s).  By default, the last axis.\n    axisb : int, optional\n        Axis of `b` that defines the vector(s).  By default, the last axis.\n    axisc : int, optional\n        Axis of `c` containing the cross product vector(s).  By default, the\n        last axis.\n    axis : int, optional\n        If defined, the axis of `a`, `b` and `c` that defines the vector(s)\n        and cross product(s).  Overrides `axisa`, `axisb` and `axisc`.\n\n    Returns\n    -------\n    c : ndarray\n        Vector cross product(s).\n\n    Raises\n    ------\n    ValueError\n        When the dimension of the vector(s) in `a` and/or `b` does not\n        equal 2 or 3.\n\n    See Also\n    --------\n    inner : Inner product\n    outer : Outer product.\n    ix_ : Construct index arrays.\n\n    Examples\n    --------\n    Vector cross-product.\n\n    >>> x = [1, 2, 3]\n    >>> y = [4, 5, 6]\n    >>> np.cross(x, y)\n    array([-3,  6, -3])\n\n    One vector with dimension 2.\n\n    >>> x = [1, 2]\n    >>> y = [4, 5, 6]\n    >>> np.cross(x, y)\n    array([12, -6, -3])\n\n    Equivalently:\n\n    >>> x = [1, 2, 0]\n    >>> y = [4, 5, 6]\n    >>> np.cross(x, y)\n    array([12, -6, -3""])\n\n    Both vectors with dimension 2.\n\n    >>> x = [1,2]\n    >>> y = [4,5]\n    >>> np.cross(x, y)\n    -3\n\n    Multiple vector cross-products. Note that the direction of the cross\n    product vector is defined by the `right-hand rule`.\n\n    >>> x = np.array([[1,2,3], [4,5,6]])\n    >>> y = np.array([[4,5,6], [1,2,3]])\n    >>> np.cross(x, y)\n    array([[-3,  6, -3],\n           [ 3, -6,  3]])\n\n    The orientation of `c` can be changed using the `axisc` keyword.\n\n    >>> np.cross(x, y, axisc=0)\n    array([[-3,  3],\n           [ 6, -6],\n           [-3,  3]])\n\n    Change the vector definition of `x` and `y` using `axisa` and `axisb`.\n\n    >>> x = np.array([[1,2,3], [4,5,6], [7, 8, 9]])\n    >>> y = np.array([[7, 8, 9], [4,5,6], [1,2,3]])\n    >>> np.cross(x, y)\n    array([[ -6,  12,  -6],\n           [  0,   0,   0],\n           [  6, -12,   6]])\n    >>> np.cross(x, y, axisa=0, axisb=0)\n    array([[-24,  48, -24],\n           [-30,  60, -30],\n           [-36,  72, -36]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_115cross = {__Pyx_NAMESTR("cross"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_115cross, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_114cross)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_115cross(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_b = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axisa = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axisb = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axisc = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("cross (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__b,&__pyx_n_s__axisa,&__pyx_n_s__axisb,&__pyx_n_s__axisc,&__pyx_n_s__axis,0};
    PyObject* values[6] = {0,0,0,0,0,0};
    values[2] = ((PyObject *)__pyx_int_neg_1);
    values[3] = ((PyObject *)__pyx_int_neg_1);
    values[4] = ((PyObject *)__pyx_int_neg_1);

    /* "ga4py/gain/notimplemented.pyx":2871
 * 
 * 
 * def cross(a, b, axisa=-1, axisb=-1, axisc=-1, axis=None):             # <<<<<<<<<<<<<<
 *     """Return the cross product of two (arrays of) vectors.
 * 
 */
    values[5] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__b)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("cross", 0, 2, 6, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2871; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axisa);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axisb);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axisc);
          if (value) { values[4] = value; kw_args--; }
        }
        case  5:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis);
          if (value) { values[5] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "cross") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2871; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_b = values[1];
    __pyx_v_axisa = values[2];
    __pyx_v_axisb = values[3];
    __pyx_v_axisc = values[4];
    __pyx_v_axis = values[5];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("cross", 0, 2, 6, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2871; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.cross", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_114cross(__pyx_self, __pyx_v_a, __pyx_v_b, __pyx_v_axisa, __pyx_v_axisb, __pyx_v_axisc, __pyx_v_axis);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_114cross(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_b, CYTHON_UNUSED PyObject *__pyx_v_axisa, CYTHON_UNUSED PyObject *__pyx_v_axisb, CYTHON_UNUSED PyObject *__pyx_v_axisc, CYTHON_UNUSED PyObject *__pyx_v_axis) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("cross", 0);

  /* "ga4py/gain/notimplemented.pyx":2976
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2976; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.cross", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_117cumprod(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_116cumprod[] = "Return the cumulative product of elements along a given axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    axis : int, optional\n        Axis along which the cumulative product is computed.  By default\n        the input is flattened.\n    dtype : dtype, optional\n        Type of the returned array, as well as of the accumulator in which\n        the elements are multiplied.  If *dtype* is not specified, it\n        defaults to the dtype of `a`, unless `a` has an integer dtype with\n        a precision less than that of the default platform integer.  In\n        that case, the default platform integer is used instead.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must\n        have the same shape and buffer length as the expected output\n        but the type of the resulting values will be cast if necessary.\n\n    Returns\n    -------\n    cumprod : ndarray\n        A new array holding the result is returned unless `out` is\n        specified, in which case a reference to out is returned.\n\n    See Also\n    --------\n    numpy.doc.ufuncs : Section \"Output arguments\"\n\n    Notes\n    -----\n    Arithmetic is modular when using integer types, and no error is\n    raised on overflow.\n\n    Examples\n    --------\n    >>> a = np.array([1,2,3])\n    >>> np.cumprod(a) # intermediate results 1, 1*2\n    ...               # total product 1*2*3 = 6\n    array([1, 2, 6])\n    >>> a = np.array([[1, 2, 3], [4, 5, 6]])\n    >>> np.cumprod(a, dtype=float) # specify type of output\n    array([   1.,    2.,    6.,   24.,  120.,  720.])\n\n    The cumulative product for each column (i.e., over the rows) of `a`:\n\n    >>> np.cumprod(a, axis=0)\n    array([[ 1,  2,  3],\n           [ 4, 10, 18]])\n\n    The cumulative product for each row (i.e. over the columns) of `a`:\n\n    >>> np.cumprod(a,axis=1)\n    array([[  1,   2,   6],\n           [  4,  20, 120]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_117cumprod = {__Pyx_NAMESTR("cumprod"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_117cumprod, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_116cumprod)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_117cumprod(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("cumprod (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__axis,&__pyx_n_s__dtype,&__pyx_n_s__out,0};
    PyObject* values[4] = {0,0,0,0};

    /* "ga4py/gain/notimplemented.pyx":2979
 * 
 * 
 * def cumprod(a, axis=None, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the cumulative product of elements along a given axis.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    values[3] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__dtype);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__out);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "cumprod") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2979; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
    __pyx_v_dtype = values[2];
    __pyx_v_out = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("cumprod", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2979; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.cumprod", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_116cumprod(__pyx_self, __pyx_v_a, __pyx_v_axis, __pyx_v_dtype, __pyx_v_out);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_116cumprod(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_out) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("cumprod", 0);

  /* "ga4py/gain/notimplemented.pyx":3038
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3038; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.cumprod", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_119cumproduct(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_118cumproduct[] = "Return the cumulative product over the given axis.\n\n\n    See Also\n    --------\n    cumprod : equivalent function; see for details.\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_119cumproduct = {__Pyx_NAMESTR("cumproduct"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_119cumproduct, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_118cumproduct)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_119cumproduct(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("cumproduct (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__axis,&__pyx_n_s__dtype,&__pyx_n_s__out,0};
    PyObject* values[4] = {0,0,0,0};

    /* "ga4py/gain/notimplemented.pyx":3041
 * 
 * 
 * def cumproduct(a, axis=None, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the cumulative product over the given axis.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    values[3] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__dtype);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__out);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "cumproduct") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3041; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
    __pyx_v_dtype = values[2];
    __pyx_v_out = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("cumproduct", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3041; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.cumproduct", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_118cumproduct(__pyx_self, __pyx_v_a, __pyx_v_axis, __pyx_v_dtype, __pyx_v_out);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_118cumproduct(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_out) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("cumproduct", 0);

  /* "ga4py/gain/notimplemented.pyx":3050
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3050; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.cumproduct", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_121cumsum(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_120cumsum[] = "Return the cumulative sum of the elements along a given axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    axis : int, optional\n        Axis along which the cumulative sum is computed. The default\n        (None) is to compute the cumsum over the flattened array.\n    dtype : dtype, optional\n        Type of the returned array and of the accumulator in which the\n        elements are summed.  If `dtype` is not specified, it defaults\n        to the dtype of `a`, unless `a` has an integer dtype with a\n        precision less than that of the default platform integer.  In\n        that case, the default platform integer is used.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must\n        have the same shape and buffer length as the expected output\n        but the type will be cast if necessary. See `doc.ufuncs`\n        (Section \"Output arguments\") for more details.\n\n    Returns\n    -------\n    cumsum_along_axis : ndarray.\n        A new array holding the result is returned unless `out` is\n        specified, in which case a reference to `out` is returned. The\n        result has the same size as `a`, and the same shape as `a` if\n        `axis` is not None or `a` is a 1-d array.\n\n\n    See Also\n    --------\n    sum : Sum array elements.\n\n    trapz : Integration of array values using the composite trapezoidal rule.\n\n    Notes\n    -----\n    Arithmetic is modular when using integer types, and no error is\n    raised on overflow.\n\n    Examples\n    --------\n    >>> a = np.array([[1,2,3], [4,5,6]])\n    >>> a\n    array([[1, 2, 3],\n           [4, 5, 6]])\n    >>> np.cumsum(a)\n    array([ 1,  3,  6, 10, 15, 21])\n    >>> np.cumsum(a, dtype=float)     # specifies type of output value(s)\n    array([  1.,   3.,   6.,  10.,  15.,  21.])\n\n    >>> np.cumsum(a,axis=0)      # sum over rows for each of the 3 columns\n    array([[1, 2, 3],\n           [5, 7, 9]])\n    >>> ""np.cumsum(a,axis=1)      # sum over columns for each of the 2 rows\n    array([[ 1,  3,  6],\n           [ 4,  9, 15]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_121cumsum = {__Pyx_NAMESTR("cumsum"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_121cumsum, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_120cumsum)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_121cumsum(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("cumsum (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__axis,&__pyx_n_s__dtype,&__pyx_n_s__out,0};
    PyObject* values[4] = {0,0,0,0};

    /* "ga4py/gain/notimplemented.pyx":3053
 * 
 * 
 * def cumsum(a, axis=None, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the cumulative sum of the elements along a given axis.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    values[3] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__dtype);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__out);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "cumsum") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3053; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
    __pyx_v_dtype = values[2];
    __pyx_v_out = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("cumsum", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3053; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.cumsum", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_120cumsum(__pyx_self, __pyx_v_a, __pyx_v_axis, __pyx_v_dtype, __pyx_v_out);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_120cumsum(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_out) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("cumsum", 0);

  /* "ga4py/gain/notimplemented.pyx":3114
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3114; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.cumsum", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_123datetime_data(PyObject *__pyx_self, PyObject *__pyx_v_dtype); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_122datetime_data[] = "Return (unit, numerator, denominator, events) from a datetime dtype\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_123datetime_data = {__Pyx_NAMESTR("datetime_data"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_123datetime_data, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_122datetime_data)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_123datetime_data(PyObject *__pyx_self, PyObject *__pyx_v_dtype) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("datetime_data (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_122datetime_data(__pyx_self, ((PyObject *)__pyx_v_dtype));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":3117
 * 
 * 
 * def datetime_data(dtype):             # <<<<<<<<<<<<<<
 *     """Return (unit, numerator, denominator, events) from a datetime dtype
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_122datetime_data(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_dtype) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("datetime_data", 0);

  /* "ga4py/gain/notimplemented.pyx":3121
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3121; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.datetime_data", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_125delete(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_124delete[] = "Return a new array with sub-arrays along an axis deleted.\n\n    Parameters\n    ----------\n    arr : array_like\n      Input array.\n    obj : slice, int or array of ints\n      Indicate which sub-arrays to remove.\n    axis : int, optional\n      The axis along which to delete the subarray defined by `obj`.\n      If `axis` is None, `obj` is applied to the flattened array.\n\n    Returns\n    -------\n    out : ndarray\n        A copy of `arr` with the elements specified by `obj` removed. Note\n        that `delete` does not occur in-place. If `axis` is None, `out` is\n        a flattened array.\n\n    See Also\n    --------\n    insert : Insert elements into an array.\n    append : Append elements at the end of an array.\n\n    Examples\n    --------\n    >>> arr = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])\n    >>> arr\n    array([[ 1,  2,  3,  4],\n           [ 5,  6,  7,  8],\n           [ 9, 10, 11, 12]])\n    >>> np.delete(arr, 1, 0)\n    array([[ 1,  2,  3,  4],\n           [ 9, 10, 11, 12]])\n\n    >>> np.delete(arr, np.s_[::2], 1)\n    array([[ 2,  4],\n           [ 6,  8],\n           [10, 12]])\n    >>> np.delete(arr, [1,3,5], None)\n    array([ 1,  3,  5,  7,  8,  9, 10, 11, 12])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_125delete = {__Pyx_NAMESTR("delete"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_125delete, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_124delete)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_125delete(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_arr = 0;
  CYTHON_UNUSED PyObject *__pyx_v_obj = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("delete (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__arr,&__pyx_n_s__obj,&__pyx_n_s__axis,0};
    PyObject* values[3] = {0,0,0};

    /* "ga4py/gain/notimplemented.pyx":3124
 * 
 * 
 * def delete(arr, obj, axis=None):             # <<<<<<<<<<<<<<
 *     """Return a new array with sub-arrays along an axis deleted.
 * 
 */
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__arr)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__obj)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("delete", 0, 2, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3124; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "delete") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3124; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_arr = values[0];
    __pyx_v_obj = values[1];
    __pyx_v_axis = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("delete", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3124; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.delete", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_124delete(__pyx_self, __pyx_v_arr, __pyx_v_obj, __pyx_v_axis);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_124delete(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_arr, CYTHON_UNUSED PyObject *__pyx_v_obj, CYTHON_UNUSED PyObject *__pyx_v_axis) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("delete", 0);

  /* "ga4py/gain/notimplemented.pyx":3168
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3168; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.delete", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_127deprecate(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_126deprecate[] = "Issues a DeprecationWarning, adds warning to `old_name`'s\n    docstring, rebinds ``old_name.__name__`` and returns the new\n    function object.\n\n    This function may also be used as a decorator.\n\n    Parameters\n    ----------\n    func : function\n        The function to be deprecated.\n    old_name : str, optional\n        The name of the function to be deprecated. Default is None, in which\n        case the name of `func` is used.\n    new_name : str, optional\n        The new name for the function. Default is None, in which case\n        the deprecation message is that `old_name` is deprecated. If given,\n        the deprecation message is that `old_name` is deprecated and `new_name`\n        should be used instead.\n    message : str, optional\n        Additional explanation of the deprecation.  Displayed in the docstring\n        after the warning.\n\n    Returns\n    -------\n    old_func : function\n        The deprecated function.\n\n    Examples\n    --------\n    Note that ``olduint`` returns a value after printing Deprecation Warning:\n\n    >>> olduint = np.deprecate(np.uint)\n    >>> olduint(6)\n    /usr/lib/python2.5/site-packages/numpy/lib/utils.py:114:\n    DeprecationWarning: uint32 is deprecated\n      warnings.warn(str1, DeprecationWarning)\n    6\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_127deprecate = {__Pyx_NAMESTR("deprecate"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_127deprecate, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_126deprecate)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_127deprecate(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("deprecate (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_126deprecate(__pyx_self);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":3171
 * 
 * 
 * def deprecate():             # <<<<<<<<<<<<<<
 *     """Issues a DeprecationWarning, adds warning to `old_name`'s
 *     docstring, rebinds ``old_name.__name__`` and returns the new
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_126deprecate(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("deprecate", 0);

  /* "ga4py/gain/notimplemented.pyx":3211
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3211; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.deprecate", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_129deprecate_with_doc(PyObject *__pyx_self, PyObject *__pyx_v_msg); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_128deprecate_with_doc[] = "message\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_129deprecate_with_doc = {__Pyx_NAMESTR("deprecate_with_doc"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_129deprecate_with_doc, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_128deprecate_with_doc)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_129deprecate_with_doc(PyObject *__pyx_self, PyObject *__pyx_v_msg) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("deprecate_with_doc (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_128deprecate_with_doc(__pyx_self, ((PyObject *)__pyx_v_msg));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":3214
 * 
 * 
 * def deprecate_with_doc(msg):             # <<<<<<<<<<<<<<
 *     """message
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_128deprecate_with_doc(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_msg) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("deprecate_with_doc", 0);

  /* "ga4py/gain/notimplemented.pyx":3218
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3218; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.deprecate_with_doc", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_131diag_indices(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_130diag_indices[] = "Return the indices to access the main diagonal of an array.\n\n    This returns a tuple of indices that can be used to access the main\n    diagonal of an array `a` with ``a.ndim >= 2`` dimensions and shape\n    (n, n, ..., n). For ``a.ndim = 2`` this is the usual diagonal, for\n    ``a.ndim > 2`` this is the set of indices to access ``a[i, i, ..., i]``\n    for ``i = [0..n-1]``.\n\n    Parameters\n    ----------\n    n : int\n      The size, along each dimension, of the arrays for which the returned\n      indices can be used.\n\n    ndim : int, optional\n      The number of dimensions.\n\n    See also\n    --------\n    diag_indices_from\n\n    Notes\n    -----\n    .. versionadded:: 1.4.0\n\n    Examples\n    --------\n    Create a set of indices to access the diagonal of a (4, 4) array:\n\n    >>> di = np.diag_indices(4)\n    >>> di\n    (array([0, 1, 2, 3]), array([0, 1, 2, 3]))\n    >>> a = np.arange(16).reshape(4, 4)\n    >>> a\n    array([[ 0,  1,  2,  3],\n           [ 4,  5,  6,  7],\n           [ 8,  9, 10, 11],\n           [12, 13, 14, 15]])\n    >>> a[di] = 100\n    >>> a\n    array([[100,   1,   2,   3],\n           [  4, 100,   6,   7],\n           [  8,   9, 100,  11],\n           [ 12,  13,  14, 100]])\n\n    Now, we create indices to manipulate a 3-D array:\n\n    >>> d3 = np.diag_indices(2, 3)\n    >>> d3\n    (array([0, 1]), array([0, 1]), array([0, 1]))\n\n    And use it to set the diagonal of an array of zeros to 1:\n\n    >>> a = np.zeros((2, 2, 2), dtype=np.int)\n    >>> a[d3] = 1\n    >>> a\n    array([[[1, 0],\n            [0, 0]],\n           [[0, 0],\n            [0, 1]]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_131diag_indices = {__Pyx_NAMESTR("diag_indices"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_131diag_indices, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_130diag_indices)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_131diag_indices(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_n = 0;
  CYTHON_UNUSED PyObject *__pyx_v_ndim = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("diag_indices (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__n,&__pyx_n_s__ndim,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)__pyx_int_2);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__n)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__ndim);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "diag_indices") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3221; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_n = values[0];
    __pyx_v_ndim = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("diag_indices", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3221; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.diag_indices", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_130diag_indices(__pyx_self, __pyx_v_n, __pyx_v_ndim);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":3221
 * 
 * 
 * def diag_indices(n, ndim=2):             # <<<<<<<<<<<<<<
 *     """Return the indices to access the main diagonal of an array.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_130diag_indices(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_n, CYTHON_UNUSED PyObject *__pyx_v_ndim) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("diag_indices", 0);

  /* "ga4py/gain/notimplemented.pyx":3284
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3284; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.diag_indices", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_133diag_indices_from(PyObject *__pyx_self, PyObject *__pyx_v_arr); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_132diag_indices_from[] = "Return the indices to access the main diagonal of an n-dimensional array.\n\n    See `diag_indices` for full details.\n\n    Parameters\n    ----------\n    arr : array, at least 2-D\n\n    See Also\n    --------\n    diag_indices\n\n    Notes\n    -----\n    .. versionadded:: 1.4.0\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_133diag_indices_from = {__Pyx_NAMESTR("diag_indices_from"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_133diag_indices_from, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_132diag_indices_from)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_133diag_indices_from(PyObject *__pyx_self, PyObject *__pyx_v_arr) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("diag_indices_from (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_132diag_indices_from(__pyx_self, ((PyObject *)__pyx_v_arr));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":3287
 * 
 * 
 * def diag_indices_from(arr):             # <<<<<<<<<<<<<<
 *     """Return the indices to access the main diagonal of an n-dimensional array.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_132diag_indices_from(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_arr) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("diag_indices_from", 0);

  /* "ga4py/gain/notimplemented.pyx":3305
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3305; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.diag_indices_from", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_135diagflat(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_134diagflat[] = "Create a two-dimensional array with the flattened input as a diagonal.\n\n    Parameters\n    ----------\n    v : array_like\n        Input data, which is flattened and set as the `k`-th\n        diagonal of the output.\n    k : int, optional\n        Diagonal to set; 0, the default, corresponds to the \"main\" diagonal,\n        a positive (negative) `k` giving the number of the diagonal above\n        (below) the main.\n\n    Returns\n    -------\n    out : ndarray\n        The 2-D output array.\n\n    See Also\n    --------\n    diag : MATLAB work-alike for 1-D and 2-D arrays.\n    diagonal : Return specified diagonals.\n    trace : Sum along diagonals.\n\n    Examples\n    --------\n    >>> np.diagflat([[1,2], [3,4]])\n    array([[1, 0, 0, 0],\n           [0, 2, 0, 0],\n           [0, 0, 3, 0],\n           [0, 0, 0, 4]])\n\n    >>> np.diagflat([1,2], 1)\n    array([[0, 1, 0],\n           [0, 0, 2],\n           [0, 0, 0]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_135diagflat = {__Pyx_NAMESTR("diagflat"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_135diagflat, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_134diagflat)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_135diagflat(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_v = 0;
  CYTHON_UNUSED PyObject *__pyx_v_k = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("diagflat (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__v,&__pyx_n_s__k,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)__pyx_int_0);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__v)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__k);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "diagflat") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3308; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_v = values[0];
    __pyx_v_k = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("diagflat", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3308; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.diagflat", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_134diagflat(__pyx_self, __pyx_v_v, __pyx_v_k);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":3308
 * 
 * 
 * def diagflat(v, k=0):             # <<<<<<<<<<<<<<
 *     """Create a two-dimensional array with the flattened input as a diagonal.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_134diagflat(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_v, CYTHON_UNUSED PyObject *__pyx_v_k) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("diagflat", 0);

  /* "ga4py/gain/notimplemented.pyx":3346
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3346; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.diagflat", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_137diff(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_136diff[] = "Calculate the n-th order discrete difference along given axis.\n\n    The first order difference is given by ``out[n] = a[n+1] - a[n]`` along\n    the given axis, higher order differences are calculated by using `diff`\n    recursively.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array\n    n : int, optional\n        The number of times values are differenced.\n    axis : int, optional\n        The axis along which the difference is taken, default is the last axis.\n\n    Returns\n    -------\n    out : ndarray\n        The `n` order differences. The shape of the output is the same as `a`\n        except along `axis` where the dimension is smaller by `n`.\n\n    See Also\n    --------\n    gradient, ediff1d\n\n    Examples\n    --------\n    >>> x = np.array([1, 2, 4, 7, 0])\n    >>> np.diff(x)\n    array([ 1,  2,  3, -7])\n    >>> np.diff(x, n=2)\n    array([  1,   1, -10])\n\n    >>> x = np.array([[1, 3, 6, 10], [0, 5, 6, 8]])\n    >>> np.diff(x)\n    array([[2, 3, 4],\n           [5, 1, 2]])\n    >>> np.diff(x, axis=0)\n    array([[-1,  2,  0, -2]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_137diff = {__Pyx_NAMESTR("diff"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_137diff, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_136diff)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_137diff(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_n = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("diff (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__n,&__pyx_n_s__axis,0};
    PyObject* values[3] = {0,0,0};
    values[1] = ((PyObject *)__pyx_int_1);
    values[2] = ((PyObject *)__pyx_int_neg_1);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__n);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "diff") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3349; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_n = values[1];
    __pyx_v_axis = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("diff", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3349; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.diff", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_136diff(__pyx_self, __pyx_v_a, __pyx_v_n, __pyx_v_axis);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":3349
 * 
 * 
 * def diff(a, n=1, axis=-1):             # <<<<<<<<<<<<<<
 *     """Calculate the n-th order discrete difference along given axis.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_136diff(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_n, CYTHON_UNUSED PyObject *__pyx_v_axis) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("diff", 0);

  /* "ga4py/gain/notimplemented.pyx":3391
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3391; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.diff", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_139digitize(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_138digitize[] = "digitize(x, bins)\n\n    Return the indices of the bins to which each value in input array belongs.\n\n    Each index ``i`` returned is such that ``bins[i-1] <= x < bins[i]`` if\n    `bins` is monotonically increasing, or ``bins[i-1] > x >= bins[i]`` if\n    `bins` is monotonically decreasing. If values in `x` are beyond the\n    bounds of `bins`, 0 or ``len(bins)`` is returned as appropriate.\n\n    Parameters\n    ----------\n    x : array_like\n        Input array to be binned. It has to be 1-dimensional.\n    bins : array_like\n        Array of bins. It has to be 1-dimensional and monotonic.\n\n    Returns\n    -------\n    out : ndarray of ints\n        Output array of indices, of same shape as `x`.\n\n    Raises\n    ------\n    ValueError\n        If the input is not 1-dimensional, or if `bins` is not monotonic.\n    TypeError\n        If the type of the input is complex.\n\n    See Also\n    --------\n    bincount, histogram, unique\n\n    Notes\n    -----\n    If values in `x` are such that they fall outside the bin range,\n    attempting to index `bins` with the indices that `digitize` returns\n    will result in an IndexError.\n\n    Examples\n    --------\n    >>> x = np.array([0.2, 6.4, 3.0, 1.6])\n    >>> bins = np.array([0.0, 1.0, 2.5, 4.0, 10.0])\n    >>> inds = np.digitize(x, bins)\n    >>> inds\n    array([1, 4, 3, 2])\n    >>> for n in range(x.size):\n    ...   print bins[inds[n]-1], \"<=\", x[n], \"<\", bins[inds[n]]\n    ...\n    0.0 <= 0.2 < 1.0\n    4.0 <= 6.4 < 10.0\n    2.5 <= 3.0 < 4.0\n    1.0 <= 1.6 < 2.5\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_139digitize = {__Pyx_NAMESTR("digitize"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_139digitize, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_138digitize)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_139digitize(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_x = 0;
  CYTHON_UNUSED PyObject *__pyx_v_bins = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("digitize (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__x,&__pyx_n_s__bins,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__x)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__bins)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("digitize", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3394; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "digitize") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3394; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_x = values[0];
    __pyx_v_bins = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("digitize", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3394; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.digitize", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_138digitize(__pyx_self, __pyx_v_x, __pyx_v_bins);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":3394
 * 
 * 
 * def digitize(x, bins):             # <<<<<<<<<<<<<<
 *     """digitize(x, bins)
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_138digitize(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_bins) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("digitize", 0);

  /* "ga4py/gain/notimplemented.pyx":3450
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3450; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.digitize", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_141disp(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_140disp[] = "Display a message on a device.\n\n    Parameters\n    ----------\n    mesg : str\n        Message to display.\n    device : object\n        Device to write message. If None, defaults to ``sys.stdout`` which is\n        very similar to ``print``. `device` needs to have ``write()`` and\n        ``flush()`` methods.\n    linefeed : bool, optional\n        Option whether to print a line feed or not. Defaults to True.\n\n    Raises\n    ------\n    AttributeError\n        If `device` does not have a ``write()`` or ``flush()`` method.\n\n    Examples\n    --------\n    Besides ``sys.stdout``, a file-like object can also be used as it has\n    both required methods:\n\n    >>> from StringIO import StringIO\n    >>> buf = StringIO()\n    >>> np.disp('\"Display\" in a file', device=buf)\n    >>> buf.getvalue()\n    '\"Display\" in a file\n'\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_141disp = {__Pyx_NAMESTR("disp"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_141disp, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_140disp)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_141disp(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_mesg = 0;
  CYTHON_UNUSED PyObject *__pyx_v_device = 0;
  CYTHON_UNUSED PyObject *__pyx_v_linefeed = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("disp (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__mesg,&__pyx_n_s__device,&__pyx_n_s__linefeed,0};
    PyObject* values[3] = {0,0,0};

    /* "ga4py/gain/notimplemented.pyx":3453
 * 
 * 
 * def disp(mesg, device=None, linefeed=True):             # <<<<<<<<<<<<<<
 *     """Display a message on a device.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    values[2] = __pyx_k_11;
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__mesg)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__device);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__linefeed);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "disp") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3453; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_mesg = values[0];
    __pyx_v_device = values[1];
    __pyx_v_linefeed = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("disp", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3453; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.disp", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_140disp(__pyx_self, __pyx_v_mesg, __pyx_v_device, __pyx_v_linefeed);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_140disp(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_mesg, CYTHON_UNUSED PyObject *__pyx_v_device, CYTHON_UNUSED PyObject *__pyx_v_linefeed) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("disp", 0);

  /* "ga4py/gain/notimplemented.pyx":3484
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3484; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.disp", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_143dsplit(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_142dsplit[] = "Split array into multiple sub-arrays along the 3rd axis (depth).\n\n    Please refer to the `split` documentation.  `dsplit` is equivalent\n    to `split` with ``axis=2``, the array is always split along the third\n    axis provided the array dimension is greater than or equal to 3.\n\n    See Also\n    --------\n    split : Split an array into multiple sub-arrays of equal size.\n\n    Examples\n    --------\n    >>> x = np.arange(16.0).reshape(2, 2, 4)\n    >>> x\n    array([[[  0.,   1.,   2.,   3.],\n            [  4.,   5.,   6.,   7.]],\n           [[  8.,   9.,  10.,  11.],\n            [ 12.,  13.,  14.,  15.]]])\n    >>> np.dsplit(x, 2)\n    [array([[[  0.,   1.],\n            [  4.,   5.]],\n           [[  8.,   9.],\n            [ 12.,  13.]]]),\n     array([[[  2.,   3.],\n            [  6.,   7.]],\n           [[ 10.,  11.],\n            [ 14.,  15.]]])]\n    >>> np.dsplit(x, np.array([3, 6]))\n    [array([[[  0.,   1.,   2.],\n            [  4.,   5.,   6.]],\n           [[  8.,   9.,  10.],\n            [ 12.,  13.,  14.]]]),\n     array([[[  3.],\n            [  7.]],\n           [[ 11.],\n            [ 15.]]]),\n     array([], dtype=float64)]\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_143dsplit = {__Pyx_NAMESTR("dsplit"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_143dsplit, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_142dsplit)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_143dsplit(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_ary = 0;
  CYTHON_UNUSED PyObject *__pyx_v_indices_or_sections = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("dsplit (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__ary,&__pyx_n_s__indices_or_sections,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__ary)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__indices_or_sections)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("dsplit", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3487; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "dsplit") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3487; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_ary = values[0];
    __pyx_v_indices_or_sections = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("dsplit", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3487; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.dsplit", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_142dsplit(__pyx_self, __pyx_v_ary, __pyx_v_indices_or_sections);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":3487
 * 
 * 
 * def dsplit(ary, indices_or_sections):             # <<<<<<<<<<<<<<
 *     """Split array into multiple sub-arrays along the 3rd axis (depth).
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_142dsplit(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_ary, CYTHON_UNUSED PyObject *__pyx_v_indices_or_sections) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("dsplit", 0);

  /* "ga4py/gain/notimplemented.pyx":3527
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3527; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.dsplit", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_145dstack(PyObject *__pyx_self, PyObject *__pyx_v_tup); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_144dstack[] = "Stack arrays in sequence depth wise (along third axis).\n\n    Takes a sequence of arrays and stack them along the third axis\n    to make a single array. Rebuilds arrays divided by `dsplit`.\n    This is a simple way to stack 2D arrays (images) into a single\n    3D array for processing.\n\n    Parameters\n    ----------\n    tup : sequence of arrays\n        Arrays to stack. All of them must have the same shape along all\n        but the third axis.\n\n    Returns\n    -------\n    stacked : ndarray\n        The array formed by stacking the given arrays.\n\n    See Also\n    --------\n    vstack : Stack along first axis.\n    hstack : Stack along second axis.\n    concatenate : Join arrays.\n    dsplit : Split array along third axis.\n\n    Notes\n    -----\n    Equivalent to ``np.concatenate(tup, axis=2)``.\n\n    Examples\n    --------\n    >>> a = np.array((1,2,3))\n    >>> b = np.array((2,3,4))\n    >>> np.dstack((a,b))\n    array([[[1, 2],\n            [2, 3],\n            [3, 4]]])\n\n    >>> a = np.array([[1],[2],[3]])\n    >>> b = np.array([[2],[3],[4]])\n    >>> np.dstack((a,b))\n    array([[[1, 2]],\n           [[2, 3]],\n           [[3, 4]]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_145dstack = {__Pyx_NAMESTR("dstack"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_145dstack, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_144dstack)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_145dstack(PyObject *__pyx_self, PyObject *__pyx_v_tup) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("dstack (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_144dstack(__pyx_self, ((PyObject *)__pyx_v_tup));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":3530
 * 
 * 
 * def dstack(tup):             # <<<<<<<<<<<<<<
 *     """Stack arrays in sequence depth wise (along third axis).
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_144dstack(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_tup) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("dstack", 0);

  /* "ga4py/gain/notimplemented.pyx":3577
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3577; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.dstack", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_147ediff1d(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_146ediff1d[] = "The differences between consecutive elements of an array.\n\n    Parameters\n    ----------\n    ary : array_like\n        If necessary, will be flattened before the differences are taken.\n    to_end : array_like, optional\n        Number(s) to append at the end of the returned differences.\n    to_begin : array_like, optional\n        Number(s) to prepend at the beginning of the returned differences.\n\n    Returns\n    -------\n    ed : ndarray\n        The differences. Loosely, this is ``ary.flat[1:] - ary.flat[:-1]``.\n\n    See Also\n    --------\n    diff, gradient\n\n    Notes\n    -----\n    When applied to masked arrays, this function drops the mask information\n    if the `to_begin` and/or `to_end` parameters are used.\n\n    Examples\n    --------\n    >>> x = np.array([1, 2, 4, 7, 0])\n    >>> np.ediff1d(x)\n    array([ 1,  2,  3, -7])\n\n    >>> np.ediff1d(x, to_begin=-99, to_end=np.array([88, 99]))\n    array([-99,   1,   2,   3,  -7,  88,  99])\n\n    The returned array is always 1D.\n\n    >>> y = [[1, 2, 4], [1, 6, 24]]\n    >>> np.ediff1d(y)\n    array([ 1,  2, -3,  5, 18])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_147ediff1d = {__Pyx_NAMESTR("ediff1d"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_147ediff1d, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_146ediff1d)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_147ediff1d(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_ary = 0;
  CYTHON_UNUSED PyObject *__pyx_v_to_end = 0;
  CYTHON_UNUSED PyObject *__pyx_v_to_begin = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ediff1d (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__ary,&__pyx_n_s__to_end,&__pyx_n_s__to_begin,0};
    PyObject* values[3] = {0,0,0};

    /* "ga4py/gain/notimplemented.pyx":3580
 * 
 * 
 * def ediff1d(ary, to_end=None, to_begin=None):             # <<<<<<<<<<<<<<
 *     """The differences between consecutive elements of an array.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__ary)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__to_end);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__to_begin);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "ediff1d") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3580; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_ary = values[0];
    __pyx_v_to_end = values[1];
    __pyx_v_to_begin = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("ediff1d", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3580; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.ediff1d", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_146ediff1d(__pyx_self, __pyx_v_ary, __pyx_v_to_end, __pyx_v_to_begin);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_146ediff1d(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_ary, CYTHON_UNUSED PyObject *__pyx_v_to_end, CYTHON_UNUSED PyObject *__pyx_v_to_begin) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("ediff1d", 0);

  /* "ga4py/gain/notimplemented.pyx":3622
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3622; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.ediff1d", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_149einsum(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_148einsum[] = "einsum(subscripts, *operands, out=None, dtype=None, order='K', casting='safe')\n\n    Evaluates the Einstein summation convention on the operands.\n\n    Using the Einstein summation convention, many common multi-dimensional\n    array operations can be represented in a simple fashion.  This function\n    provides a way compute such summations. The best way to understand this\n    function is to try the examples below, which show how many common NumPy\n    functions can be implemented as calls to `einsum`.\n\n    Parameters\n    ----------\n    subscripts : str\n        Specifies the subscripts for summation.\n    operands : list of array_like\n        These are the arrays for the operation.\n    out : ndarray, optional\n        If provided, the calculation is done into this array.\n    dtype : data-type, optional\n        If provided, forces the calculation to use the data type specified.\n        Note that you may have to also give a more liberal `casting`\n        parameter to allow the conversions.\n    order : {'C', 'F', 'A', or 'K'}, optional\n        Controls the memory layout of the output. 'C' means it should\n        be C contiguous. 'F' means it should be Fortran contiguous,\n        'A' means it should be 'F' if the inputs are all 'F', 'C' otherwise.\n        'K' means it should be as close to the layout as the inputs as\n        is possible, including arbitrarily permuted axes.\n        Default is 'K'.\n    casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional\n        Controls what kind of data casting may occur.  Setting this to\n        'unsafe' is not recommended, as it can adversely affect accumulations.\n\n          * 'no' means the data types should not be cast at all.\n          * 'equiv' means only byte-order changes are allowed.\n          * 'safe' means only casts which can preserve values are allowed.\n          * 'same_kind' means only safe casts or casts within a kind,\n            like float64 to float32, are allowed.\n      ""    * 'unsafe' means any data conversions may be done.\n\n    Returns\n    -------\n    output : ndarray\n        The calculation based on the Einstein summation convention.\n\n    See Also\n    --------\n    dot, inner, outer, tensordot\n\n    Notes\n    -----\n    .. versionadded:: 1.6.0\n\n    The subscripts string is a comma-separated list of subscript labels,\n    where each label refers to a dimension of the corresponding operand.\n    Repeated subscripts labels in one operand take the diagonal.  For example,\n    ``np.einsum('ii', a)`` is equivalent to ``np.trace(a)``.\n\n    Whenever a label is repeated, it is summed, so ``np.einsum('i,i', a, b)``\n    is equivalent to ``np.inner(a,b)``.  If a label appears only once,\n    it is not summed, so ``np.einsum('i', a)`` produces a view of ``a``\n    with no changes.\n\n    The order of labels in the output is by default alphabetical.  This\n    means that ``np.einsum('ij', a)`` doesn't affect a 2D array, while\n    ``np.einsum('ji', a)`` takes its transpose.\n\n    The output can be controlled by specifying output subscript labels\n    as well.  This specifies the label order, and allows summing to\n    be disallowed or forced when desired.  The call ``np.einsum('i->', a)``\n    is like ``np.sum(a, axis=-1)``, and ``np.einsum('ii->i', a)``\n    is like ``np.diag(a)``.  The difference is that `einsum` does not\n    allow broadcasting by default.\n\n    To enable and control broadcasting, use an ellipsis.  Default\n    NumPy-style broadcasting is done by adding an ellipsis\n    to the left of each term, like ``np.einsum('...ii->...i', a)``.\n    To take the trace along the first and last axes,\n    you can do ``np.einsum('i...i', a)``, or to do a matrix-matrix\n    product with the left-most indices instead of rightmost, you can do\n    ``np.einsum('ij...,jk...->ik...', a, b)``.\n\n    When there is only one operand, no axes are summed, and no output\n    parameter is provided, a view into the operand is returned i""nstead\n    of a new array.  Thus, taking the diagonal as ``np.einsum('ii->i', a)``\n    produces a view.\n\n    An alternative way to provide the subscripts and operands is as\n    ``einsum(op0, sublist0, op1, sublist1, ..., [sublistout])``. The examples\n    below have corresponding `einsum` calls with the two parameter methods.\n\n    Examples\n    --------\n    >>> a = np.arange(25).reshape(5,5)\n    >>> b = np.arange(5)\n    >>> c = np.arange(6).reshape(2,3)\n\n    >>> np.einsum('ii', a)\n    60\n    >>> np.einsum(a, [0,0])\n    60\n    >>> np.trace(a)\n    60\n\n    >>> np.einsum('ii->i', a)\n    array([ 0,  6, 12, 18, 24])\n    >>> np.einsum(a, [0,0], [0])\n    array([ 0,  6, 12, 18, 24])\n    >>> np.diag(a)\n    array([ 0,  6, 12, 18, 24])\n\n    >>> np.einsum('ij,j', a, b)\n    array([ 30,  80, 130, 180, 230])\n    >>> np.einsum(a, [0,1], b, [1])\n    array([ 30,  80, 130, 180, 230])\n    >>> np.dot(a, b)\n    array([ 30,  80, 130, 180, 230])\n\n    >>> np.einsum('ji', c)\n    array([[0, 3],\n           [1, 4],\n           [2, 5]])\n    >>> np.einsum(c, [1,0])\n    array([[0, 3],\n           [1, 4],\n           [2, 5]])\n    >>> c.T\n    array([[0, 3],\n           [1, 4],\n           [2, 5]])\n\n    >>> np.einsum('..., ...', 3, c)\n    array([[ 0,  3,  6],\n           [ 9, 12, 15]])\n    >>> np.einsum(3, [Ellipsis], c, [Ellipsis])\n    array([[ 0,  3,  6],\n           [ 9, 12, 15]])\n    >>> np.multiply(3, c)\n    array([[ 0,  3,  6],\n           [ 9, 12, 15]])\n\n    >>> np.einsum('i,i', b, b)\n    30\n    >>> np.einsum(b, [0], b, [0])\n    30\n    >>> np.inner(b,b)\n    30\n\n    >>> np.einsum('i,j', np.arange(2)+1, b)\n    array([[0, 1, 2, 3, 4],\n           [0, 2, 4, 6, 8]])\n    >>> np.einsum(np.arange(2)+1, [0], b, [1])\n    array([[0, 1, 2, 3, 4],\n           [0, 2, 4, 6, 8]])\n    >>> np.outer(np.arange(2)+1, b)\n    array([[0, 1, 2, 3, 4],\n           [0, 2, 4, 6, 8]])\n\n    >>> np.einsum('i...->...', a)\n    array([50, 55, 60, 65, 70])\n    >>> n""p.einsum(a, [0,Ellipsis], [Ellipsis])\n    array([50, 55, 60, 65, 70])\n    >>> np.sum(a, axis=0)\n    array([50, 55, 60, 65, 70])\n\n    >>> a = np.arange(60.).reshape(3,4,5)\n    >>> b = np.arange(24.).reshape(4,3,2)\n    >>> np.einsum('ijk,jil->kl', a, b)\n    array([[ 4400.,  4730.],\n           [ 4532.,  4874.],\n           [ 4664.,  5018.],\n           [ 4796.,  5162.],\n           [ 4928.,  5306.]])\n    >>> np.einsum(a, [0,1,2], b, [1,0,3], [2,3])\n    array([[ 4400.,  4730.],\n           [ 4532.,  4874.],\n           [ 4664.,  5018.],\n           [ 4796.,  5162.],\n           [ 4928.,  5306.]])\n    >>> np.tensordot(a,b, axes=([1,0],[0,1]))\n    array([[ 4400.,  4730.],\n           [ 4532.,  4874.],\n           [ 4664.,  5018.],\n           [ 4796.,  5162.],\n           [ 4928.,  5306.]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_149einsum = {__Pyx_NAMESTR("einsum"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_149einsum, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_148einsum)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_149einsum(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("einsum (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_148einsum(__pyx_self);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":3625
 * 
 * 
 * def einsum():             # <<<<<<<<<<<<<<
 *     """einsum(subscripts, *operands, out=None, dtype=None, order='K', casting='safe')
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_148einsum(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("einsum", 0);

  /* "ga4py/gain/notimplemented.pyx":3814
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3814; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.einsum", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_151expand_dims(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_150expand_dims[] = "Expand the shape of an array.\n\n    Insert a new axis, corresponding to a given position in the array shape.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    axis : int\n        Position (amongst axes) where new axis is to be inserted.\n\n    Returns\n    -------\n    res : ndarray\n        Output array. The number of dimensions is one greater than that of\n        the input array.\n\n    See Also\n    --------\n    doc.indexing, atleast_1d, atleast_2d, atleast_3d\n\n    Examples\n    --------\n    >>> x = np.array([1,2])\n    >>> x.shape\n    (2,)\n\n    The following is equivalent to ``x[np.newaxis,:]`` or ``x[np.newaxis]``:\n\n    >>> y = np.expand_dims(x, axis=0)\n    >>> y\n    array([[1, 2]])\n    >>> y.shape\n    (1, 2)\n\n    >>> y = np.expand_dims(x, axis=1)  # Equivalent to x[:,newaxis]\n    >>> y\n    array([[1],\n           [2]])\n    >>> y.shape\n    (2, 1)\n\n    Note that some examples may use ``None`` instead of ``np.newaxis``.  These\n    are the same objects:\n\n    >>> np.newaxis is None\n    True\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_151expand_dims = {__Pyx_NAMESTR("expand_dims"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_151expand_dims, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_150expand_dims)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_151expand_dims(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("expand_dims (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__axis,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("expand_dims", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3817; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "expand_dims") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3817; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("expand_dims", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3817; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.expand_dims", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_150expand_dims(__pyx_self, __pyx_v_a, __pyx_v_axis);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":3817
 * 
 * 
 * def expand_dims(a, axis):             # <<<<<<<<<<<<<<
 *     """Expand the shape of an array.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_150expand_dims(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("expand_dims", 0);

  /* "ga4py/gain/notimplemented.pyx":3867
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3867; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.expand_dims", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_153extract(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_152extract[] = "Return the elements of an array that satisfy some condition.\n\n    This is equivalent to ``np.compress(ravel(condition), ravel(arr))``.  If\n    `condition` is boolean ``np.extract`` is equivalent to ``arr[condition]``.\n\n    Parameters\n    ----------\n    condition : array_like\n        An array whose nonzero or True entries indicate the elements of `arr`\n        to extract.\n    arr : array_like\n        Input array of the same size as `condition`.\n\n    See Also\n    --------\n    take, put, putmask, compress\n\n    Examples\n    --------\n    >>> arr = np.arange(12).reshape((3, 4))\n    >>> arr\n    array([[ 0,  1,  2,  3],\n           [ 4,  5,  6,  7],\n           [ 8,  9, 10, 11]])\n    >>> condition = np.mod(arr, 3)==0\n    >>> condition\n    array([[ True, False, False,  True],\n           [False, False,  True, False],\n           [False,  True, False, False]], dtype=bool)\n    >>> np.extract(condition, arr)\n    array([0, 3, 6, 9])\n\n\n    If `condition` is boolean:\n\n    >>> arr[condition]\n    array([0, 3, 6, 9])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_153extract = {__Pyx_NAMESTR("extract"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_153extract, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_152extract)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_153extract(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_condition = 0;
  CYTHON_UNUSED PyObject *__pyx_v_arr = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("extract (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__condition,&__pyx_n_s__arr,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__condition)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__arr)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("extract", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3870; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "extract") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3870; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_condition = values[0];
    __pyx_v_arr = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("extract", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3870; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.extract", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_152extract(__pyx_self, __pyx_v_condition, __pyx_v_arr);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":3870
 * 
 * 
 * def extract(condition, arr):             # <<<<<<<<<<<<<<
 *     """Return the elements of an array that satisfy some condition.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_152extract(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_condition, CYTHON_UNUSED PyObject *__pyx_v_arr) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("extract", 0);

  /* "ga4py/gain/notimplemented.pyx":3910
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3910; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.extract", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_155_fastCopyAndTranspose(PyObject *__pyx_self, PyObject *__pyx_v_a); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_154_fastCopyAndTranspose[] = "_fastCopyAndTranspose(a)\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_155_fastCopyAndTranspose = {__Pyx_NAMESTR("_fastCopyAndTranspose"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_155_fastCopyAndTranspose, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_154_fastCopyAndTranspose)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_155_fastCopyAndTranspose(PyObject *__pyx_self, PyObject *__pyx_v_a) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_fastCopyAndTranspose (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_154_fastCopyAndTranspose(__pyx_self, ((PyObject *)__pyx_v_a));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":3913
 * 
 * 
 * def _fastCopyAndTranspose(a):             # <<<<<<<<<<<<<<
 *     """_fastCopyAndTranspose(a)
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_154_fastCopyAndTranspose(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_fastCopyAndTranspose", 0);

  /* "ga4py/gain/notimplemented.pyx":3918
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3918; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented._fastCopyAndTranspose", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_157fill_diagonal(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_156fill_diagonal[] = "Fill the main diagonal of the given array of any dimensionality.\n\n    For an array `a` with ``a.ndim > 2``, the diagonal is the list of\n    locations with indices ``a[i, i, ..., i]`` all identical. This function\n    modifies the input array in-place, it does not return a value.\n\n    Parameters\n    ----------\n    a : array, at least 2-D.\n      Array whose diagonal is to be filled, it gets modified in-place.\n\n    val : scalar\n      Value to be written on the diagonal, its type must be compatible with\n      that of the array a.\n\n    See also\n    --------\n    diag_indices, diag_indices_from\n\n    Notes\n    -----\n    .. versionadded:: 1.4.0\n\n    This functionality can be obtained via `diag_indices`, but internally\n    this version uses a much faster implementation that never constructs the\n    indices and uses simple slicing.\n\n    Examples\n    --------\n    >>> a = np.zeros((3, 3), int)\n    >>> np.fill_diagonal(a, 5)\n    >>> a\n    array([[5, 0, 0],\n           [0, 5, 0],\n           [0, 0, 5]])\n\n    The same function can operate on a 4-D array:\n\n    >>> a = np.zeros((3, 3, 3, 3), int)\n    >>> np.fill_diagonal(a, 4)\n\n    We only show a few blocks for clarity:\n\n    >>> a[0, 0]\n    array([[4, 0, 0],\n           [0, 0, 0],\n           [0, 0, 0]])\n    >>> a[1, 1]\n    array([[0, 0, 0],\n           [0, 4, 0],\n           [0, 0, 0]])\n    >>> a[2, 2]\n    array([[0, 0, 0],\n           [0, 0, 0],\n           [0, 0, 4]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_157fill_diagonal = {__Pyx_NAMESTR("fill_diagonal"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_157fill_diagonal, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_156fill_diagonal)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_157fill_diagonal(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_val = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("fill_diagonal (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__val,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__val)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("fill_diagonal", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3921; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "fill_diagonal") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3921; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_a = values[0];
    __pyx_v_val = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("fill_diagonal", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3921; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.fill_diagonal", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_156fill_diagonal(__pyx_self, __pyx_v_a, __pyx_v_val);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":3921
 * 
 * 
 * def fill_diagonal(a, val):             # <<<<<<<<<<<<<<
 *     """Fill the main diagonal of the given array of any dimensionality.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_156fill_diagonal(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_val) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("fill_diagonal", 0);

  /* "ga4py/gain/notimplemented.pyx":3979
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3979; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.fill_diagonal", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_159find_common_type(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_158find_common_type[] = "Determine common type following standard coercion rules.\n\n    Parameters\n    ----------\n    array_types : sequence\n        A list of dtypes or dtype convertible objects representing arrays.\n    scalar_types : sequence\n        A list of dtypes or dtype convertible objects representing scalars.\n\n    Returns\n    -------\n    datatype : dtype\n        The common data type, which is the maximum of `array_types` ignoring\n        `scalar_types`, unless the maximum of `scalar_types` is of a\n        different kind (`dtype.kind`). If the kind is not understood, then\n        None is returned.\n\n    See Also\n    --------\n    dtype, common_type, can_cast, mintypecode\n\n    Examples\n    --------\n    >>> np.find_common_type([], [np.int64, np.float32, np.complex])\n    dtype('complex128')\n    >>> np.find_common_type([np.int64, np.float32], [])\n    dtype('float64')\n\n    The standard casting rules ensure that a scalar cannot up-cast an\n    array unless the scalar is of a fundamentally different kind of data\n    (i.e. under a different hierarchy in the data type hierarchy) then\n    the array:\n\n    >>> np.find_common_type([np.float32], [np.int64, np.float64])\n    dtype('float32')\n\n    Complex is of a different type, so it up-casts the float in the\n    `array_types` argument:\n\n    >>> np.find_common_type([np.float32], [np.complex])\n    dtype('complex128')\n\n    Type specifier strings are convertible to dtypes and can therefore\n    be used instead of dtypes:\n\n    >>> np.find_common_type(['f4', 'f4', 'i4'], ['c8'])\n    dtype('complex128')\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_159find_common_type = {__Pyx_NAMESTR("find_common_type"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_159find_common_type, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_158find_common_type)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_159find_common_type(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_array_types = 0;
  CYTHON_UNUSED PyObject *__pyx_v_scalar_types = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("find_common_type (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__array_types,&__pyx_n_s__scalar_types,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__array_types)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__scalar_types)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("find_common_type", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3982; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "find_common_type") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3982; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_array_types = values[0];
    __pyx_v_scalar_types = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("find_common_type", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3982; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.find_common_type", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_158find_common_type(__pyx_self, __pyx_v_array_types, __pyx_v_scalar_types);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":3982
 * 
 * 
 * def find_common_type(array_types, scalar_types):             # <<<<<<<<<<<<<<
 *     """Determine common type following standard coercion rules.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_158find_common_type(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_array_types, CYTHON_UNUSED PyObject *__pyx_v_scalar_types) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("find_common_type", 0);

  /* "ga4py/gain/notimplemented.pyx":4032
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4032; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.find_common_type", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_161fix(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_160fix[] = "Round to nearest integer towards zero.\n\n    Round an array of floats element-wise to nearest integer towards zero.\n    The rounded values are returned as floats.\n\n    Parameters\n    ----------\n    x : array_like\n        An array of floats to be rounded\n    y : ndarray, optional\n        Output array\n\n    Returns\n    -------\n    out : ndarray of floats\n        The array of rounded numbers\n\n    See Also\n    --------\n    trunc, floor, ceil\n    around : Round to given number of decimals\n\n    Examples\n    --------\n    >>> np.fix(3.14)\n    3.0\n    >>> np.fix(3)\n    3.0\n    >>> np.fix([2.1, 2.9, -2.1, -2.9])\n    array([ 2.,  2., -2., -2.])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_161fix = {__Pyx_NAMESTR("fix"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_161fix, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_160fix)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_161fix(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_x = 0;
  CYTHON_UNUSED PyObject *__pyx_v_y = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("fix (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__x,&__pyx_n_s__y,0};
    PyObject* values[2] = {0,0};

    /* "ga4py/gain/notimplemented.pyx":4035
 * 
 * 
 * def fix(x, y=None):             # <<<<<<<<<<<<<<
 *     """Round to nearest integer towards zero.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__x)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__y);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "fix") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4035; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_x = values[0];
    __pyx_v_y = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("fix", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4035; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.fix", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_160fix(__pyx_self, __pyx_v_x, __pyx_v_y);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_160fix(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_y) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("fix", 0);

  /* "ga4py/gain/notimplemented.pyx":4068
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4068; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.fix", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_163flatnonzero(PyObject *__pyx_self, PyObject *__pyx_v_a); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_162flatnonzero[] = "Return indices that are non-zero in the flattened version of a.\n\n    This is equivalent to a.ravel().nonzero()[0].\n\n    Parameters\n    ----------\n    a : ndarray\n        Input array.\n\n    Returns\n    -------\n    res : ndarray\n        Output array, containing the indices of the elements of `a.ravel()`\n        that are non-zero.\n\n    See Also\n    --------\n    nonzero : Return the indices of the non-zero elements of the input array.\n    ravel : Return a 1-D array containing the elements of the input array.\n\n    Examples\n    --------\n    >>> x = np.arange(-2, 3)\n    >>> x\n    array([-2, -1,  0,  1,  2])\n    >>> np.flatnonzero(x)\n    array([0, 1, 3, 4])\n\n    Use the indices of the non-zero elements as an index array to extract\n    these elements:\n\n    >>> x.ravel()[np.flatnonzero(x)]\n    array([-2, -1,  1,  2])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_163flatnonzero = {__Pyx_NAMESTR("flatnonzero"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_163flatnonzero, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_162flatnonzero)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_163flatnonzero(PyObject *__pyx_self, PyObject *__pyx_v_a) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("flatnonzero (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_162flatnonzero(__pyx_self, ((PyObject *)__pyx_v_a));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":4071
 * 
 * 
 * def flatnonzero(a):             # <<<<<<<<<<<<<<
 *     """Return indices that are non-zero in the flattened version of a.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_162flatnonzero(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("flatnonzero", 0);

  /* "ga4py/gain/notimplemented.pyx":4107
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4107; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.flatnonzero", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_165fliplr(PyObject *__pyx_self, PyObject *__pyx_v_m); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_164fliplr[] = "Flip array in the left/right direction.\n\n    Flip the entries in each row in the left/right direction.\n    Columns are preserved, but appear in a different order than before.\n\n    Parameters\n    ----------\n    m : array_like\n        Input array.\n\n    Returns\n    -------\n    f : ndarray\n        A view of `m` with the columns reversed.  Since a view\n        is returned, this operation is :math:`\\mathcal O(1)`.\n\n    See Also\n    --------\n    flipud : Flip array in the up/down direction.\n    rot90 : Rotate array counterclockwise.\n\n    Notes\n    -----\n    Equivalent to A[:,::-1]. Does not require the array to be\n    two-dimensional.\n\n    Examples\n    --------\n    >>> A = np.diag([1.,2.,3.])\n    >>> A\n    array([[ 1.,  0.,  0.],\n           [ 0.,  2.,  0.],\n           [ 0.,  0.,  3.]])\n    >>> np.fliplr(A)\n    array([[ 0.,  0.,  1.],\n           [ 0.,  2.,  0.],\n           [ 3.,  0.,  0.]])\n\n    >>> A = np.random.randn(2,3,5)\n    >>> np.all(np.fliplr(A)==A[:,::-1,...])\n    True\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_165fliplr = {__Pyx_NAMESTR("fliplr"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_165fliplr, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_164fliplr)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_165fliplr(PyObject *__pyx_self, PyObject *__pyx_v_m) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("fliplr (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_164fliplr(__pyx_self, ((PyObject *)__pyx_v_m));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":4110
 * 
 * 
 * def fliplr(m):             # <<<<<<<<<<<<<<
 *     """Flip array in the left/right direction.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_164fliplr(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_m) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("fliplr", 0);

  /* "ga4py/gain/notimplemented.pyx":4154
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4154; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.fliplr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_167flipud(PyObject *__pyx_self, PyObject *__pyx_v_m); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_166flipud[] = "Flip array in the up/down direction.\n\n    Flip the entries in each column in the up/down direction.\n    Rows are preserved, but appear in a different order than before.\n\n    Parameters\n    ----------\n    m : array_like\n        Input array.\n\n    Returns\n    -------\n    out : array_like\n        A view of `m` with the rows reversed.  Since a view is\n        returned, this operation is :math:`\\mathcal O(1)`.\n\n    See Also\n    --------\n    fliplr : Flip array in the left/right direction.\n    rot90 : Rotate array counterclockwise.\n\n    Notes\n    -----\n    Equivalent to ``A[::-1,...]``.\n    Does not require the array to be two-dimensional.\n\n    Examples\n    --------\n    >>> A = np.diag([1.0, 2, 3])\n    >>> A\n    array([[ 1.,  0.,  0.],\n           [ 0.,  2.,  0.],\n           [ 0.,  0.,  3.]])\n    >>> np.flipud(A)\n    array([[ 0.,  0.,  3.],\n           [ 0.,  2.,  0.],\n           [ 1.,  0.,  0.]])\n\n    >>> A = np.random.randn(2,3,5)\n    >>> np.all(np.flipud(A)==A[::-1,...])\n    True\n\n    >>> np.flipud([1,2])\n    array([2, 1])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_167flipud = {__Pyx_NAMESTR("flipud"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_167flipud, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_166flipud)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_167flipud(PyObject *__pyx_self, PyObject *__pyx_v_m) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("flipud (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_166flipud(__pyx_self, ((PyObject *)__pyx_v_m));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":4157
 * 
 * 
 * def flipud(m):             # <<<<<<<<<<<<<<
 *     """Flip array in the up/down direction.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_166flipud(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_m) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("flipud", 0);

  /* "ga4py/gain/notimplemented.pyx":4204
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4204; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.flipud", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_169frombuffer(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_168frombuffer[] = "frombuffer(buffer, dtype=float, count=-1, offset=0)\n\n    Interpret a buffer as a 1-dimensional array.\n\n    Parameters\n    ----------\n    buffer : buffer_like\n        An object that exposes the buffer interface.\n    dtype : data-type, optional\n        Data-type of the returned array; default: float.\n    count : int, optional\n        Number of items to read. ``-1`` means all data in the buffer.\n    offset : int, optional\n        Start reading the buffer from this offset; default: 0.\n\n    Notes\n    -----\n    If the buffer has data that is not in machine byte-order, this should\n    be specified as part of the data-type, e.g.::\n\n      >>> dt = np.dtype(int)\n      >>> dt = dt.newbyteorder('>')\n      >>> np.frombuffer(buf, dtype=dt)\n\n    The data of the resulting array will not be byteswapped, but will be\n    interpreted correctly.\n\n    Examples\n    --------\n    >>> s = 'hello world'\n    >>> np.frombuffer(s, dtype='S1', count=5, offset=6)\n    array(['w', 'o', 'r', 'l', 'd'],\n          dtype='|S1')\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_169frombuffer = {__Pyx_NAMESTR("frombuffer"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_169frombuffer, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_168frombuffer)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_169frombuffer(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_buffer = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  CYTHON_UNUSED PyObject *__pyx_v_count = 0;
  CYTHON_UNUSED PyObject *__pyx_v_offset = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("frombuffer (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__buffer,&__pyx_n_s__dtype,&__pyx_n_s__count,&__pyx_n_s__offset,0};
    PyObject* values[4] = {0,0,0,0};
    values[1] = __pyx_k_12;
    values[2] = ((PyObject *)__pyx_int_neg_1);
    values[3] = ((PyObject *)__pyx_int_0);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__buffer)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__dtype);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__count);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__offset);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "frombuffer") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4207; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_buffer = values[0];
    __pyx_v_dtype = values[1];
    __pyx_v_count = values[2];
    __pyx_v_offset = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("frombuffer", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4207; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.frombuffer", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_168frombuffer(__pyx_self, __pyx_v_buffer, __pyx_v_dtype, __pyx_v_count, __pyx_v_offset);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":4207
 * 
 * 
 * def frombuffer(buffer, dtype=float, count=-1, offset=0):             # <<<<<<<<<<<<<<
 *     """frombuffer(buffer, dtype=float, count=-1, offset=0)
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_168frombuffer(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_buffer, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_count, CYTHON_UNUSED PyObject *__pyx_v_offset) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("frombuffer", 0);

  /* "ga4py/gain/notimplemented.pyx":4244
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4244; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.frombuffer", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_171fromfile(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_170fromfile[] = "fromfile(file, dtype=float, count=-1, sep='')\n\n    Construct an array from data in a text or binary file.\n\n    A highly efficient way of reading binary data with a known data-type,\n    as well as parsing simply formatted text files.  Data written using the\n    `tofile` method can be read using this function.\n\n    Parameters\n    ----------\n    file : file or str\n        Open file object or filename.\n    dtype : data-type\n        Data type of the returned array.\n        For binary files, it is used to determine the size and byte-order\n        of the items in the file.\n    count : int\n        Number of items to read. ``-1`` means all items (i.e., the complete\n        file).\n    sep : str\n        Separator between items if file is a text file.\n        Empty (\"\") separator means the file should be treated as binary.\n        Spaces (\" \") in the separator match zero or more whitespace characters.\n        A separator consisting only of spaces must match at least one\n        whitespace.\n\n    See also\n    --------\n    load, save\n    ndarray.tofile\n    loadtxt : More flexible way of loading data from a text file.\n\n    Notes\n    -----\n    Do not rely on the combination of `tofile` and `fromfile` for\n    data storage, as the binary files generated are are not platform\n    independent.  In particular, no byte-order or data-type information is\n    saved.  Data can be stored in the platform independent ``.npy`` format\n    using `save` and `load` instead.\n\n    Examples\n    --------\n    Construct an ndarray:\n\n    >>> dt = np.dtype([('time', [('min', int), ('sec', int)]),\n    ...                ('temp', float)])\n    >>> x = np.zeros((1,), dtype=dt)\n    >>> x['time']['min'] = 10; x['temp'] = 98.25\n    >>> x\n    array([((10, 0), 98.25)],\n          dtype=[('time', [('min', '<i4'), ('sec', '<i4')]), ('temp', '<f8')])\n\n    Save the raw data to disk:\n\n    >>> import os\n    >>> fname = os.tmpnam()\n    >>> x.tofile(fname)\n\n    Read"" the raw data from disk:\n\n    >>> np.fromfile(fname, dtype=dt)\n    array([((10, 0), 98.25)],\n          dtype=[('time', [('min', '<i4'), ('sec', '<i4')]), ('temp', '<f8')])\n\n    The recommended way to store and load data:\n\n    >>> np.save(fname, x)\n    >>> np.load(fname + '.npy')\n    array([((10, 0), 98.25)],\n          dtype=[('time', [('min', '<i4'), ('sec', '<i4')]), ('temp', '<f8')])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_171fromfile = {__Pyx_NAMESTR("fromfile"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_171fromfile, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_170fromfile)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_171fromfile(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_file = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  CYTHON_UNUSED PyObject *__pyx_v_count = 0;
  CYTHON_UNUSED PyObject *__pyx_v_sep = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("fromfile (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__file,&__pyx_n_s__dtype,&__pyx_n_s__count,&__pyx_n_s__sep,0};
    PyObject* values[4] = {0,0,0,0};
    values[1] = __pyx_k_13;
    values[2] = ((PyObject *)__pyx_int_neg_1);
    values[3] = ((PyObject *)__pyx_kp_s_6);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__file)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__dtype);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__count);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__sep);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "fromfile") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4247; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_file = values[0];
    __pyx_v_dtype = values[1];
    __pyx_v_count = values[2];
    __pyx_v_sep = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("fromfile", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4247; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.fromfile", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_170fromfile(__pyx_self, __pyx_v_file, __pyx_v_dtype, __pyx_v_count, __pyx_v_sep);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":4247
 * 
 * 
 * def fromfile(file, dtype=float, count=-1, sep=''):             # <<<<<<<<<<<<<<
 *     """fromfile(file, dtype=float, count=-1, sep='')
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_170fromfile(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_file, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_count, CYTHON_UNUSED PyObject *__pyx_v_sep) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("fromfile", 0);

  /* "ga4py/gain/notimplemented.pyx":4321
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4321; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.fromfile", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_173fromiter(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_172fromiter[] = "fromiter(iterable, dtype, count=-1)\n\n    Create a new 1-dimensional array from an iterable object.\n\n    Parameters\n    ----------\n    iterable : iterable object\n        An iterable object providing data for the array.\n    dtype : data-type\n        The data-type of the returned array.\n    count : int, optional\n        The number of items to read from *iterable*.  The default is -1,\n        which means all data is read.\n\n    Returns\n    -------\n    out : ndarray\n        The output array.\n\n    Notes\n    -----\n    Specify `count` to improve performance.  It allows ``fromiter`` to\n    pre-allocate the output array, instead of resizing it on demand.\n\n    Examples\n    --------\n    >>> iterable = (x*x for x in range(5))\n    >>> np.fromiter(iterable, np.float)\n    array([  0.,   1.,   4.,   9.,  16.])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_173fromiter = {__Pyx_NAMESTR("fromiter"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_173fromiter, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_172fromiter)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_173fromiter(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_iterable = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  CYTHON_UNUSED PyObject *__pyx_v_count = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("fromiter (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__iterable,&__pyx_n_s__dtype,&__pyx_n_s__count,0};
    PyObject* values[3] = {0,0,0};
    values[2] = ((PyObject *)__pyx_int_neg_1);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__iterable)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__dtype)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("fromiter", 0, 2, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4324; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__count);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "fromiter") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4324; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_iterable = values[0];
    __pyx_v_dtype = values[1];
    __pyx_v_count = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("fromiter", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4324; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.fromiter", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_172fromiter(__pyx_self, __pyx_v_iterable, __pyx_v_dtype, __pyx_v_count);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":4324
 * 
 * 
 * def fromiter(iterable, dtype, count=-1):             # <<<<<<<<<<<<<<
 *     """fromiter(iterable, dtype, count=-1)
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_172fromiter(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_iterable, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_count) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("fromiter", 0);

  /* "ga4py/gain/notimplemented.pyx":4357
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4357; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.fromiter", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_175frompyfunc(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_174frompyfunc[] = "frompyfunc(func, nin, nout)\n\n    Takes an arbitrary Python function and returns a Numpy ufunc.\n\n    Can be used, for example, to add broadcasting to a built-in Python\n    function (see Examples section).\n\n    Parameters\n    ----------\n    func : Python function object\n        An arbitrary Python function.\n    nin : int\n        The number of input arguments.\n    nout : int\n        The number of objects returned by `func`.\n\n    Returns\n    -------\n    out : ufunc\n        Returns a Numpy universal function (``ufunc``) object.\n\n    Notes\n    -----\n    The returned ufunc always returns PyObject arrays.\n\n    Examples\n    --------\n    Use frompyfunc to add broadcasting to the Python function ``oct``:\n\n    >>> oct_array = np.frompyfunc(oct, 1, 1)\n    >>> oct_array(np.array((10, 30, 100)))\n    array([012, 036, 0144], dtype=object)\n    >>> np.array((oct(10), oct(30), oct(100))) # for comparison\n    array(['012', '036', '0144'],\n          dtype='|S4')\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_175frompyfunc = {__Pyx_NAMESTR("frompyfunc"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_175frompyfunc, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_174frompyfunc)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_175frompyfunc(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_func = 0;
  CYTHON_UNUSED PyObject *__pyx_v_nin = 0;
  CYTHON_UNUSED PyObject *__pyx_v_nout = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("frompyfunc (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__func,&__pyx_n_s__nin,&__pyx_n_s__nout,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__func)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__nin)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("frompyfunc", 1, 3, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4360; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__nout)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("frompyfunc", 1, 3, 3, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4360; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "frompyfunc") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4360; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_func = values[0];
    __pyx_v_nin = values[1];
    __pyx_v_nout = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("frompyfunc", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4360; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.frompyfunc", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_174frompyfunc(__pyx_self, __pyx_v_func, __pyx_v_nin, __pyx_v_nout);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":4360
 * 
 * 
 * def frompyfunc(func, nin, nout):             # <<<<<<<<<<<<<<
 *     """frompyfunc(func, nin, nout)
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_174frompyfunc(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_func, CYTHON_UNUSED PyObject *__pyx_v_nin, CYTHON_UNUSED PyObject *__pyx_v_nout) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("frompyfunc", 0);

  /* "ga4py/gain/notimplemented.pyx":4399
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4399; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.frompyfunc", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_177fromregex(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_176fromregex[] = "Construct an array from a text file, using regular expression parsing.\n\n    The returned array is always a structured array, and is constructed from\n    all matches of the regular expression in the file. Groups in the regular\n    expression are converted to fields of the structured array.\n\n    Parameters\n    ----------\n    file : str or file\n        File name or file object to read.\n    regexp : str or regexp\n        Regular expression used to parse the file.\n        Groups in the regular expression correspond to fields in the dtype.\n    dtype : dtype or list of dtypes\n        Dtype for the structured array.\n\n    Returns\n    -------\n    output : ndarray\n        The output array, containing the part of the content of `file` that\n        was matched by `regexp`. `output` is always a structured array.\n\n    Raises\n    ------\n    TypeError\n        When `dtype` is not a valid dtype for a structured array.\n\n    See Also\n    --------\n    fromstring, loadtxt\n\n    Notes\n    -----\n    Dtypes for structured arrays can be specified in several forms, but all\n    forms specify at least the data type and field name. For details see\n    `doc.structured_arrays`.\n\n    Examples\n    --------\n    >>> f = open('test.dat', 'w')\n    >>> f.write(\"1312 foo\n1534  bar\n444   qux\")\n    >>> f.close()\n\n    >>> regexp = r\"(\\d+)\\s+(...)\"  # match [digits, whitespace, anything]\n    >>> output = np.fromregex('test.dat', regexp,\n    ...                       [('num', np.int64), ('key', 'S3')])\n    >>> output\n    array([(1312L, 'foo'), (1534L, 'bar'), (444L, 'qux')],\n          dtype=[('num', '<i8'), ('key', '|S3')])\n    >>> output['num']\n    array([1312, 1534,  444], dtype=int64)\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_177fromregex = {__Pyx_NAMESTR("fromregex"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_177fromregex, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_176fromregex)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_177fromregex(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_file = 0;
  CYTHON_UNUSED PyObject *__pyx_v_regexp = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("fromregex (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__file,&__pyx_n_s__regexp,&__pyx_n_s__dtype,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__file)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__regexp)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("fromregex", 1, 3, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4402; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__dtype)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("fromregex", 1, 3, 3, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4402; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "fromregex") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4402; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_file = values[0];
    __pyx_v_regexp = values[1];
    __pyx_v_dtype = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("fromregex", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4402; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.fromregex", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_176fromregex(__pyx_self, __pyx_v_file, __pyx_v_regexp, __pyx_v_dtype);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":4402
 * 
 * 
 * def fromregex(file, regexp, dtype):             # <<<<<<<<<<<<<<
 *     """Construct an array from a text file, using regular expression parsing.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_176fromregex(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_file, CYTHON_UNUSED PyObject *__pyx_v_regexp, CYTHON_UNUSED PyObject *__pyx_v_dtype) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("fromregex", 0);

  /* "ga4py/gain/notimplemented.pyx":4456
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4456; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.fromregex", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_179fromstring(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_178fromstring[] = "fromstring(string, dtype=float, count=-1, sep='')\n\n    A new 1-D array initialized from raw binary or text data in a string.\n\n    Parameters\n    ----------\n    string : str\n        A string containing the data.\n    dtype : data-type, optional\n        The data type of the array; default: float.  For binary input data,\n        the data must be in exactly this format.\n    count : int, optional\n        Read this number of `dtype` elements from the data.  If this is\n        negative (the default), the count will be determined from the\n        length of the data.\n    sep : str, optional\n        If not provided or, equivalently, the empty string, the data will\n        be interpreted as binary data; otherwise, as ASCII text with\n        decimal numbers.  Also in this latter case, this argument is\n        interpreted as the string separating numbers in the data; extra\n        whitespace between elements is also ignored.\n\n    Returns\n    -------\n    arr : ndarray\n        The constructed array.\n\n    Raises\n    ------\n    ValueError\n        If the string is not the correct size to satisfy the requested\n        `dtype` and `count`.\n\n    See Also\n    --------\n    frombuffer, fromfile, fromiter\n\n    Examples\n    --------\n    >>> np.fromstring('\001\002', dtype=np.uint8)\n    array([1, 2], dtype=uint8)\n    >>> np.fromstring('1 2', dtype=int, sep=' ')\n    array([1, 2])\n    >>> np.fromstring('1, 2', dtype=int, sep=',')\n    array([1, 2])\n    >>> np.fromstring('\001\002\003\004\005', dtype=np.uint8, count=3)\n    array([1, 2, 3], dtype=uint8)\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_179fromstring = {__Pyx_NAMESTR("fromstring"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_179fromstring, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_178fromstring)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_179fromstring(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_string = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  CYTHON_UNUSED PyObject *__pyx_v_count = 0;
  CYTHON_UNUSED PyObject *__pyx_v_sep = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("fromstring (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__string,&__pyx_n_s__dtype,&__pyx_n_s__count,&__pyx_n_s__sep,0};
    PyObject* values[4] = {0,0,0,0};
    values[1] = __pyx_k_14;
    values[2] = ((PyObject *)__pyx_int_neg_1);
    values[3] = ((PyObject *)__pyx_kp_s_6);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__string)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__dtype);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__count);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__sep);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "fromstring") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4459; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_string = values[0];
    __pyx_v_dtype = values[1];
    __pyx_v_count = values[2];
    __pyx_v_sep = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("fromstring", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4459; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.fromstring", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_178fromstring(__pyx_self, __pyx_v_string, __pyx_v_dtype, __pyx_v_count, __pyx_v_sep);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":4459
 * 
 * 
 * def fromstring(string, dtype=float, count=-1, sep=''):             # <<<<<<<<<<<<<<
 *     """fromstring(string, dtype=float, count=-1, sep='')
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_178fromstring(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_string, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_count, CYTHON_UNUSED PyObject *__pyx_v_sep) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("fromstring", 0);

  /* "ga4py/gain/notimplemented.pyx":4510
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4510; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.fromstring", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_181fv(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_180fv[] = "Compute the future value.\n\n    Given:\n     * a present value, `pv`\n     * an interest `rate` compounded once per period, of which\n       there are\n     * `nper` total\n     * a (fixed) payment, `pmt`, paid either\n     * at the beginning (`when` = {'begin', 1}) or the end\n       (`when` = {'end', 0}) of each period\n\n    Return:\n       the value at the end of the `nper` periods\n\n    Parameters\n    ----------\n    rate : scalar or array_like of shape(M, )\n        Rate of interest as decimal (not per cent) per period\n    nper : scalar or array_like of shape(M, )\n        Number of compounding periods\n    pmt : scalar or array_like of shape(M, )\n        Payment\n    pv : scalar or array_like of shape(M, )\n        Present value\n    when : {{'begin', 1}, {'end', 0}}, {string, int}, optional\n        When payments are due ('begin' (1) or 'end' (0)).\n        Defaults to {'end', 0}.\n\n    Returns\n    -------\n    out : ndarray\n        Future values.  If all input is scalar, returns a scalar float.  If\n        any input is array_like, returns future values for each input element.\n        If multiple inputs are array_like, they all must have the same shape.\n\n    Notes\n    -----\n    The future value is computed by solving the equation::\n\n     fv +\n     pv*(1+rate)**nper +\n     pmt*(1 + rate*when)/rate*((1 + rate)**nper - 1) == 0\n\n    or, when ``rate == 0``::\n\n     fv + pv + pmt * nper == 0\n\n    References\n    ----------\n    .. [WRW] Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May).\n       Open Document Format for Office Applications (OpenDocument)v1.2,\n       Part 2: Recalculated Formula (OpenFormula) Format - Annotated Version,\n       Pre-Draft 12. Organization for the Advancement of Structured Information\n       Standards (OASIS). Billerica, MA, USA. [ODT Document].\n       Available:\n       http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula\n       OpenDocument-formula-20090508.odt\n\n    Example""s\n    --------\n    What is the future value after 10 years of saving $100 now, with\n    an additional monthly savings of $100.  Assume the interest rate is\n    5% (annually) compounded monthly?\n\n    >>> np.fv(0.05/12, 10*12, -100, -100)\n    15692.928894335748\n\n    By convention, the negative sign represents cash flow out (i.e. money not\n    available today).  Thus, saving $100 a month at 5% annual interest leads\n    to $15,692.93 available to spend in 10 years.\n\n    If any input is array_like, returns an array of equal shape.  Let's\n    compare different interest rates from the example above.\n\n    >>> a = np.array((0.05, 0.06, 0.07))/12\n    >>> np.fv(a, 10*12, -100, -100)\n    array([ 15692.92889434,  16569.87435405,  17509.44688102])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_181fv = {__Pyx_NAMESTR("fv"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_181fv, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_180fv)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_181fv(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_rate = 0;
  CYTHON_UNUSED PyObject *__pyx_v_nper = 0;
  CYTHON_UNUSED PyObject *__pyx_v_pmt = 0;
  CYTHON_UNUSED PyObject *__pyx_v_pv = 0;
  CYTHON_UNUSED PyObject *__pyx_v_when = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("fv (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__rate,&__pyx_n_s__nper,&__pyx_n_s__pmt,&__pyx_n_s__pv,&__pyx_n_s__when,0};
    PyObject* values[5] = {0,0,0,0,0};
    values[4] = ((PyObject *)__pyx_n_s__end);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__rate)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__nper)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("fv", 0, 4, 5, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4513; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__pmt)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("fv", 0, 4, 5, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4513; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__pv)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("fv", 0, 4, 5, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4513; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__when);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "fv") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4513; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_rate = values[0];
    __pyx_v_nper = values[1];
    __pyx_v_pmt = values[2];
    __pyx_v_pv = values[3];
    __pyx_v_when = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("fv", 0, 4, 5, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4513; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.fv", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_180fv(__pyx_self, __pyx_v_rate, __pyx_v_nper, __pyx_v_pmt, __pyx_v_pv, __pyx_v_when);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":4513
 * 
 * 
 * def fv(rate, nper, pmt, pv, when='end'):             # <<<<<<<<<<<<<<
 *     """Compute the future value.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_180fv(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_rate, CYTHON_UNUSED PyObject *__pyx_v_nper, CYTHON_UNUSED PyObject *__pyx_v_pmt, CYTHON_UNUSED PyObject *__pyx_v_pv, CYTHON_UNUSED PyObject *__pyx_v_when) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("fv", 0);

  /* "ga4py/gain/notimplemented.pyx":4593
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4593; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.fv", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_183genfromtxt(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_182genfromtxt[] = "Load data from a text file, with missing values handled as specified.\n\n    Each line past the first `skip_header` lines is split at the `delimiter`\n    character, and characters following the `comments` character are discarded.\n\n    Parameters\n    ----------\n    fname : file or str\n        File, filename, or generator to read.  If the filename extension is\n        `.gz` or `.bz2`, the file is first decompressed. Note that\n        generators must return byte strings in Python 3k.\n    dtype : dtype, optional\n        Data type of the resulting array.\n        If None, the dtypes will be determined by the contents of each\n        column, individually.\n    comments : str, optional\n        The character used to indicate the start of a comment.\n        All the characters occurring on a line after a comment are discarded\n    delimiter : str, int, or sequence, optional\n        The string used to separate values.  By default, any consecutive\n        whitespaces act as delimiter.  An integer or sequence of integers\n        can also be provided as width(s) of each field.\n    skip_header : int, optional\n        The numbers of lines to skip at the beginning of the file.\n    skip_footer : int, optional\n        The numbers of lines to skip at the end of the file\n    converters : variable, optional\n        The set of functions that convert the data of a column to a value.\n        The converters can also be used to provide a default value\n        for missing data: ``converters = {3: lambda s: float(s or 0)}``.\n    missing_values : variable, optional\n        The set of strings corresponding to missing data.\n    filling_values : variable, optional\n        The set of values to be used as default when the data are missing.\n    usecols : sequence, optional\n        Which columns to read, with 0 being the first.  For example,\n        ``usecols = (1, 4, 5)`` will extract the 2nd, 5th and 6th columns.\n    names : {None, True, str, sequence}, optional\n     ""   If `names` is True, the field names are read from the first valid line\n        after the first `skip_header` lines.\n        If `names` is a sequence or a single-string of comma-separated names,\n        the names will be used to define the field names in a structured dtype.\n        If `names` is None, the names of the dtype fields will be used, if any.\n    excludelist : sequence, optional\n        A list of names to exclude. This list is appended to the default list\n        ['return','file','print']. Excluded names are appended an underscore:\n        for example, `file` would become `file_`.\n    deletechars : str, optional\n        A string combining invalid characters that must be deleted from the\n        names.\n    defaultfmt : str, optional\n        A format used to define default field names, such as \"f%i\" or \"f_%02i\".\n    autostrip : bool, optional\n        Whether to automatically strip white spaces from the variables.\n    replace_space : char, optional\n        Character(s) used in replacement of white spaces in the variables names.\n        By default, use a '_'.\n    case_sensitive : {True, False, 'upper', 'lower'}, optional\n        If True, field names are case sensitive.\n        If False or 'upper', field names are converted to upper case.\n        If 'lower', field names are converted to lower case.\n    unpack : bool, optional\n        If True, the returned array is transposed, so that arguments may be\n        unpacked using ``x, y, z = loadtxt(...)``\n    usemask : bool, optional\n        If True, return a masked array.\n        If False, return a regular array.\n    invalid_raise : bool, optional\n        If True, an exception is raised if an inconsistency is detected in the\n        number of columns.\n        If False, a warning is emitted and the offending lines are skipped.\n\n    Returns\n    -------\n    out : ndarray\n        Data read from the text file. If `usemask` is True, this is a\n        masked array.\n\n    See Als""o\n    --------\n    numpy.loadtxt : equivalent function when no data is missing.\n\n    Notes\n    -----\n    * When spaces are used as delimiters, or when no delimiter has been given\n      as input, there should not be any missing data between two fields.\n    * When the variables are named (either by a flexible dtype or with `names`,\n      there must not be any header in the file (else a ValueError\n      exception is raised).\n    * Individual values are not stripped of spaces by default.\n      When using a custom converter, make sure the function does remove spaces.\n\n    Examples\n    ---------\n    >>> from StringIO import StringIO\n    >>> import numpy as np\n\n    Comma delimited file with mixed dtype\n\n    >>> s = StringIO(\"1,1.3,abcde\")\n    >>> data = np.genfromtxt(s, dtype=[('myint','i8'),('myfloat','f8'),\n    ... ('mystring','S5')], delimiter=\",\")\n    >>> data\n    array((1, 1.3, 'abcde'),\n          dtype=[('myint', '<i8'), ('myfloat', '<f8'), ('mystring', '|S5')])\n\n    Using dtype = None\n\n    >>> s.seek(0) # needed for StringIO example only\n    >>> data = np.genfromtxt(s, dtype=None,\n    ... names = ['myint','myfloat','mystring'], delimiter=\",\")\n    >>> data\n    array((1, 1.3, 'abcde'),\n          dtype=[('myint', '<i8'), ('myfloat', '<f8'), ('mystring', '|S5')])\n\n    Specifying dtype and names\n\n    >>> s.seek(0)\n    >>> data = np.genfromtxt(s, dtype=\"i8,f8,S5\",\n    ... names=['myint','myfloat','mystring'], delimiter=\",\")\n    >>> data\n    array((1, 1.3, 'abcde'),\n          dtype=[('myint', '<i8'), ('myfloat', '<f8'), ('mystring', '|S5')])\n\n    An example with fixed-width columns\n\n    >>> s = StringIO(\"11.3abcde\")\n    >>> data = np.genfromtxt(s, dtype=None, names=['intvar','fltvar','strvar'],\n    ...     delimiter=[1,3,5])\n    >>> data\n    array((1, 1.3, 'abcde'),\n          dtype=[('intvar', '<i8'), ('fltvar', '<f8'), ('strvar', '|S5')])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_183genfromtxt = {__Pyx_NAMESTR("genfromtxt"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_183genfromtxt, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_182genfromtxt)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_183genfromtxt(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_fname = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  CYTHON_UNUSED PyObject *__pyx_v_comments = 0;
  CYTHON_UNUSED PyObject *__pyx_v_delimiter = 0;
  CYTHON_UNUSED PyObject *__pyx_v_skiprows = 0;
  CYTHON_UNUSED PyObject *__pyx_v_skip_header = 0;
  CYTHON_UNUSED PyObject *__pyx_v_skip_footer = 0;
  CYTHON_UNUSED PyObject *__pyx_v_converters = 0;
  CYTHON_UNUSED PyObject *__pyx_v_missing = 0;
  CYTHON_UNUSED PyObject *__pyx_v_missing_values = 0;
  CYTHON_UNUSED PyObject *__pyx_v_filling_values = 0;
  CYTHON_UNUSED PyObject *__pyx_v_usecols = 0;
  CYTHON_UNUSED PyObject *__pyx_v_names = 0;
  CYTHON_UNUSED PyObject *__pyx_v_excludelist = 0;
  CYTHON_UNUSED PyObject *__pyx_v_deletechars = 0;
  CYTHON_UNUSED PyObject *__pyx_v_replace_space = 0;
  CYTHON_UNUSED PyObject *__pyx_v_autostrip = 0;
  CYTHON_UNUSED PyObject *__pyx_v_case_sensitive = 0;
  CYTHON_UNUSED PyObject *__pyx_v_defaultfmt = 0;
  CYTHON_UNUSED PyObject *__pyx_v_unpack = 0;
  CYTHON_UNUSED PyObject *__pyx_v_usemask = 0;
  CYTHON_UNUSED PyObject *__pyx_v_loose = 0;
  CYTHON_UNUSED PyObject *__pyx_v_invalid_raise = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("genfromtxt (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__fname,&__pyx_n_s__dtype,&__pyx_n_s__comments,&__pyx_n_s__delimiter,&__pyx_n_s__skiprows,&__pyx_n_s__skip_header,&__pyx_n_s__skip_footer,&__pyx_n_s__converters,&__pyx_n_s__missing,&__pyx_n_s__missing_values,&__pyx_n_s__filling_values,&__pyx_n_s__usecols,&__pyx_n_s__names,&__pyx_n_s__excludelist,&__pyx_n_s__deletechars,&__pyx_n_s__replace_space,&__pyx_n_s__autostrip,&__pyx_n_s__case_sensitive,&__pyx_n_s__defaultfmt,&__pyx_n_s__unpack,&__pyx_n_s__usemask,&__pyx_n_s__loose,&__pyx_n_s__invalid_raise,0};
    PyObject* values[23] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
    values[1] = __pyx_k_15;
    values[2] = ((PyObject *)__pyx_kp_s_16);

    /* "ga4py/gain/notimplemented.pyx":4596
 * 
 * 
 * def genfromtxt(fname, dtype=float, comments='#', delimiter=None, skiprows=0, skip_header=0, skip_footer=0, converters=None, missing='', missing_values=None, filling_values=None, usecols=None, names=None, excludelist=None, deletechars=None, replace_space='_', autostrip=False, case_sensitive=True, defaultfmt='f%i', unpack=None, usemask=False, loose=True, invalid_raise=True):             # <<<<<<<<<<<<<<
 *     """Load data from a text file, with missing values handled as specified.
 * 
 */
    values[3] = ((PyObject *)Py_None);
    values[4] = ((PyObject *)__pyx_int_0);
    values[5] = ((PyObject *)__pyx_int_0);
    values[6] = ((PyObject *)__pyx_int_0);
    values[7] = ((PyObject *)Py_None);
    values[8] = ((PyObject *)__pyx_kp_s_6);
    values[9] = ((PyObject *)Py_None);
    values[10] = ((PyObject *)Py_None);
    values[11] = ((PyObject *)Py_None);
    values[12] = ((PyObject *)Py_None);
    values[13] = ((PyObject *)Py_None);
    values[14] = ((PyObject *)Py_None);
    values[15] = ((PyObject *)__pyx_n_s___);
    values[16] = __pyx_k_17;
    values[17] = __pyx_k_18;
    values[18] = ((PyObject *)__pyx_kp_s_19);
    values[19] = ((PyObject *)Py_None);
    values[20] = __pyx_k_20;
    values[21] = __pyx_k_21;
    values[22] = __pyx_k_22;
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case 23: values[22] = PyTuple_GET_ITEM(__pyx_args, 22);
        case 22: values[21] = PyTuple_GET_ITEM(__pyx_args, 21);
        case 21: values[20] = PyTuple_GET_ITEM(__pyx_args, 20);
        case 20: values[19] = PyTuple_GET_ITEM(__pyx_args, 19);
        case 19: values[18] = PyTuple_GET_ITEM(__pyx_args, 18);
        case 18: values[17] = PyTuple_GET_ITEM(__pyx_args, 17);
        case 17: values[16] = PyTuple_GET_ITEM(__pyx_args, 16);
        case 16: values[15] = PyTuple_GET_ITEM(__pyx_args, 15);
        case 15: values[14] = PyTuple_GET_ITEM(__pyx_args, 14);
        case 14: values[13] = PyTuple_GET_ITEM(__pyx_args, 13);
        case 13: values[12] = PyTuple_GET_ITEM(__pyx_args, 12);
        case 12: values[11] = PyTuple_GET_ITEM(__pyx_args, 11);
        case 11: values[10] = PyTuple_GET_ITEM(__pyx_args, 10);
        case 10: values[9] = PyTuple_GET_ITEM(__pyx_args, 9);
        case  9: values[8] = PyTuple_GET_ITEM(__pyx_args, 8);
        case  8: values[7] = PyTuple_GET_ITEM(__pyx_args, 7);
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__fname)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__dtype);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__comments);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__delimiter);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__skiprows);
          if (value) { values[4] = value; kw_args--; }
        }
        case  5:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__skip_header);
          if (value) { values[5] = value; kw_args--; }
        }
        case  6:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__skip_footer);
          if (value) { values[6] = value; kw_args--; }
        }
        case  7:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__converters);
          if (value) { values[7] = value; kw_args--; }
        }
        case  8:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__missing);
          if (value) { values[8] = value; kw_args--; }
        }
        case  9:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__missing_values);
          if (value) { values[9] = value; kw_args--; }
        }
        case 10:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__filling_values);
          if (value) { values[10] = value; kw_args--; }
        }
        case 11:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__usecols);
          if (value) { values[11] = value; kw_args--; }
        }
        case 12:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__names);
          if (value) { values[12] = value; kw_args--; }
        }
        case 13:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__excludelist);
          if (value) { values[13] = value; kw_args--; }
        }
        case 14:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__deletechars);
          if (value) { values[14] = value; kw_args--; }
        }
        case 15:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__replace_space);
          if (value) { values[15] = value; kw_args--; }
        }
        case 16:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__autostrip);
          if (value) { values[16] = value; kw_args--; }
        }
        case 17:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__case_sensitive);
          if (value) { values[17] = value; kw_args--; }
        }
        case 18:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__defaultfmt);
          if (value) { values[18] = value; kw_args--; }
        }
        case 19:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__unpack);
          if (value) { values[19] = value; kw_args--; }
        }
        case 20:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__usemask);
          if (value) { values[20] = value; kw_args--; }
        }
        case 21:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__loose);
          if (value) { values[21] = value; kw_args--; }
        }
        case 22:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__invalid_raise);
          if (value) { values[22] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "genfromtxt") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4596; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case 23: values[22] = PyTuple_GET_ITEM(__pyx_args, 22);
        case 22: values[21] = PyTuple_GET_ITEM(__pyx_args, 21);
        case 21: values[20] = PyTuple_GET_ITEM(__pyx_args, 20);
        case 20: values[19] = PyTuple_GET_ITEM(__pyx_args, 19);
        case 19: values[18] = PyTuple_GET_ITEM(__pyx_args, 18);
        case 18: values[17] = PyTuple_GET_ITEM(__pyx_args, 17);
        case 17: values[16] = PyTuple_GET_ITEM(__pyx_args, 16);
        case 16: values[15] = PyTuple_GET_ITEM(__pyx_args, 15);
        case 15: values[14] = PyTuple_GET_ITEM(__pyx_args, 14);
        case 14: values[13] = PyTuple_GET_ITEM(__pyx_args, 13);
        case 13: values[12] = PyTuple_GET_ITEM(__pyx_args, 12);
        case 12: values[11] = PyTuple_GET_ITEM(__pyx_args, 11);
        case 11: values[10] = PyTuple_GET_ITEM(__pyx_args, 10);
        case 10: values[9] = PyTuple_GET_ITEM(__pyx_args, 9);
        case  9: values[8] = PyTuple_GET_ITEM(__pyx_args, 8);
        case  8: values[7] = PyTuple_GET_ITEM(__pyx_args, 7);
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_fname = values[0];
    __pyx_v_dtype = values[1];
    __pyx_v_comments = values[2];
    __pyx_v_delimiter = values[3];
    __pyx_v_skiprows = values[4];
    __pyx_v_skip_header = values[5];
    __pyx_v_skip_footer = values[6];
    __pyx_v_converters = values[7];
    __pyx_v_missing = values[8];
    __pyx_v_missing_values = values[9];
    __pyx_v_filling_values = values[10];
    __pyx_v_usecols = values[11];
    __pyx_v_names = values[12];
    __pyx_v_excludelist = values[13];
    __pyx_v_deletechars = values[14];
    __pyx_v_replace_space = values[15];
    __pyx_v_autostrip = values[16];
    __pyx_v_case_sensitive = values[17];
    __pyx_v_defaultfmt = values[18];
    __pyx_v_unpack = values[19];
    __pyx_v_usemask = values[20];
    __pyx_v_loose = values[21];
    __pyx_v_invalid_raise = values[22];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("genfromtxt", 0, 1, 23, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4596; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.genfromtxt", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_182genfromtxt(__pyx_self, __pyx_v_fname, __pyx_v_dtype, __pyx_v_comments, __pyx_v_delimiter, __pyx_v_skiprows, __pyx_v_skip_header, __pyx_v_skip_footer, __pyx_v_converters, __pyx_v_missing, __pyx_v_missing_values, __pyx_v_filling_values, __pyx_v_usecols, __pyx_v_names, __pyx_v_excludelist, __pyx_v_deletechars, __pyx_v_replace_space, __pyx_v_autostrip, __pyx_v_case_sensitive, __pyx_v_defaultfmt, __pyx_v_unpack, __pyx_v_usemask, __pyx_v_loose, __pyx_v_invalid_raise);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_182genfromtxt(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_fname, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_comments, CYTHON_UNUSED PyObject *__pyx_v_delimiter, CYTHON_UNUSED PyObject *__pyx_v_skiprows, CYTHON_UNUSED PyObject *__pyx_v_skip_header, CYTHON_UNUSED PyObject *__pyx_v_skip_footer, CYTHON_UNUSED PyObject *__pyx_v_converters, CYTHON_UNUSED PyObject *__pyx_v_missing, CYTHON_UNUSED PyObject *__pyx_v_missing_values, CYTHON_UNUSED PyObject *__pyx_v_filling_values, CYTHON_UNUSED PyObject *__pyx_v_usecols, CYTHON_UNUSED PyObject *__pyx_v_names, CYTHON_UNUSED PyObject *__pyx_v_excludelist, CYTHON_UNUSED PyObject *__pyx_v_deletechars, CYTHON_UNUSED PyObject *__pyx_v_replace_space, CYTHON_UNUSED PyObject *__pyx_v_autostrip, CYTHON_UNUSED PyObject *__pyx_v_case_sensitive, CYTHON_UNUSED PyObject *__pyx_v_defaultfmt, CYTHON_UNUSED PyObject *__pyx_v_unpack, CYTHON_UNUSED PyObject *__pyx_v_usemask, CYTHON_UNUSED PyObject *__pyx_v_loose, CYTHON_UNUSED PyObject *__pyx_v_invalid_raise) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("genfromtxt", 0);

  /* "ga4py/gain/notimplemented.pyx":4731
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4731; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.genfromtxt", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_185get_array_wrap(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_184get_array_wrap[] = "Find the wrapper for the array with the highest priority.\n\n    In case of ties, leftmost wins. If no wrapper is found, return None\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_185get_array_wrap = {__Pyx_NAMESTR("get_array_wrap"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_185get_array_wrap, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_184get_array_wrap)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_185get_array_wrap(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("get_array_wrap (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_184get_array_wrap(__pyx_self);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":4734
 * 
 * 
 * def get_array_wrap():             # <<<<<<<<<<<<<<
 *     """Find the wrapper for the array with the highest priority.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_184get_array_wrap(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("get_array_wrap", 0);

  /* "ga4py/gain/notimplemented.pyx":4740
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4740; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.get_array_wrap", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_187get_include(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_186get_include[] = "Return the directory that contains the NumPy \\*.h header files.\n\n    Extension modules that need to compile against NumPy should use this\n    function to locate the appropriate include directory.\n\n    Notes\n    -----\n    When using ``distutils``, for example in ``setup.py``.\n    ::\n\n        import numpy as np\n        ...\n        Extension('extension_name', ...\n                include_dirs=[np.get_include()])\n        ...\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_187get_include = {__Pyx_NAMESTR("get_include"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_187get_include, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_186get_include)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_187get_include(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("get_include (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_186get_include(__pyx_self);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":4743
 * 
 * 
 * def get_include():             # <<<<<<<<<<<<<<
 *     """Return the directory that contains the NumPy \*.h header files.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_186get_include(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("get_include", 0);

  /* "ga4py/gain/notimplemented.pyx":4761
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4761; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.get_include", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_189get_numarray_include(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_188get_numarray_include[] = "Return the directory that contains the numarray \\*.h header files.\n\n    Extension modules that need to compile against numarray should use this\n    function to locate the appropriate include directory.\n\n    Parameters\n    ----------\n    type : any, optional\n        If `type` is not None, the location of the NumPy headers is returned\n        as well.\n\n    Returns\n    -------\n    dirs : str or list of str\n        If `type` is None, `dirs` is a string containing the path to the\n        numarray headers.\n        If `type` is not None, `dirs` is a list of strings with first the\n        path(s) to the numarray headers, followed by the path to the NumPy\n        headers.\n\n    Notes\n    -----\n    Useful when using ``distutils``, for example in ``setup.py``.\n    ::\n\n        import numpy as np\n        ...\n        Extension('extension_name', ...\n                include_dirs=[np.get_numarray_include()])\n        ...\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_189get_numarray_include = {__Pyx_NAMESTR("get_numarray_include"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_189get_numarray_include, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_188get_numarray_include)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_189get_numarray_include(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_type = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("get_numarray_include (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__type,0};
    PyObject* values[1] = {0};

    /* "ga4py/gain/notimplemented.pyx":4764
 * 
 * 
 * def get_numarray_include(type=None):             # <<<<<<<<<<<<<<
 *     """Return the directory that contains the numarray \*.h header files.
 * 
 */
    values[0] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__type);
          if (value) { values[0] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "get_numarray_include") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4764; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_type = values[0];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("get_numarray_include", 0, 0, 1, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4764; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.get_numarray_include", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_188get_numarray_include(__pyx_self, __pyx_v_type);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_188get_numarray_include(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_type) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("get_numarray_include", 0);

  /* "ga4py/gain/notimplemented.pyx":4797
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4797; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.get_numarray_include", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_191get_printoptions(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_190get_printoptions[] = "Return the current print options.\n\n    Returns\n    -------\n    print_opts : dict\n        Dictionary of current print options with keys\n\n          - precision : int\n          - threshold : int\n          - edgeitems : int\n          - linewidth : int\n          - suppress : bool\n          - nanstr : str\n          - infstr : str\n\n        For a full description of these options, see `set_printoptions`.\n\n    See Also\n    --------\n    set_printoptions, set_string_function\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_191get_printoptions = {__Pyx_NAMESTR("get_printoptions"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_191get_printoptions, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_190get_printoptions)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_191get_printoptions(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("get_printoptions (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_190get_printoptions(__pyx_self);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":4800
 * 
 * 
 * def get_printoptions():             # <<<<<<<<<<<<<<
 *     """Return the current print options.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_190get_printoptions(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("get_printoptions", 0);

  /* "ga4py/gain/notimplemented.pyx":4823
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4823; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.get_printoptions", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_193getbuffer(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_192getbuffer[] = "getbuffer(obj [,offset[, size]])\n\n    Create a buffer object from the given object referencing a slice of\n    length size starting at offset.\n\n    Default is the entire buffer. A read-write buffer is attempted followed\n    by a read-only buffer.\n\n    Parameters\n    ----------\n    obj : object\n\n    offset : int, optional\n\n    size : int, optional\n\n    Returns\n    -------\n    buffer_obj : buffer\n\n    Examples\n    --------\n    >>> buf = np.getbuffer(np.ones(5), 1, 3)\n    >>> len(buf)\n    3\n    >>> buf[0]\n    '\000'\n    >>> buf\n    <read-write buffer for 0x8af1e70, size 3, offset 1 at 0x8ba4ec0>\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_193getbuffer = {__Pyx_NAMESTR("getbuffer"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_193getbuffer, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_192getbuffer)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_193getbuffer(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getbuffer (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_192getbuffer(__pyx_self);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":4826
 * 
 * 
 * def getbuffer():             # <<<<<<<<<<<<<<
 *     """getbuffer(obj [,offset[, size]])
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_192getbuffer(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("getbuffer", 0);

  /* "ga4py/gain/notimplemented.pyx":4859
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4859; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.getbuffer", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_195getbufsize(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_194getbufsize[] = "Return the size of the buffer used in ufuncs.\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_195getbufsize = {__Pyx_NAMESTR("getbufsize"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_195getbufsize, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_194getbufsize)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_195getbufsize(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getbufsize (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_194getbufsize(__pyx_self);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":4862
 * 
 * 
 * def getbufsize():             # <<<<<<<<<<<<<<
 *     """Return the size of the buffer used in ufuncs.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_194getbufsize(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("getbufsize", 0);

  /* "ga4py/gain/notimplemented.pyx":4866
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4866; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.getbufsize", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_197geterr(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_196geterr[] = "Get the current way of handling floating-point errors.\n\n    Returns\n    -------\n    res : dict\n        A dictionary with keys \"divide\", \"over\", \"under\", and \"invalid\",\n        whose values are from the strings \"ignore\", \"print\", \"log\", \"warn\",\n        \"raise\", and \"call\". The keys represent possible floating-point\n        exceptions, and the values define how these exceptions are handled.\n\n    See Also\n    --------\n    geterrcall, seterr, seterrcall\n\n    Notes\n    -----\n    For complete documentation of the types of floating-point exceptions and\n    treatment options, see `seterr`.\n\n    Examples\n    --------\n    >>> np.geterr()\n    {'over': 'warn', 'divide': 'warn', 'invalid': 'warn',\n    'under': 'ignore'}\n    >>> np.arange(3.) / np.arange(3.)\n    array([ NaN,   1.,   1.])\n\n    >>> oldsettings = np.seterr(all='warn', over='raise')\n    >>> np.geterr()\n    {'over': 'raise', 'divide': 'warn', 'invalid': 'warn', 'under': 'warn'}\n    >>> np.arange(3.) / np.arange(3.)\n    __main__:1: RuntimeWarning: invalid value encountered in divide\n    array([ NaN,   1.,   1.])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_197geterr = {__Pyx_NAMESTR("geterr"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_197geterr, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_196geterr)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_197geterr(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("geterr (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_196geterr(__pyx_self);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":4869
 * 
 * 
 * def geterr():             # <<<<<<<<<<<<<<
 *     """Get the current way of handling floating-point errors.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_196geterr(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("geterr", 0);

  /* "ga4py/gain/notimplemented.pyx":4905
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4905; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.geterr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_199geterrcall(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_198geterrcall[] = "Return the current callback function used on floating-point errors.\n\n    When the error handling for a floating-point error (one of \"divide\",\n    \"over\", \"under\", or \"invalid\") is set to 'call' or 'log', the function\n    that is called or the log instance that is written to is returned by\n    `geterrcall`. This function or log instance has been set with\n    `seterrcall`.\n\n    Returns\n    -------\n    errobj : callable, log instance or None\n        The current error handler. If no handler was set through `seterrcall`,\n        ``None`` is returned.\n\n    See Also\n    --------\n    seterrcall, seterr, geterr\n\n    Notes\n    -----\n    For complete documentation of the types of floating-point exceptions and\n    treatment options, see `seterr`.\n\n    Examples\n    --------\n    >>> np.geterrcall()  # we did not yet set a handler, returns None\n\n    >>> oldsettings = np.seterr(all='call')\n    >>> def err_handler(type, flag):\n    ...     print \"Floating point error (%s), with flag %s\" % (type, flag)\n    >>> oldhandler = np.seterrcall(err_handler)\n    >>> np.array([1, 2, 3]) / 0.0\n    Floating point error (divide by zero), with flag 1\n    array([ Inf,  Inf,  Inf])\n\n    >>> cur_handler = np.geterrcall()\n    >>> cur_handler is err_handler\n    True\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_199geterrcall = {__Pyx_NAMESTR("geterrcall"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_199geterrcall, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_198geterrcall)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_199geterrcall(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("geterrcall (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_198geterrcall(__pyx_self);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":4908
 * 
 * 
 * def geterrcall():             # <<<<<<<<<<<<<<
 *     """Return the current callback function used on floating-point errors.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_198geterrcall(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("geterrcall", 0);

  /* "ga4py/gain/notimplemented.pyx":4949
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4949; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.geterrcall", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_201geterrobj(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_200geterrobj[] = "geterrobj()\n\n    Return the current object that defines floating-point error handling.\n\n    The error object contains all information that defines the error handling\n    behavior in Numpy. `geterrobj` is used internally by the other\n    functions that get and set error handling behavior (`geterr`, `seterr`,\n    `geterrcall`, `seterrcall`).\n\n    Returns\n    -------\n    errobj : list\n        The error object, a list containing three elements:\n        [internal numpy buffer size, error mask, error callback function].\n\n        The error mask is a single integer that holds the treatment information\n        on all four floating point errors. The information for each error type\n        is contained in three bits of the integer. If we print it in base 8, we\n        can see what treatment is set for \"invalid\", \"under\", \"over\", and\n        \"divide\" (in that order). The printed string can be interpreted with\n\n        * 0 : 'ignore'\n        * 1 : 'warn'\n        * 2 : 'raise'\n        * 3 : 'call'\n        * 4 : 'print'\n        * 5 : 'log'\n\n    See Also\n    --------\n    seterrobj, seterr, geterr, seterrcall, geterrcall\n    getbufsize, setbufsize\n\n    Notes\n    -----\n    For complete documentation of the types of floating-point exceptions and\n    treatment options, see `seterr`.\n\n    Examples\n    --------\n    >>> np.geterrobj()  # first get the defaults\n    [10000, 0, None]\n\n    >>> def err_handler(type, flag):\n    ...     print \"Floating point error (%s), with flag %s\" % (type, flag)\n    ...\n    >>> old_bufsize = np.setbufsize(20000)\n    >>> old_err = np.seterr(divide='raise')\n    >>> old_handler = np.seterrcall(err_handler)\n    >>> np.geterrobj()\n    [20000, 2, <function err_handler at 0x91dcaac>]\n\n    >>> old_err = np.seterr(all='ignore')\n    >>> np.base_repr(np.geterrobj()[1], 8)\n    '0'\n    >>> old_err = np.seterr(divide='warn', over='log', under='call',\n                            invalid='print')\n    >>> np.b""ase_repr(np.geterrobj()[1], 8)\n    '4351'\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_201geterrobj = {__Pyx_NAMESTR("geterrobj"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_201geterrobj, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_200geterrobj)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_201geterrobj(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("geterrobj (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_200geterrobj(__pyx_self);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":4952
 * 
 * 
 * def geterrobj():             # <<<<<<<<<<<<<<
 *     """geterrobj()
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_200geterrobj(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("geterrobj", 0);

  /* "ga4py/gain/notimplemented.pyx":5015
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5015; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.geterrobj", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_203gradient(PyObject *__pyx_self, PyObject *__pyx_v_f); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_202gradient[] = "Return the gradient of an N-dimensional array.\n\n    The gradient is computed using central differences in the interior\n    and first differences at the boundaries. The returned gradient hence has\n    the same shape as the input array.\n\n    Parameters\n    ----------\n    f : array_like\n      An N-dimensional array containing samples of a scalar function.\n    `*varargs` : scalars\n      0, 1, or N scalars specifying the sample distances in each direction,\n      that is: `dx`, `dy`, `dz`, ... The default distance is 1.\n\n\n    Returns\n    -------\n    g : ndarray\n      N arrays of the same shape as `f` giving the derivative of `f` with\n      respect to each dimension.\n\n    Examples\n    --------\n    >>> x = np.array([1, 2, 4, 7, 11, 16], dtype=np.float)\n    >>> np.gradient(x)\n    array([ 1. ,  1.5,  2.5,  3.5,  4.5,  5. ])\n    >>> np.gradient(x, 2)\n    array([ 0.5 ,  0.75,  1.25,  1.75,  2.25,  2.5 ])\n\n    >>> np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=np.float))\n    [array([[ 2.,  2., -1.],\n           [ 2.,  2., -1.]]),\n    array([[ 1. ,  2.5,  4. ],\n           [ 1. ,  1. ,  1. ]])]\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_203gradient = {__Pyx_NAMESTR("gradient"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_203gradient, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_202gradient)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_203gradient(PyObject *__pyx_self, PyObject *__pyx_v_f) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("gradient (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_202gradient(__pyx_self, ((PyObject *)__pyx_v_f));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":5018
 * 
 * 
 * def gradient(f):             # <<<<<<<<<<<<<<
 *     """Return the gradient of an N-dimensional array.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_202gradient(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_f) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("gradient", 0);

  /* "ga4py/gain/notimplemented.pyx":5055
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5055; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.gradient", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_205hamming(PyObject *__pyx_self, PyObject *__pyx_v_M); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_204hamming[] = "Return the Hamming window.\n\n    The Hamming window is a taper formed by using a weighted cosine.\n\n    Parameters\n    ----------\n    M : int\n        Number of points in the output window. If zero or less, an\n        empty array is returned.\n\n    Returns\n    -------\n    out : ndarray\n        The window, normalized to one (the value one\n        appears only if the number of samples is odd).\n\n    See Also\n    --------\n    bartlett, blackman, hanning, kaiser\n\n    Notes\n    -----\n    The Hamming window is defined as\n\n    .. math::  w(n) = 0.54 + 0.46cos\\left(\014rac{2\\pi{n}}{M-1}\right)\n               \\qquad 0 \\leq n \\leq M-1\n\n    The Hamming was named for R. W. Hamming, an associate of J. W. Tukey and\n    is described in Blackman and Tukey. It was recommended for smoothing the\n    truncated autocovariance function in the time domain.\n    Most references to the Hamming window come from the signal processing\n    literature, where it is used as one of many windowing functions for\n    smoothing values.  It is also known as an apodization (which means\n    \"removing the foot\", i.e. smoothing discontinuities at the beginning\n    and end of the sampled signal) or tapering function.\n\n    References\n    ----------\n    .. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power\n           spectra, Dover Publications, New York.\n    .. [2] E.R. Kanasewich, \"Time Sequence Analysis in Geophysics\", The\n           University of Alberta Press, 1975, pp. 109-110.\n    .. [3] Wikipedia, \"Window function\",\n           http://en.wikipedia.org/wiki/Window_function\n    .. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,\n           \"Numerical Recipes\", Cambridge University Press, 1986, page 425.\n\n    Examples\n    --------\n    >>> np.hamming(12)\n    array([ 0.08      ,  0.15302337,  0.34890909,  0.60546483,  0.84123594,\n            0.98136677,  0.98136677,  0.84123594,  0.60546483,  0.34890909,\n         ""   0.15302337,  0.08      ])\n\n    Plot the window and the frequency response:\n\n    >>> from numpy.fft import fft, fftshift\n    >>> import matplotlib.pyplot as plt\n\n    >>> window = np.hamming(51)\n    >>> plt.plot(window)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Hamming window\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.ylabel(\"Amplitude\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.xlabel(\"Sample\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.show()\n\n    >>> plt.figure()\n    <matplotlib.figure.Figure object at 0x...>\n    >>> A = fft(window, 2048) / 25.5\n    >>> mag = np.abs(fftshift(A))\n    >>> freq = np.linspace(-0.5, 0.5, len(A))\n    >>> response = 20 * np.log10(mag)\n    >>> response = np.clip(response, -100, 100)\n    >>> plt.plot(freq, response)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Frequency response of Hamming window\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.ylabel(\"Magnitude [dB]\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.xlabel(\"Normalized frequency [cycles per sample]\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.axis('tight')\n    (-0.5, 0.5, -100.0, ...)\n    >>> plt.show()\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_205hamming = {__Pyx_NAMESTR("hamming"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_205hamming, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_204hamming)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_205hamming(PyObject *__pyx_self, PyObject *__pyx_v_M) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("hamming (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_204hamming(__pyx_self, ((PyObject *)__pyx_v_M));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":5058
 * 
 * 
 * def hamming(M):             # <<<<<<<<<<<<<<
 *     """Return the Hamming window.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_204hamming(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_M) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("hamming", 0);

  /* "ga4py/gain/notimplemented.pyx":5149
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5149; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.hamming", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_207hanning(PyObject *__pyx_self, PyObject *__pyx_v_M); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_206hanning[] = "Return the Hanning window.\n\n    The Hanning window is a taper formed by using a weighted cosine.\n\n    Parameters\n    ----------\n    M : int\n        Number of points in the output window. If zero or less, an\n        empty array is returned.\n\n    Returns\n    -------\n    out : ndarray, shape(M,)\n        The window, normalized to one (the value one\n        appears only if `M` is odd).\n\n    See Also\n    --------\n    bartlett, blackman, hamming, kaiser\n\n    Notes\n    -----\n    The Hanning window is defined as\n\n    .. math::  w(n) = 0.5 - 0.5cos\\left(\014rac{2\\pi{n}}{M-1}\right)\n               \\qquad 0 \\leq n \\leq M-1\n\n    The Hanning was named for Julius van Hann, an Austrian meterologist. It is\n    also known as the Cosine Bell. Some authors prefer that it be called a\n    Hann window, to help avoid confusion with the very similar Hamming window.\n\n    Most references to the Hanning window come from the signal processing\n    literature, where it is used as one of many windowing functions for\n    smoothing values.  It is also known as an apodization (which means\n    \"removing the foot\", i.e. smoothing discontinuities at the beginning\n    and end of the sampled signal) or tapering function.\n\n    References\n    ----------\n    .. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power\n           spectra, Dover Publications, New York.\n    .. [2] E.R. Kanasewich, \"Time Sequence Analysis in Geophysics\",\n           The University of Alberta Press, 1975, pp. 106-108.\n    .. [3] Wikipedia, \"Window function\",\n           http://en.wikipedia.org/wiki/Window_function\n    .. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,\n           \"Numerical Recipes\", Cambridge University Press, 1986, page 425.\n\n    Examples\n    --------\n    >>> from numpy import hanning\n    >>> hanning(12)\n    array([ 0.        ,  0.07937323,  0.29229249,  0.57115742,  0.82743037,\n            0.97974649,  0.97974649,  0.""82743037,  0.57115742,  0.29229249,\n            0.07937323,  0.        ])\n\n    Plot the window and its frequency response:\n\n    >>> from numpy.fft import fft, fftshift\n    >>> import matplotlib.pyplot as plt\n\n    >>> window = np.hanning(51)\n    >>> plt.plot(window)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Hann window\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.ylabel(\"Amplitude\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.xlabel(\"Sample\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.show()\n\n    >>> plt.figure()\n    <matplotlib.figure.Figure object at 0x...>\n    >>> A = fft(window, 2048) / 25.5\n    >>> mag = abs(fftshift(A))\n    >>> freq = np.linspace(-0.5,0.5,len(A))\n    >>> response = 20*np.log10(mag)\n    >>> response = np.clip(response,-100,100)\n    >>> plt.plot(freq, response)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Frequency response of the Hann window\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.ylabel(\"Magnitude [dB]\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.xlabel(\"Normalized frequency [cycles per sample]\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.axis('tight')\n    (-0.5, 0.5, -100.0, ...)\n    >>> plt.show()\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_207hanning = {__Pyx_NAMESTR("hanning"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_207hanning, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_206hanning)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_207hanning(PyObject *__pyx_self, PyObject *__pyx_v_M) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("hanning (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_206hanning(__pyx_self, ((PyObject *)__pyx_v_M));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":5152
 * 
 * 
 * def hanning(M):             # <<<<<<<<<<<<<<
 *     """Return the Hanning window.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_206hanning(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_M) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("hanning", 0);

  /* "ga4py/gain/notimplemented.pyx":5245
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5245; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.hanning", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_209histogram(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_208histogram[] = "Compute the histogram of a set of data.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data. The histogram is computed over the flattened array.\n    bins : int or sequence of scalars, optional\n        If `bins` is an int, it defines the number of equal-width\n        bins in the given range (10, by default). If `bins` is a sequence,\n        it defines the bin edges, including the rightmost edge, allowing\n        for non-uniform bin widths.\n    range : (float, float), optional\n        The lower and upper range of the bins.  If not provided, range\n        is simply ``(a.min(), a.max())``.  Values outside the range are\n        ignored.\n    normed : bool, optional\n        This keyword is deprecated in Numpy 1.6 due to confusing/buggy\n        behavior. It will be removed in Numpy 2.0. Use the density keyword\n        instead.\n        If False, the result will contain the number of samples\n        in each bin.  If True, the result is the value of the\n        probability *density* function at the bin, normalized such that\n        the *integral* over the range is 1. Note that this latter behavior is\n        known to be buggy with unequal bin widths; use `density` instead.\n    weights : array_like, optional\n        An array of weights, of the same shape as `a`.  Each value in `a`\n        only contributes its associated weight towards the bin count\n        (instead of 1).  If `normed` is True, the weights are normalized,\n        so that the integral of the density over the range remains 1\n    density : bool, optional\n        If False, the result will contain the number of samples\n        in each bin.  If True, the result is the value of the\n        probability *density* function at the bin, normalized such that\n        the *integral* over the range is 1. Note that the sum of the\n        histogram values will not be equal to 1 unless bins of unity\n        width are chosen; it is not a probability *mass* function.\n        Overr""ides the `normed` keyword if given.\n\n    Returns\n    -------\n    hist : array\n        The values of the histogram. See `normed` and `weights` for a\n        description of the possible semantics.\n    bin_edges : array of dtype float\n        Return the bin edges ``(length(hist)+1)``.\n\n\n    See Also\n    --------\n    histogramdd, bincount, searchsorted, digitize\n\n    Notes\n    -----\n    All but the last (righthand-most) bin is half-open.  In other words, if\n    `bins` is::\n\n      [1, 2, 3, 4]\n\n    then the first bin is ``[1, 2)`` (including 1, but excluding 2) and the\n    second ``[2, 3)``.  The last bin, however, is ``[3, 4]``, which *includes*\n    4.\n\n    Examples\n    --------\n    >>> np.histogram([1, 2, 1], bins=[0, 1, 2, 3])\n    (array([0, 2, 1]), array([0, 1, 2, 3]))\n    >>> np.histogram(np.arange(4), bins=np.arange(5), density=True)\n    (array([ 0.25,  0.25,  0.25,  0.25]), array([0, 1, 2, 3, 4]))\n    >>> np.histogram([[1, 2, 1], [1, 0, 1]], bins=[0,1,2,3])\n    (array([1, 4, 1]), array([0, 1, 2, 3]))\n\n    >>> a = np.arange(5)\n    >>> hist, bin_edges = np.histogram(a, density=True)\n    >>> hist\n    array([ 0.5,  0. ,  0.5,  0. ,  0. ,  0.5,  0. ,  0.5,  0. ,  0.5])\n    >>> hist.sum()\n    2.4999999999999996\n    >>> np.sum(hist*np.diff(bin_edges))\n    1.0\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_209histogram = {__Pyx_NAMESTR("histogram"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_209histogram, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_208histogram)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_209histogram(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_bins = 0;
  CYTHON_UNUSED PyObject *__pyx_v_range = 0;
  CYTHON_UNUSED PyObject *__pyx_v_normed = 0;
  CYTHON_UNUSED PyObject *__pyx_v_weights = 0;
  CYTHON_UNUSED PyObject *__pyx_v_density = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("histogram (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__bins,&__pyx_n_s__range,&__pyx_n_s__normed,&__pyx_n_s__weights,&__pyx_n_s__density,0};
    PyObject* values[6] = {0,0,0,0,0,0};
    values[1] = ((PyObject *)__pyx_int_10);

    /* "ga4py/gain/notimplemented.pyx":5248
 * 
 * 
 * def histogram(a, bins=10, range=None, normed=False, weights=None, density=None):             # <<<<<<<<<<<<<<
 *     """Compute the histogram of a set of data.
 * 
 */
    values[2] = ((PyObject *)Py_None);
    values[3] = __pyx_k_23;
    values[4] = ((PyObject *)Py_None);
    values[5] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__bins);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__range);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__normed);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__weights);
          if (value) { values[4] = value; kw_args--; }
        }
        case  5:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__density);
          if (value) { values[5] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "histogram") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5248; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_bins = values[1];
    __pyx_v_range = values[2];
    __pyx_v_normed = values[3];
    __pyx_v_weights = values[4];
    __pyx_v_density = values[5];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("histogram", 0, 1, 6, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5248; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.histogram", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_208histogram(__pyx_self, __pyx_v_a, __pyx_v_bins, __pyx_v_range, __pyx_v_normed, __pyx_v_weights, __pyx_v_density);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_208histogram(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_bins, CYTHON_UNUSED PyObject *__pyx_v_range, CYTHON_UNUSED PyObject *__pyx_v_normed, CYTHON_UNUSED PyObject *__pyx_v_weights, CYTHON_UNUSED PyObject *__pyx_v_density) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("histogram", 0);

  /* "ga4py/gain/notimplemented.pyx":5330
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5330; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.histogram", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_211histogram2d(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_210histogram2d[] = "Compute the bi-dimensional histogram of two data samples.\n\n    Parameters\n    ----------\n    x : array_like, shape(N,)\n        A sequence of values to be histogrammed along the first dimension.\n    y : array_like, shape(M,)\n        A sequence of values to be histogrammed along the second dimension.\n    bins : int or [int, int] or array_like or [array, array], optional\n        The bin specification:\n\n          * If int, the number of bins for the two dimensions (nx=ny=bins).\n          * If [int, int], the number of bins in each dimension (nx, ny = bins).\n          * If array_like, the bin edges for the two dimensions (x_edges=y_edges=bins).\n          * If [array, array], the bin edges in each dimension (x_edges, y_edges = bins).\n\n    range : array_like, shape(2,2), optional\n        The leftmost and rightmost edges of the bins along each dimension\n        (if not specified explicitly in the `bins` parameters):\n        ``[[xmin, xmax], [ymin, ymax]]``. All values outside of this range\n        will be considered outliers and not tallied in the histogram.\n    normed : bool, optional\n        If False, returns the number of samples in each bin. If True, returns\n        the bin density, i.e. the bin count divided by the bin area.\n    weights : array_like, shape(N,), optional\n        An array of values ``w_i`` weighing each sample ``(x_i, y_i)``. Weights\n        are normalized to 1 if `normed` is True. If `normed` is False, the\n        values of the returned histogram are equal to the sum of the weights\n        belonging to the samples falling into each bin.\n\n    Returns\n    -------\n    H : ndarray, shape(nx, ny)\n        The bi-dimensional histogram of samples `x` and `y`. Values in `x`\n        are histogrammed along the first dimension and values in `y` are\n        histogrammed along the second dimension.\n    xedges : ndarray, shape(nx,)\n        The bin edges along the first dimension.\n    yedges : ndarray, shape(ny,)\n        The bin e""dges along the second dimension.\n\n    See Also\n    --------\n    histogram: 1D histogram\n    histogramdd: Multidimensional histogram\n\n    Notes\n    -----\n    When `normed` is True, then the returned histogram is the sample density,\n    defined such that:\n\n    .. math::\n      \\sum_{i=0}^{nx-1} \\sum_{j=0}^{ny-1} H_{i,j} \\Delta x_i \\Delta y_j = 1\n\n    where `H` is the histogram array and :math:`\\Delta x_i \\Delta y_i`\n    the area of bin `{i,j}`.\n\n    Please note that the histogram does not follow the Cartesian convention\n    where `x` values are on the abcissa and `y` values on the ordinate axis.\n    Rather, `x` is histogrammed along the first dimension of the array\n    (vertical), and `y` along the second dimension of the array (horizontal).\n    This ensures compatibility with `histogramdd`.\n\n    Examples\n    --------\n    >>> x, y = np.random.randn(2, 100)\n    >>> H, xedges, yedges = np.histogram2d(x, y, bins=(5, 8))\n    >>> H.shape, xedges.shape, yedges.shape\n    ((5, 8), (6,), (9,))\n\n    We can now use the Matplotlib to visualize this 2-dimensional histogram:\n\n    >>> extent = [yedges[0], yedges[-1], xedges[-1], xedges[0]]\n    >>> import matplotlib.pyplot as plt\n    >>> plt.imshow(H, extent=extent, interpolation='nearest')\n    <matplotlib.image.AxesImage object at ...>\n    >>> plt.colorbar()\n    <matplotlib.colorbar.Colorbar instance at ...>\n    >>> plt.show()\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_211histogram2d = {__Pyx_NAMESTR("histogram2d"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_211histogram2d, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_210histogram2d)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_211histogram2d(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_x = 0;
  CYTHON_UNUSED PyObject *__pyx_v_y = 0;
  CYTHON_UNUSED PyObject *__pyx_v_bins = 0;
  CYTHON_UNUSED PyObject *__pyx_v_range = 0;
  CYTHON_UNUSED PyObject *__pyx_v_normed = 0;
  CYTHON_UNUSED PyObject *__pyx_v_weights = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("histogram2d (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__x,&__pyx_n_s__y,&__pyx_n_s__bins,&__pyx_n_s__range,&__pyx_n_s__normed,&__pyx_n_s__weights,0};
    PyObject* values[6] = {0,0,0,0,0,0};
    values[2] = ((PyObject *)__pyx_int_10);

    /* "ga4py/gain/notimplemented.pyx":5333
 * 
 * 
 * def histogram2d(x, y, bins=10, range=None, normed=False, weights=None):             # <<<<<<<<<<<<<<
 *     """Compute the bi-dimensional histogram of two data samples.
 * 
 */
    values[3] = ((PyObject *)Py_None);
    values[4] = __pyx_k_24;
    values[5] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__x)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__y)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("histogram2d", 0, 2, 6, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5333; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__bins);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__range);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__normed);
          if (value) { values[4] = value; kw_args--; }
        }
        case  5:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__weights);
          if (value) { values[5] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "histogram2d") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5333; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_x = values[0];
    __pyx_v_y = values[1];
    __pyx_v_bins = values[2];
    __pyx_v_range = values[3];
    __pyx_v_normed = values[4];
    __pyx_v_weights = values[5];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("histogram2d", 0, 2, 6, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5333; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.histogram2d", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_210histogram2d(__pyx_self, __pyx_v_x, __pyx_v_y, __pyx_v_bins, __pyx_v_range, __pyx_v_normed, __pyx_v_weights);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_210histogram2d(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_y, CYTHON_UNUSED PyObject *__pyx_v_bins, CYTHON_UNUSED PyObject *__pyx_v_range, CYTHON_UNUSED PyObject *__pyx_v_normed, CYTHON_UNUSED PyObject *__pyx_v_weights) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("histogram2d", 0);

  /* "ga4py/gain/notimplemented.pyx":5415
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5415; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.histogram2d", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_213histogramdd(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_212histogramdd[] = "Compute the multidimensional histogram of some data.\n\n    Parameters\n    ----------\n    sample : array_like\n        The data to be histogrammed. It must be an (N,D) array or data\n        that can be converted to such. The rows of the resulting array\n        are the coordinates of points in a D dimensional polytope.\n    bins : sequence or int, optional\n        The bin specification:\n\n        * A sequence of arrays describing the bin edges along each dimension.\n        * The number of bins for each dimension (nx, ny, ... =bins)\n        * The number of bins for all dimensions (nx=ny=...=bins).\n\n    range : sequence, optional\n        A sequence of lower and upper bin edges to be used if the edges are\n        not given explicitely in `bins`. Defaults to the minimum and maximum\n        values along each dimension.\n    normed : bool, optional\n        If False, returns the number of samples in each bin. If True, returns\n        the bin density, ie, the bin count divided by the bin hypervolume.\n    weights : array_like (N,), optional\n        An array of values `w_i` weighing each sample `(x_i, y_i, z_i, ...)`.\n        Weights are normalized to 1 if normed is True. If normed is False, the\n        values of the returned histogram are equal to the sum of the weights\n        belonging to the samples falling into each bin.\n\n    Returns\n    -------\n    H : ndarray\n        The multidimensional histogram of sample x. See normed and weights for\n        the different possible semantics.\n    edges : list\n        A list of D arrays describing the bin edges for each dimension.\n\n    See Also\n    --------\n    histogram: 1-D histogram\n    histogram2d: 2-D histogram\n\n    Examples\n    --------\n    >>> r = np.random.randn(100,3)\n    >>> H, edges = np.histogramdd(r, bins = (5, 8, 4))\n    >>> H.shape, edges[0].size, edges[1].size, edges[2].size\n    ((5, 8, 4), 6, 9, 5)\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_213histogramdd = {__Pyx_NAMESTR("histogramdd"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_213histogramdd, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_212histogramdd)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_213histogramdd(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_sample = 0;
  CYTHON_UNUSED PyObject *__pyx_v_bins = 0;
  CYTHON_UNUSED PyObject *__pyx_v_range = 0;
  CYTHON_UNUSED PyObject *__pyx_v_normed = 0;
  CYTHON_UNUSED PyObject *__pyx_v_weights = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("histogramdd (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__sample,&__pyx_n_s__bins,&__pyx_n_s__range,&__pyx_n_s__normed,&__pyx_n_s__weights,0};
    PyObject* values[5] = {0,0,0,0,0};
    values[1] = ((PyObject *)__pyx_int_10);

    /* "ga4py/gain/notimplemented.pyx":5418
 * 
 * 
 * def histogramdd(sample, bins=10, range=None, normed=False, weights=None):             # <<<<<<<<<<<<<<
 *     """Compute the multidimensional histogram of some data.
 * 
 */
    values[2] = ((PyObject *)Py_None);
    values[3] = __pyx_k_25;
    values[4] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__sample)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__bins);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__range);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__normed);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__weights);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "histogramdd") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5418; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_sample = values[0];
    __pyx_v_bins = values[1];
    __pyx_v_range = values[2];
    __pyx_v_normed = values[3];
    __pyx_v_weights = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("histogramdd", 0, 1, 5, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5418; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.histogramdd", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_212histogramdd(__pyx_self, __pyx_v_sample, __pyx_v_bins, __pyx_v_range, __pyx_v_normed, __pyx_v_weights);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_212histogramdd(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_sample, CYTHON_UNUSED PyObject *__pyx_v_bins, CYTHON_UNUSED PyObject *__pyx_v_range, CYTHON_UNUSED PyObject *__pyx_v_normed, CYTHON_UNUSED PyObject *__pyx_v_weights) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("histogramdd", 0);

  /* "ga4py/gain/notimplemented.pyx":5468
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5468; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.histogramdd", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_215hsplit(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_214hsplit[] = "Split an array into multiple sub-arrays horizontally (column-wise).\n\n    Please refer to the `split` documentation.  `hsplit` is equivalent\n    to `split` with ``axis=1``, the array is always split along the second\n    axis regardless of the array dimension.\n\n    See Also\n    --------\n    split : Split an array into multiple sub-arrays of equal size.\n\n    Examples\n    --------\n    >>> x = np.arange(16.0).reshape(4, 4)\n    >>> x\n    array([[  0.,   1.,   2.,   3.],\n           [  4.,   5.,   6.,   7.],\n           [  8.,   9.,  10.,  11.],\n           [ 12.,  13.,  14.,  15.]])\n    >>> np.hsplit(x, 2)\n    [array([[  0.,   1.],\n           [  4.,   5.],\n           [  8.,   9.],\n           [ 12.,  13.]]),\n     array([[  2.,   3.],\n           [  6.,   7.],\n           [ 10.,  11.],\n           [ 14.,  15.]])]\n    >>> np.hsplit(x, np.array([3, 6]))\n    [array([[  0.,   1.,   2.],\n           [  4.,   5.,   6.],\n           [  8.,   9.,  10.],\n           [ 12.,  13.,  14.]]),\n     array([[  3.],\n           [  7.],\n           [ 11.],\n           [ 15.]]),\n     array([], dtype=float64)]\n\n    With a higher dimensional array the split is still along the second axis.\n\n    >>> x = np.arange(8.0).reshape(2, 2, 2)\n    >>> x\n    array([[[ 0.,  1.],\n            [ 2.,  3.]],\n           [[ 4.,  5.],\n            [ 6.,  7.]]])\n    >>> np.hsplit(x, 2)\n    [array([[[ 0.,  1.]],\n           [[ 4.,  5.]]]),\n     array([[[ 2.,  3.]],\n           [[ 6.,  7.]]])]\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_215hsplit = {__Pyx_NAMESTR("hsplit"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_215hsplit, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_214hsplit)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_215hsplit(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_ary = 0;
  CYTHON_UNUSED PyObject *__pyx_v_indices_or_sections = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("hsplit (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__ary,&__pyx_n_s__indices_or_sections,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__ary)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__indices_or_sections)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("hsplit", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5471; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "hsplit") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5471; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_ary = values[0];
    __pyx_v_indices_or_sections = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("hsplit", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5471; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.hsplit", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_214hsplit(__pyx_self, __pyx_v_ary, __pyx_v_indices_or_sections);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":5471
 * 
 * 
 * def hsplit(ary, indices_or_sections):             # <<<<<<<<<<<<<<
 *     """Split an array into multiple sub-arrays horizontally (column-wise).
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_214hsplit(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_ary, CYTHON_UNUSED PyObject *__pyx_v_indices_or_sections) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("hsplit", 0);

  /* "ga4py/gain/notimplemented.pyx":5525
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5525; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.hsplit", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_217hstack(PyObject *__pyx_self, PyObject *__pyx_v_tup); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_216hstack[] = "Stack arrays in sequence horizontally (column wise).\n\n    Take a sequence of arrays and stack them horizontally to make\n    a single array. Rebuild arrays divided by `hsplit`.\n\n    Parameters\n    ----------\n    tup : sequence of ndarrays\n        All arrays must have the same shape along all but the second axis.\n\n    Returns\n    -------\n    stacked : ndarray\n        The array formed by stacking the given arrays.\n\n    See Also\n    --------\n    vstack : Stack arrays in sequence vertically (row wise).\n    dstack : Stack arrays in sequence depth wise (along third axis).\n    concatenate : Join a sequence of arrays together.\n    hsplit : Split array along second axis.\n\n    Notes\n    -----\n    Equivalent to ``np.concatenate(tup, axis=1)``\n\n    Examples\n    --------\n    >>> a = np.array((1,2,3))\n    >>> b = np.array((2,3,4))\n    >>> np.hstack((a,b))\n    array([1, 2, 3, 2, 3, 4])\n    >>> a = np.array([[1],[2],[3]])\n    >>> b = np.array([[2],[3],[4]])\n    >>> np.hstack((a,b))\n    array([[1, 2],\n           [2, 3],\n           [3, 4]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_217hstack = {__Pyx_NAMESTR("hstack"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_217hstack, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_216hstack)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_217hstack(PyObject *__pyx_self, PyObject *__pyx_v_tup) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("hstack (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_216hstack(__pyx_self, ((PyObject *)__pyx_v_tup));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":5528
 * 
 * 
 * def hstack(tup):             # <<<<<<<<<<<<<<
 *     """Stack arrays in sequence horizontally (column wise).
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_216hstack(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_tup) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("hstack", 0);

  /* "ga4py/gain/notimplemented.pyx":5569
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5569; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.hstack", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_219i0(PyObject *__pyx_self, PyObject *__pyx_v_x); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_218i0[] = "Modified Bessel function of the first kind, order 0.\n\n    Usually denoted :math:`I_0`.  This function does broadcast, but will *not*\n    \"up-cast\" int dtype arguments unless accompanied by at least one float or\n    complex dtype argument (see Raises below).\n\n    Parameters\n    ----------\n    x : array_like, dtype float or complex\n        Argument of the Bessel function.\n\n    Returns\n    -------\n    out : ndarray, shape = x.shape, dtype = x.dtype\n        The modified Bessel function evaluated at each of the elements of `x`.\n\n    Raises\n    ------\n    TypeError: array cannot be safely cast to required type\n        If argument consists exclusively of int dtypes.\n\n    See Also\n    --------\n    scipy.special.iv, scipy.special.ive\n\n    Notes\n    -----\n    We use the algorithm published by Clenshaw [1]_ and referenced by\n    Abramowitz and Stegun [2]_, for which the function domain is partitioned\n    into the two intervals [0,8] and (8,inf), and Chebyshev polynomial\n    expansions are employed in each interval. Relative error on the domain\n    [0,30] using IEEE arithmetic is documented [3]_ as having a peak of 5.8e-16\n    with an rms of 1.4e-16 (n = 30000).\n\n    References\n    ----------\n    .. [1] C. W. Clenshaw, \"Chebyshev series for mathematical functions,\" in\n           *National Physical Laboratory Mathematical Tables*, vol. 5, London:\n           Her Majesty's Stationery Office, 1962.\n    .. [2] M. Abramowitz and I. A. Stegun, *Handbook of Mathematical\n           Functions*, 10th printing, New York: Dover, 1964, pp. 379.\n           http://www.math.sfu.ca/~cbm/aands/page_379.htm\n    .. [3] http://kobesearch.cpan.org/htdocs/Math-Cephes/Math/Cephes.html\n\n    Examples\n    --------\n    >>> np.i0([0.])\n    array(1.0)\n    >>> np.i0([0., 1. + 2j])\n    array([ 1.00000000+0.j        ,  0.18785373+0.64616944j])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_219i0 = {__Pyx_NAMESTR("i0"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_219i0, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_218i0)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_219i0(PyObject *__pyx_self, PyObject *__pyx_v_x) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("i0 (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_218i0(__pyx_self, ((PyObject *)__pyx_v_x));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":5572
 * 
 * 
 * def i0(x):             # <<<<<<<<<<<<<<
 *     """Modified Bessel function of the first kind, order 0.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_218i0(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("i0", 0);

  /* "ga4py/gain/notimplemented.pyx":5625
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5625; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.i0", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_221imag(PyObject *__pyx_self, PyObject *__pyx_v_val); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_220imag[] = "Return the imaginary part of the elements of the array.\n\n    Parameters\n    ----------\n    val : array_like\n        Input array.\n\n    Returns\n    -------\n    out : ndarray\n        Output array. If `val` is real, the type of `val` is used for the\n        output.  If `val` has complex elements, the returned type is float.\n\n    See Also\n    --------\n    real, angle, real_if_close\n\n    Examples\n    --------\n    >>> a = np.array([1+2j, 3+4j, 5+6j])\n    >>> a.imag\n    array([ 2.,  4.,  6.])\n    >>> a.imag = np.array([8, 10, 12])\n    >>> a\n    array([ 1. +8.j,  3.+10.j,  5.+12.j])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_221imag = {__Pyx_NAMESTR("imag"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_221imag, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_220imag)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_221imag(PyObject *__pyx_self, PyObject *__pyx_v_val) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("imag (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_220imag(__pyx_self, ((PyObject *)__pyx_v_val));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":5628
 * 
 * 
 * def imag(val):             # <<<<<<<<<<<<<<
 *     """Return the imaginary part of the elements of the array.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_220imag(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_val) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("imag", 0);

  /* "ga4py/gain/notimplemented.pyx":5656
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5656; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.imag", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_223in1d(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_222in1d[] = "Test whether each element of a 1D array is also present in a second array.\n\n    Returns a boolean array the same length as `ar1` that is True\n    where an element of `ar1` is in `ar2` and False otherwise.\n\n    Parameters\n    ----------\n    ar1 : array_like, shape (M,)\n        Input array.\n    ar2 : array_like\n        The values against which to test each value of `ar1`.\n    assume_unique : bool, optional\n        If True, the input arrays are both assumed to be unique, which\n        can speed up the calculation.  Default is False.\n\n    Returns\n    -------\n    mask : ndarray of bools, shape(M,)\n        The values `ar1[mask]` are in `ar2`.\n\n    See Also\n    --------\n    numpy.lib.arraysetops : Module with a number of other functions for\n                            performing set operations on arrays.\n\n    Notes\n    -----\n    `in1d` can be considered as an element-wise function version of the\n    python keyword `in`, for 1D sequences. ``in1d(a, b)`` is roughly\n    equivalent to ``np.array([item in b for item in a])``.\n\n    .. versionadded:: 1.4.0\n\n    Examples\n    --------\n    >>> test = np.array([0, 1, 2, 5, 0])\n    >>> states = [0, 2]\n    >>> mask = np.in1d(test, states)\n    >>> mask\n    array([ True, False,  True, False,  True], dtype=bool)\n    >>> test[mask]\n    array([0, 2, 0])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_223in1d = {__Pyx_NAMESTR("in1d"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_223in1d, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_222in1d)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_223in1d(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_ar1 = 0;
  CYTHON_UNUSED PyObject *__pyx_v_ar2 = 0;
  CYTHON_UNUSED PyObject *__pyx_v_assume_unique = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("in1d (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__ar1,&__pyx_n_s__ar2,&__pyx_n_s__assume_unique,0};
    PyObject* values[3] = {0,0,0};
    values[2] = __pyx_k_26;
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__ar1)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__ar2)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("in1d", 0, 2, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5659; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__assume_unique);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "in1d") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5659; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_ar1 = values[0];
    __pyx_v_ar2 = values[1];
    __pyx_v_assume_unique = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("in1d", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5659; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.in1d", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_222in1d(__pyx_self, __pyx_v_ar1, __pyx_v_ar2, __pyx_v_assume_unique);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":5659
 * 
 * 
 * def in1d(ar1, ar2, assume_unique=False):             # <<<<<<<<<<<<<<
 *     """Test whether each element of a 1D array is also present in a second array.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_222in1d(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_ar1, CYTHON_UNUSED PyObject *__pyx_v_ar2, CYTHON_UNUSED PyObject *__pyx_v_assume_unique) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("in1d", 0);

  /* "ga4py/gain/notimplemented.pyx":5704
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5704; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.in1d", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_225indices(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_224indices[] = "Return an array representing the indices of a grid.\n\n    Compute an array where the subarrays contain index values 0,1,...\n    varying only along the corresponding axis.\n\n    Parameters\n    ----------\n    dimensions : sequence of ints\n        The shape of the grid.\n    dtype : dtype, optional\n        Data type of the result.\n\n    Returns\n    -------\n    grid : ndarray\n        The array of grid indices,\n        ``grid.shape = (len(dimensions),) + tuple(dimensions)``.\n\n    See Also\n    --------\n    mgrid, meshgrid\n\n    Notes\n    -----\n    The output shape is obtained by prepending the number of dimensions\n    in front of the tuple of dimensions, i.e. if `dimensions` is a tuple\n    ``(r0, ..., rN-1)`` of length ``N``, the output shape is\n    ``(N,r0,...,rN-1)``.\n\n    The subarrays ``grid[k]`` contains the N-D array of indices along the\n    ``k-th`` axis. Explicitly::\n\n        grid[k,i0,i1,...,iN-1] = ik\n\n    Examples\n    --------\n    >>> grid = np.indices((2, 3))\n    >>> grid.shape\n    (2, 2, 3)\n    >>> grid[0]        # row indices\n    array([[0, 0, 0],\n           [1, 1, 1]])\n    >>> grid[1]        # column indices\n    array([[0, 1, 2],\n           [0, 1, 2]])\n\n    The indices can be used as an index into an array.\n\n    >>> x = np.arange(20).reshape(5, 4)\n    >>> row, col = np.indices((2, 3))\n    >>> x[row, col]\n    array([[0, 1, 2],\n           [4, 5, 6]])\n\n    Note that it would be more straightforward in the above example to\n    extract the required elements directly with ``x[:2, :3]``.\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_225indices = {__Pyx_NAMESTR("indices"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_225indices, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_224indices)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_225indices(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_dimensions = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("indices (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__dimensions,&__pyx_n_s__dtype,0};
    PyObject* values[2] = {0,0};
    values[1] = __pyx_k_27;
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__dimensions)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__dtype);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "indices") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5707; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_dimensions = values[0];
    __pyx_v_dtype = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("indices", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5707; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.indices", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_224indices(__pyx_self, __pyx_v_dimensions, __pyx_v_dtype);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":5707
 * 
 * 
 * def indices(dimensions, dtype=int):             # <<<<<<<<<<<<<<
 *     """Return an array representing the indices of a grid.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_224indices(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_dimensions, CYTHON_UNUSED PyObject *__pyx_v_dtype) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("indices", 0);

  /* "ga4py/gain/notimplemented.pyx":5766
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5766; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.indices", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_227info(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_226info[] = "Get help information for a function, class, or module.\n\n    Parameters\n    ----------\n    object : object or str, optional\n        Input object or name to get information about. If `object` is a\n        numpy object, its docstring is given. If it is a string, available\n        modules are searched for matching objects.\n        If None, information about `info` itself is returned.\n    maxwidth : int, optional\n        Printing width.\n    output : file like object, optional\n        File like object that the output is written to, default is ``stdout``.\n        The object has to be opened in 'w' or 'a' mode.\n    toplevel : str, optional\n        Start search at this level.\n\n    See Also\n    --------\n    source, lookfor\n\n    Notes\n    -----\n    When used interactively with an object, ``np.info(obj)`` is equivalent to\n    ``help(obj)`` on the Python prompt or ``obj?`` on the IPython prompt.\n\n    Examples\n    --------\n    >>> np.info(np.polyval) # doctest: +SKIP\n       polyval(p, x)\n         Evaluate the polynomial p at x.\n         ...\n\n    When using a string for `object` it is possible to get multiple results.\n\n    >>> np.info('fft') # doctest: +SKIP\n         *** Found in numpy ***\n    Core FFT routines\n    ...\n         *** Found in numpy.fft ***\n     fft(a, n=None, axis=-1)\n    ...\n         *** Repeat reference found in numpy.fft.fftpack ***\n         *** Total of 3 references found. ***\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_227info = {__Pyx_NAMESTR("info"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_227info, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_226info)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_227info(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_object = 0;
  CYTHON_UNUSED PyObject *__pyx_v_maxwidth = 0;
  CYTHON_UNUSED PyObject *__pyx_v_output = 0;
  CYTHON_UNUSED PyObject *__pyx_v_toplevel = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("info (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__object,&__pyx_n_s__maxwidth,&__pyx_n_s__output,&__pyx_n_s__toplevel,0};
    PyObject* values[4] = {0,0,0,0};

    /* "ga4py/gain/notimplemented.pyx":5769
 * 
 * 
 * def info(object=None, maxwidth=76, output=sys.stdout, toplevel='numpy'):             # <<<<<<<<<<<<<<
 *     """Get help information for a function, class, or module.
 * 
 */
    values[0] = ((PyObject *)Py_None);
    values[1] = ((PyObject *)__pyx_int_76);
    values[2] = __pyx_k_28;
    values[3] = ((PyObject *)__pyx_n_s__numpy);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__object);
          if (value) { values[0] = value; kw_args--; }
        }
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__maxwidth);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__output);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__toplevel);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "info") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5769; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_object = values[0];
    __pyx_v_maxwidth = values[1];
    __pyx_v_output = values[2];
    __pyx_v_toplevel = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("info", 0, 0, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5769; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.info", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_226info(__pyx_self, __pyx_v_object, __pyx_v_maxwidth, __pyx_v_output, __pyx_v_toplevel);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_226info(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_object, CYTHON_UNUSED PyObject *__pyx_v_maxwidth, CYTHON_UNUSED PyObject *__pyx_v_output, CYTHON_UNUSED PyObject *__pyx_v_toplevel) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("info", 0);

  /* "ga4py/gain/notimplemented.pyx":5816
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5816; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.info", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_229inner(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_228inner[] = "inner(a, b)\n\n    Inner product of two arrays.\n\n    Ordinary inner product of vectors for 1-D arrays (without complex\n    conjugation), in higher dimensions a sum product over the last axes.\n\n    Parameters\n    ----------\n    a, b : array_like\n        If `a` and `b` are nonscalar, their last dimensions of must match.\n\n    Returns\n    -------\n    out : ndarray\n        `out.shape = a.shape[:-1] + b.shape[:-1]`\n\n    Raises\n    ------\n    ValueError\n        If the last dimension of `a` and `b` has different size.\n\n    See Also\n    --------\n    tensordot : Sum products over arbitrary axes.\n    dot : Generalised matrix product, using second last dimension of `b`.\n    einsum : Einstein summation convention.\n\n    Notes\n    -----\n    For vectors (1-D arrays) it computes the ordinary inner-product::\n\n        np.inner(a, b) = sum(a[:]*b[:])\n\n    More generally, if `ndim(a) = r > 0` and `ndim(b) = s > 0`::\n\n        np.inner(a, b) = np.tensordot(a, b, axes=(-1,-1))\n\n    or explicitly::\n\n        np.inner(a, b)[i0,...,ir-1,j0,...,js-1]\n             = sum(a[i0,...,ir-1,:]*b[j0,...,js-1,:])\n\n    In addition `a` or `b` may be scalars, in which case::\n\n       np.inner(a,b) = a*b\n\n    Examples\n    --------\n    Ordinary inner product for vectors:\n\n    >>> a = np.array([1,2,3])\n    >>> b = np.array([0,1,0])\n    >>> np.inner(a, b)\n    2\n\n    A multidimensional example:\n\n    >>> a = np.arange(24).reshape((2,3,4))\n    >>> b = np.arange(4)\n    >>> np.inner(a, b)\n    array([[ 14,  38,  62],\n           [ 86, 110, 134]])\n\n    An example where `b` is a scalar:\n\n    >>> np.inner(np.eye(2), 7)\n    array([[ 7.,  0.],\n           [ 0.,  7.]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_229inner = {__Pyx_NAMESTR("inner"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_229inner, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_228inner)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_229inner(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_b = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("inner (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__b,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__b)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("inner", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5819; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "inner") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5819; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_a = values[0];
    __pyx_v_b = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("inner", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5819; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.inner", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_228inner(__pyx_self, __pyx_v_a, __pyx_v_b);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":5819
 * 
 * 
 * def inner(a, b):             # <<<<<<<<<<<<<<
 *     """inner(a, b)
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_228inner(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_b) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("inner", 0);

  /* "ga4py/gain/notimplemented.pyx":5892
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5892; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.inner", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_231insert(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_230insert[] = "Insert values along the given axis before the given indices.\n\n    Parameters\n    ----------\n    arr : array_like\n        Input array.\n    obj : int, slice or sequence of ints\n        Object that defines the index or indices before which `values` is\n        inserted.\n    values : array_like\n        Values to insert into `arr`. If the type of `values` is different\n        from that of `arr`, `values` is converted to the type of `arr`.\n    axis : int, optional\n        Axis along which to insert `values`.  If `axis` is None then `arr`\n        is flattened first.\n\n    Returns\n    -------\n    out : ndarray\n        A copy of `arr` with `values` inserted.  Note that `insert`\n        does not occur in-place: a new array is returned. If\n        `axis` is None, `out` is a flattened array.\n\n    See Also\n    --------\n    append : Append elements at the end of an array.\n    delete : Delete elements from an array.\n\n    Examples\n    --------\n    >>> a = np.array([[1, 1], [2, 2], [3, 3]])\n    >>> a\n    array([[1, 1],\n           [2, 2],\n           [3, 3]])\n    >>> np.insert(a, 1, 5)\n    array([1, 5, 1, 2, 2, 3, 3])\n    >>> np.insert(a, 1, 5, axis=1)\n    array([[1, 5, 1],\n           [2, 5, 2],\n           [3, 5, 3]])\n\n    >>> b = a.flatten()\n    >>> b\n    array([1, 1, 2, 2, 3, 3])\n    >>> np.insert(b, [2, 2], [5, 6])\n    array([1, 1, 5, 6, 2, 2, 3, 3])\n\n    >>> np.insert(b, slice(2, 4), [5, 6])\n    array([1, 1, 5, 2, 6, 2, 3, 3])\n\n    >>> np.insert(b, [2, 2], [7.13, False]) # type casting\n    array([1, 1, 7, 0, 2, 2, 3, 3])\n\n    >>> x = np.arange(8).reshape(2, 4)\n    >>> idx = (1, 3)\n    >>> np.insert(x, idx, 999, axis=1)\n    array([[  0, 999,   1,   2, 999,   3],\n           [  4, 999,   5,   6, 999,   7]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_231insert = {__Pyx_NAMESTR("insert"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_231insert, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_230insert)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_231insert(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_arr = 0;
  CYTHON_UNUSED PyObject *__pyx_v_obj = 0;
  CYTHON_UNUSED PyObject *__pyx_v_values = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("insert (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__arr,&__pyx_n_s__obj,&__pyx_n_s__values,&__pyx_n_s__axis,0};
    PyObject* values[4] = {0,0,0,0};

    /* "ga4py/gain/notimplemented.pyx":5895
 * 
 * 
 * def insert(arr, obj, values, axis=None):             # <<<<<<<<<<<<<<
 *     """Insert values along the given axis before the given indices.
 * 
 */
    values[3] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__arr)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__obj)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("insert", 0, 3, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5895; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__values)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("insert", 0, 3, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5895; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "insert") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5895; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_arr = values[0];
    __pyx_v_obj = values[1];
    __pyx_v_values = values[2];
    __pyx_v_axis = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("insert", 0, 3, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5895; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.insert", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_230insert(__pyx_self, __pyx_v_arr, __pyx_v_obj, __pyx_v_values, __pyx_v_axis);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_230insert(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_arr, CYTHON_UNUSED PyObject *__pyx_v_obj, CYTHON_UNUSED PyObject *__pyx_v_values, CYTHON_UNUSED PyObject *__pyx_v_axis) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("insert", 0);

  /* "ga4py/gain/notimplemented.pyx":5957
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5957; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.insert", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_233int_asbuffer(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_232int_asbuffer[] = "\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_233int_asbuffer = {__Pyx_NAMESTR("int_asbuffer"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_233int_asbuffer, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_232int_asbuffer)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_233int_asbuffer(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("int_asbuffer (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_232int_asbuffer(__pyx_self);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":5960
 * 
 * 
 * def int_asbuffer():             # <<<<<<<<<<<<<<
 *     """
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_232int_asbuffer(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("int_asbuffer", 0);

  /* "ga4py/gain/notimplemented.pyx":5965
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5965; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.int_asbuffer", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_235interp(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_234interp[] = "One-dimensional linear interpolation.\n\n    Returns the one-dimensional piecewise linear interpolant to a function\n    with given values at discrete data-points.\n\n    Parameters\n    ----------\n    x : array_like\n        The x-coordinates of the interpolated values.\n\n    xp : 1-D sequence of floats\n        The x-coordinates of the data points, must be increasing.\n\n    fp : 1-D sequence of floats\n        The y-coordinates of the data points, same length as `xp`.\n\n    left : float, optional\n        Value to return for `x < xp[0]`, default is `fp[0]`.\n\n    right : float, optional\n        Value to return for `x > xp[-1]`, defaults is `fp[-1]`.\n\n    Returns\n    -------\n    y : {float, ndarray}\n        The interpolated values, same shape as `x`.\n\n    Raises\n    ------\n    ValueError\n        If `xp` and `fp` have different length\n\n    Notes\n    -----\n    Does not check that the x-coordinate sequence `xp` is increasing.\n    If `xp` is not increasing, the results are nonsense.\n    A simple check for increasingness is::\n\n        np.all(np.diff(xp) > 0)\n\n\n    Examples\n    --------\n    >>> xp = [1, 2, 3]\n    >>> fp = [3, 2, 0]\n    >>> np.interp(2.5, xp, fp)\n    1.0\n    >>> np.interp([0, 1, 1.5, 2.72, 3.14], xp, fp)\n    array([ 3. ,  3. ,  2.5 ,  0.56,  0. ])\n    >>> UNDEF = -99.0\n    >>> np.interp(3.14, xp, fp, right=UNDEF)\n    -99.0\n\n    Plot an interpolant to the sine function:\n\n    >>> x = np.linspace(0, 2*np.pi, 10)\n    >>> y = np.sin(x)\n    >>> xvals = np.linspace(0, 2*np.pi, 50)\n    >>> yinterp = np.interp(xvals, x, y)\n    >>> import matplotlib.pyplot as plt\n    >>> plt.plot(x, y, 'o')\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.plot(xvals, yinterp, '-x')\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.show()\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_235interp = {__Pyx_NAMESTR("interp"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_235interp, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_234interp)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_235interp(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_x = 0;
  CYTHON_UNUSED PyObject *__pyx_v_xp = 0;
  CYTHON_UNUSED PyObject *__pyx_v_fp = 0;
  CYTHON_UNUSED PyObject *__pyx_v_left = 0;
  CYTHON_UNUSED PyObject *__pyx_v_right = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("interp (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__x,&__pyx_n_s__xp,&__pyx_n_s__fp,&__pyx_n_s__left,&__pyx_n_s__right,0};
    PyObject* values[5] = {0,0,0,0,0};

    /* "ga4py/gain/notimplemented.pyx":5968
 * 
 * 
 * def interp(x, xp, fp, left=None, right=None):             # <<<<<<<<<<<<<<
 *     """One-dimensional linear interpolation.
 * 
 */
    values[3] = ((PyObject *)Py_None);
    values[4] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__x)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__xp)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("interp", 0, 3, 5, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5968; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__fp)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("interp", 0, 3, 5, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5968; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__left);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__right);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "interp") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5968; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_x = values[0];
    __pyx_v_xp = values[1];
    __pyx_v_fp = values[2];
    __pyx_v_left = values[3];
    __pyx_v_right = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("interp", 0, 3, 5, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5968; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.interp", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_234interp(__pyx_self, __pyx_v_x, __pyx_v_xp, __pyx_v_fp, __pyx_v_left, __pyx_v_right);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_234interp(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_xp, CYTHON_UNUSED PyObject *__pyx_v_fp, CYTHON_UNUSED PyObject *__pyx_v_left, CYTHON_UNUSED PyObject *__pyx_v_right) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("interp", 0);

  /* "ga4py/gain/notimplemented.pyx":6036
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6036; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.interp", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_237intersect1d(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_236intersect1d[] = "Find the intersection of two arrays.\n\n    Return the sorted, unique values that are in both of the input arrays.\n\n    Parameters\n    ----------\n    ar1, ar2 : array_like\n        Input arrays.\n    assume_unique : bool\n        If True, the input arrays are both assumed to be unique, which\n        can speed up the calculation.  Default is False.\n\n    Returns\n    -------\n    out : ndarray\n        Sorted 1D array of common and unique elements.\n\n    See Also\n    --------\n    numpy.lib.arraysetops : Module with a number of other functions for\n                            performing set operations on arrays.\n\n    Examples\n    --------\n    >>> np.intersect1d([1, 3, 4, 3], [3, 1, 2, 1])\n    array([1, 3])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_237intersect1d = {__Pyx_NAMESTR("intersect1d"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_237intersect1d, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_236intersect1d)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_237intersect1d(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_ar1 = 0;
  CYTHON_UNUSED PyObject *__pyx_v_ar2 = 0;
  CYTHON_UNUSED PyObject *__pyx_v_assume_unique = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("intersect1d (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__ar1,&__pyx_n_s__ar2,&__pyx_n_s__assume_unique,0};
    PyObject* values[3] = {0,0,0};
    values[2] = __pyx_k_29;
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__ar1)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__ar2)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("intersect1d", 0, 2, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6039; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__assume_unique);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "intersect1d") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6039; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_ar1 = values[0];
    __pyx_v_ar2 = values[1];
    __pyx_v_assume_unique = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("intersect1d", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6039; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.intersect1d", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_236intersect1d(__pyx_self, __pyx_v_ar1, __pyx_v_ar2, __pyx_v_assume_unique);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":6039
 * 
 * 
 * def intersect1d(ar1, ar2, assume_unique=False):             # <<<<<<<<<<<<<<
 *     """Find the intersection of two arrays.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_236intersect1d(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_ar1, CYTHON_UNUSED PyObject *__pyx_v_ar2, CYTHON_UNUSED PyObject *__pyx_v_assume_unique) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("intersect1d", 0);

  /* "ga4py/gain/notimplemented.pyx":6068
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6068; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.intersect1d", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_239ipmt(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_238ipmt[] = "Not implemented. Compute the payment portion for loan interest.\n\n    Parameters\n    ----------\n    rate : scalar or array_like of shape(M, )\n        Rate of interest as decimal (not per cent) per period\n    per : scalar or array_like of shape(M, )\n        Interest paid against the loan changes during the life or the loan.\n        The `per` is the payment period to calculate the interest amount.\n    nper : scalar or array_like of shape(M, )\n        Number of compounding periods\n    pv : scalar or array_like of shape(M, )\n        Present value\n    fv : scalar or array_like of shape(M, ), optional\n        Future value\n    when : {{'begin', 1}, {'end', 0}}, {string, int}, optional\n        When payments are due ('begin' (1) or 'end' (0)).\n        Defaults to {'end', 0}.\n\n    Returns\n    -------\n    out : ndarray\n        Interest portion of payment.  If all input is scalar, returns a scalar\n        float.  If any input is array_like, returns interest payment for each\n        input element. If multiple inputs are array_like, they all must have\n        the same shape.\n\n    See Also\n    --------\n    ppmt, pmt, pv\n\n    Notes\n    -----\n    The total payment is made up of payment against principal plus interest.\n\n    ``pmt = ppmt + ipmt``\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_239ipmt = {__Pyx_NAMESTR("ipmt"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_239ipmt, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_238ipmt)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_239ipmt(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_rate = 0;
  CYTHON_UNUSED PyObject *__pyx_v_per = 0;
  CYTHON_UNUSED PyObject *__pyx_v_nper = 0;
  CYTHON_UNUSED PyObject *__pyx_v_pv = 0;
  CYTHON_UNUSED PyObject *__pyx_v_fv = 0;
  CYTHON_UNUSED PyObject *__pyx_v_when = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ipmt (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__rate,&__pyx_n_s__per,&__pyx_n_s__nper,&__pyx_n_s__pv,&__pyx_n_s__fv,&__pyx_n_s__when,0};
    PyObject* values[6] = {0,0,0,0,0,0};
    values[4] = __pyx_k_30;
    values[5] = ((PyObject *)__pyx_n_s__end);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__rate)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__per)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("ipmt", 0, 4, 6, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6071; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__nper)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("ipmt", 0, 4, 6, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6071; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__pv)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("ipmt", 0, 4, 6, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6071; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__fv);
          if (value) { values[4] = value; kw_args--; }
        }
        case  5:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__when);
          if (value) { values[5] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "ipmt") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6071; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_rate = values[0];
    __pyx_v_per = values[1];
    __pyx_v_nper = values[2];
    __pyx_v_pv = values[3];
    __pyx_v_fv = values[4];
    __pyx_v_when = values[5];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("ipmt", 0, 4, 6, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6071; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.ipmt", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_238ipmt(__pyx_self, __pyx_v_rate, __pyx_v_per, __pyx_v_nper, __pyx_v_pv, __pyx_v_fv, __pyx_v_when);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":6071
 * 
 * 
 * def ipmt(rate, per, nper, pv, fv=0.0, when='end'):             # <<<<<<<<<<<<<<
 *     """Not implemented. Compute the payment portion for loan interest.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_238ipmt(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_rate, CYTHON_UNUSED PyObject *__pyx_v_per, CYTHON_UNUSED PyObject *__pyx_v_nper, CYTHON_UNUSED PyObject *__pyx_v_pv, CYTHON_UNUSED PyObject *__pyx_v_fv, CYTHON_UNUSED PyObject *__pyx_v_when) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("ipmt", 0);

  /* "ga4py/gain/notimplemented.pyx":6110
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6110; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.ipmt", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_241irr(PyObject *__pyx_self, PyObject *__pyx_v_values); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_240irr[] = "Return the Internal Rate of Return (IRR).\n\n    This is the \"average\" periodically compounded rate of return\n    that gives a net present value of 0.0; for a more complete explanation,\n    see Notes below.\n\n    Parameters\n    ----------\n    values : array_like, shape(N,)\n        Input cash flows per time period.  By convention, net \"deposits\"\n        are negative and net \"withdrawals\" are positive.  Thus, for example,\n        at least the first element of `values`, which represents the initial\n        investment, will typically be negative.\n\n    Returns\n    -------\n    out : float\n        Internal Rate of Return for periodic input values.\n\n    Notes\n    -----\n    The IRR is perhaps best understood through an example (illustrated\n    using np.irr in the Examples section below).  Suppose one invests\n    100 units and then makes the following withdrawals at regular\n    (fixed) intervals: 39, 59, 55, 20.  Assuming the ending value is 0,\n    one's 100 unit investment yields 173 units; however, due to the\n    combination of compounding and the periodic withdrawals, the\n    \"average\" rate of return is neither simply 0.73/4 nor (1.73)^0.25-1.\n    Rather, it is the solution (for :math:`r`) of the equation:\n\n    .. math:: -100 + \014rac{39}{1+r} + \014rac{59}{(1+r)^2}\n     + \014rac{55}{(1+r)^3} + \014rac{20}{(1+r)^4} = 0\n\n    In general, for `values` :math:`= [v_0, v_1, ... v_M]`,\n    irr is the solution of the equation: [G]_\n\n    .. math:: \\sum_{t=0}^M{\014rac{v_t}{(1+irr)^{t}}} = 0\n\n    References\n    ----------\n    .. [G] L. J. Gitman, \"Principles of Managerial Finance, Brief,\" 3rd ed.,\n       Addison-Wesley, 2003, pg. 348.\n\n    Examples\n    --------\n    >>> np.irr([-100, 39, 59, 55, 20])\n    0.2809484211599611\n\n    (Compare with the Example given for numpy.lib.financial.npv)\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_241irr = {__Pyx_NAMESTR("irr"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_241irr, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_240irr)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_241irr(PyObject *__pyx_self, PyObject *__pyx_v_values) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("irr (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_240irr(__pyx_self, ((PyObject *)__pyx_v_values));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":6113
 * 
 * 
 * def irr(values):             # <<<<<<<<<<<<<<
 *     """Return the Internal Rate of Return (IRR).
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_240irr(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_values) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("irr", 0);

  /* "ga4py/gain/notimplemented.pyx":6165
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6165; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.irr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_243iscomplex(PyObject *__pyx_self, PyObject *__pyx_v_x); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_242iscomplex[] = "Returns a bool array, where True if input element is complex.\n\n    What is tested is whether the input has a non-zero imaginary part, not if\n    the input type is complex.\n\n    Parameters\n    ----------\n    x : array_like\n        Input array.\n\n    Returns\n    -------\n    out : ndarray of bools\n        Output array.\n\n    See Also\n    --------\n    isreal\n    iscomplexobj : Return True if x is a complex type or an array of complex\n                   numbers.\n\n    Examples\n    --------\n    >>> np.iscomplex([1+1j, 1+0j, 4.5, 3, 2, 2j])\n    array([ True, False, False, False, False,  True], dtype=bool)\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_243iscomplex = {__Pyx_NAMESTR("iscomplex"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_243iscomplex, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_242iscomplex)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_243iscomplex(PyObject *__pyx_self, PyObject *__pyx_v_x) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("iscomplex (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_242iscomplex(__pyx_self, ((PyObject *)__pyx_v_x));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":6168
 * 
 * 
 * def iscomplex(x):             # <<<<<<<<<<<<<<
 *     """Returns a bool array, where True if input element is complex.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_242iscomplex(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("iscomplex", 0);

  /* "ga4py/gain/notimplemented.pyx":6196
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6196; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.iscomplex", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_245iscomplexobj(PyObject *__pyx_self, PyObject *__pyx_v_x); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_244iscomplexobj[] = "Return True if x is a complex type or an array of complex numbers.\n\n    The type of the input is checked, not the value. So even if the input\n    has an imaginary part equal to zero, `iscomplexobj` evaluates to True\n    if the data type is complex.\n\n    Parameters\n    ----------\n    x : any\n        The input can be of any type and shape.\n\n    Returns\n    -------\n    y : bool\n        The return value, True if `x` is of a complex type.\n\n    See Also\n    --------\n    isrealobj, iscomplex\n\n    Examples\n    --------\n    >>> np.iscomplexobj(1)\n    False\n    >>> np.iscomplexobj(1+0j)\n    True\n    >>> np.iscomplexobj([3, 1+0j, True])\n    True\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_245iscomplexobj = {__Pyx_NAMESTR("iscomplexobj"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_245iscomplexobj, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_244iscomplexobj)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_245iscomplexobj(PyObject *__pyx_self, PyObject *__pyx_v_x) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("iscomplexobj (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_244iscomplexobj(__pyx_self, ((PyObject *)__pyx_v_x));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":6199
 * 
 * 
 * def iscomplexobj(x):             # <<<<<<<<<<<<<<
 *     """Return True if x is a complex type or an array of complex numbers.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_244iscomplexobj(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("iscomplexobj", 0);

  /* "ga4py/gain/notimplemented.pyx":6230
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6230; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.iscomplexobj", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_247isfortran(PyObject *__pyx_self, PyObject *__pyx_v_a); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_246isfortran[] = "Returns True if array is arranged in Fortran-order in memory\n    and dimension > 1.\n\n    Parameters\n    ----------\n    a : ndarray\n        Input array.\n\n\n    Examples\n    --------\n\n    np.array allows to specify whether the array is written in C-contiguous\n    order (last index varies the fastest), or FORTRAN-contiguous order in\n    memory (first index varies the fastest).\n\n    >>> a = np.array([[1, 2, 3], [4, 5, 6]], order='C')\n    >>> a\n    array([[1, 2, 3],\n           [4, 5, 6]])\n    >>> np.isfortran(a)\n    False\n\n    >>> b = np.array([[1, 2, 3], [4, 5, 6]], order='FORTRAN')\n    >>> b\n    array([[1, 2, 3],\n           [4, 5, 6]])\n    >>> np.isfortran(b)\n    True\n\n\n    The transpose of a C-ordered array is a FORTRAN-ordered array.\n\n    >>> a = np.array([[1, 2, 3], [4, 5, 6]], order='C')\n    >>> a\n    array([[1, 2, 3],\n           [4, 5, 6]])\n    >>> np.isfortran(a)\n    False\n    >>> b = a.T\n    >>> b\n    array([[1, 4],\n           [2, 5],\n           [3, 6]])\n    >>> np.isfortran(b)\n    True\n\n    1-D arrays always evaluate as False.\n\n    >>> np.isfortran(np.array([1, 2], order='FORTRAN'))\n    False\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_247isfortran = {__Pyx_NAMESTR("isfortran"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_247isfortran, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_246isfortran)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_247isfortran(PyObject *__pyx_self, PyObject *__pyx_v_a) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("isfortran (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_246isfortran(__pyx_self, ((PyObject *)__pyx_v_a));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":6233
 * 
 * 
 * def isfortran(a):             # <<<<<<<<<<<<<<
 *     """Returns True if array is arranged in Fortran-order in memory
 *     and dimension > 1.
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_246isfortran(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("isfortran", 0);

  /* "ga4py/gain/notimplemented.pyx":6287
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6287; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.isfortran", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_249isneginf(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_248isneginf[] = "Test element-wise for negative infinity, return result as bool array.\n\n    Parameters\n    ----------\n    x : array_like\n        The input array.\n    y : array_like, optional\n        A boolean array with the same shape and type as `x` to store the\n        result.\n\n    Returns\n    -------\n    y : ndarray\n        A boolean array with the same dimensions as the input.\n        If second argument is not supplied then a numpy boolean array is\n        returned with values True where the corresponding element of the\n        input is negative infinity and values False where the element of\n        the input is not negative infinity.\n\n        If a second argument is supplied the result is stored there. If the\n        type of that array is a numeric type the result is represented as\n        zeros and ones, if the type is boolean then as False and True. The\n        return value `y` is then a reference to that array.\n\n    See Also\n    --------\n    isinf, isposinf, isnan, isfinite\n\n    Notes\n    -----\n    Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n    (IEEE 754).\n\n    Errors result if the second argument is also supplied when x is a scalar\n    input, or if first and second arguments have different shapes.\n\n    Examples\n    --------\n    >>> np.isneginf(np.NINF)\n    array(True, dtype=bool)\n    >>> np.isneginf(np.inf)\n    array(False, dtype=bool)\n    >>> np.isneginf(np.PINF)\n    array(False, dtype=bool)\n    >>> np.isneginf([-np.inf, 0., np.inf])\n    array([ True, False, False], dtype=bool)\n\n    >>> x = np.array([-np.inf, 0., np.inf])\n    >>> y = np.array([2, 2, 2])\n    >>> np.isneginf(x, y)\n    array([1, 0, 0])\n    >>> y\n    array([1, 0, 0])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_249isneginf = {__Pyx_NAMESTR("isneginf"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_249isneginf, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_248isneginf)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_249isneginf(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_x = 0;
  CYTHON_UNUSED PyObject *__pyx_v_y = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("isneginf (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__x,&__pyx_n_s__y,0};
    PyObject* values[2] = {0,0};

    /* "ga4py/gain/notimplemented.pyx":6290
 * 
 * 
 * def isneginf(x, y=None):             # <<<<<<<<<<<<<<
 *     """Test element-wise for negative infinity, return result as bool array.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__x)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__y);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "isneginf") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6290; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_x = values[0];
    __pyx_v_y = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("isneginf", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6290; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.isneginf", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_248isneginf(__pyx_self, __pyx_v_x, __pyx_v_y);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_248isneginf(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_y) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("isneginf", 0);

  /* "ga4py/gain/notimplemented.pyx":6346
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6346; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.isneginf", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_251isposinf(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_250isposinf[] = "Test element-wise for positive infinity, return result as bool array.\n\n    Parameters\n    ----------\n    x : array_like\n        The input array.\n    y : array_like, optional\n        A boolean array with the same shape as `x` to store the result.\n\n    Returns\n    -------\n    y : ndarray\n        A boolean array with the same dimensions as the input.\n        If second argument is not supplied then a boolean array is returned\n        with values True where the corresponding element of the input is\n        positive infinity and values False where the element of the input is\n        not positive infinity.\n\n        If a second argument is supplied the result is stored there. If the\n        type of that array is a numeric type the result is represented as zeros\n        and ones, if the type is boolean then as False and True.\n        The return value `y` is then a reference to that array.\n\n    See Also\n    --------\n    isinf, isneginf, isfinite, isnan\n\n    Notes\n    -----\n    Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n    (IEEE 754).\n\n    Errors result if the second argument is also supplied when `x` is a\n    scalar input, or if first and second arguments have different shapes.\n\n    Examples\n    --------\n    >>> np.isposinf(np.PINF)\n    array(True, dtype=bool)\n    >>> np.isposinf(np.inf)\n    array(True, dtype=bool)\n    >>> np.isposinf(np.NINF)\n    array(False, dtype=bool)\n    >>> np.isposinf([-np.inf, 0., np.inf])\n    array([False, False,  True], dtype=bool)\n\n    >>> x = np.array([-np.inf, 0., np.inf])\n    >>> y = np.array([2, 2, 2])\n    >>> np.isposinf(x, y)\n    array([0, 0, 1])\n    >>> y\n    array([0, 0, 1])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_251isposinf = {__Pyx_NAMESTR("isposinf"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_251isposinf, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_250isposinf)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_251isposinf(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_x = 0;
  CYTHON_UNUSED PyObject *__pyx_v_y = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("isposinf (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__x,&__pyx_n_s__y,0};
    PyObject* values[2] = {0,0};

    /* "ga4py/gain/notimplemented.pyx":6349
 * 
 * 
 * def isposinf(x, y=None):             # <<<<<<<<<<<<<<
 *     """Test element-wise for positive infinity, return result as bool array.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__x)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__y);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "isposinf") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6349; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_x = values[0];
    __pyx_v_y = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("isposinf", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6349; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.isposinf", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_250isposinf(__pyx_self, __pyx_v_x, __pyx_v_y);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_250isposinf(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_y) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("isposinf", 0);

  /* "ga4py/gain/notimplemented.pyx":6404
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6404; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.isposinf", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_253isreal(PyObject *__pyx_self, PyObject *__pyx_v_x); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_252isreal[] = "Returns a bool array, where True if input element is real.\n\n    If element has complex type with zero complex part, the return value\n    for that element is True.\n\n    Parameters\n    ----------\n    x : array_like\n        Input array.\n\n    Returns\n    -------\n    out : ndarray, bool\n        Boolean array of same shape as `x`.\n\n    See Also\n    --------\n    iscomplex\n    isrealobj : Return True if x is not a complex type.\n\n    Examples\n    --------\n    >>> np.isreal([1+1j, 1+0j, 4.5, 3, 2, 2j])\n    array([False,  True,  True,  True,  True, False], dtype=bool)\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_253isreal = {__Pyx_NAMESTR("isreal"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_253isreal, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_252isreal)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_253isreal(PyObject *__pyx_self, PyObject *__pyx_v_x) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("isreal (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_252isreal(__pyx_self, ((PyObject *)__pyx_v_x));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":6407
 * 
 * 
 * def isreal(x):             # <<<<<<<<<<<<<<
 *     """Returns a bool array, where True if input element is real.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_252isreal(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("isreal", 0);

  /* "ga4py/gain/notimplemented.pyx":6434
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6434; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.isreal", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_255isrealobj(PyObject *__pyx_self, PyObject *__pyx_v_x); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_254isrealobj[] = "Return True if x is a not complex type or an array of complex numbers.\n\n    The type of the input is checked, not the value. So even if the input\n    has an imaginary part equal to zero, `isrealobj` evaluates to False\n    if the data type is complex.\n\n    Parameters\n    ----------\n    x : any\n        The input can be of any type and shape.\n\n    Returns\n    -------\n    y : bool\n        The return value, False if `x` is of a complex type.\n\n    See Also\n    --------\n    iscomplexobj, isreal\n\n    Examples\n    --------\n    >>> np.isrealobj(1)\n    True\n    >>> np.isrealobj(1+0j)\n    False\n    >>> np.isrealobj([3, 1+0j, True])\n    False\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_255isrealobj = {__Pyx_NAMESTR("isrealobj"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_255isrealobj, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_254isrealobj)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_255isrealobj(PyObject *__pyx_self, PyObject *__pyx_v_x) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("isrealobj (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_254isrealobj(__pyx_self, ((PyObject *)__pyx_v_x));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":6437
 * 
 * 
 * def isrealobj(x):             # <<<<<<<<<<<<<<
 *     """Return True if x is a not complex type or an array of complex numbers.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_254isrealobj(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("isrealobj", 0);

  /* "ga4py/gain/notimplemented.pyx":6468
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6468; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.isrealobj", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_257isscalar(PyObject *__pyx_self, PyObject *__pyx_v_num); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_256isscalar[] = "Returns True if the type of `num` is a scalar type.\n\n    Parameters\n    ----------\n    num : any\n        Input argument, can be of any type and shape.\n\n    Returns\n    -------\n    val : bool\n        True if `num` is a scalar type, False if it is not.\n\n    Examples\n    --------\n    >>> np.isscalar(3.1)\n    True\n    >>> np.isscalar([3.1])\n    False\n    >>> np.isscalar(False)\n    True\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_257isscalar = {__Pyx_NAMESTR("isscalar"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_257isscalar, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_256isscalar)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_257isscalar(PyObject *__pyx_self, PyObject *__pyx_v_num) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("isscalar (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_256isscalar(__pyx_self, ((PyObject *)__pyx_v_num));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":6471
 * 
 * 
 * def isscalar(num):             # <<<<<<<<<<<<<<
 *     """Returns True if the type of `num` is a scalar type.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_256isscalar(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_num) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("isscalar", 0);

  /* "ga4py/gain/notimplemented.pyx":6494
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6494; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.isscalar", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_259issctype(PyObject *__pyx_self, PyObject *__pyx_v_rep); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_258issctype[] = "Determines whether the given object represents a scalar data-type.\n\n    Parameters\n    ----------\n    rep : any\n        If `rep` is an instance of a scalar dtype, True is returned. If not,\n        False is returned.\n\n    Returns\n    -------\n    out : bool\n        Boolean result of check whether `rep` is a scalar dtype.\n\n    See Also\n    --------\n    issubsctype, issubdtype, obj2sctype, sctype2char\n\n    Examples\n    --------\n    >>> np.issctype(np.int32)\n    True\n    >>> np.issctype(list)\n    False\n    >>> np.issctype(1.1)\n    False\n\n    Strings are also a scalar type:\n\n    >>> np.issctype(np.dtype('str'))\n    True\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_259issctype = {__Pyx_NAMESTR("issctype"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_259issctype, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_258issctype)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_259issctype(PyObject *__pyx_self, PyObject *__pyx_v_rep) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("issctype (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_258issctype(__pyx_self, ((PyObject *)__pyx_v_rep));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":6497
 * 
 * 
 * def issctype(rep):             # <<<<<<<<<<<<<<
 *     """Determines whether the given object represents a scalar data-type.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_258issctype(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_rep) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("issctype", 0);

  /* "ga4py/gain/notimplemented.pyx":6530
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6530; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.issctype", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_261issubclass_(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_260issubclass_[] = "Determine if a class is a subclass of a second class.\n\n    `issubclass_` is equivalent to the Python built-in ``issubclass``,\n    except that it returns False instead of raising a TypeError is one\n    of the arguments is not a class.\n\n    Parameters\n    ----------\n    arg1 : class\n        Input class. True is returned if `arg1` is a subclass of `arg2`.\n    arg2 : class or tuple of classes.\n        Input class. If a tuple of classes, True is returned if `arg1` is a\n        subclass of any of the tuple elements.\n\n    Returns\n    -------\n    out : bool\n        Whether `arg1` is a subclass of `arg2` or not.\n\n    See Also\n    --------\n    issubsctype, issubdtype, issctype\n\n    Examples\n    --------\n    >>> np.issubclass_(np.int32, np.int)\n    True\n    >>> np.issubclass_(np.int32, np.float)\n    False\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_261issubclass_ = {__Pyx_NAMESTR("issubclass_"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_261issubclass_, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_260issubclass_)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_261issubclass_(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_arg1 = 0;
  CYTHON_UNUSED PyObject *__pyx_v_arg2 = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("issubclass_ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__arg1,&__pyx_n_s__arg2,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__arg1)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__arg2)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("issubclass_", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6533; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "issubclass_") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6533; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_arg1 = values[0];
    __pyx_v_arg2 = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("issubclass_", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6533; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.issubclass_", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_260issubclass_(__pyx_self, __pyx_v_arg1, __pyx_v_arg2);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":6533
 * 
 * 
 * def issubclass_(arg1, arg2):             # <<<<<<<<<<<<<<
 *     """Determine if a class is a subclass of a second class.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_260issubclass_(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_arg1, CYTHON_UNUSED PyObject *__pyx_v_arg2) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("issubclass_", 0);

  /* "ga4py/gain/notimplemented.pyx":6565
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6565; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.issubclass_", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_263issubdtype(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_262issubdtype[] = "Returns True if first argument is a typecode lower/equal in type hierarchy.\n\n    Parameters\n    ----------\n    arg1, arg2 : dtype_like\n        dtype or string representing a typecode.\n\n    Returns\n    -------\n    out : bool\n\n    See Also\n    --------\n    issubsctype, issubclass_\n    numpy.core.numerictypes : Overview of numpy type hierarchy.\n\n    Examples\n    --------\n    >>> np.issubdtype('S1', str)\n    True\n    >>> np.issubdtype(np.float64, np.float32)\n    False\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_263issubdtype = {__Pyx_NAMESTR("issubdtype"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_263issubdtype, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_262issubdtype)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_263issubdtype(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_arg1 = 0;
  CYTHON_UNUSED PyObject *__pyx_v_arg2 = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("issubdtype (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__arg1,&__pyx_n_s__arg2,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__arg1)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__arg2)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("issubdtype", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6568; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "issubdtype") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6568; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_arg1 = values[0];
    __pyx_v_arg2 = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("issubdtype", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6568; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.issubdtype", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_262issubdtype(__pyx_self, __pyx_v_arg1, __pyx_v_arg2);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":6568
 * 
 * 
 * def issubdtype(arg1, arg2):             # <<<<<<<<<<<<<<
 *     """Returns True if first argument is a typecode lower/equal in type hierarchy.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_262issubdtype(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_arg1, CYTHON_UNUSED PyObject *__pyx_v_arg2) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("issubdtype", 0);

  /* "ga4py/gain/notimplemented.pyx":6593
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6593; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.issubdtype", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_265issubsctype(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_264issubsctype[] = "Determine if the first argument is a subclass of the second argument.\n\n    Parameters\n    ----------\n    arg1, arg2 : dtype or dtype specifier\n        Data-types.\n\n    Returns\n    -------\n    out : bool\n        The result.\n\n    See Also\n    --------\n    issctype, issubdtype,obj2sctype\n\n    Examples\n    --------\n    >>> np.issubsctype('S8', str)\n    True\n    >>> np.issubsctype(np.array([1]), np.int)\n    True\n    >>> np.issubsctype(np.array([1]), np.float)\n    False\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_265issubsctype = {__Pyx_NAMESTR("issubsctype"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_265issubsctype, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_264issubsctype)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_265issubsctype(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_arg1 = 0;
  CYTHON_UNUSED PyObject *__pyx_v_arg2 = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("issubsctype (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__arg1,&__pyx_n_s__arg2,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__arg1)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__arg2)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("issubsctype", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6596; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "issubsctype") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6596; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_arg1 = values[0];
    __pyx_v_arg2 = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("issubsctype", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6596; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.issubsctype", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_264issubsctype(__pyx_self, __pyx_v_arg1, __pyx_v_arg2);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":6596
 * 
 * 
 * def issubsctype(arg1, arg2):             # <<<<<<<<<<<<<<
 *     """Determine if the first argument is a subclass of the second argument.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_264issubsctype(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_arg1, CYTHON_UNUSED PyObject *__pyx_v_arg2) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("issubsctype", 0);

  /* "ga4py/gain/notimplemented.pyx":6623
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6623; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.issubsctype", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_267iterable(PyObject *__pyx_self, PyObject *__pyx_v_y); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_266iterable[] = "Check whether or not an object can be iterated over.\n\n    Parameters\n    ----------\n    y : object\n      Input object.\n\n    Returns\n    -------\n    b : {0, 1}\n      Return 1 if the object has an iterator method or is a sequence,\n      and 0 otherwise.\n\n\n    Examples\n    --------\n    >>> np.iterable([1, 2, 3])\n    1\n    >>> np.iterable(2)\n    0\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_267iterable = {__Pyx_NAMESTR("iterable"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_267iterable, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_266iterable)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_267iterable(PyObject *__pyx_self, PyObject *__pyx_v_y) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("iterable (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_266iterable(__pyx_self, ((PyObject *)__pyx_v_y));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":6626
 * 
 * 
 * def iterable(y):             # <<<<<<<<<<<<<<
 *     """Check whether or not an object can be iterated over.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_266iterable(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_y) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("iterable", 0);

  /* "ga4py/gain/notimplemented.pyx":6649
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6649; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.iterable", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_269ix_(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_268ix_[] = "Construct an open mesh from multiple sequences.\n\n    This function takes N 1-D sequences and returns N outputs with N\n    dimensions each, such that the shape is 1 in all but one dimension\n    and the dimension with the non-unit shape value cycles through all\n    N dimensions.\n\n    Using `ix_` one can quickly construct index arrays that will index\n    the cross product. ``a[np.ix_([1,3],[2,5])]`` returns the array\n    ``[[a[1,2] a[1,5]], [a[3,2] a[3,5]]]``.\n\n    Parameters\n    ----------\n    args : 1-D sequences\n\n    Returns\n    -------\n    out : tuple of ndarrays\n        N arrays with N dimensions each, with N the number of input\n        sequences. Together these arrays form an open mesh.\n\n    See Also\n    --------\n    ogrid, mgrid, meshgrid\n\n    Examples\n    --------\n    >>> a = np.arange(10).reshape(2, 5)\n    >>> a\n    array([[0, 1, 2, 3, 4],\n           [5, 6, 7, 8, 9]])\n    >>> ixgrid = np.ix_([0,1], [2,4])\n    >>> ixgrid\n    (array([[0],\n           [1]]), array([[2, 4]]))\n    >>> ixgrid[0].shape, ixgrid[1].shape\n    ((2, 1), (1, 2))\n    >>> a[ixgrid]\n    array([[2, 4],\n           [7, 9]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_269ix_ = {__Pyx_NAMESTR("ix_"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_269ix_, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_268ix_)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_269ix_(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ix_ (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_268ix_(__pyx_self);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":6652
 * 
 * 
 * def ix_():             # <<<<<<<<<<<<<<
 *     """Construct an open mesh from multiple sequences.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_268ix_(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("ix_", 0);

  /* "ga4py/gain/notimplemented.pyx":6695
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6695; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.ix_", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_271kaiser(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_270kaiser[] = "Return the Kaiser window.\n\n    The Kaiser window is a taper formed by using a Bessel function.\n\n    Parameters\n    ----------\n    M : int\n        Number of points in the output window. If zero or less, an\n        empty array is returned.\n    beta : float\n        Shape parameter for window.\n\n    Returns\n    -------\n    out : array\n        The window, normalized to one (the value one\n        appears only if the number of samples is odd).\n\n    See Also\n    --------\n    bartlett, blackman, hamming, hanning\n\n    Notes\n    -----\n    The Kaiser window is defined as\n\n    .. math::  w(n) = I_0\\left( \010eta \\sqrt{1-\014rac{4n^2}{(M-1)^2}}\n               \right)/I_0(\010eta)\n\n    with\n\n    .. math:: \\quad -\014rac{M-1}{2} \\leq n \\leq \014rac{M-1}{2},\n\n    where :math:`I_0` is the modified zeroth-order Bessel function.\n\n    The Kaiser was named for Jim Kaiser, who discovered a simple approximation\n    to the DPSS window based on Bessel functions.\n    The Kaiser window is a very good approximation to the Digital Prolate\n    Spheroidal Sequence, or Slepian window, which is the transform which\n    maximizes the energy in the main lobe of the window relative to total\n    energy.\n\n    The Kaiser can approximate many other windows by varying the beta\n    parameter.\n\n    ====  =======================\n    beta  Window shape\n    ====  =======================\n    0     Rectangular\n    5     Similar to a Hamming\n    6     Similar to a Hanning\n    8.6   Similar to a Blackman\n    ====  =======================\n\n    A beta value of 14 is probably a good starting point. Note that as beta\n    gets large, the window narrows, and so the number of samples needs to be\n    large enough to sample the increasingly narrow spike, otherwise nans will\n    get returned.\n\n\n    Most references to the Kaiser window come from the signal processing\n    literature, where it is used as one of many windowing functions for\n    smoothing values.  It"" is also known as an apodization (which means\n    \"removing the foot\", i.e. smoothing discontinuities at the beginning\n    and end of the sampled signal) or tapering function.\n\n    References\n    ----------\n    .. [1] J. F. Kaiser, \"Digital Filters\" - Ch 7 in \"Systems analysis by\n           digital computer\", Editors: F.F. Kuo and J.F. Kaiser, p 218-285.\n           John Wiley and Sons, New York, (1966).\n    .. [2] E.R. Kanasewich, \"Time Sequence Analysis in Geophysics\", The\n           University of Alberta Press, 1975, pp. 177-178.\n    .. [3] Wikipedia, \"Window function\",\n           http://en.wikipedia.org/wiki/Window_function\n\n    Examples\n    --------\n    >>> from numpy import kaiser\n    >>> kaiser(12, 14)\n    array([  7.72686684e-06,   3.46009194e-03,   4.65200189e-02,\n             2.29737120e-01,   5.99885316e-01,   9.45674898e-01,\n             9.45674898e-01,   5.99885316e-01,   2.29737120e-01,\n             4.65200189e-02,   3.46009194e-03,   7.72686684e-06])\n\n\n    Plot the window and the frequency response:\n\n    >>> from numpy import clip, log10, array, kaiser, linspace\n    >>> from numpy.fft import fft, fftshift\n    >>> import matplotlib.pyplot as plt\n\n    >>> window = kaiser(51, 14)\n    >>> plt.plot(window)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Kaiser window\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.ylabel(\"Amplitude\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.xlabel(\"Sample\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.show()\n\n    >>> plt.figure()\n    <matplotlib.figure.Figure object at 0x...>\n    >>> A = fft(window, 2048) / 25.5\n    >>> mag = abs(fftshift(A))\n    >>> freq = linspace(-0.5,0.5,len(A))\n    >>> response = 20*log10(mag)\n    >>> response = clip(response,-100,100)\n    >>> plt.plot(freq, response)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Frequency response of Kaiser window\")\n    <matplot""lib.text.Text object at 0x...>\n    >>> plt.ylabel(\"Magnitude [dB]\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.xlabel(\"Normalized frequency [cycles per sample]\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.axis('tight')\n    (-0.5, 0.5, -100.0, ...)\n    >>> plt.show()\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_271kaiser = {__Pyx_NAMESTR("kaiser"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_271kaiser, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_270kaiser)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_271kaiser(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_M = 0;
  CYTHON_UNUSED PyObject *__pyx_v_beta = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("kaiser (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__M,&__pyx_n_s__beta,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__M)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__beta)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("kaiser", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6698; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "kaiser") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6698; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_M = values[0];
    __pyx_v_beta = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("kaiser", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6698; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.kaiser", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_270kaiser(__pyx_self, __pyx_v_M, __pyx_v_beta);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":6698
 * 
 * 
 * def kaiser(M, beta):             # <<<<<<<<<<<<<<
 *     """Return the Kaiser window.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_270kaiser(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_M, CYTHON_UNUSED PyObject *__pyx_v_beta) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("kaiser", 0);

  /* "ga4py/gain/notimplemented.pyx":6822
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6822; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.kaiser", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_273kron(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_272kron[] = "Kronecker product of two arrays.\n\n    Computes the Kronecker product, a composite array made of blocks of the\n    second array scaled by the first.\n\n    Parameters\n    ----------\n    a, b : array_like\n\n    Returns\n    -------\n    out : ndarray\n\n    See Also\n    --------\n\n    outer : The outer product\n\n    Notes\n    -----\n\n    The function assumes that the number of dimenensions of `a` and `b`\n    are the same, if necessary prepending the smallest with ones.\n    If `a.shape = (r0,r1,..,rN)` and `b.shape = (s0,s1,...,sN)`,\n    the Kronecker product has shape `(r0*s0, r1*s1, ..., rN*SN)`.\n    The elements are products of elements from `a` and `b`, organized\n    explicitly by::\n\n        kron(a,b)[k0,k1,...,kN] = a[i0,i1,...,iN] * b[j0,j1,...,jN]\n\n    where::\n\n        kt = it * st + jt,  t = 0,...,N\n\n    In the common 2-D case (N=1), the block structure can be visualized::\n\n        [[ a[0,0]*b,   a[0,1]*b,  ... , a[0,-1]*b  ],\n         [  ...                              ...   ],\n         [ a[-1,0]*b,  a[-1,1]*b, ... , a[-1,-1]*b ]]\n\n\n    Examples\n    --------\n    >>> np.kron([1,10,100], [5,6,7])\n    array([  5,   6,   7,  50,  60,  70, 500, 600, 700])\n    >>> np.kron([5,6,7], [1,10,100])\n    array([  5,  50, 500,   6,  60, 600,   7,  70, 700])\n\n    >>> np.kron(np.eye(2), np.ones((2,2)))\n    array([[ 1.,  1.,  0.,  0.],\n           [ 1.,  1.,  0.,  0.],\n           [ 0.,  0.,  1.,  1.],\n           [ 0.,  0.,  1.,  1.]])\n\n    >>> a = np.arange(100).reshape((2,5,2,5))\n    >>> b = np.arange(24).reshape((2,3,4))\n    >>> c = np.kron(a,b)\n    >>> c.shape\n    (2, 10, 6, 20)\n    >>> I = (1,3,0,2)\n    >>> J = (0,2,1)\n    >>> J1 = (0,) + J             # extend to ndim=4\n    >>> S1 = (1,) + b.shape\n    >>> K = tuple(np.array(I) * np.array(S1) + np.array(J1))\n    >>> c[K] == a[I]*b[J]\n    True\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_273kron = {__Pyx_NAMESTR("kron"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_273kron, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_272kron)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_273kron(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_b = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("kron (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__b,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__b)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("kron", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6825; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "kron") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6825; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_a = values[0];
    __pyx_v_b = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("kron", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6825; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.kron", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_272kron(__pyx_self, __pyx_v_a, __pyx_v_b);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":6825
 * 
 * 
 * def kron(a, b):             # <<<<<<<<<<<<<<
 *     """Kronecker product of two arrays.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_272kron(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_b) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("kron", 0);

  /* "ga4py/gain/notimplemented.pyx":6894
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6894; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.kron", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_275lexsort(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_274lexsort[] = "lexsort(keys, axis=-1)\n\n    Perform an indirect sort using a sequence of keys.\n\n    Given multiple sorting keys, which can be interpreted as columns in a\n    spreadsheet, lexsort returns an array of integer indices that describes\n    the sort order by multiple columns. The last key in the sequence is used\n    for the primary sort order, the second-to-last key for the secondary sort\n    order, and so on. The keys argument must be a sequence of objects that\n    can be converted to arrays of the same shape. If a 2D array is provided\n    for the keys argument, it's rows are interpreted as the sorting keys and\n    sorting is according to the last row, second last row etc.\n\n    Parameters\n    ----------\n    keys : (k,N) array or tuple containing k (N,)-shaped sequences\n        The `k` different \"columns\" to be sorted.  The last column (or row if\n        `keys` is a 2D array) is the primary sort key.\n    axis : int, optional\n        Axis to be indirectly sorted.  By default, sort over the last axis.\n\n    Returns\n    -------\n    indices : (N,) ndarray of ints\n        Array of indices that sort the keys along the specified axis.\n\n    See Also\n    --------\n    argsort : Indirect sort.\n    ndarray.sort : In-place sort.\n    sort : Return a sorted copy of an array.\n\n    Examples\n    --------\n    Sort names: first by surname, then by name.\n\n    >>> surnames =    ('Hertz',    'Galilei', 'Hertz')\n    >>> first_names = ('Heinrich', 'Galileo', 'Gustav')\n    >>> ind = np.lexsort((first_names, surnames))\n    >>> ind\n    array([1, 2, 0])\n\n    >>> [surnames[i] + \", \" + first_names[i] for i in ind]\n    ['Galilei, Galileo', 'Hertz, Gustav', 'Hertz, Heinrich']\n\n    Sort two columns of numbers:\n\n    >>> a = [1,5,1,4,3,4,4] # First column\n    >>> b = [9,4,0,4,0,2,1] # Second column\n    >>> ind = np.lexsort((b,a)) # Sort by a, then by b\n    >>> print ind\n    [2 0 4 6 5 3 1]\n\n    >>> [(a[i],b[i]) for i in ind]\n    [(1, 0), (1, 9), (3, 0)"", (4, 1), (4, 2), (4, 4), (5, 4)]\n\n    Note that sorting is first according to the elements of ``a``.\n    Secondary sorting is according to the elements of ``b``.\n\n    A normal ``argsort`` would have yielded:\n\n    >>> [(a[i],b[i]) for i in np.argsort(a)]\n    [(1, 9), (1, 0), (3, 0), (4, 4), (4, 2), (4, 1), (5, 4)]\n\n    Structured arrays are sorted lexically by ``argsort``:\n\n    >>> x = np.array([(1,9), (5,4), (1,0), (4,4), (3,0), (4,2), (4,1)],\n    ...              dtype=np.dtype([('x', int), ('y', int)]))\n\n    >>> np.argsort(x) # or np.argsort(x, order=('x', 'y'))\n    array([2, 0, 4, 6, 5, 3, 1])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_275lexsort = {__Pyx_NAMESTR("lexsort"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_275lexsort, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_274lexsort)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_275lexsort(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_keys = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("lexsort (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__keys,&__pyx_n_s__axis,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)__pyx_int_neg_1);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__keys)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "lexsort") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6897; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_keys = values[0];
    __pyx_v_axis = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("lexsort", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6897; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.lexsort", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_274lexsort(__pyx_self, __pyx_v_keys, __pyx_v_axis);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":6897
 * 
 * 
 * def lexsort(keys, axis=-1):             # <<<<<<<<<<<<<<
 *     """lexsort(keys, axis=-1)
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_274lexsort(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_keys, CYTHON_UNUSED PyObject *__pyx_v_axis) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("lexsort", 0);

  /* "ga4py/gain/notimplemented.pyx":6972
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6972; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.lexsort", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_277load(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_276load[] = "Load a pickled, ``.npy``, or ``.npz`` binary file.\n\n    Parameters\n    ----------\n    file : file-like object or string\n        The file to read.  It must support ``seek()`` and ``read()`` methods.\n        If the filename extension is ``.gz``, the file is first decompressed.\n    mmap_mode: {None, 'r+', 'r', 'w+', 'c'}, optional\n        If not None, then memory-map the file, using the given mode\n        (see `numpy.memmap`).  The mode has no effect for pickled or\n        zipped files.\n        A memory-mapped array is stored on disk, and not directly loaded\n        into memory.  However, it can be accessed and sliced like any\n        ndarray.  Memory mapping is especially useful for accessing\n        small fragments of large files without reading the entire file\n        into memory.\n\n    Returns\n    -------\n    result : array, tuple, dict, etc.\n        Data stored in the file.\n\n    Raises\n    ------\n    IOError\n        If the input file does not exist or cannot be read.\n\n    See Also\n    --------\n    save, savez, loadtxt\n    memmap : Create a memory-map to an array stored in a file on disk.\n\n    Notes\n    -----\n    - If the file contains pickle data, then whatever is stored in the\n      pickle is returned.\n    - If the file is a ``.npy`` file, then an array is returned.\n    - If the file is a ``.npz`` file, then a dictionary-like object is\n      returned, containing ``{filename: array}`` key-value pairs, one for\n      each file in the archive.\n\n    Examples\n    --------\n    Store data to disk, and load it again:\n\n    >>> np.save('/tmp/123', np.array([[1, 2, 3], [4, 5, 6]]))\n    >>> np.load('/tmp/123.npy')\n    array([[1, 2, 3],\n           [4, 5, 6]])\n\n    Mem-map the stored array, and then access the second row\n    directly from disk:\n\n    >>> X = np.load('/tmp/123.npy', mmap_mode='r')\n    >>> X[1, :]\n    memmap([4, 5, 6])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_277load = {__Pyx_NAMESTR("load"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_277load, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_276load)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_277load(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_file = 0;
  CYTHON_UNUSED PyObject *__pyx_v_mmap_mode = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("load (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__file,&__pyx_n_s__mmap_mode,0};
    PyObject* values[2] = {0,0};

    /* "ga4py/gain/notimplemented.pyx":6975
 * 
 * 
 * def load(file, mmap_mode=None):             # <<<<<<<<<<<<<<
 *     """Load a pickled, ``.npy``, or ``.npz`` binary file.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__file)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__mmap_mode);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "load") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6975; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_file = values[0];
    __pyx_v_mmap_mode = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("load", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6975; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.load", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_276load(__pyx_self, __pyx_v_file, __pyx_v_mmap_mode);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_276load(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_file, CYTHON_UNUSED PyObject *__pyx_v_mmap_mode) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("load", 0);

  /* "ga4py/gain/notimplemented.pyx":7034
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7034; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.load", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_279loads(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_278loads[] = "loads(string) -- Load a pickle from the given string\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_279loads = {__Pyx_NAMESTR("loads"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_279loads, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_278loads)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_279loads(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("loads (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_278loads(__pyx_self);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":7037
 * 
 * 
 * def loads():             # <<<<<<<<<<<<<<
 *     """loads(string) -- Load a pickle from the given string
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_278loads(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("loads", 0);

  /* "ga4py/gain/notimplemented.pyx":7042
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7042; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.loads", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_281loadtxt(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_280loadtxt[] = "Load data from a text file.\n\n    Each row in the text file must have the same number of values.\n\n    Parameters\n    ----------\n    fname : file or str\n        File, filename, or generator to read.  If the filename extension is\n        ``.gz`` or ``.bz2``, the file is first decompressed. Note that\n        generators should return byte strings for Python 3k.\n    dtype : data-type, optional\n        Data-type of the resulting array; default: float.  If this is a\n        record data-type, the resulting array will be 1-dimensional, and\n        each row will be interpreted as an element of the array.  In this\n        case, the number of columns used must match the number of fields in\n        the data-type.\n    comments : str, optional\n        The character used to indicate the start of a comment;\n        default: '#'.\n    delimiter : str, optional\n        The string used to separate values.  By default, this is any\n        whitespace.\n    converters : dict, optional\n        A dictionary mapping column number to a function that will convert\n        that column to a float.  E.g., if column 0 is a date string:\n        ``converters = {0: datestr2num}``.  Converters can also be used to\n        provide a default value for missing data (but see also `genfromtxt`):\n        ``converters = {3: lambda s: float(s.strip() or 0)}``.  Default: None.\n    skiprows : int, optional\n        Skip the first `skiprows` lines; default: 0.\n    usecols : sequence, optional\n        Which columns to read, with 0 being the first.  For example,\n        ``usecols = (1,4,5)`` will extract the 2nd, 5th and 6th columns.\n        The default, None, results in all columns being read.\n    unpack : bool, optional\n        If True, the returned array is transposed, so that arguments may be\n        unpacked using ``x, y, z = loadtxt(...)``.  When used with a record\n        data-type, arrays are returned for each field.  Default is False.\n    ndmin : int, optional\n        The ""returned array will have at least `ndmin` dimensions.\n        Otherwise mono-dimensional axes will be squeezed. \n        Legal values: 0 (default), 1 or 2.\n        .. versionadded:: 1.6.0\n\n    Returns\n    -------\n    out : ndarray\n        Data read from the text file.\n\n    See Also\n    --------\n    load, fromstring, fromregex\n    genfromtxt : Load data with missing values handled as specified.\n    scipy.io.loadmat : reads MATLAB data files\n\n    Notes\n    -----\n    This function aims to be a fast reader for simply formatted files.  The\n    `genfromtxt` function provides more sophisticated handling of, e.g.,\n    lines with missing values.\n\n    Examples\n    --------\n    >>> from StringIO import StringIO   # StringIO behaves like a file object\n    >>> c = StringIO(\"0 1\n2 3\")\n    >>> np.loadtxt(c)\n    array([[ 0.,  1.],\n           [ 2.,  3.]])\n\n    >>> d = StringIO(\"M 21 72\nF 35 58\")\n    >>> np.loadtxt(d, dtype={'names': ('gender', 'age', 'weight'),\n    ...                      'formats': ('S1', 'i4', 'f4')})\n    array([('M', 21, 72.0), ('F', 35, 58.0)],\n          dtype=[('gender', '|S1'), ('age', '<i4'), ('weight', '<f4')])\n\n    >>> c = StringIO(\"1,0,2\n3,0,4\")\n    >>> x, y = np.loadtxt(c, delimiter=',', usecols=(0, 2), unpack=True)\n    >>> x\n    array([ 1.,  3.])\n    >>> y\n    array([ 2.,  4.])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_281loadtxt = {__Pyx_NAMESTR("loadtxt"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_281loadtxt, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_280loadtxt)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_281loadtxt(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_fname = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  CYTHON_UNUSED PyObject *__pyx_v_comments = 0;
  CYTHON_UNUSED PyObject *__pyx_v_delimiter = 0;
  CYTHON_UNUSED PyObject *__pyx_v_converters = 0;
  CYTHON_UNUSED PyObject *__pyx_v_skiprows = 0;
  CYTHON_UNUSED PyObject *__pyx_v_usecols = 0;
  CYTHON_UNUSED PyObject *__pyx_v_unpack = 0;
  CYTHON_UNUSED PyObject *__pyx_v_ndmin = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("loadtxt (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__fname,&__pyx_n_s__dtype,&__pyx_n_s__comments,&__pyx_n_s__delimiter,&__pyx_n_s__converters,&__pyx_n_s__skiprows,&__pyx_n_s__usecols,&__pyx_n_s__unpack,&__pyx_n_s__ndmin,0};
    PyObject* values[9] = {0,0,0,0,0,0,0,0,0};
    values[1] = __pyx_k_31;
    values[2] = ((PyObject *)__pyx_kp_s_16);

    /* "ga4py/gain/notimplemented.pyx":7045
 * 
 * 
 * def loadtxt(fname, dtype=float, comments='#', delimiter=None, converters=None, skiprows=0, usecols=None, unpack=False, ndmin=0):             # <<<<<<<<<<<<<<
 *     """Load data from a text file.
 * 
 */
    values[3] = ((PyObject *)Py_None);
    values[4] = ((PyObject *)Py_None);
    values[5] = ((PyObject *)__pyx_int_0);
    values[6] = ((PyObject *)Py_None);
    values[7] = __pyx_k_32;
    values[8] = ((PyObject *)__pyx_int_0);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  9: values[8] = PyTuple_GET_ITEM(__pyx_args, 8);
        case  8: values[7] = PyTuple_GET_ITEM(__pyx_args, 7);
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__fname)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__dtype);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__comments);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__delimiter);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__converters);
          if (value) { values[4] = value; kw_args--; }
        }
        case  5:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__skiprows);
          if (value) { values[5] = value; kw_args--; }
        }
        case  6:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__usecols);
          if (value) { values[6] = value; kw_args--; }
        }
        case  7:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__unpack);
          if (value) { values[7] = value; kw_args--; }
        }
        case  8:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__ndmin);
          if (value) { values[8] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "loadtxt") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7045; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  9: values[8] = PyTuple_GET_ITEM(__pyx_args, 8);
        case  8: values[7] = PyTuple_GET_ITEM(__pyx_args, 7);
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_fname = values[0];
    __pyx_v_dtype = values[1];
    __pyx_v_comments = values[2];
    __pyx_v_delimiter = values[3];
    __pyx_v_converters = values[4];
    __pyx_v_skiprows = values[5];
    __pyx_v_usecols = values[6];
    __pyx_v_unpack = values[7];
    __pyx_v_ndmin = values[8];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("loadtxt", 0, 1, 9, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7045; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.loadtxt", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_280loadtxt(__pyx_self, __pyx_v_fname, __pyx_v_dtype, __pyx_v_comments, __pyx_v_delimiter, __pyx_v_converters, __pyx_v_skiprows, __pyx_v_usecols, __pyx_v_unpack, __pyx_v_ndmin);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_280loadtxt(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_fname, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_comments, CYTHON_UNUSED PyObject *__pyx_v_delimiter, CYTHON_UNUSED PyObject *__pyx_v_converters, CYTHON_UNUSED PyObject *__pyx_v_skiprows, CYTHON_UNUSED PyObject *__pyx_v_usecols, CYTHON_UNUSED PyObject *__pyx_v_unpack, CYTHON_UNUSED PyObject *__pyx_v_ndmin) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("loadtxt", 0);

  /* "ga4py/gain/notimplemented.pyx":7129
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7129; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.loadtxt", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_283lookfor(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_282lookfor[] = "Do a keyword search on docstrings.\n\n    A list of of objects that matched the search is displayed,\n    sorted by relevance. All given keywords need to be found in the\n    docstring for it to be returned as a result, but the order does\n    not matter.\n\n    Parameters\n    ----------\n    what : str\n        String containing words to look for.\n    module : str or list, optional\n        Name of module(s) whose docstrings to go through.\n    import_modules : bool, optional\n        Whether to import sub-modules in packages. Default is True.\n    regenerate : bool, optional\n        Whether to re-generate the docstring cache. Default is False.\n    output : file-like, optional\n        File-like object to write the output to. If omitted, use a pager.\n\n    See Also\n    --------\n    source, info\n\n    Notes\n    -----\n    Relevance is determined only roughly, by checking if the keywords occur\n    in the function name, at the start of a docstring, etc.\n\n    Examples\n    --------\n    >>> np.lookfor('binary representation')\n    Search results for 'binary representation'\n    ------------------------------------------\n    numpy.binary_repr\n        Return the binary representation of the input number as a string.\n    numpy.core.setup_common.long_double_representation\n        Given a binary dump as given by GNU od -b, look for long double\n    numpy.base_repr\n        Return a string representation of a number in the given base system.\n    ...\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_283lookfor = {__Pyx_NAMESTR("lookfor"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_283lookfor, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_282lookfor)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_283lookfor(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_what = 0;
  CYTHON_UNUSED PyObject *__pyx_v_module = 0;
  CYTHON_UNUSED PyObject *__pyx_v_import_modules = 0;
  CYTHON_UNUSED PyObject *__pyx_v_regenerate = 0;
  CYTHON_UNUSED PyObject *__pyx_v_output = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("lookfor (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__what,&__pyx_n_s__module,&__pyx_n_s__import_modules,&__pyx_n_s__regenerate,&__pyx_n_s__output,0};
    PyObject* values[5] = {0,0,0,0,0};

    /* "ga4py/gain/notimplemented.pyx":7132
 * 
 * 
 * def lookfor(what, module=None, import_modules=True, regenerate=False, output=None):             # <<<<<<<<<<<<<<
 *     """Do a keyword search on docstrings.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    values[2] = __pyx_k_33;
    values[3] = __pyx_k_34;
    values[4] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__what)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__module);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__import_modules);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__regenerate);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__output);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "lookfor") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7132; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_what = values[0];
    __pyx_v_module = values[1];
    __pyx_v_import_modules = values[2];
    __pyx_v_regenerate = values[3];
    __pyx_v_output = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("lookfor", 0, 1, 5, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7132; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.lookfor", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_282lookfor(__pyx_self, __pyx_v_what, __pyx_v_module, __pyx_v_import_modules, __pyx_v_regenerate, __pyx_v_output);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_282lookfor(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_what, CYTHON_UNUSED PyObject *__pyx_v_module, CYTHON_UNUSED PyObject *__pyx_v_import_modules, CYTHON_UNUSED PyObject *__pyx_v_regenerate, CYTHON_UNUSED PyObject *__pyx_v_output) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("lookfor", 0);

  /* "ga4py/gain/notimplemented.pyx":7176
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7176; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.lookfor", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_285mafromtxt(PyObject *__pyx_self, PyObject *__pyx_v_fname); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_284mafromtxt[] = "Load ASCII data stored in a text file and return a masked array.\n\n    For a complete description of all the input parameters, see `genfromtxt`.\n\n    See Also\n    --------\n    numpy.genfromtxt : generic function to load ASCII data.\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_285mafromtxt = {__Pyx_NAMESTR("mafromtxt"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_285mafromtxt, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_284mafromtxt)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_285mafromtxt(PyObject *__pyx_self, PyObject *__pyx_v_fname) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("mafromtxt (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_284mafromtxt(__pyx_self, ((PyObject *)__pyx_v_fname));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":7179
 * 
 * 
 * def mafromtxt(fname):             # <<<<<<<<<<<<<<
 *     """Load ASCII data stored in a text file and return a masked array.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_284mafromtxt(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_fname) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("mafromtxt", 0);

  /* "ga4py/gain/notimplemented.pyx":7189
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7189; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.mafromtxt", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_287mask_indices(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_286mask_indices[] = "Return the indices to access (n, n) arrays, given a masking function.\n\n    Assume `mask_func` is a function that, for a square array a of size\n    ``(n, n)`` with a possible offset argument `k`, when called as\n    ``mask_func(a, k)`` returns a new array with zeros in certain locations\n    (functions like `triu` or `tril` do precisely this). Then this function\n    returns the indices where the non-zero values would be located.\n\n    Parameters\n    ----------\n    n : int\n        The returned indices will be valid to access arrays of shape (n, n).\n    mask_func : callable\n        A function whose call signature is similar to that of `triu`, `tril`.\n        That is, ``mask_func(x, k)`` returns a boolean array, shaped like `x`.\n        `k` is an optional argument to the function.\n    k : scalar\n        An optional argument which is passed through to `mask_func`. Functions\n        like `triu`, `tril` take a second argument that is interpreted as an\n        offset.\n\n    Returns\n    -------\n    indices : tuple of arrays.\n        The `n` arrays of indices corresponding to the locations where\n        ``mask_func(np.ones((n, n)), k)`` is True.\n\n    See Also\n    --------\n    triu, tril, triu_indices, tril_indices\n\n    Notes\n    -----\n    .. versionadded:: 1.4.0\n\n    Examples\n    --------\n    These are the indices that would allow you to access the upper triangular\n    part of any 3x3 array:\n\n    >>> iu = np.mask_indices(3, np.triu)\n\n    For example, if `a` is a 3x3 array:\n\n    >>> a = np.arange(9).reshape(3, 3)\n    >>> a\n    array([[0, 1, 2],\n           [3, 4, 5],\n           [6, 7, 8]])\n    >>> a[iu]\n    array([0, 1, 2, 4, 5, 8])\n\n    An offset can be passed also to the masking function.  This gets us the\n    indices starting on the first diagonal right of the main one:\n\n    >>> iu1 = np.mask_indices(3, np.triu, 1)\n\n    with which we now extract only three elements:\n\n    >>> a[iu1]\n    array([1, 2, 5])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_287mask_indices = {__Pyx_NAMESTR("mask_indices"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_287mask_indices, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_286mask_indices)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_287mask_indices(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_n = 0;
  CYTHON_UNUSED PyObject *__pyx_v_mask_func = 0;
  CYTHON_UNUSED PyObject *__pyx_v_k = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("mask_indices (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__n,&__pyx_n_s__mask_func,&__pyx_n_s__k,0};
    PyObject* values[3] = {0,0,0};
    values[2] = ((PyObject *)__pyx_int_0);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__n)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__mask_func)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("mask_indices", 0, 2, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7192; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__k);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "mask_indices") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7192; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_n = values[0];
    __pyx_v_mask_func = values[1];
    __pyx_v_k = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("mask_indices", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7192; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.mask_indices", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_286mask_indices(__pyx_self, __pyx_v_n, __pyx_v_mask_func, __pyx_v_k);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":7192
 * 
 * 
 * def mask_indices(n, mask_func, k=0):             # <<<<<<<<<<<<<<
 *     """Return the indices to access (n, n) arrays, given a masking function.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_286mask_indices(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_n, CYTHON_UNUSED PyObject *__pyx_v_mask_func, CYTHON_UNUSED PyObject *__pyx_v_k) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("mask_indices", 0);

  /* "ga4py/gain/notimplemented.pyx":7256
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7256; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.mask_indices", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_289mat(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_288mat[] = "Interpret the input as a matrix.\n\n    Unlike `matrix`, `asmatrix` does not make a copy if the input is already\n    a matrix or an ndarray.  Equivalent to ``matrix(data, copy=False)``.\n\n    Parameters\n    ----------\n    data : array_like\n        Input data.\n\n    Returns\n    -------\n    mat : matrix\n        `data` interpreted as a matrix.\n\n    Examples\n    --------\n    >>> x = np.array([[1, 2], [3, 4]])\n\n    >>> m = np.asmatrix(x)\n\n    >>> x[0,0] = 5\n\n    >>> m\n    matrix([[5, 2],\n            [3, 4]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_289mat = {__Pyx_NAMESTR("mat"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_289mat, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_288mat)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_289mat(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_data = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("mat (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__data,&__pyx_n_s__dtype,0};
    PyObject* values[2] = {0,0};

    /* "ga4py/gain/notimplemented.pyx":7259
 * 
 * 
 * def mat(data, dtype=None):             # <<<<<<<<<<<<<<
 *     """Interpret the input as a matrix.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__data)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__dtype);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "mat") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7259; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_data = values[0];
    __pyx_v_dtype = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("mat", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7259; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.mat", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_288mat(__pyx_self, __pyx_v_data, __pyx_v_dtype);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_288mat(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_data, CYTHON_UNUSED PyObject *__pyx_v_dtype) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("mat", 0);

  /* "ga4py/gain/notimplemented.pyx":7288
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7288; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.mat", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_291max(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_290max[] = "Return the maximum of an array or maximum along an axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    axis : int, optional\n        Axis along which to operate.  By default flattened input is used.\n    out : ndarray, optional\n        Alternate output array in which to place the result.  Must be of\n        the same shape and buffer length as the expected output.  See\n        `doc.ufuncs` (Section \"Output arguments\") for more details.\n\n    Returns\n    -------\n    amax : ndarray or scalar\n        Maximum of `a`. If `axis` is None, the result is a scalar value.\n        If `axis` is given, the result is an array of dimension\n        ``a.ndim - 1``.\n\n    See Also\n    --------\n    nanmax : NaN values are ignored instead of being propagated.\n    fmax : same behavior as the C99 fmax function.\n    argmax : indices of the maximum values.\n\n    Notes\n    -----\n    NaN values are propagated, that is if at least one item is NaN, the\n    corresponding max value will be NaN as well.  To ignore NaN values\n    (MATLAB behavior), please use nanmax.\n\n    Examples\n    --------\n    >>> a = np.arange(4).reshape((2,2))\n    >>> a\n    array([[0, 1],\n           [2, 3]])\n    >>> np.amax(a)\n    3\n    >>> np.amax(a, axis=0)\n    array([2, 3])\n    >>> np.amax(a, axis=1)\n    array([1, 3])\n\n    >>> b = np.arange(5, dtype=np.float)\n    >>> b[2] = np.NaN\n    >>> np.amax(b)\n    nan\n    >>> np.nanmax(b)\n    4.0\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_291max = {__Pyx_NAMESTR("max"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_291max, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_290max)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_291max(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("max (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__axis,&__pyx_n_s__out,0};
    PyObject* values[3] = {0,0,0};

    /* "ga4py/gain/notimplemented.pyx":7291
 * 
 * 
 * def max(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the maximum of an array or maximum along an axis.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__out);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "max") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7291; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
    __pyx_v_out = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("max", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7291; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.max", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_290max(__pyx_self, __pyx_v_a, __pyx_v_axis, __pyx_v_out);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_290max(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("max", 0);

  /* "ga4py/gain/notimplemented.pyx":7345
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7345; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.max", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_293maximum_sctype(PyObject *__pyx_self, PyObject *__pyx_v_t); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_292maximum_sctype[] = "Return the scalar type of highest precision of the same kind as the input.\n\n    Parameters\n    ----------\n    t : dtype or dtype specifier\n        The input data type. This can be a `dtype` object or an object that\n        is convertible to a `dtype`.\n\n    Returns\n    -------\n    out : dtype\n        The highest precision data type of the same kind (`dtype.kind`) as `t`.\n\n    See Also\n    --------\n    obj2sctype, mintypecode, sctype2char\n    dtype\n\n    Examples\n    --------\n    >>> np.maximum_sctype(np.int)\n    <type 'numpy.int64'>\n    >>> np.maximum_sctype(np.uint8)\n    <type 'numpy.uint64'>\n    >>> np.maximum_sctype(np.complex)\n    <type 'numpy.complex192'>\n\n    >>> np.maximum_sctype(str)\n    <type 'numpy.string_'>\n\n    >>> np.maximum_sctype('i2')\n    <type 'numpy.int64'>\n    >>> np.maximum_sctype('f4')\n    <type 'numpy.float96'>\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_293maximum_sctype = {__Pyx_NAMESTR("maximum_sctype"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_293maximum_sctype, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_292maximum_sctype)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_293maximum_sctype(PyObject *__pyx_self, PyObject *__pyx_v_t) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("maximum_sctype (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_292maximum_sctype(__pyx_self, ((PyObject *)__pyx_v_t));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":7348
 * 
 * 
 * def maximum_sctype(t):             # <<<<<<<<<<<<<<
 *     """Return the scalar type of highest precision of the same kind as the input.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_292maximum_sctype(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_t) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("maximum_sctype", 0);

  /* "ga4py/gain/notimplemented.pyx":7385
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7385; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.maximum_sctype", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_295may_share_memory(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_294may_share_memory[] = "Determine if two arrays can share memory\n\n    The memory-bounds of a and b are computed.  If they overlap then\n    this function returns True.  Otherwise, it returns False.\n\n    A return of True does not necessarily mean that the two arrays\n    share any element.  It just means that they *might*.\n\n    Parameters\n    ----------\n    a, b : ndarray\n\n    Returns\n    -------\n    out : bool\n\n    Examples\n    --------\n    >>> np.may_share_memory(np.array([1,2]), np.array([5,8,9]))\n    False\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_295may_share_memory = {__Pyx_NAMESTR("may_share_memory"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_295may_share_memory, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_294may_share_memory)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_295may_share_memory(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_b = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("may_share_memory (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__b,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__b)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("may_share_memory", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7388; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "may_share_memory") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7388; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_a = values[0];
    __pyx_v_b = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("may_share_memory", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7388; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.may_share_memory", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_294may_share_memory(__pyx_self, __pyx_v_a, __pyx_v_b);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":7388
 * 
 * 
 * def may_share_memory(a, b):             # <<<<<<<<<<<<<<
 *     """Determine if two arrays can share memory
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_294may_share_memory(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_b) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("may_share_memory", 0);

  /* "ga4py/gain/notimplemented.pyx":7411
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7411; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.may_share_memory", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_297mean(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_296mean[] = "Compute the arithmetic mean along the specified axis.\n\n    Returns the average of the array elements.  The average is taken over\n    the flattened array by default, otherwise over the specified axis.\n    `float64` intermediate and return values are used for integer inputs.\n\n    Parameters\n    ----------\n    a : array_like\n        Array containing numbers whose mean is desired. If `a` is not an\n        array, a conversion is attempted.\n    axis : int, optional\n        Axis along which the means are computed. The default is to compute\n        the mean of the flattened array.\n    dtype : data-type, optional\n        Type to use in computing the mean.  For integer inputs, the default\n        is `float64`; for floating point inputs, it is the same as the\n        input dtype.\n    out : ndarray, optional\n        Alternate output array in which to place the result.  The default\n        is ``None``; if provided, it must have the same shape as the\n        expected output, but the type will be cast if necessary.\n        See `doc.ufuncs` for details.\n\n    Returns\n    -------\n    m : ndarray, see dtype parameter above\n        If `out=None`, returns a new array containing the mean values,\n        otherwise a reference to the output array is returned.\n\n    See Also\n    --------\n    average : Weighted average\n\n    Notes\n    -----\n    The arithmetic mean is the sum of the elements along the axis divided\n    by the number of elements.\n\n    Note that for floating-point input, the mean is computed using the\n    same precision the input has.  Depending on the input data, this can\n    cause the results to be inaccurate, especially for `float32` (see\n    example below).  Specifying a higher-precision accumulator using the\n    `dtype` keyword can alleviate this issue.\n\n    Examples\n    --------\n    >>> a = np.array([[1, 2], [3, 4]])\n    >>> np.mean(a)\n    2.5\n    >>> np.mean(a, axis=0)\n    array([ 2.,  3.])\n    >>> np.mean(a, axis=1)\n    ""array([ 1.5,  3.5])\n\n    In single precision, `mean` can be inaccurate:\n\n    >>> a = np.zeros((2, 512*512), dtype=np.float32)\n    >>> a[0, :] = 1.0\n    >>> a[1, :] = 0.1\n    >>> np.mean(a)\n    0.546875\n\n    Computing the mean in float64 is more accurate:\n\n    >>> np.mean(a, dtype=np.float64)\n    0.55000000074505806\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_297mean = {__Pyx_NAMESTR("mean"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_297mean, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_296mean)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_297mean(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("mean (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__axis,&__pyx_n_s__dtype,&__pyx_n_s__out,0};
    PyObject* values[4] = {0,0,0,0};

    /* "ga4py/gain/notimplemented.pyx":7414
 * 
 * 
 * def mean(a, axis=None, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Compute the arithmetic mean along the specified axis.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    values[3] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__dtype);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__out);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "mean") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7414; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
    __pyx_v_dtype = values[2];
    __pyx_v_out = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("mean", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7414; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.mean", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_296mean(__pyx_self, __pyx_v_a, __pyx_v_axis, __pyx_v_dtype, __pyx_v_out);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_296mean(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_out) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("mean", 0);

  /* "ga4py/gain/notimplemented.pyx":7484
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7484; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.mean", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_299median(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_298median[] = "Compute the median along the specified axis.\n\n    Returns the median of the array elements.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array or object that can be converted to an array.\n    axis : {None, int}, optional\n        Axis along which the medians are computed. The default (axis=None)\n        is to compute the median along a flattened version of the array.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must\n        have the same shape and buffer length as the expected output,\n        but the type (of the output) will be cast if necessary.\n    overwrite_input : {False, True}, optional\n       If True, then allow use of memory of input array (a) for\n       calculations. The input array will be modified by the call to\n       median. This will save memory when you do not need to preserve\n       the contents of the input array. Treat the input as undefined,\n       but it will probably be fully or partially sorted. Default is\n       False. Note that, if `overwrite_input` is True and the input\n       is not already an ndarray, an error will be raised.\n\n    Returns\n    -------\n    median : ndarray\n        A new array holding the result (unless `out` is specified, in\n        which case that array is returned instead).  If the input contains\n        integers, or floats of smaller precision than 64, then the output\n        data-type is float64.  Otherwise, the output data-type is the same\n        as that of the input.\n\n    See Also\n    --------\n    mean, percentile\n\n    Notes\n    -----\n    Given a vector V of length N, the median of V is the middle value of\n    a sorted copy of V, ``V_sorted`` - i.e., ``V_sorted[(N-1)/2]``, when N is\n    odd.  When N is even, it is the average of the two middle values of\n    ``V_sorted``.\n\n    Examples\n    --------\n    >>> a = np.array([[10, 7, 4], [3, 2, 1]])\n    >>> a\n    array([[10,  7,  4],\n           [ 3,  2,  1]])""\n    >>> np.median(a)\n    3.5\n    >>> np.median(a, axis=0)\n    array([ 6.5,  4.5,  2.5])\n    >>> np.median(a, axis=1)\n    array([ 7.,  2.])\n    >>> m = np.median(a, axis=0)\n    >>> out = np.zeros_like(m)\n    >>> np.median(a, axis=0, out=m)\n    array([ 6.5,  4.5,  2.5])\n    >>> m\n    array([ 6.5,  4.5,  2.5])\n    >>> b = a.copy()\n    >>> np.median(b, axis=1, overwrite_input=True)\n    array([ 7.,  2.])\n    >>> assert not np.all(a==b)\n    >>> b = a.copy()\n    >>> np.median(b, axis=None, overwrite_input=True)\n    3.5\n    >>> assert not np.all(a==b)\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_299median = {__Pyx_NAMESTR("median"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_299median, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_298median)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_299median(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  CYTHON_UNUSED PyObject *__pyx_v_overwrite_input = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("median (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__axis,&__pyx_n_s__out,&__pyx_n_s__overwrite_input,0};
    PyObject* values[4] = {0,0,0,0};

    /* "ga4py/gain/notimplemented.pyx":7487
 * 
 * 
 * def median(a, axis=None, out=None, overwrite_input=False):             # <<<<<<<<<<<<<<
 *     """Compute the median along the specified axis.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    values[3] = __pyx_k_35;
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__out);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__overwrite_input);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "median") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7487; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
    __pyx_v_out = values[2];
    __pyx_v_overwrite_input = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("median", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7487; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.median", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_298median(__pyx_self, __pyx_v_a, __pyx_v_axis, __pyx_v_out, __pyx_v_overwrite_input);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_298median(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out, CYTHON_UNUSED PyObject *__pyx_v_overwrite_input) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("median", 0);

  /* "ga4py/gain/notimplemented.pyx":7560
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7560; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.median", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_301meshgrid(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_300meshgrid[] = "Return coordinate matrices from two coordinate vectors.\n\n    Parameters\n    ----------\n    x, y : ndarray\n        Two 1-D arrays representing the x and y coordinates of a grid.\n\n    Returns\n    -------\n    X, Y : ndarray\n        For vectors `x`, `y` with lengths ``Nx=len(x)`` and ``Ny=len(y)``,\n        return `X`, `Y` where `X` and `Y` are ``(Ny, Nx)`` shaped arrays\n        with the elements of `x` and y repeated to fill the matrix along\n        the first dimension for `x`, the second for `y`.\n\n    See Also\n    --------\n    index_tricks.mgrid : Construct a multi-dimensional \"meshgrid\"\n                         using indexing notation.\n    index_tricks.ogrid : Construct an open multi-dimensional \"meshgrid\"\n                         using indexing notation.\n\n    Examples\n    --------\n    >>> X, Y = np.meshgrid([1,2,3], [4,5,6,7])\n    >>> X\n    array([[1, 2, 3],\n           [1, 2, 3],\n           [1, 2, 3],\n           [1, 2, 3]])\n    >>> Y\n    array([[4, 4, 4],\n           [5, 5, 5],\n           [6, 6, 6],\n           [7, 7, 7]])\n\n    `meshgrid` is very useful to evaluate functions on a grid.\n\n    >>> x = np.arange(-5, 5, 0.1)\n    >>> y = np.arange(-5, 5, 0.1)\n    >>> xx, yy = np.meshgrid(x, y)\n    >>> z = np.sin(xx**2+yy**2)/(xx**2+yy**2)\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_301meshgrid = {__Pyx_NAMESTR("meshgrid"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_301meshgrid, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_300meshgrid)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_301meshgrid(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_x = 0;
  CYTHON_UNUSED PyObject *__pyx_v_y = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("meshgrid (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__x,&__pyx_n_s__y,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__x)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__y)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("meshgrid", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7563; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "meshgrid") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7563; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_x = values[0];
    __pyx_v_y = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("meshgrid", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7563; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.meshgrid", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_300meshgrid(__pyx_self, __pyx_v_x, __pyx_v_y);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":7563
 * 
 * 
 * def meshgrid(x, y):             # <<<<<<<<<<<<<<
 *     """Return coordinate matrices from two coordinate vectors.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_300meshgrid(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_y) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("meshgrid", 0);

  /* "ga4py/gain/notimplemented.pyx":7608
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7608; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.meshgrid", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_303min(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_302min[] = "Return the minimum of an array or minimum along an axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    axis : int, optional\n        Axis along which to operate.  By default a flattened input is used.\n    out : ndarray, optional\n        Alternative output array in which to place the result.  Must\n        be of the same shape and buffer length as the expected output.\n        See `doc.ufuncs` (Section \"Output arguments\") for more details.\n\n    Returns\n    -------\n    amin : ndarray\n        A new array or a scalar array with the result.\n\n    See Also\n    --------\n    nanmin: nan values are ignored instead of being propagated\n    fmin: same behavior as the C99 fmin function\n    argmin: Return the indices of the minimum values.\n\n    amax, nanmax, fmax\n\n    Notes\n    -----\n    NaN values are propagated, that is if at least one item is nan, the\n    corresponding min value will be nan as well. To ignore NaN values (matlab\n    behavior), please use nanmin.\n\n    Examples\n    --------\n    >>> a = np.arange(4).reshape((2,2))\n    >>> a\n    array([[0, 1],\n           [2, 3]])\n    >>> np.amin(a)           # Minimum of the flattened array\n    0\n    >>> np.amin(a, axis=0)         # Minima along the first axis\n    array([0, 1])\n    >>> np.amin(a, axis=1)         # Minima along the second axis\n    array([0, 2])\n\n    >>> b = np.arange(5, dtype=np.float)\n    >>> b[2] = np.NaN\n    >>> np.amin(b)\n    nan\n    >>> np.nanmin(b)\n    0.0\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_303min = {__Pyx_NAMESTR("min"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_303min, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_302min)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_303min(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("min (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__axis,&__pyx_n_s__out,0};
    PyObject* values[3] = {0,0,0};

    /* "ga4py/gain/notimplemented.pyx":7611
 * 
 * 
 * def min(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the minimum of an array or minimum along an axis.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__out);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "min") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7611; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
    __pyx_v_out = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("min", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7611; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.min", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_302min(__pyx_self, __pyx_v_a, __pyx_v_axis, __pyx_v_out);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_302min(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("min", 0);

  /* "ga4py/gain/notimplemented.pyx":7665
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7665; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.min", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_305min_scalar_type(PyObject *__pyx_self, PyObject *__pyx_v_a); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_304min_scalar_type[] = "min_scalar_type(a)\n\n    For scalar ``a``, returns the data type with the smallest size\n    and smallest scalar kind which can hold its value.  For non-scalar\n    array ``a``, returns the vector's dtype unmodified.\n\n    Floating point values are not demoted to integers,\n    and complex values are not demoted to floats.\n\n    Parameters\n    ----------\n    a : scalar or array_like\n        The value whose minimal data type is to be found.\n\n    Returns\n    -------\n    out : dtype\n        The minimal data type.\n\n    Notes\n    -----\n    .. versionadded:: 1.6.0\n\n    See Also\n    --------\n    result_type, promote_types, dtype, can_cast\n\n    Examples\n    --------\n    >>> np.min_scalar_type(10)\n    dtype('uint8')\n\n    >>> np.min_scalar_type(-260)\n    dtype('int16')\n\n    >>> np.min_scalar_type(3.1)\n    dtype('float16')\n\n    >>> np.min_scalar_type(1e50)\n    dtype('float64')\n\n    >>> np.min_scalar_type(np.arange(4,dtype='f8'))\n    dtype('float64')\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_305min_scalar_type = {__Pyx_NAMESTR("min_scalar_type"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_305min_scalar_type, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_304min_scalar_type)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_305min_scalar_type(PyObject *__pyx_self, PyObject *__pyx_v_a) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("min_scalar_type (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_304min_scalar_type(__pyx_self, ((PyObject *)__pyx_v_a));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":7668
 * 
 * 
 * def min_scalar_type(a):             # <<<<<<<<<<<<<<
 *     """min_scalar_type(a)
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_304min_scalar_type(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("min_scalar_type", 0);

  /* "ga4py/gain/notimplemented.pyx":7715
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7715; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.min_scalar_type", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_307mintypecode(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_306mintypecode[] = "Return the character for the minimum-size type to which given types can\n    be safely cast.\n\n    The returned type character must represent the smallest size dtype such\n    that an array of the returned type can handle the data from an array of\n    all types in `typechars` (or if `typechars` is an array, then its\n    dtype.char).\n\n    Parameters\n    ----------\n    typechars : list of str or array_like\n        If a list of strings, each string should represent a dtype.\n        If array_like, the character representation of the array dtype is used.\n    typeset : str or list of str, optional\n        The set of characters that the returned character is chosen from.\n        The default set is 'GDFgdf'.\n    default : str, optional\n        The default character, this is returned if none of the characters in\n        `typechars` matches a character in `typeset`.\n\n    Returns\n    -------\n    typechar : str\n        The character representing the minimum-size type that was found.\n\n    See Also\n    --------\n    dtype, sctype2char, maximum_sctype\n\n    Examples\n    --------\n    >>> np.mintypecode(['d', 'f', 'S'])\n    'd'\n    >>> x = np.array([1.1, 2-3.j])\n    >>> np.mintypecode(x)\n    'D'\n\n    >>> np.mintypecode('abceh', default='G')\n    'G'\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_307mintypecode = {__Pyx_NAMESTR("mintypecode"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_307mintypecode, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_306mintypecode)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_307mintypecode(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_typechars = 0;
  CYTHON_UNUSED PyObject *__pyx_v_typeset = 0;
  CYTHON_UNUSED PyObject *__pyx_v_default = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("mintypecode (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__typechars,&__pyx_n_s__typeset,&__pyx_n_s__default,0};
    PyObject* values[3] = {0,0,0};
    values[1] = ((PyObject *)__pyx_n_s__GDFgdf);
    values[2] = ((PyObject *)__pyx_n_s__d);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__typechars)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__typeset);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__default);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "mintypecode") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7718; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_typechars = values[0];
    __pyx_v_typeset = values[1];
    __pyx_v_default = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("mintypecode", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7718; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.mintypecode", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_306mintypecode(__pyx_self, __pyx_v_typechars, __pyx_v_typeset, __pyx_v_default);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":7718
 * 
 * 
 * def mintypecode(typechars, typeset='GDFgdf', default='d'):             # <<<<<<<<<<<<<<
 *     """Return the character for the minimum-size type to which given types can
 *     be safely cast.
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_306mintypecode(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_typechars, CYTHON_UNUSED PyObject *__pyx_v_typeset, CYTHON_UNUSED PyObject *__pyx_v_default) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("mintypecode", 0);

  /* "ga4py/gain/notimplemented.pyx":7760
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7760; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.mintypecode", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_309mirr(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_308mirr[] = "Modified internal rate of return.\n\n    Parameters\n    ----------\n    values : array_like\n        Cash flows (must contain at least one positive and one negative value)\n        or nan is returned.  The first value is considered a sunk cost at time zero.\n    finance_rate : scalar\n        Interest rate paid on the cash flows\n    reinvest_rate : scalar\n        Interest rate received on the cash flows upon reinvestment\n\n    Returns\n    -------\n    out : float\n        Modified internal rate of return\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_309mirr = {__Pyx_NAMESTR("mirr"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_309mirr, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_308mirr)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_309mirr(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_values = 0;
  CYTHON_UNUSED PyObject *__pyx_v_finance_rate = 0;
  CYTHON_UNUSED PyObject *__pyx_v_reinvest_rate = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("mirr (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__values,&__pyx_n_s__finance_rate,&__pyx_n_s__reinvest_rate,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__values)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__finance_rate)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("mirr", 1, 3, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7763; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__reinvest_rate)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("mirr", 1, 3, 3, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7763; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "mirr") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7763; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_values = values[0];
    __pyx_v_finance_rate = values[1];
    __pyx_v_reinvest_rate = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("mirr", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7763; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.mirr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_308mirr(__pyx_self, __pyx_v_values, __pyx_v_finance_rate, __pyx_v_reinvest_rate);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":7763
 * 
 * 
 * def mirr(values, finance_rate, reinvest_rate):             # <<<<<<<<<<<<<<
 *     """Modified internal rate of return.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_308mirr(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_values, CYTHON_UNUSED PyObject *__pyx_v_finance_rate, CYTHON_UNUSED PyObject *__pyx_v_reinvest_rate) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("mirr", 0);

  /* "ga4py/gain/notimplemented.pyx":7782
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7782; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.mirr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_311msort(PyObject *__pyx_self, PyObject *__pyx_v_a); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_310msort[] = "Return a copy of an array sorted along the first axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Array to be sorted.\n\n    Returns\n    -------\n    sorted_array : ndarray\n        Array of the same type and shape as `a`.\n\n    See Also\n    --------\n    sort\n\n    Notes\n    -----\n    ``np.msort(a)`` is equivalent to  ``np.sort(a, axis=0)``.\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_311msort = {__Pyx_NAMESTR("msort"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_311msort, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_310msort)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_311msort(PyObject *__pyx_self, PyObject *__pyx_v_a) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("msort (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_310msort(__pyx_self, ((PyObject *)__pyx_v_a));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":7785
 * 
 * 
 * def msort(a):             # <<<<<<<<<<<<<<
 *     """Return a copy of an array sorted along the first axis.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_310msort(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("msort", 0);

  /* "ga4py/gain/notimplemented.pyx":7807
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7807; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.msort", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_313nan_to_num(PyObject *__pyx_self, PyObject *__pyx_v_x); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_312nan_to_num[] = "Replace nan with zero and inf with finite numbers.\n\n    Returns an array or scalar replacing Not a Number (NaN) with zero,\n    (positive) infinity with a very large number and negative infinity\n    with a very small (or negative) number.\n\n    Parameters\n    ----------\n    x : array_like\n        Input data.\n\n    Returns\n    -------\n    out : ndarray, float\n        Array with the same shape as `x` and dtype of the element in `x`  with\n        the greatest precision. NaN is replaced by zero, and infinity\n        (-infinity) is replaced by the largest (smallest or most negative)\n        floating point value that fits in the output dtype. All finite numbers\n        are upcast to the output dtype (default float64).\n\n    See Also\n    --------\n    isinf : Shows which elements are negative or negative infinity.\n    isneginf : Shows which elements are negative infinity.\n    isposinf : Shows which elements are positive infinity.\n    isnan : Shows which elements are Not a Number (NaN).\n    isfinite : Shows which elements are finite (not NaN, not infinity)\n\n    Notes\n    -----\n    Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n    (IEEE 754). This means that Not a Number is not equivalent to infinity.\n\n\n    Examples\n    --------\n    >>> np.set_printoptions(precision=8)\n    >>> x = np.array([np.inf, -np.inf, np.nan, -128, 128])\n    >>> np.nan_to_num(x)\n    array([  1.79769313e+308,  -1.79769313e+308,   0.00000000e+000,\n            -1.28000000e+002,   1.28000000e+002])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_313nan_to_num = {__Pyx_NAMESTR("nan_to_num"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_313nan_to_num, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_312nan_to_num)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_313nan_to_num(PyObject *__pyx_self, PyObject *__pyx_v_x) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("nan_to_num (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_312nan_to_num(__pyx_self, ((PyObject *)__pyx_v_x));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":7810
 * 
 * 
 * def nan_to_num(x):             # <<<<<<<<<<<<<<
 *     """Replace nan with zero and inf with finite numbers.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_312nan_to_num(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("nan_to_num", 0);

  /* "ga4py/gain/notimplemented.pyx":7854
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7854; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.nan_to_num", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_315nanargmax(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_314nanargmax[] = "Return indices of the maximum values over an axis, ignoring NaNs.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    axis : int, optional\n        Axis along which to operate.  By default flattened input is used.\n\n    Returns\n    -------\n    index_array : ndarray\n        An array of indices or a single index value.\n\n    See Also\n    --------\n    argmax, nanargmin\n\n    Examples\n    --------\n    >>> a = np.array([[np.nan, 4], [2, 3]])\n    >>> np.argmax(a)\n    0\n    >>> np.nanargmax(a)\n    1\n    >>> np.nanargmax(a, axis=0)\n    array([1, 0])\n    >>> np.nanargmax(a, axis=1)\n    array([1, 1])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_315nanargmax = {__Pyx_NAMESTR("nanargmax"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_315nanargmax, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_314nanargmax)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_315nanargmax(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("nanargmax (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__axis,0};
    PyObject* values[2] = {0,0};

    /* "ga4py/gain/notimplemented.pyx":7857
 * 
 * 
 * def nanargmax(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Return indices of the maximum values over an axis, ignoring NaNs.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "nanargmax") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7857; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("nanargmax", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7857; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.nanargmax", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_314nanargmax(__pyx_self, __pyx_v_a, __pyx_v_axis);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_314nanargmax(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("nanargmax", 0);

  /* "ga4py/gain/notimplemented.pyx":7889
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7889; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.nanargmax", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_317nanargmin(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_316nanargmin[] = "Return indices of the minimum values over an axis, ignoring NaNs.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    axis : int, optional\n        Axis along which to operate.  By default flattened input is used.\n\n    Returns\n    -------\n    index_array : ndarray\n        An array of indices or a single index value.\n\n    See Also\n    --------\n    argmin, nanargmax\n\n    Examples\n    --------\n    >>> a = np.array([[np.nan, 4], [2, 3]])\n    >>> np.argmin(a)\n    0\n    >>> np.nanargmin(a)\n    2\n    >>> np.nanargmin(a, axis=0)\n    array([1, 1])\n    >>> np.nanargmin(a, axis=1)\n    array([1, 0])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_317nanargmin = {__Pyx_NAMESTR("nanargmin"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_317nanargmin, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_316nanargmin)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_317nanargmin(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("nanargmin (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__axis,0};
    PyObject* values[2] = {0,0};

    /* "ga4py/gain/notimplemented.pyx":7892
 * 
 * 
 * def nanargmin(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Return indices of the minimum values over an axis, ignoring NaNs.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "nanargmin") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7892; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("nanargmin", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7892; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.nanargmin", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_316nanargmin(__pyx_self, __pyx_v_a, __pyx_v_axis);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_316nanargmin(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("nanargmin", 0);

  /* "ga4py/gain/notimplemented.pyx":7924
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7924; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.nanargmin", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_319nanmax(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_318nanmax[] = "Return the maximum of an array or maximum along an axis ignoring any NaNs.\n\n    Parameters\n    ----------\n    a : array_like\n        Array containing numbers whose maximum is desired. If `a` is not\n        an array, a conversion is attempted.\n    axis : int, optional\n        Axis along which the maximum is computed. The default is to compute\n        the maximum of the flattened array.\n\n    Returns\n    -------\n    nanmax : ndarray\n        An array with the same shape as `a`, with the specified axis removed.\n        If `a` is a 0-d array, or if axis is None, a ndarray scalar is\n        returned.  The the same dtype as `a` is returned.\n\n    See Also\n    --------\n    numpy.amax : Maximum across array including any Not a Numbers.\n    numpy.nanmin : Minimum across array ignoring any Not a Numbers.\n    isnan : Shows which elements are Not a Number (NaN).\n    isfinite: Shows which elements are not: Not a Number, positive and\n             negative infinity\n\n    Notes\n    -----\n    Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n    (IEEE 754). This means that Not a Number is not equivalent to infinity.\n    Positive infinity is treated as a very large number and negative infinity\n    is treated as a very small (i.e. negative) number.\n\n    If the input has a integer type the function is equivalent to np.max.\n\n    Examples\n    --------\n    >>> a = np.array([[1, 2], [3, np.nan]])\n    >>> np.nanmax(a)\n    3.0\n    >>> np.nanmax(a, axis=0)\n    array([ 3.,  2.])\n    >>> np.nanmax(a, axis=1)\n    array([ 2.,  3.])\n\n    When positive infinity and negative infinity are present:\n\n    >>> np.nanmax([1, 2, np.nan, np.NINF])\n    2.0\n    >>> np.nanmax([1, 2, np.nan, np.inf])\n    inf\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_319nanmax = {__Pyx_NAMESTR("nanmax"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_319nanmax, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_318nanmax)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_319nanmax(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("nanmax (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__axis,0};
    PyObject* values[2] = {0,0};

    /* "ga4py/gain/notimplemented.pyx":7927
 * 
 * 
 * def nanmax(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Return the maximum of an array or maximum along an axis ignoring any NaNs.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "nanmax") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7927; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("nanmax", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7927; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.nanmax", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_318nanmax(__pyx_self, __pyx_v_a, __pyx_v_axis);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_318nanmax(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("nanmax", 0);

  /* "ga4py/gain/notimplemented.pyx":7981
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7981; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.nanmax", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_321nanmin(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_320nanmin[] = "Return the minimum of an array or minimum along an axis ignoring any NaNs.\n\n    Parameters\n    ----------\n    a : array_like\n        Array containing numbers whose minimum is desired.\n    axis : int, optional\n        Axis along which the minimum is computed.The default is to compute\n        the minimum of the flattened array.\n\n    Returns\n    -------\n    nanmin : ndarray\n        A new array or a scalar array with the result.\n\n    See Also\n    --------\n    numpy.amin : Minimum across array including any Not a Numbers.\n    numpy.nanmax : Maximum across array ignoring any Not a Numbers.\n    isnan : Shows which elements are Not a Number (NaN).\n    isfinite: Shows which elements are not: Not a Number, positive and\n             negative infinity\n\n    Notes\n    -----\n    Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n    (IEEE 754). This means that Not a Number is not equivalent to infinity.\n    Positive infinity is treated as a very large number and negative infinity\n    is treated as a very small (i.e. negative) number.\n\n    If the input has a integer type the function is equivalent to np.min.\n\n\n    Examples\n    --------\n    >>> a = np.array([[1, 2], [3, np.nan]])\n    >>> np.nanmin(a)\n    1.0\n    >>> np.nanmin(a, axis=0)\n    array([ 1.,  2.])\n    >>> np.nanmin(a, axis=1)\n    array([ 1.,  3.])\n\n    When positive infinity and negative infinity are present:\n\n    >>> np.nanmin([1, 2, np.nan, np.inf])\n    1.0\n    >>> np.nanmin([1, 2, np.nan, np.NINF])\n    -inf\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_321nanmin = {__Pyx_NAMESTR("nanmin"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_321nanmin, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_320nanmin)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_321nanmin(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("nanmin (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__axis,0};
    PyObject* values[2] = {0,0};

    /* "ga4py/gain/notimplemented.pyx":7984
 * 
 * 
 * def nanmin(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Return the minimum of an array or minimum along an axis ignoring any NaNs.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "nanmin") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7984; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("nanmin", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7984; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.nanmin", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_320nanmin(__pyx_self, __pyx_v_a, __pyx_v_axis);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_320nanmin(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("nanmin", 0);

  /* "ga4py/gain/notimplemented.pyx":8036
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8036; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.nanmin", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_323nansum(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_322nansum[] = "Return the sum of array elements over a given axis treating\n    Not a Numbers (NaNs) as zero.\n\n    Parameters\n    ----------\n    a : array_like\n        Array containing numbers whose sum is desired. If `a` is not an\n        array, a conversion is attempted.\n    axis : int, optional\n        Axis along which the sum is computed. The default is to compute\n        the sum of the flattened array.\n\n    Returns\n    -------\n    y : ndarray\n        An array with the same shape as a, with the specified axis removed.\n        If a is a 0-d array, or if axis is None, a scalar is returned with\n        the same dtype as `a`.\n\n    See Also\n    --------\n    numpy.sum : Sum across array including Not a Numbers.\n    isnan : Shows which elements are Not a Number (NaN).\n    isfinite: Shows which elements are not: Not a Number, positive and\n             negative infinity\n\n    Notes\n    -----\n    Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n    (IEEE 754). This means that Not a Number is not equivalent to infinity.\n    If positive or negative infinity are present the result is positive or\n    negative infinity. But if both positive and negative infinity are present,\n    the result is Not A Number (NaN).\n\n    Arithmetic is modular when using integer types (all elements of `a` must\n    be finite i.e. no elements that are NaNs, positive infinity and negative\n    infinity because NaNs are floating point types), and no error is raised\n    on overflow.\n\n\n    Examples\n    --------\n    >>> np.nansum(1)\n    1\n    >>> np.nansum([1])\n    1\n    >>> np.nansum([1, np.nan])\n    1.0\n    >>> a = np.array([[1, 1], [1, np.nan]])\n    >>> np.nansum(a)\n    3.0\n    >>> np.nansum(a, axis=0)\n    array([ 2.,  1.])\n\n    When positive infinity and negative infinity are present\n\n    >>> np.nansum([1, np.nan, np.inf])\n    inf\n    >>> np.nansum([1, np.nan, np.NINF])\n    -inf\n    >>> np.nansum([1, np.nan, np.inf, np.NINF])\n    nan\n   "" \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_323nansum = {__Pyx_NAMESTR("nansum"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_323nansum, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_322nansum)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_323nansum(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("nansum (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__axis,0};
    PyObject* values[2] = {0,0};

    /* "ga4py/gain/notimplemented.pyx":8039
 * 
 * 
 * def nansum(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Return the sum of array elements over a given axis treating
 *     Not a Numbers (NaNs) as zero.
 */
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "nansum") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8039; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("nansum", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8039; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.nansum", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_322nansum(__pyx_self, __pyx_v_a, __pyx_v_axis);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_322nansum(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("nansum", 0);

  /* "ga4py/gain/notimplemented.pyx":8104
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8104; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.nansum", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_325ndfromtxt(PyObject *__pyx_self, PyObject *__pyx_v_fname); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_324ndfromtxt[] = "Load ASCII data stored in a file and return it as a single array.\n\n    Complete description of all the optional input parameters is available in\n    the docstring of the `genfromtxt` function.\n\n    See Also\n    --------\n    numpy.genfromtxt : generic function.\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_325ndfromtxt = {__Pyx_NAMESTR("ndfromtxt"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_325ndfromtxt, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_324ndfromtxt)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_325ndfromtxt(PyObject *__pyx_self, PyObject *__pyx_v_fname) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ndfromtxt (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_324ndfromtxt(__pyx_self, ((PyObject *)__pyx_v_fname));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":8107
 * 
 * 
 * def ndfromtxt(fname):             # <<<<<<<<<<<<<<
 *     """Load ASCII data stored in a file and return it as a single array.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_324ndfromtxt(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_fname) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("ndfromtxt", 0);

  /* "ga4py/gain/notimplemented.pyx":8118
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8118; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.ndfromtxt", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_327ndim(PyObject *__pyx_self, PyObject *__pyx_v_a); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_326ndim[] = "Return the number of dimensions of an array.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.  If it is not already an ndarray, a conversion is\n        attempted.\n\n    Returns\n    -------\n    number_of_dimensions : int\n        The number of dimensions in `a`.  Scalars are zero-dimensional.\n\n    See Also\n    --------\n    ndarray.ndim : equivalent method\n    shape : dimensions of array\n    ndarray.shape : dimensions of array\n\n    Examples\n    --------\n    >>> np.ndim([[1,2,3],[4,5,6]])\n    2\n    >>> np.ndim(np.array([[1,2,3],[4,5,6]]))\n    2\n    >>> np.ndim(1)\n    0\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_327ndim = {__Pyx_NAMESTR("ndim"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_327ndim, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_326ndim)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_327ndim(PyObject *__pyx_self, PyObject *__pyx_v_a) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ndim (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_326ndim(__pyx_self, ((PyObject *)__pyx_v_a));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":8121
 * 
 * 
 * def ndim(a):             # <<<<<<<<<<<<<<
 *     """Return the number of dimensions of an array.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_326ndim(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("ndim", 0);

  /* "ga4py/gain/notimplemented.pyx":8151
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8151; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.ndim", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_329nested_iters(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_328nested_iters[] = "\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_329nested_iters = {__Pyx_NAMESTR("nested_iters"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_329nested_iters, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_328nested_iters)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_329nested_iters(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("nested_iters (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_328nested_iters(__pyx_self);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":8154
 * 
 * 
 * def nested_iters():             # <<<<<<<<<<<<<<
 *     """
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_328nested_iters(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("nested_iters", 0);

  /* "ga4py/gain/notimplemented.pyx":8159
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8159; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.nested_iters", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_331newbuffer(PyObject *__pyx_self, PyObject *__pyx_v_size); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_330newbuffer[] = "newbuffer(size)\n\n    Return a new uninitialized buffer object of size bytes\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_331newbuffer = {__Pyx_NAMESTR("newbuffer"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_331newbuffer, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_330newbuffer)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_331newbuffer(PyObject *__pyx_self, PyObject *__pyx_v_size) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("newbuffer (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_330newbuffer(__pyx_self, ((PyObject *)__pyx_v_size));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":8162
 * 
 * 
 * def newbuffer(size):             # <<<<<<<<<<<<<<
 *     """newbuffer(size)
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_330newbuffer(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_size) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("newbuffer", 0);

  /* "ga4py/gain/notimplemented.pyx":8169
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8169; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.newbuffer", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_333nonzero(PyObject *__pyx_self, PyObject *__pyx_v_a); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_332nonzero[] = "Return the indices of the elements that are non-zero.\n\n    Returns a tuple of arrays, one for each dimension of `a`, containing\n    the indices of the non-zero elements in that dimension. The\n    corresponding non-zero values can be obtained with::\n\n        a[nonzero(a)]\n\n    To group the indices by element, rather than dimension, use::\n\n        transpose(nonzero(a))\n\n    The result of this is always a 2-D array, with a row for\n    each non-zero element.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n\n    Returns\n    -------\n    tuple_of_arrays : tuple\n        Indices of elements that are non-zero.\n\n    See Also\n    --------\n    flatnonzero :\n        Return indices that are non-zero in the flattened version of the input\n        array.\n    ndarray.nonzero :\n        Equivalent ndarray method.\n    count_nonzero :\n        Counts the number of non-zero elements in the input array.\n\n    Examples\n    --------\n    >>> x = np.eye(3)\n    >>> x\n    array([[ 1.,  0.,  0.],\n           [ 0.,  1.,  0.],\n           [ 0.,  0.,  1.]])\n    >>> np.nonzero(x)\n    (array([0, 1, 2]), array([0, 1, 2]))\n\n    >>> x[np.nonzero(x)]\n    array([ 1.,  1.,  1.])\n    >>> np.transpose(np.nonzero(x))\n    array([[0, 0],\n           [1, 1],\n           [2, 2]])\n\n    A common use for ``nonzero`` is to find the indices of an array, where\n    a condition is True.  Given an array `a`, the condition `a` > 3 is a\n    boolean array and since False is interpreted as 0, np.nonzero(a > 3)\n    yields the indices of the `a` where the condition is true.\n\n    >>> a = np.array([[1,2,3],[4,5,6],[7,8,9]])\n    >>> a > 3\n    array([[False, False, False],\n           [ True,  True,  True],\n           [ True,  True,  True]], dtype=bool)\n    >>> np.nonzero(a > 3)\n    (array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))\n\n    The ``nonzero`` method of the boolean array can also be called.\n\n    >>> (a > 3).nonzero()\n    (array([1, 1, 1, ""2, 2, 2]), array([0, 1, 2, 0, 1, 2]))\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_333nonzero = {__Pyx_NAMESTR("nonzero"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_333nonzero, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_332nonzero)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_333nonzero(PyObject *__pyx_self, PyObject *__pyx_v_a) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("nonzero (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_332nonzero(__pyx_self, ((PyObject *)__pyx_v_a));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":8172
 * 
 * 
 * def nonzero(a):             # <<<<<<<<<<<<<<
 *     """Return the indices of the elements that are non-zero.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_332nonzero(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("nonzero", 0);

  /* "ga4py/gain/notimplemented.pyx":8244
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8244; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.nonzero", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_335nper(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_334nper[] = "Compute the number of periodic payments.\n\n    Parameters\n    ----------\n    rate : array_like\n        Rate of interest (per period)\n    pmt : array_like\n        Payment\n    pv : array_like\n        Present value\n    fv : array_like, optional\n        Future value\n    when : {{'begin', 1}, {'end', 0}}, {string, int}, optional\n        When payments are due ('begin' (1) or 'end' (0))\n\n    Notes\n    -----\n    The number of periods ``nper`` is computed by solving the equation::\n\n     fv + pv*(1+rate)**nper + pmt*(1+rate*when)/rate*((1+rate)**nper-1) = 0\n\n    but if ``rate = 0`` then::\n\n     fv + pv + pmt*nper = 0\n\n    Examples\n    --------\n    If you only had $150/month to pay towards the loan, how long would it take\n    to pay-off a loan of $8,000 at 7% annual interest?\n\n    >>> np.nper(0.07/12, -150, 8000)\n    64.073348770661852\n\n    So, over 64 months would be required to pay off the loan.\n\n    The same analysis could be done with several different interest rates\n    and/or payments and/or total amounts to produce an entire table.\n\n    >>> np.nper(*(np.ogrid[0.07/12: 0.08/12: 0.01/12,\n    ...                    -150   : -99     : 50    ,\n    ...                    8000   : 9001    : 1000]))\n    array([[[  64.07334877,   74.06368256],\n            [ 108.07548412,  127.99022654]],\n           [[  66.12443902,   76.87897353],\n            [ 114.70165583,  137.90124779]]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_335nper = {__Pyx_NAMESTR("nper"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_335nper, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_334nper)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_335nper(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_rate = 0;
  CYTHON_UNUSED PyObject *__pyx_v_pmt = 0;
  CYTHON_UNUSED PyObject *__pyx_v_pv = 0;
  CYTHON_UNUSED PyObject *__pyx_v_fv = 0;
  CYTHON_UNUSED PyObject *__pyx_v_when = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("nper (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__rate,&__pyx_n_s__pmt,&__pyx_n_s__pv,&__pyx_n_s__fv,&__pyx_n_s__when,0};
    PyObject* values[5] = {0,0,0,0,0};
    values[3] = ((PyObject *)__pyx_int_0);
    values[4] = ((PyObject *)__pyx_n_s__end);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__rate)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__pmt)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("nper", 0, 3, 5, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8247; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__pv)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("nper", 0, 3, 5, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8247; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__fv);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__when);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "nper") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8247; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_rate = values[0];
    __pyx_v_pmt = values[1];
    __pyx_v_pv = values[2];
    __pyx_v_fv = values[3];
    __pyx_v_when = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("nper", 0, 3, 5, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8247; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.nper", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_334nper(__pyx_self, __pyx_v_rate, __pyx_v_pmt, __pyx_v_pv, __pyx_v_fv, __pyx_v_when);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":8247
 * 
 * 
 * def nper(rate, pmt, pv, fv=0, when='end'):             # <<<<<<<<<<<<<<
 *     """Compute the number of periodic payments.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_334nper(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_rate, CYTHON_UNUSED PyObject *__pyx_v_pmt, CYTHON_UNUSED PyObject *__pyx_v_pv, CYTHON_UNUSED PyObject *__pyx_v_fv, CYTHON_UNUSED PyObject *__pyx_v_when) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("nper", 0);

  /* "ga4py/gain/notimplemented.pyx":8295
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8295; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.nper", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_337npv(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_336npv[] = "Returns the NPV (Net Present Value) of a cash flow series.\n\n    Parameters\n    ----------\n    rate : scalar\n        The discount rate.\n    values : array_like, shape(M, )\n        The values of the time series of cash flows.  The (fixed) time\n        interval between cash flow \"events\" must be the same as that\n        for which `rate` is given (i.e., if `rate` is per year, then\n        precisely a year is understood to elapse between each cash flow\n        event).  By convention, investments or \"deposits\" are negative,\n        income or \"withdrawals\" are positive; `values` must begin with\n        the initial investment, thus `values[0]` will typically be\n        negative.\n\n    Returns\n    -------\n    out : float\n        The NPV of the input cash flow series `values` at the discount `rate`.\n\n    Notes\n    -----\n    Returns the result of: [G]_\n\n    .. math :: \\sum_{t=0}^M{\014rac{values_t}{(1+rate)^{t}}}\n\n    References\n    ----------\n    .. [G] L. J. Gitman, \"Principles of Managerial Finance, Brief,\" 3rd ed.,\n       Addison-Wesley, 2003, pg. 346.\n\n    Examples\n    --------\n    >>> np.npv(0.281,[-100, 39, 59, 55, 20])\n    -0.0066187288356340801\n\n    (Compare with the Example given for numpy.lib.financial.irr)\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_337npv = {__Pyx_NAMESTR("npv"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_337npv, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_336npv)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_337npv(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_rate = 0;
  CYTHON_UNUSED PyObject *__pyx_v_values = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("npv (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__rate,&__pyx_n_s__values,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__rate)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__values)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("npv", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8298; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "npv") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8298; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_rate = values[0];
    __pyx_v_values = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("npv", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8298; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.npv", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_336npv(__pyx_self, __pyx_v_rate, __pyx_v_values);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":8298
 * 
 * 
 * def npv(rate, values):             # <<<<<<<<<<<<<<
 *     """Returns the NPV (Net Present Value) of a cash flow series.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_336npv(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_rate, CYTHON_UNUSED PyObject *__pyx_v_values) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("npv", 0);

  /* "ga4py/gain/notimplemented.pyx":8339
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8339; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.npv", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_339obj2sctype(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_338obj2sctype[] = "Return the scalar dtype or NumPy equivalent of Python type of an object.\n\n    Parameters\n    ----------\n    rep : any\n        The object of which the type is returned.\n    default : any, optional\n        If given, this is returned for objects whose types can not be\n        determined. If not given, None is returned for those objects.\n\n    Returns\n    -------\n    dtype : dtype or Python type\n        The data type of `rep`.\n\n    See Also\n    --------\n    sctype2char, issctype, issubsctype, issubdtype, maximum_sctype\n\n    Examples\n    --------\n    >>> np.obj2sctype(np.int32)\n    <type 'numpy.int32'>\n    >>> np.obj2sctype(np.array([1., 2.]))\n    <type 'numpy.float64'>\n    >>> np.obj2sctype(np.array([1.j]))\n    <type 'numpy.complex128'>\n\n    >>> np.obj2sctype(dict)\n    <type 'numpy.object_'>\n    >>> np.obj2sctype('string')\n    <type 'numpy.string_'>\n\n    >>> np.obj2sctype(1, default=list)\n    <type 'list'>\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_339obj2sctype = {__Pyx_NAMESTR("obj2sctype"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_339obj2sctype, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_338obj2sctype)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_339obj2sctype(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_rep = 0;
  CYTHON_UNUSED PyObject *__pyx_v_default = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("obj2sctype (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__rep,&__pyx_n_s__default,0};
    PyObject* values[2] = {0,0};

    /* "ga4py/gain/notimplemented.pyx":8342
 * 
 * 
 * def obj2sctype(rep, default=None):             # <<<<<<<<<<<<<<
 *     """Return the scalar dtype or NumPy equivalent of Python type of an object.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__rep)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__default);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "obj2sctype") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8342; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_rep = values[0];
    __pyx_v_default = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("obj2sctype", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8342; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.obj2sctype", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_338obj2sctype(__pyx_self, __pyx_v_rep, __pyx_v_default);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_338obj2sctype(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_rep, CYTHON_UNUSED PyObject *__pyx_v_default) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("obj2sctype", 0);

  /* "ga4py/gain/notimplemented.pyx":8380
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8380; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.obj2sctype", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_341outer(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_340outer[] = "Compute the outer product of two vectors.\n\n    Given two vectors, ``a = [a0, a1, ..., aM]`` and\n    ``b = [b0, b1, ..., bN]``,\n    the outer product [1]_ is::\n\n      [[a0*b0  a0*b1 ... a0*bN ]\n       [a1*b0    .\n       [ ...          .\n       [aM*b0            aM*bN ]]\n\n    Parameters\n    ----------\n    a, b : array_like, shape (M,), (N,)\n        First and second input vectors.  Inputs are flattened if they\n        are not already 1-dimensional.\n\n    Returns\n    -------\n    out : ndarray, shape (M, N)\n        ``out[i, j] = a[i] * b[j]``\n\n    See also\n    --------\n    inner, einsum\n\n    References\n    ----------\n    .. [1] : G. H. Golub and C. F. van Loan, *Matrix Computations*, 3rd\n             ed., Baltimore, MD, Johns Hopkins University Press, 1996,\n             pg. 8.\n\n    Examples\n    --------\n    Make a (*very* coarse) grid for computing a Mandelbrot set:\n\n    >>> rl = np.outer(np.ones((5,)), np.linspace(-2, 2, 5))\n    >>> rl\n    array([[-2., -1.,  0.,  1.,  2.],\n           [-2., -1.,  0.,  1.,  2.],\n           [-2., -1.,  0.,  1.,  2.],\n           [-2., -1.,  0.,  1.,  2.],\n           [-2., -1.,  0.,  1.,  2.]])\n    >>> im = np.outer(1j*np.linspace(2, -2, 5), np.ones((5,)))\n    >>> im\n    array([[ 0.+2.j,  0.+2.j,  0.+2.j,  0.+2.j,  0.+2.j],\n           [ 0.+1.j,  0.+1.j,  0.+1.j,  0.+1.j,  0.+1.j],\n           [ 0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j],\n           [ 0.-1.j,  0.-1.j,  0.-1.j,  0.-1.j,  0.-1.j],\n           [ 0.-2.j,  0.-2.j,  0.-2.j,  0.-2.j,  0.-2.j]])\n    >>> grid = rl + im\n    >>> grid\n    array([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],\n           [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],\n           [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],\n           [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],\n           [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])\n\n    An example using a \"vector\" of letters:\n\n    >>> x = np.array(['a', 'b', 'c'], dtype=object)\n    >>> np.""outer(x, [1, 2, 3])\n    array([[a, aa, aaa],\n           [b, bb, bbb],\n           [c, cc, ccc]], dtype=object)\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_341outer = {__Pyx_NAMESTR("outer"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_341outer, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_340outer)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_341outer(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_b = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("outer (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__b,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__b)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("outer", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8383; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "outer") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8383; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_a = values[0];
    __pyx_v_b = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("outer", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8383; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.outer", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_340outer(__pyx_self, __pyx_v_a, __pyx_v_b);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":8383
 * 
 * 
 * def outer(a, b):             # <<<<<<<<<<<<<<
 *     """Compute the outer product of two vectors.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_340outer(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_b) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("outer", 0);

  /* "ga4py/gain/notimplemented.pyx":8451
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8451; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.outer", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_343packbits(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_342packbits[] = "packbits(myarray, axis=None)\n\n    Packs the elements of a binary-valued array into bits in a uint8 array.\n\n    The result is padded to full bytes by inserting zero bits at the end.\n\n    Parameters\n    ----------\n    myarray : array_like\n        An integer type array whose elements should be packed to bits.\n    axis : int, optional\n        The dimension over which bit-packing is done.\n        ``None`` implies packing the flattened array.\n\n    Returns\n    -------\n    packed : ndarray\n        Array of type uint8 whose elements represent bits corresponding to the\n        logical (0 or nonzero) value of the input elements. The shape of\n        `packed` has the same number of dimensions as the input (unless `axis`\n        is None, in which case the output is 1-D).\n\n    See Also\n    --------\n    unpackbits: Unpacks elements of a uint8 array into a binary-valued output\n                array.\n\n    Examples\n    --------\n    >>> a = np.array([[[1,0,1],\n    ...                [0,1,0]],\n    ...               [[1,1,0],\n    ...                [0,0,1]]])\n    >>> b = np.packbits(a, axis=-1)\n    >>> b\n    array([[[160],[64]],[[192],[32]]], dtype=uint8)\n\n    Note that in binary 160 = 1010 0000, 64 = 0100 0000, 192 = 1100 0000,\n    and 32 = 0010 0000.\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_343packbits = {__Pyx_NAMESTR("packbits"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_343packbits, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_342packbits)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_343packbits(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_myarray = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("packbits (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__myarray,&__pyx_n_s__axis,0};
    PyObject* values[2] = {0,0};

    /* "ga4py/gain/notimplemented.pyx":8454
 * 
 * 
 * def packbits(myarray, axis=None):             # <<<<<<<<<<<<<<
 *     """packbits(myarray, axis=None)
 * 
 */
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__myarray)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "packbits") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8454; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_myarray = values[0];
    __pyx_v_axis = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("packbits", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8454; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.packbits", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_342packbits(__pyx_self, __pyx_v_myarray, __pyx_v_axis);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_342packbits(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_myarray, CYTHON_UNUSED PyObject *__pyx_v_axis) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("packbits", 0);

  /* "ga4py/gain/notimplemented.pyx":8497
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8497; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.packbits", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_345percentile(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_344percentile[] = "Compute the qth percentile of the data along the specified axis.\n\n    Returns the qth percentile of the array elements.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array or object that can be converted to an array.\n    q : float in range of [0,100] (or sequence of floats)\n        Percentile to compute which must be between 0 and 100 inclusive.\n    axis : int, optional\n        Axis along which the percentiles are computed. The default (None)\n        is to compute the median along a flattened version of the array.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must\n        have the same shape and buffer length as the expected output,\n        but the type (of the output) will be cast if necessary.\n    overwrite_input : bool, optional\n       If True, then allow use of memory of input array `a` for\n       calculations. The input array will be modified by the call to\n       median. This will save memory when you do not need to preserve\n       the contents of the input array. Treat the input as undefined,\n       but it will probably be fully or partially sorted.\n       Default is False. Note that, if `overwrite_input` is True and the\n       input is not already an array, an error will be raised.\n\n    Returns\n    -------\n    pcntile : ndarray\n        A new array holding the result (unless `out` is specified, in\n        which case that array is returned instead).  If the input contains\n        integers, or floats of smaller precision than 64, then the output\n        data-type is float64.  Otherwise, the output data-type is the same\n        as that of the input.\n\n    See Also\n    --------\n    mean, median\n\n    Notes\n    -----\n    Given a vector V of length N, the qth percentile of V is the qth ranked\n    value in a sorted copy of V.  A weighted average of the two nearest\n    neighbors is used if the normalized ranking does not match q exactly.\n    The same as the med""ian if ``q=0.5``, the same as the minimum if ``q=0``\n    and the same as the maximum if ``q=1``.\n\n    Examples\n    --------\n    >>> a = np.array([[10, 7, 4], [3, 2, 1]])\n    >>> a\n    array([[10,  7,  4],\n           [ 3,  2,  1]])\n    >>> np.percentile(a, 50)\n    3.5\n    >>> np.percentile(a, 0.5, axis=0)\n    array([ 6.5,  4.5,  2.5])\n    >>> np.percentile(a, 50, axis=1)\n    array([ 7.,  2.])\n\n    >>> m = np.percentile(a, 50, axis=0)\n    >>> out = np.zeros_like(m)\n    >>> np.percentile(a, 50, axis=0, out=m)\n    array([ 6.5,  4.5,  2.5])\n    >>> m\n    array([ 6.5,  4.5,  2.5])\n\n    >>> b = a.copy()\n    >>> np.percentile(b, 50, axis=1, overwrite_input=True)\n    array([ 7.,  2.])\n    >>> assert not np.all(a==b)\n    >>> b = a.copy()\n    >>> np.percentile(b, 50, axis=None, overwrite_input=True)\n    3.5\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_345percentile = {__Pyx_NAMESTR("percentile"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_345percentile, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_344percentile)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_345percentile(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_q = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  CYTHON_UNUSED PyObject *__pyx_v_overwrite_input = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("percentile (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__q,&__pyx_n_s__axis,&__pyx_n_s__out,&__pyx_n_s__overwrite_input,0};
    PyObject* values[5] = {0,0,0,0,0};

    /* "ga4py/gain/notimplemented.pyx":8500
 * 
 * 
 * def percentile(a, q, axis=None, out=None, overwrite_input=False):             # <<<<<<<<<<<<<<
 *     """Compute the qth percentile of the data along the specified axis.
 * 
 */
    values[2] = ((PyObject *)Py_None);
    values[3] = ((PyObject *)Py_None);
    values[4] = __pyx_k_36;
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__q)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("percentile", 0, 2, 5, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8500; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__out);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__overwrite_input);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "percentile") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8500; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_q = values[1];
    __pyx_v_axis = values[2];
    __pyx_v_out = values[3];
    __pyx_v_overwrite_input = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("percentile", 0, 2, 5, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8500; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.percentile", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_344percentile(__pyx_self, __pyx_v_a, __pyx_v_q, __pyx_v_axis, __pyx_v_out, __pyx_v_overwrite_input);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_344percentile(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_q, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out, CYTHON_UNUSED PyObject *__pyx_v_overwrite_input) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("percentile", 0);

  /* "ga4py/gain/notimplemented.pyx":8577
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8577; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.percentile", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_347piecewise(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_346piecewise[] = "Evaluate a piecewise-defined function.\n\n    Given a set of conditions and corresponding functions, evaluate each\n    function on the input data wherever its condition is true.\n\n    Parameters\n    ----------\n    x : ndarray\n        The input domain.\n    condlist : list of bool arrays\n        Each boolean array corresponds to a function in `funclist`.  Wherever\n        `condlist[i]` is True, `funclist[i](x)` is used as the output value.\n\n        Each boolean array in `condlist` selects a piece of `x`,\n        and should therefore be of the same shape as `x`.\n\n        The length of `condlist` must correspond to that of `funclist`.\n        If one extra function is given, i.e. if\n        ``len(funclist) - len(condlist) == 1``, then that extra function\n        is the default value, used wherever all conditions are false.\n    funclist : list of callables, f(x,*args,**kw), or scalars\n        Each function is evaluated over `x` wherever its corresponding\n        condition is True.  It should take an array as input and give an array\n        or a scalar value as output.  If, instead of a callable,\n        a scalar is provided then a constant function (``lambda x: scalar``) is\n        assumed.\n    args : tuple, optional\n        Any further arguments given to `piecewise` are passed to the functions\n        upon execution, i.e., if called ``piecewise(..., ..., 1, 'a')``, then\n        each function is called as ``f(x, 1, 'a')``.\n    kw : dict, optional\n        Keyword arguments used in calling `piecewise` are passed to the\n        functions upon execution, i.e., if called\n        ``piecewise(..., ..., lambda=1)``, then each function is called as\n        ``f(x, lambda=1)``.\n\n    Returns\n    -------\n    out : ndarray\n        The output is the same shape and type as x and is found by\n        calling the functions in `funclist` on the appropriate portions of `x`,\n        as defined by the boolean arrays in `condlist`.  Portions not covered\n   ""     by any condition have undefined values.\n\n\n    See Also\n    --------\n    choose, select, where\n\n    Notes\n    -----\n    This is similar to choose or select, except that functions are\n    evaluated on elements of `x` that satisfy the corresponding condition from\n    `condlist`.\n\n    The result is::\n\n            |--\n            |funclist[0](x[condlist[0]])\n      out = |funclist[1](x[condlist[1]])\n            |...\n            |funclist[n2](x[condlist[n2]])\n            |--\n\n    Examples\n    --------\n    Define the sigma function, which is -1 for ``x < 0`` and +1 for ``x >= 0``.\n\n    >>> x = np.arange(6) - 2.5\n    >>> np.piecewise(x, [x < 0, x >= 0], [-1, 1])\n    array([-1., -1., -1.,  1.,  1.,  1.])\n\n    Define the absolute value, which is ``-x`` for ``x <0`` and ``x`` for\n    ``x >= 0``.\n\n    >>> np.piecewise(x, [x < 0, x >= 0], [lambda x: -x, lambda x: x])\n    array([ 2.5,  1.5,  0.5,  0.5,  1.5,  2.5])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_347piecewise = {__Pyx_NAMESTR("piecewise"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_347piecewise, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_346piecewise)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_347piecewise(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_x = 0;
  CYTHON_UNUSED PyObject *__pyx_v_condlist = 0;
  CYTHON_UNUSED PyObject *__pyx_v_funclist = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("piecewise (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__x,&__pyx_n_s__condlist,&__pyx_n_s__funclist,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__x)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__condlist)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("piecewise", 1, 3, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8580; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__funclist)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("piecewise", 1, 3, 3, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8580; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "piecewise") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8580; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_x = values[0];
    __pyx_v_condlist = values[1];
    __pyx_v_funclist = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("piecewise", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8580; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.piecewise", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_346piecewise(__pyx_self, __pyx_v_x, __pyx_v_condlist, __pyx_v_funclist);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":8580
 * 
 * 
 * def piecewise(x, condlist, funclist):             # <<<<<<<<<<<<<<
 *     """Evaluate a piecewise-defined function.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_346piecewise(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_condlist, CYTHON_UNUSED PyObject *__pyx_v_funclist) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("piecewise", 0);

  /* "ga4py/gain/notimplemented.pyx":8660
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8660; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.piecewise", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_349pkgload(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_348pkgload[] = "Load one or more packages into parent package top-level namespace.\n\n       This function is intended to shorten the need to import many\n       subpackages, say of scipy, constantly with statements such as\n\n         import scipy.linalg, scipy.fftpack, scipy.etc...\n\n       Instead, you can say:\n\n         import scipy\n         scipy.pkgload('linalg','fftpack',...)\n\n       or\n\n         scipy.pkgload()\n\n       to load all of them in one call.\n\n       If a name which doesn't exist in scipy's namespace is\n       given, a warning is shown.\n\n       Parameters\n       ----------\n        *packages : arg-tuple\n             the names (one or more strings) of all the modules one\n             wishes to load into the top-level namespace.\n        verbose= : integer\n             verbosity level [default: -1].\n             verbose=-1 will suspend also warnings.\n        force= : bool\n             when True, force reloading loaded packages [default: False].\n        postpone= : bool\n             when True, don't load packages [default: False]\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_349pkgload = {__Pyx_NAMESTR("pkgload"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_349pkgload, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_348pkgload)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_349pkgload(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("pkgload (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_348pkgload(__pyx_self);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":8663
 * 
 * 
 * def pkgload():             # <<<<<<<<<<<<<<
 *     """Load one or more packages into parent package top-level namespace.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_348pkgload(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("pkgload", 0);

  /* "ga4py/gain/notimplemented.pyx":8699
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8699; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.pkgload", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_351place(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_350place[] = "Change elements of an array based on conditional and input values.\n\n    Similar to ``np.putmask(arr, mask, vals)``, the difference is that `place`\n    uses the first N elements of `vals`, where N is the number of True values\n    in `mask`, while `putmask` uses the elements where `mask` is True.\n\n    Note that `extract` does the exact opposite of `place`.\n\n    Parameters\n    ----------\n    arr : array_like\n        Array to put data into.\n    mask : array_like\n        Boolean mask array. Must have the same size as `a`.\n    vals : 1-D sequence\n        Values to put into `a`. Only the first N elements are used, where\n        N is the number of True values in `mask`. If `vals` is smaller\n        than N it will be repeated.\n\n    See Also\n    --------\n    putmask, put, take, extract\n\n    Examples\n    --------\n    >>> arr = np.arange(6).reshape(2, 3)\n    >>> np.place(arr, arr>2, [44, 55])\n    >>> arr\n    array([[ 0,  1,  2],\n           [44, 55, 44]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_351place = {__Pyx_NAMESTR("place"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_351place, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_350place)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_351place(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_arr = 0;
  CYTHON_UNUSED PyObject *__pyx_v_mask = 0;
  CYTHON_UNUSED PyObject *__pyx_v_vals = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("place (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__arr,&__pyx_n_s__mask,&__pyx_n_s__vals,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__arr)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__mask)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("place", 1, 3, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8702; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__vals)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("place", 1, 3, 3, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8702; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "place") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8702; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_arr = values[0];
    __pyx_v_mask = values[1];
    __pyx_v_vals = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("place", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8702; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.place", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_350place(__pyx_self, __pyx_v_arr, __pyx_v_mask, __pyx_v_vals);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":8702
 * 
 * 
 * def place(arr, mask, vals):             # <<<<<<<<<<<<<<
 *     """Change elements of an array based on conditional and input values.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_350place(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_arr, CYTHON_UNUSED PyObject *__pyx_v_mask, CYTHON_UNUSED PyObject *__pyx_v_vals) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("place", 0);

  /* "ga4py/gain/notimplemented.pyx":8735
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8735; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.place", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_353pmt(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_352pmt[] = "Compute the payment against loan principal plus interest.\n\n    Given:\n     * a present value, `pv` (e.g., an amount borrowed)\n     * a future value, `fv` (e.g., 0)\n     * an interest `rate` compounded once per period, of which\n       there are\n     * `nper` total\n     * and (optional) specification of whether payment is made\n       at the beginning (`when` = {'begin', 1}) or the end\n       (`when` = {'end', 0}) of each period\n\n    Return:\n       the (fixed) periodic payment.\n\n    Parameters\n    ----------\n    rate : array_like\n        Rate of interest (per period)\n    nper : array_like\n        Number of compounding periods\n    pv : array_like\n        Present value\n    fv : array_like (optional)\n        Future value (default = 0)\n    when : {{'begin', 1}, {'end', 0}}, {string, int}\n        When payments are due ('begin' (1) or 'end' (0))\n\n    Returns\n    -------\n    out : ndarray\n        Payment against loan plus interest.  If all input is scalar, returns a\n        scalar float.  If any input is array_like, returns payment for each\n        input element. If multiple inputs are array_like, they all must have\n        the same shape.\n\n    Notes\n    -----\n    The payment is computed by solving the equation::\n\n     fv +\n     pv*(1 + rate)**nper +\n     pmt*(1 + rate*when)/rate*((1 + rate)**nper - 1) == 0\n\n    or, when ``rate == 0``::\n\n      fv + pv + pmt * nper == 0\n\n    for ``pmt``.\n\n    Note that computing a monthly mortgage payment is only\n    one use for this function.  For example, pmt returns the\n    periodic deposit one must make to achieve a specified\n    future balance given an initial deposit, a fixed,\n    periodically compounded interest rate, and the total\n    number of periods.\n\n    References\n    ----------\n    .. [WRW] Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May).\n       Open Document Format for Office Applications (OpenDocument)v1.2,\n       Part 2: Recalculated Formula (OpenFormula) F""ormat - Annotated Version,\n       Pre-Draft 12. Organization for the Advancement of Structured Information\n       Standards (OASIS). Billerica, MA, USA. [ODT Document].\n       Available:\n       http://www.oasis-open.org/committees/documents.php\n       ?wg_abbrev=office-formulaOpenDocument-formula-20090508.odt\n\n    Examples\n    --------\n    What is the monthly payment needed to pay off a $200,000 loan in 15\n    years at an annual interest rate of 7.5%?\n\n    >>> np.pmt(0.075/12, 12*15, 200000)\n    -1854.0247200054619\n\n    In order to pay-off (i.e., have a future-value of 0) the $200,000 obtained\n    today, a monthly payment of $1,854.02 would be required.  Note that this\n    example illustrates usage of `fv` having a default value of 0.\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_353pmt = {__Pyx_NAMESTR("pmt"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_353pmt, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_352pmt)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_353pmt(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_rate = 0;
  CYTHON_UNUSED PyObject *__pyx_v_nper = 0;
  CYTHON_UNUSED PyObject *__pyx_v_pv = 0;
  CYTHON_UNUSED PyObject *__pyx_v_fv = 0;
  CYTHON_UNUSED PyObject *__pyx_v_when = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("pmt (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__rate,&__pyx_n_s__nper,&__pyx_n_s__pv,&__pyx_n_s__fv,&__pyx_n_s__when,0};
    PyObject* values[5] = {0,0,0,0,0};
    values[3] = ((PyObject *)__pyx_int_0);
    values[4] = ((PyObject *)__pyx_n_s__end);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__rate)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__nper)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("pmt", 0, 3, 5, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8738; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__pv)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("pmt", 0, 3, 5, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8738; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__fv);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__when);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "pmt") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8738; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_rate = values[0];
    __pyx_v_nper = values[1];
    __pyx_v_pv = values[2];
    __pyx_v_fv = values[3];
    __pyx_v_when = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("pmt", 0, 3, 5, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8738; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.pmt", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_352pmt(__pyx_self, __pyx_v_rate, __pyx_v_nper, __pyx_v_pv, __pyx_v_fv, __pyx_v_when);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":8738
 * 
 * 
 * def pmt(rate, nper, pv, fv=0, when='end'):             # <<<<<<<<<<<<<<
 *     """Compute the payment against loan principal plus interest.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_352pmt(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_rate, CYTHON_UNUSED PyObject *__pyx_v_nper, CYTHON_UNUSED PyObject *__pyx_v_pv, CYTHON_UNUSED PyObject *__pyx_v_fv, CYTHON_UNUSED PyObject *__pyx_v_when) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("pmt", 0);

  /* "ga4py/gain/notimplemented.pyx":8820
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8820; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.pmt", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_355poly(PyObject *__pyx_self, PyObject *__pyx_v_seq_of_zeros); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_354poly[] = "Find the coefficients of a polynomial with the given sequence of roots.\n\n    Returns the coefficients of the polynomial whose leading coefficient\n    is one for the given sequence of zeros (multiple roots must be included\n    in the sequence as many times as their multiplicity; see Examples).\n    A square matrix (or array, which will be treated as a matrix) can also\n    be given, in which case the coefficients of the characteristic polynomial\n    of the matrix are returned.\n\n    Parameters\n    ----------\n    seq_of_zeros : array_like, shape (N,) or (N, N)\n        A sequence of polynomial roots, or a square array or matrix object.\n\n    Returns\n    -------\n    c : ndarray\n        1D array of polynomial coefficients from highest to lowest degree:\n\n        ``c[0] * x**(N) + c[1] * x**(N-1) + ... + c[N-1] * x + c[N]``\n        where c[0] always equals 1.\n\n    Raises\n    ------\n    ValueError\n        If input is the wrong shape (the input must be a 1-D or square\n        2-D array).\n\n    See Also\n    --------\n    polyval : Evaluate a polynomial at a point.\n    roots : Return the roots of a polynomial.\n    polyfit : Least squares polynomial fit.\n    poly1d : A one-dimensional polynomial class.\n\n    Notes\n    -----\n    Specifying the roots of a polynomial still leaves one degree of\n    freedom, typically represented by an undetermined leading\n    coefficient. [1]_ In the case of this function, that coefficient -\n    the first one in the returned array - is always taken as one. (If\n    for some reason you have one other point, the only automatic way\n    presently to leverage that information is to use ``polyfit``.)\n\n    The characteristic polynomial, :math:`p_a(t)`, of an `n`-by-`n`\n    matrix **A** is given by\n\n        :math:`p_a(t) = \\mathrm{det}(t\\, \\mathbf{I} - \\mathbf{A})`,\n\n    where **I** is the `n`-by-`n` identity matrix. [2]_\n\n    References\n    ----------\n    .. [1] M. Sullivan and M. Sullivan, III, \"Algebra a""nd Trignometry,\n       Enhanced With Graphing Utilities,\" Prentice-Hall, pg. 318, 1996.\n\n    .. [2] G. Strang, \"Linear Algebra and Its Applications, 2nd Edition,\"\n       Academic Press, pg. 182, 1980.\n\n    Examples\n    --------\n    Given a sequence of a polynomial's zeros:\n\n    >>> np.poly((0, 0, 0)) # Multiple root example\n    array([1, 0, 0, 0])\n    \n    The line above represents z**3 + 0*z**2 + 0*z + 0.\n\n    >>> np.poly((-1./2, 0, 1./2))\n    array([ 1.  ,  0.  , -0.25,  0.  ])\n    \n    The line above represents z**3 - z/4\n\n    >>> np.poly((np.random.random(1.)[0], 0, np.random.random(1.)[0]))\n    array([ 1.        , -0.77086955,  0.08618131,  0.        ]) #random\n\n    Given a square array object:\n\n    >>> P = np.array([[0, 1./3], [-1./2, 0]])\n    >>> np.poly(P)\n    array([ 1.        ,  0.        ,  0.16666667])\n\n    Or a square matrix object:\n\n    >>> np.poly(np.matrix(P))\n    array([ 1.        ,  0.        ,  0.16666667])\n\n    Note how in all cases the leading coefficient is always 1.\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_355poly = {__Pyx_NAMESTR("poly"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_355poly, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_354poly)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_355poly(PyObject *__pyx_self, PyObject *__pyx_v_seq_of_zeros) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("poly (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_354poly(__pyx_self, ((PyObject *)__pyx_v_seq_of_zeros));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":8823
 * 
 * 
 * def poly(seq_of_zeros):             # <<<<<<<<<<<<<<
 *     """Find the coefficients of a polynomial with the given sequence of roots.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_354poly(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_seq_of_zeros) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("poly", 0);

  /* "ga4py/gain/notimplemented.pyx":8914
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8914; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.poly", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_357polyadd(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_356polyadd[] = "Find the sum of two polynomials.\n\n    Returns the polynomial resulting from the sum of two input polynomials.\n    Each input must be either a poly1d object or a 1D sequence of polynomial\n    coefficients, from highest to lowest degree.\n\n    Parameters\n    ----------\n    a1, a2 : array_like or poly1d object\n        Input polynomials.\n\n    Returns\n    -------\n    out : ndarray or poly1d object\n        The sum of the inputs. If either input is a poly1d object, then the\n        output is also a poly1d object. Otherwise, it is a 1D array of\n        polynomial coefficients from highest to lowest degree.\n\n    See Also\n    --------\n    poly1d : A one-dimensional polynomial class.\n    poly, polyadd, polyder, polydiv, polyfit, polyint, polysub, polyval\n\n    Examples\n    --------\n    >>> np.polyadd([1, 2], [9, 5, 4])\n    array([9, 6, 6])\n\n    Using poly1d objects:\n\n    >>> p1 = np.poly1d([1, 2])\n    >>> p2 = np.poly1d([9, 5, 4])\n    >>> print p1\n    1 x + 2\n    >>> print p2\n       2\n    9 x + 5 x + 4\n    >>> print np.polyadd(p1, p2)\n       2\n    9 x + 6 x + 6\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_357polyadd = {__Pyx_NAMESTR("polyadd"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_357polyadd, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_356polyadd)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_357polyadd(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a1 = 0;
  CYTHON_UNUSED PyObject *__pyx_v_a2 = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("polyadd (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a1,&__pyx_n_s__a2,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a1)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a2)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("polyadd", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8917; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "polyadd") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8917; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_a1 = values[0];
    __pyx_v_a2 = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("polyadd", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8917; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.polyadd", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_356polyadd(__pyx_self, __pyx_v_a1, __pyx_v_a2);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":8917
 * 
 * 
 * def polyadd(a1, a2):             # <<<<<<<<<<<<<<
 *     """Find the sum of two polynomials.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_356polyadd(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a1, CYTHON_UNUSED PyObject *__pyx_v_a2) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("polyadd", 0);

  /* "ga4py/gain/notimplemented.pyx":8960
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8960; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.polyadd", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_359polyder(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_358polyder[] = "Return the derivative of the specified order of a polynomial.\n\n    Parameters\n    ----------\n    p : poly1d or sequence\n        Polynomial to differentiate.\n        A sequence is interpreted as polynomial coefficients, see `poly1d`.\n    m : int, optional\n        Order of differentiation (default: 1)\n\n    Returns\n    -------\n    der : poly1d\n        A new polynomial representing the derivative.\n\n    See Also\n    --------\n    polyint : Anti-derivative of a polynomial.\n    poly1d : Class for one-dimensional polynomials.\n\n    Examples\n    --------\n    The derivative of the polynomial :math:`x^3 + x^2 + x^1 + 1` is:\n\n    >>> p = np.poly1d([1,1,1,1])\n    >>> p2 = np.polyder(p)\n    >>> p2\n    poly1d([3, 2, 1])\n\n    which evaluates to:\n\n    >>> p2(2.)\n    17.0\n\n    We can verify this, approximating the derivative with\n    ``(f(x + h) - f(x))/h``:\n\n    >>> (p(2. + 0.001) - p(2.)) / 0.001\n    17.007000999997857\n\n    The fourth-order derivative of a 3rd-order polynomial is zero:\n\n    >>> np.polyder(p, 2)\n    poly1d([6, 2])\n    >>> np.polyder(p, 3)\n    poly1d([6])\n    >>> np.polyder(p, 4)\n    poly1d([ 0.])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_359polyder = {__Pyx_NAMESTR("polyder"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_359polyder, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_358polyder)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_359polyder(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_p = 0;
  CYTHON_UNUSED PyObject *__pyx_v_m = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("polyder (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__p,&__pyx_n_s__m,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)__pyx_int_1);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__p)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__m);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "polyder") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8963; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_p = values[0];
    __pyx_v_m = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("polyder", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8963; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.polyder", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_358polyder(__pyx_self, __pyx_v_p, __pyx_v_m);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":8963
 * 
 * 
 * def polyder(p, m=1):             # <<<<<<<<<<<<<<
 *     """Return the derivative of the specified order of a polynomial.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_358polyder(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_p, CYTHON_UNUSED PyObject *__pyx_v_m) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("polyder", 0);

  /* "ga4py/gain/notimplemented.pyx":9014
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9014; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.polyder", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_361polydiv(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_360polydiv[] = "Returns the quotient and remainder of polynomial division.\n\n    The input arrays are the coefficients (including any coefficients\n    equal to zero) of the \"numerator\" (dividend) and \"denominator\"\n    (divisor) polynomials, respectively.\n\n    Parameters\n    ----------\n    u : array_like or poly1d\n        Dividend polynomial's coefficients.\n\n    v : array_like or poly1d\n        Divisor polynomial's coefficients.\n\n    Returns\n    -------\n    q : ndarray\n        Coefficients, including those equal to zero, of the quotient.\n    r : ndarray\n        Coefficients, including those equal to zero, of the remainder.\n\n    See Also\n    --------\n    poly, polyadd, polyder, polydiv, polyfit, polyint, polymul, polysub,\n    polyval\n\n    Notes\n    -----\n    Both `u` and `v` must be 0-d or 1-d (ndim = 0 or 1), but `u.ndim` need\n    not equal `v.ndim`. In other words, all four possible combinations -\n    ``u.ndim = v.ndim = 0``, ``u.ndim = v.ndim = 1``,\n    ``u.ndim = 1, v.ndim = 0``, and ``u.ndim = 0, v.ndim = 1`` - work.\n\n    Examples\n    --------\n    .. math:: \014rac{3x^2 + 5x + 2}{2x + 1} = 1.5x + 1.75, remainder 0.25\n\n    >>> x = np.array([3.0, 5.0, 2.0])\n    >>> y = np.array([2.0, 1.0])\n    >>> np.polydiv(x, y)\n    (array([ 1.5 ,  1.75]), array([ 0.25]))\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_361polydiv = {__Pyx_NAMESTR("polydiv"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_361polydiv, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_360polydiv)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_361polydiv(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_u = 0;
  CYTHON_UNUSED PyObject *__pyx_v_v = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("polydiv (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__u,&__pyx_n_s__v,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__u)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__v)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("polydiv", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9017; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "polydiv") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9017; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_u = values[0];
    __pyx_v_v = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("polydiv", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9017; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.polydiv", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_360polydiv(__pyx_self, __pyx_v_u, __pyx_v_v);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":9017
 * 
 * 
 * def polydiv(u, v):             # <<<<<<<<<<<<<<
 *     """Returns the quotient and remainder of polynomial division.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_360polydiv(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_u, CYTHON_UNUSED PyObject *__pyx_v_v) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("polydiv", 0);

  /* "ga4py/gain/notimplemented.pyx":9061
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9061; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.polydiv", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_363polyfit(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_362polyfit[] = "Least squares polynomial fit.\n\n    Fit a polynomial ``p(x) = p[0] * x**deg + ... + p[deg]`` of degree `deg`\n    to points `(x, y)`. Returns a vector of coefficients `p` that minimises\n    the squared error.\n\n    Parameters\n    ----------\n    x : array_like, shape (M,)\n        x-coordinates of the M sample points ``(x[i], y[i])``.\n    y : array_like, shape (M,) or (M, K)\n        y-coordinates of the sample points. Several data sets of sample\n        points sharing the same x-coordinates can be fitted at once by\n        passing in a 2D-array that contains one dataset per column.\n    deg : int\n        Degree of the fitting polynomial\n    rcond : float, optional\n        Relative condition number of the fit. Singular values smaller than this\n        relative to the largest singular value will be ignored. The default\n        value is len(x)*eps, where eps is the relative precision of the float\n        type, about 2e-16 in most cases.\n    full : bool, optional\n        Switch determining nature of return value. When it is\n        False (the default) just the coefficients are returned, when True\n        diagnostic information from the singular value decomposition is also\n        returned.\n\n    Returns\n    -------\n    p : ndarray, shape (M,) or (M, K)\n        Polynomial coefficients, highest power first.\n        If `y` was 2-D, the coefficients for `k`-th data set are in ``p[:,k]``.\n\n    residuals, rank, singular_values, rcond : present only if `full` = True\n        Residuals of the least-squares fit, the effective rank of the scaled\n        Vandermonde coefficient matrix, its singular values, and the specified\n        value of `rcond`. For more details, see `linalg.lstsq`.\n\n    Warns\n    -----\n    RankWarning\n        The rank of the coefficient matrix in the least-squares fit is\n        deficient. The warning is only raised if `full` = False.\n\n        The warnings can be turned off by\n\n        >>> import warnings\n        >>> war""nings.simplefilter('ignore', np.RankWarning)\n\n    See Also\n    --------\n    polyval : Computes polynomial values.\n    linalg.lstsq : Computes a least-squares fit.\n    scipy.interpolate.UnivariateSpline : Computes spline fits.\n\n    Notes\n    -----\n    The solution minimizes the squared error\n\n    .. math ::\n        E = \\sum_{j=0}^k |p(x_j) - y_j|^2\n\n    in the equations::\n\n        x[0]**n * p[n] + ... + x[0] * p[1] + p[0] = y[0]\n        x[1]**n * p[n] + ... + x[1] * p[1] + p[0] = y[1]\n        ...\n        x[k]**n * p[n] + ... + x[k] * p[1] + p[0] = y[k]\n\n    The coefficient matrix of the coefficients `p` is a Vandermonde matrix.\n\n    `polyfit` issues a `RankWarning` when the least-squares fit is badly\n    conditioned. This implies that the best fit is not well-defined due\n    to numerical error. The results may be improved by lowering the polynomial\n    degree or by replacing `x` by `x` - `x`.mean(). The `rcond` parameter\n    can also be set to a value smaller than its default, but the resulting\n    fit may be spurious: including contributions from the small singular\n    values can add numerical noise to the result.\n\n    Note that fitting polynomial coefficients is inherently badly conditioned\n    when the degree of the polynomial is large or the interval of sample points\n    is badly centered. The quality of the fit should always be checked in these\n    cases. When polynomial fits are not satisfactory, splines may be a good\n    alternative.\n\n    References\n    ----------\n    .. [1] Wikipedia, \"Curve fitting\",\n           http://en.wikipedia.org/wiki/Curve_fitting\n    .. [2] Wikipedia, \"Polynomial interpolation\",\n           http://en.wikipedia.org/wiki/Polynomial_interpolation\n\n    Examples\n    --------\n    >>> x = np.array([0.0, 1.0, 2.0, 3.0,  4.0,  5.0])\n    >>> y = np.array([0.0, 0.8, 0.9, 0.1, -0.8, -1.0])\n    >>> z = np.polyfit(x, y, 3)\n    >>> z\n    array([ 0.08703704, -0.81349206,  1.69312169, -0.03968254]"")\n\n    It is convenient to use `poly1d` objects for dealing with polynomials:\n\n    >>> p = np.poly1d(z)\n    >>> p(0.5)\n    0.6143849206349179\n    >>> p(3.5)\n    -0.34732142857143039\n    >>> p(10)\n    22.579365079365115\n\n    High-order polynomials may oscillate wildly:\n\n    >>> p30 = np.poly1d(np.polyfit(x, y, 30))\n    /... RankWarning: Polyfit may be poorly conditioned...\n    >>> p30(4)\n    -0.80000000000000204\n    >>> p30(5)\n    -0.99999999999999445\n    >>> p30(4.5)\n    -0.10547061179440398\n\n    Illustration:\n\n    >>> import matplotlib.pyplot as plt\n    >>> xp = np.linspace(-2, 6, 100)\n    >>> plt.plot(x, y, '.', xp, p(xp), '-', xp, p30(xp), '--')\n    [<matplotlib.lines.Line2D object at 0x...>, <matplotlib.lines.Line2D object at 0x...>, <matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.ylim(-2,2)\n    (-2, 2)\n    >>> plt.show()\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_363polyfit = {__Pyx_NAMESTR("polyfit"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_363polyfit, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_362polyfit)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_363polyfit(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_x = 0;
  CYTHON_UNUSED PyObject *__pyx_v_y = 0;
  CYTHON_UNUSED PyObject *__pyx_v_deg = 0;
  CYTHON_UNUSED PyObject *__pyx_v_rcond = 0;
  CYTHON_UNUSED PyObject *__pyx_v_full = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("polyfit (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__x,&__pyx_n_s__y,&__pyx_n_s__deg,&__pyx_n_s__rcond,&__pyx_n_s__full,0};
    PyObject* values[5] = {0,0,0,0,0};

    /* "ga4py/gain/notimplemented.pyx":9064
 * 
 * 
 * def polyfit(x, y, deg, rcond=None, full=False):             # <<<<<<<<<<<<<<
 *     """Least squares polynomial fit.
 * 
 */
    values[3] = ((PyObject *)Py_None);
    values[4] = __pyx_k_37;
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__x)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__y)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("polyfit", 0, 3, 5, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9064; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__deg)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("polyfit", 0, 3, 5, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9064; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__rcond);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__full);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "polyfit") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9064; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_x = values[0];
    __pyx_v_y = values[1];
    __pyx_v_deg = values[2];
    __pyx_v_rcond = values[3];
    __pyx_v_full = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("polyfit", 0, 3, 5, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9064; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.polyfit", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_362polyfit(__pyx_self, __pyx_v_x, __pyx_v_y, __pyx_v_deg, __pyx_v_rcond, __pyx_v_full);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_362polyfit(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_y, CYTHON_UNUSED PyObject *__pyx_v_deg, CYTHON_UNUSED PyObject *__pyx_v_rcond, CYTHON_UNUSED PyObject *__pyx_v_full) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("polyfit", 0);

  /* "ga4py/gain/notimplemented.pyx":9197
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9197; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.polyfit", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_365polyint(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_364polyint[] = "Return an antiderivative (indefinite integral) of a polynomial.\n\n    The returned order `m` antiderivative `P` of polynomial `p` satisfies\n    :math:`\014rac{d^m}{dx^m}P(x) = p(x)` and is defined up to `m - 1`\n    integration constants `k`. The constants determine the low-order\n    polynomial part\n\n    .. math:: \014rac{k_{m-1}}{0!} x^0 + \\ldots + \014rac{k_0}{(m-1)!}x^{m-1}\n\n    of `P` so that :math:`P^{(j)}(0) = k_{m-j-1}`.\n\n    Parameters\n    ----------\n    p : {array_like, poly1d}\n        Polynomial to differentiate.\n        A sequence is interpreted as polynomial coefficients, see `poly1d`.\n    m : int, optional\n        Order of the antiderivative. (Default: 1)\n    k : {None, list of `m` scalars, scalar}, optional\n        Integration constants. They are given in the order of integration:\n        those corresponding to highest-order terms come first.\n\n        If ``None`` (default), all constants are assumed to be zero.\n        If `m = 1`, a single scalar can be given instead of a list.\n\n    See Also\n    --------\n    polyder : derivative of a polynomial\n    poly1d.integ : equivalent method\n\n    Examples\n    --------\n    The defining property of the antiderivative:\n\n    >>> p = np.poly1d([1,1,1])\n    >>> P = np.polyint(p)\n    >>> P\n    poly1d([ 0.33333333,  0.5       ,  1.        ,  0.        ])\n    >>> np.polyder(P) == p\n    True\n\n    The integration constants default to zero, but can be specified:\n\n    >>> P = np.polyint(p, 3)\n    >>> P(0)\n    0.0\n    >>> np.polyder(P)(0)\n    0.0\n    >>> np.polyder(P, 2)(0)\n    0.0\n    >>> P = np.polyint(p, 3, k=[6,5,3])\n    >>> P\n    poly1d([ 0.01666667,  0.04166667,  0.16666667,  3. ,  5. ,  3. ])\n\n    Note that 3 = 6 / 2!, and that the constants are given in the order of\n    integrations. Constant of the highest-order polynomial term comes first:\n\n    >>> np.polyder(P, 2)(0)\n    6.0\n    >>> np.polyder(P, 1)(0)\n    5.0\n    >>> P(0)\n    3.0\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_365polyint = {__Pyx_NAMESTR("polyint"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_365polyint, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_364polyint)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_365polyint(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_p = 0;
  CYTHON_UNUSED PyObject *__pyx_v_m = 0;
  CYTHON_UNUSED PyObject *__pyx_v_k = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("polyint (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__p,&__pyx_n_s__m,&__pyx_n_s__k,0};
    PyObject* values[3] = {0,0,0};
    values[1] = ((PyObject *)__pyx_int_1);

    /* "ga4py/gain/notimplemented.pyx":9200
 * 
 * 
 * def polyint(p, m=1, k=None):             # <<<<<<<<<<<<<<
 *     """Return an antiderivative (indefinite integral) of a polynomial.
 * 
 */
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__p)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__m);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__k);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "polyint") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9200; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_p = values[0];
    __pyx_v_m = values[1];
    __pyx_v_k = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("polyint", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9200; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.polyint", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_364polyint(__pyx_self, __pyx_v_p, __pyx_v_m, __pyx_v_k);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_364polyint(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_p, CYTHON_UNUSED PyObject *__pyx_v_m, CYTHON_UNUSED PyObject *__pyx_v_k) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("polyint", 0);

  /* "ga4py/gain/notimplemented.pyx":9266
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9266; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.polyint", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_367polymul(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_366polymul[] = "Find the product of two polynomials.\n\n    Finds the polynomial resulting from the multiplication of the two input\n    polynomials. Each input must be either a poly1d object or a 1D sequence\n    of polynomial coefficients, from highest to lowest degree.\n\n    Parameters\n    ----------\n    a1, a2 : array_like or poly1d object\n        Input polynomials.\n\n    Returns\n    -------\n    out : ndarray or poly1d object\n        The polynomial resulting from the multiplication of the inputs. If\n        either inputs is a poly1d object, then the output is also a poly1d\n        object. Otherwise, it is a 1D array of polynomial coefficients from\n        highest to lowest degree.\n\n    See Also\n    --------\n    poly1d : A one-dimensional polynomial class.\n    poly, polyadd, polyder, polydiv, polyfit, polyint, polysub,\n    polyval\n\n    Examples\n    --------\n    >>> np.polymul([1, 2, 3], [9, 5, 1])\n    array([ 9, 23, 38, 17,  3])\n\n    Using poly1d objects:\n\n    >>> p1 = np.poly1d([1, 2, 3])\n    >>> p2 = np.poly1d([9, 5, 1])\n    >>> print p1\n       2\n    1 x + 2 x + 3\n    >>> print p2\n       2\n    9 x + 5 x + 1\n    >>> print np.polymul(p1, p2)\n       4      3      2\n    9 x + 23 x + 38 x + 17 x + 3\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_367polymul = {__Pyx_NAMESTR("polymul"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_367polymul, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_366polymul)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_367polymul(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a1 = 0;
  CYTHON_UNUSED PyObject *__pyx_v_a2 = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("polymul (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a1,&__pyx_n_s__a2,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a1)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a2)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("polymul", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9269; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "polymul") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9269; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_a1 = values[0];
    __pyx_v_a2 = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("polymul", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9269; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.polymul", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_366polymul(__pyx_self, __pyx_v_a1, __pyx_v_a2);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":9269
 * 
 * 
 * def polymul(a1, a2):             # <<<<<<<<<<<<<<
 *     """Find the product of two polynomials.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_366polymul(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a1, CYTHON_UNUSED PyObject *__pyx_v_a2) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("polymul", 0);

  /* "ga4py/gain/notimplemented.pyx":9315
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9315; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.polymul", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_369polysub(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_368polysub[] = "Difference (subtraction) of two polynomials.\n\n    Given two polynomials `a1` and `a2`, returns ``a1 - a2``.\n    `a1` and `a2` can be either array_like sequences of the polynomials'\n    coefficients (including coefficients equal to zero), or `poly1d` objects.\n\n    Parameters\n    ----------\n    a1, a2 : array_like or poly1d\n        Minuend and subtrahend polynomials, respectively.\n\n    Returns\n    -------\n    out : ndarray or poly1d\n        Array or `poly1d` object of the difference polynomial's coefficients.\n\n    See Also\n    --------\n    polyval, polydiv, polymul, polyadd\n\n    Examples\n    --------\n    .. math:: (2 x^2 + 10 x - 2) - (3 x^2 + 10 x -4) = (-x^2 + 2)\n\n    >>> np.polysub([2, 10, -2], [3, 10, -4])\n    array([-1,  0,  2])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_369polysub = {__Pyx_NAMESTR("polysub"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_369polysub, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_368polysub)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_369polysub(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a1 = 0;
  CYTHON_UNUSED PyObject *__pyx_v_a2 = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("polysub (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a1,&__pyx_n_s__a2,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a1)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a2)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("polysub", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9318; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "polysub") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9318; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_a1 = values[0];
    __pyx_v_a2 = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("polysub", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9318; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.polysub", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_368polysub(__pyx_self, __pyx_v_a1, __pyx_v_a2);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":9318
 * 
 * 
 * def polysub(a1, a2):             # <<<<<<<<<<<<<<
 *     """Difference (subtraction) of two polynomials.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_368polysub(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a1, CYTHON_UNUSED PyObject *__pyx_v_a2) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("polysub", 0);

  /* "ga4py/gain/notimplemented.pyx":9347
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9347; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.polysub", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_371polyval(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_370polyval[] = "Evaluate a polynomial at specific values.\n\n    If `p` is of length N, this function returns the value:\n\n        ``p[0]*x**(N-1) + p[1]*x**(N-2) + ... + p[N-2]*x + p[N-1]``\n\n    If `x` is a sequence, then `p(x)` is returned for each element of `x`.\n    If `x` is another polynomial then the composite polynomial `p(x(t))`\n    is returned.\n\n    Parameters\n    ----------\n    p : array_like or poly1d object\n       1D array of polynomial coefficients (including coefficients equal\n       to zero) from highest degree to the constant term, or an\n       instance of poly1d.\n    x : array_like or poly1d object\n       A number, a 1D array of numbers, or an instance of poly1d, \"at\"\n       which to evaluate `p`.\n\n    Returns\n    -------\n    values : ndarray or poly1d\n       If `x` is a poly1d instance, the result is the composition of the two\n       polynomials, i.e., `x` is \"substituted\" in `p` and the simplified\n       result is returned. In addition, the type of `x` - array_like or\n       poly1d - governs the type of the output: `x` array_like => `values`\n       array_like, `x` a poly1d object => `values` is also.\n\n    See Also\n    --------\n    poly1d: A polynomial class.\n\n    Notes\n    -----\n    Horner's scheme [1]_ is used to evaluate the polynomial. Even so,\n    for polynomials of high degree the values may be inaccurate due to\n    rounding errors. Use carefully.\n\n    References\n    ----------\n    .. [1] I. N. Bronshtein, K. A. Semendyayev, and K. A. Hirsch (Eng.\n       trans. Ed.), *Handbook of Mathematics*, New York, Van Nostrand\n       Reinhold Co., 1985, pg. 720.\n\n    Examples\n    --------\n    >>> np.polyval([3,0,1], 5)  # 3 * 5**2 + 0 * 5**1 + 1\n    76\n    >>> np.polyval([3,0,1], np.poly1d(5))\n    poly1d([ 76.])\n    >>> np.polyval(np.poly1d([3,0,1]), 5)\n    76\n    >>> np.polyval(np.poly1d([3,0,1]), np.poly1d(5))\n    poly1d([ 76.])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_371polyval = {__Pyx_NAMESTR("polyval"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_371polyval, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_370polyval)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_371polyval(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_p = 0;
  CYTHON_UNUSED PyObject *__pyx_v_x = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("polyval (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__p,&__pyx_n_s__x,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__p)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__x)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("polyval", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9350; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "polyval") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9350; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_p = values[0];
    __pyx_v_x = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("polyval", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9350; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.polyval", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_370polyval(__pyx_self, __pyx_v_p, __pyx_v_x);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":9350
 * 
 * 
 * def polyval(p, x):             # <<<<<<<<<<<<<<
 *     """Evaluate a polynomial at specific values.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_370polyval(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_p, CYTHON_UNUSED PyObject *__pyx_v_x) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("polyval", 0);

  /* "ga4py/gain/notimplemented.pyx":9408
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9408; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.polyval", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_373ppmt(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_372ppmt[] = "Not implemented. Compute the payment against loan principal.\n\n    Parameters\n    ----------\n    rate : array_like\n        Rate of interest (per period)\n    per : array_like, int\n        Amount paid against the loan changes.  The `per` is the period of\n        interest.\n    nper : array_like\n        Number of compounding periods\n    pv : array_like\n        Present value\n    fv : array_like, optional\n        Future value\n    when : {{'begin', 1}, {'end', 0}}, {string, int}\n        When payments are due ('begin' (1) or 'end' (0))\n\n    See Also\n    --------\n    pmt, pv, ipmt\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_373ppmt = {__Pyx_NAMESTR("ppmt"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_373ppmt, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_372ppmt)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_373ppmt(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_rate = 0;
  CYTHON_UNUSED PyObject *__pyx_v_per = 0;
  CYTHON_UNUSED PyObject *__pyx_v_nper = 0;
  CYTHON_UNUSED PyObject *__pyx_v_pv = 0;
  CYTHON_UNUSED PyObject *__pyx_v_fv = 0;
  CYTHON_UNUSED PyObject *__pyx_v_when = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ppmt (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__rate,&__pyx_n_s__per,&__pyx_n_s__nper,&__pyx_n_s__pv,&__pyx_n_s__fv,&__pyx_n_s__when,0};
    PyObject* values[6] = {0,0,0,0,0,0};
    values[4] = __pyx_k_38;
    values[5] = ((PyObject *)__pyx_n_s__end);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__rate)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__per)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("ppmt", 0, 4, 6, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9411; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__nper)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("ppmt", 0, 4, 6, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9411; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__pv)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("ppmt", 0, 4, 6, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9411; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__fv);
          if (value) { values[4] = value; kw_args--; }
        }
        case  5:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__when);
          if (value) { values[5] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "ppmt") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9411; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_rate = values[0];
    __pyx_v_per = values[1];
    __pyx_v_nper = values[2];
    __pyx_v_pv = values[3];
    __pyx_v_fv = values[4];
    __pyx_v_when = values[5];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("ppmt", 0, 4, 6, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9411; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.ppmt", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_372ppmt(__pyx_self, __pyx_v_rate, __pyx_v_per, __pyx_v_nper, __pyx_v_pv, __pyx_v_fv, __pyx_v_when);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":9411
 * 
 * 
 * def ppmt(rate, per, nper, pv, fv=0.0, when='end'):             # <<<<<<<<<<<<<<
 *     """Not implemented. Compute the payment against loan principal.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_372ppmt(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_rate, CYTHON_UNUSED PyObject *__pyx_v_per, CYTHON_UNUSED PyObject *__pyx_v_nper, CYTHON_UNUSED PyObject *__pyx_v_pv, CYTHON_UNUSED PyObject *__pyx_v_fv, CYTHON_UNUSED PyObject *__pyx_v_when) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("ppmt", 0);

  /* "ga4py/gain/notimplemented.pyx":9435
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9435; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.ppmt", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_375prod(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_374prod[] = "Return the product of array elements over a given axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    axis : int, optional\n        Axis over which the product is taken.  By default, the product\n        of all elements is calculated.\n    dtype : data-type, optional\n        The data-type of the returned array, as well as of the accumulator\n        in which the elements are multiplied.  By default, if `a` is of\n        integer type, `dtype` is the default platform integer. (Note: if\n        the type of `a` is unsigned, then so is `dtype`.)  Otherwise,\n        the dtype is the same as that of `a`.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must have\n        the same shape as the expected output, but the type of the\n        output values will be cast if necessary.\n\n    Returns\n    -------\n    product_along_axis : ndarray, see `dtype` parameter above.\n        An array shaped as `a` but with the specified axis removed.\n        Returns a reference to `out` if specified.\n\n    See Also\n    --------\n    ndarray.prod : equivalent method\n    numpy.doc.ufuncs : Section \"Output arguments\"\n\n    Notes\n    -----\n    Arithmetic is modular when using integer types, and no error is\n    raised on overflow.  That means that, on a 32-bit platform:\n\n    >>> x = np.array([536870910, 536870910, 536870910, 536870910])\n    >>> np.prod(x) #random\n    16\n\n    Examples\n    --------\n    By default, calculate the product of all elements:\n\n    >>> np.prod([1.,2.])\n    2.0\n\n    Even when the input array is two-dimensional:\n\n    >>> np.prod([[1.,2.],[3.,4.]])\n    24.0\n\n    But we can also specify the axis over which to multiply:\n\n    >>> np.prod([[1.,2.],[3.,4.]], axis=1)\n    array([  2.,  12.])\n\n    If the type of `x` is unsigned, then the output type is\n    the unsigned platform integer:\n\n    >>> x = np.array([1, 2, 3], dtype=np.uint8)\n    >>> np.prod(x).dtype ""== np.uint\n    True\n\n    If `x` is of a signed integer type, then the output type\n    is the default platform integer:\n\n    >>> x = np.array([1, 2, 3], dtype=np.int8)\n    >>> np.prod(x).dtype == np.int\n    True\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_375prod = {__Pyx_NAMESTR("prod"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_375prod, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_374prod)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_375prod(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("prod (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__axis,&__pyx_n_s__dtype,&__pyx_n_s__out,0};
    PyObject* values[4] = {0,0,0,0};

    /* "ga4py/gain/notimplemented.pyx":9438
 * 
 * 
 * def prod(a, axis=None, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the product of array elements over a given axis.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    values[3] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__dtype);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__out);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "prod") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9438; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
    __pyx_v_dtype = values[2];
    __pyx_v_out = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("prod", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9438; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.prod", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_374prod(__pyx_self, __pyx_v_a, __pyx_v_axis, __pyx_v_dtype, __pyx_v_out);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_374prod(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_out) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("prod", 0);

  /* "ga4py/gain/notimplemented.pyx":9511
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9511; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.prod", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_377product(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_376product[] = "Return the product of array elements over a given axis.\n\n    See Also\n    --------\n    prod : equivalent function; see for details.\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_377product = {__Pyx_NAMESTR("product"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_377product, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_376product)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_377product(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("product (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__axis,&__pyx_n_s__dtype,&__pyx_n_s__out,0};
    PyObject* values[4] = {0,0,0,0};

    /* "ga4py/gain/notimplemented.pyx":9514
 * 
 * 
 * def product(a, axis=None, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the product of array elements over a given axis.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    values[3] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__dtype);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__out);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "product") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9514; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
    __pyx_v_dtype = values[2];
    __pyx_v_out = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("product", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9514; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.product", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_376product(__pyx_self, __pyx_v_a, __pyx_v_axis, __pyx_v_dtype, __pyx_v_out);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_376product(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_out) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("product", 0);

  /* "ga4py/gain/notimplemented.pyx":9522
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9522; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.product", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_379promote_types(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_378promote_types[] = "promote_types(type1, type2)\n\n    Returns the data type with the smallest size and smallest scalar\n    kind to which both ``type1`` and ``type2`` may be safely cast.\n    The returned data type is always in native byte order.\n\n    This function is symmetric and associative.\n\n    Parameters\n    ----------\n    type1 : dtype or dtype specifier\n        First data type.\n    type2 : dtype or dtype specifier\n        Second data type.\n\n    Returns\n    -------\n    out : dtype\n        The promoted data type.\n\n    Notes\n    -----\n    .. versionadded:: 1.6.0\n\n    See Also\n    --------\n    result_type, dtype, can_cast\n\n    Examples\n    --------\n    >>> np.promote_types('f4', 'f8')\n    dtype('float64')\n\n    >>> np.promote_types('i8', 'f4')\n    dtype('float64')\n\n    >>> np.promote_types('>i8', '<c8')\n    dtype('complex128')\n\n    >>> np.promote_types('i1', 'S8')\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    TypeError: invalid type promotion\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_379promote_types = {__Pyx_NAMESTR("promote_types"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_379promote_types, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_378promote_types)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_379promote_types(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_type1 = 0;
  CYTHON_UNUSED PyObject *__pyx_v_type2 = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("promote_types (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__type1,&__pyx_n_s__type2,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__type1)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__type2)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("promote_types", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9525; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "promote_types") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9525; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_type1 = values[0];
    __pyx_v_type2 = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("promote_types", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9525; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.promote_types", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_378promote_types(__pyx_self, __pyx_v_type1, __pyx_v_type2);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":9525
 * 
 * 
 * def promote_types(type1, type2):             # <<<<<<<<<<<<<<
 *     """promote_types(type1, type2)
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_378promote_types(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_type1, CYTHON_UNUSED PyObject *__pyx_v_type2) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("promote_types", 0);

  /* "ga4py/gain/notimplemented.pyx":9572
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9572; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.promote_types", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_381ptp(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_380ptp[] = "Range of values (maximum - minimum) along an axis.\n\n    The name of the function comes from the acronym for 'peak to peak'.\n\n    Parameters\n    ----------\n    a : array_like\n        Input values.\n    axis : int, optional\n        Axis along which to find the peaks.  By default, flatten the\n        array.\n    out : array_like\n        Alternative output array in which to place the result. It must\n        have the same shape and buffer length as the expected output,\n        but the type of the output values will be cast if necessary.\n\n    Returns\n    -------\n    ptp : ndarray\n        A new array holding the result, unless `out` was\n        specified, in which case a reference to `out` is returned.\n\n    Examples\n    --------\n    >>> x = np.arange(4).reshape((2,2))\n    >>> x\n    array([[0, 1],\n           [2, 3]])\n\n    >>> np.ptp(x, axis=0)\n    array([2, 2])\n\n    >>> np.ptp(x, axis=1)\n    array([1, 1])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_381ptp = {__Pyx_NAMESTR("ptp"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_381ptp, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_380ptp)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_381ptp(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ptp (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__axis,&__pyx_n_s__out,0};
    PyObject* values[3] = {0,0,0};

    /* "ga4py/gain/notimplemented.pyx":9575
 * 
 * 
 * def ptp(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Range of values (maximum - minimum) along an axis.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__out);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "ptp") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9575; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
    __pyx_v_out = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("ptp", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9575; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.ptp", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_380ptp(__pyx_self, __pyx_v_a, __pyx_v_axis, __pyx_v_out);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_380ptp(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("ptp", 0);

  /* "ga4py/gain/notimplemented.pyx":9612
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9612; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.ptp", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_383put(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_382put[] = "Replaces specified elements of an array with given values.\n\n    The indexing works on the flattened target array. `put` is roughly\n    equivalent to:\n\n    ::\n\n        a.flat[ind] = v\n\n    Parameters\n    ----------\n    a : ndarray\n        Target array.\n    ind : array_like\n        Target indices, interpreted as integers.\n    v : array_like\n        Values to place in `a` at target indices. If `v` is shorter than\n        `ind` it will be repeated as necessary.\n    mode : {'raise', 'wrap', 'clip'}, optional\n        Specifies how out-of-bounds indices will behave.\n\n        * 'raise' -- raise an error (default)\n        * 'wrap' -- wrap around\n        * 'clip' -- clip to the range\n\n        'clip' mode means that all indices that are too large are replaced\n        by the index that addresses the last element along that axis. Note\n        that this disables indexing with negative numbers.\n\n    See Also\n    --------\n    putmask, place\n\n    Examples\n    --------\n    >>> a = np.arange(5)\n    >>> np.put(a, [0, 2], [-44, -55])\n    >>> a\n    array([-44,   1, -55,   3,   4])\n\n    >>> a = np.arange(5)\n    >>> np.put(a, 22, -5, mode='clip')\n    >>> a\n    array([ 0,  1,  2,  3, -5])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_383put = {__Pyx_NAMESTR("put"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_383put, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_382put)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_383put(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_ind = 0;
  CYTHON_UNUSED PyObject *__pyx_v_v = 0;
  CYTHON_UNUSED PyObject *__pyx_v_mode = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("put (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__ind,&__pyx_n_s__v,&__pyx_n_s__mode,0};
    PyObject* values[4] = {0,0,0,0};
    values[3] = ((PyObject *)__pyx_n_s__raise);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__ind)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("put", 0, 3, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9615; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__v)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("put", 0, 3, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9615; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__mode);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "put") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9615; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_ind = values[1];
    __pyx_v_v = values[2];
    __pyx_v_mode = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("put", 0, 3, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9615; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.put", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_382put(__pyx_self, __pyx_v_a, __pyx_v_ind, __pyx_v_v, __pyx_v_mode);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":9615
 * 
 * 
 * def put(a, ind, v, mode='raise'):             # <<<<<<<<<<<<<<
 *     """Replaces specified elements of an array with given values.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_382put(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_ind, CYTHON_UNUSED PyObject *__pyx_v_v, CYTHON_UNUSED PyObject *__pyx_v_mode) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("put", 0);

  /* "ga4py/gain/notimplemented.pyx":9662
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9662; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.put", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_385putmask(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_384putmask[] = "putmask(a, mask, values)\n\n    Changes elements of an array based on conditional and input values.\n\n    Sets ``a.flat[n] = values[n]`` for each n where ``mask.flat[n]==True``.\n\n    If `values` is not the same size as `a` and `mask` then it will repeat.\n    This gives behavior different from ``a[mask] = values``.\n\n    Parameters\n    ----------\n    a : array_like\n        Target array.\n    mask : array_like\n        Boolean mask array. It has to be the same shape as `a`.\n    values : array_like\n        Values to put into `a` where `mask` is True. If `values` is smaller\n        than `a` it will be repeated.\n\n    See Also\n    --------\n    place, put, take\n\n    Examples\n    --------\n    >>> x = np.arange(6).reshape(2, 3)\n    >>> np.putmask(x, x>2, x**2)\n    >>> x\n    array([[ 0,  1,  2],\n           [ 9, 16, 25]])\n\n    If `values` is smaller than `a` it is repeated:\n\n    >>> x = np.arange(5)\n    >>> np.putmask(x, x>1, [-33, -44])\n    >>> x\n    array([  0,   1, -33, -44, -33])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_385putmask = {__Pyx_NAMESTR("putmask"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_385putmask, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_384putmask)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_385putmask(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_mask = 0;
  CYTHON_UNUSED PyObject *__pyx_v_values = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("putmask (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__mask,&__pyx_n_s__values,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__mask)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("putmask", 1, 3, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9665; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__values)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("putmask", 1, 3, 3, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9665; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "putmask") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9665; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_a = values[0];
    __pyx_v_mask = values[1];
    __pyx_v_values = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("putmask", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9665; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.putmask", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_384putmask(__pyx_self, __pyx_v_a, __pyx_v_mask, __pyx_v_values);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":9665
 * 
 * 
 * def putmask(a, mask, values):             # <<<<<<<<<<<<<<
 *     """putmask(a, mask, values)
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_384putmask(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_mask, CYTHON_UNUSED PyObject *__pyx_v_values) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("putmask", 0);

  /* "ga4py/gain/notimplemented.pyx":9706
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9706; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.putmask", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_387pv(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_386pv[] = "Compute the present value.\n\n    Given:\n     * a future value, `fv`\n     * an interest `rate` compounded once per period, of which\n       there are\n     * `nper` total\n     * a (fixed) payment, `pmt`, paid either\n     * at the beginning (`when` = {'begin', 1}) or the end\n       (`when` = {'end', 0}) of each period\n\n    Return:\n       the value now\n\n    Parameters\n    ----------\n    rate : array_like\n        Rate of interest (per period)\n    nper : array_like\n        Number of compounding periods\n    pmt : array_like\n        Payment\n    fv : array_like, optional\n        Future value\n    when : {{'begin', 1}, {'end', 0}}, {string, int}, optional\n        When payments are due ('begin' (1) or 'end' (0))\n\n    Returns\n    -------\n    out : ndarray, float\n        Present value of a series of payments or investments.\n\n    Notes\n    -----\n    The present value is computed by solving the equation::\n\n     fv +\n     pv*(1 + rate)**nper +\n     pmt*(1 + rate*when)/rate*((1 + rate)**nper - 1) = 0\n\n    or, when ``rate = 0``::\n\n     fv + pv + pmt * nper = 0\n\n    for `pv`, which is then returned.\n\n    References\n    ----------\n    .. [WRW] Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May).\n       Open Document Format for Office Applications (OpenDocument)v1.2,\n       Part 2: Recalculated Formula (OpenFormula) Format - Annotated Version,\n       Pre-Draft 12. Organization for the Advancement of Structured Information\n       Standards (OASIS). Billerica, MA, USA. [ODT Document].\n       Available:\n       http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula\n       OpenDocument-formula-20090508.odt\n\n    Examples\n    --------\n    What is the present value (e.g., the initial investment)\n    of an investment that needs to total $15692.93\n    after 10 years of saving $100 every month?  Assume the\n    interest rate is 5% (annually) compounded monthly.\n\n    >>> np.pv(0.05/12, 10*12, -100, 15692.93)\n   "" -100.00067131625819\n\n    By convention, the negative sign represents cash flow out\n    (i.e., money not available today).  Thus, to end up with\n    $15,692.93 in 10 years saving $100 a month at 5% annual\n    interest, one's initial deposit should also be $100.\n\n    If any input is array_like, ``pv`` returns an array of equal shape.\n    Let's compare different interest rates in the example above:\n\n    >>> a = np.array((0.05, 0.04, 0.03))/12\n    >>> np.pv(a, 10*12, -100, 15692.93)\n    array([ -100.00067132,  -649.26771385, -1273.78633713])\n\n    So, to end up with the same $15692.93 under the same $100 per month\n    \"savings plan,\" for annual interest rates of 4% and 3%, one would\n    need initial investments of $649.27 and $1273.79, respectively.\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_387pv = {__Pyx_NAMESTR("pv"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_387pv, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_386pv)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_387pv(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_rate = 0;
  CYTHON_UNUSED PyObject *__pyx_v_nper = 0;
  CYTHON_UNUSED PyObject *__pyx_v_pmt = 0;
  CYTHON_UNUSED PyObject *__pyx_v_fv = 0;
  CYTHON_UNUSED PyObject *__pyx_v_when = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("pv (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__rate,&__pyx_n_s__nper,&__pyx_n_s__pmt,&__pyx_n_s__fv,&__pyx_n_s__when,0};
    PyObject* values[5] = {0,0,0,0,0};
    values[3] = __pyx_k_39;
    values[4] = ((PyObject *)__pyx_n_s__end);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__rate)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__nper)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("pv", 0, 3, 5, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9709; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__pmt)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("pv", 0, 3, 5, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9709; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__fv);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__when);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "pv") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9709; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_rate = values[0];
    __pyx_v_nper = values[1];
    __pyx_v_pmt = values[2];
    __pyx_v_fv = values[3];
    __pyx_v_when = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("pv", 0, 3, 5, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9709; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.pv", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_386pv(__pyx_self, __pyx_v_rate, __pyx_v_nper, __pyx_v_pmt, __pyx_v_fv, __pyx_v_when);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":9709
 * 
 * 
 * def pv(rate, nper, pmt, fv=0.0, when='end'):             # <<<<<<<<<<<<<<
 *     """Compute the present value.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_386pv(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_rate, CYTHON_UNUSED PyObject *__pyx_v_nper, CYTHON_UNUSED PyObject *__pyx_v_pmt, CYTHON_UNUSED PyObject *__pyx_v_fv, CYTHON_UNUSED PyObject *__pyx_v_when) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("pv", 0);

  /* "ga4py/gain/notimplemented.pyx":9794
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9794; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.pv", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_389rank(PyObject *__pyx_self, PyObject *__pyx_v_a); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_388rank[] = "Return the number of dimensions of an array.\n\n    If `a` is not already an array, a conversion is attempted.\n    Scalars are zero dimensional.\n\n    Parameters\n    ----------\n    a : array_like\n        Array whose number of dimensions is desired. If `a` is not an array,\n        a conversion is attempted.\n\n    Returns\n    -------\n    number_of_dimensions : int\n        The number of dimensions in the array.\n\n    See Also\n    --------\n    ndim : equivalent function\n    ndarray.ndim : equivalent property\n    shape : dimensions of array\n    ndarray.shape : dimensions of array\n\n    Notes\n    -----\n    In the old Numeric package, `rank` was the term used for the number of\n    dimensions, but in Numpy `ndim` is used instead.\n\n    Examples\n    --------\n    >>> np.rank([1,2,3])\n    1\n    >>> np.rank(np.array([[1,2,3],[4,5,6]]))\n    2\n    >>> np.rank(1)\n    0\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_389rank = {__Pyx_NAMESTR("rank"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_389rank, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_388rank)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_389rank(PyObject *__pyx_self, PyObject *__pyx_v_a) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("rank (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_388rank(__pyx_self, ((PyObject *)__pyx_v_a));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":9797
 * 
 * 
 * def rank(a):             # <<<<<<<<<<<<<<
 *     """Return the number of dimensions of an array.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_388rank(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("rank", 0);

  /* "ga4py/gain/notimplemented.pyx":9836
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9836; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.rank", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_391rate(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_390rate[] = "Compute the rate of interest per period.\n\n    Parameters\n    ----------\n    nper : array_like\n        Number of compounding periods\n    pmt : array_like\n        Payment\n    pv : array_like\n        Present value\n    fv : array_like\n        Future value\n    when : {{'begin', 1}, {'end', 0}}, {string, int}, optional\n        When payments are due ('begin' (1) or 'end' (0))\n    guess : float, optional\n        Starting guess for solving the rate of interest\n    tol : float, optional\n        Required tolerance for the solution\n    maxiter : int, optional\n        Maximum iterations in finding the solution\n\n    Notes\n    -----\n    The rate of interest is computed by iteratively solving the\n    (non-linear) equation::\n\n     fv + pv*(1+rate)**nper + pmt*(1+rate*when)/rate * ((1+rate)**nper - 1) = 0\n\n    for ``rate``.\n\n    References\n    ----------\n    Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May). Open Document\n    Format for Office Applications (OpenDocument)v1.2, Part 2: Recalculated\n    Formula (OpenFormula) Format - Annotated Version, Pre-Draft 12.\n    Organization for the Advancement of Structured Information Standards\n    (OASIS). Billerica, MA, USA. [ODT Document]. Available:\n    http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula\n    OpenDocument-formula-20090508.odt\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_391rate = {__Pyx_NAMESTR("rate"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_391rate, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_390rate)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_391rate(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_nper = 0;
  CYTHON_UNUSED PyObject *__pyx_v_pmt = 0;
  CYTHON_UNUSED PyObject *__pyx_v_pv = 0;
  CYTHON_UNUSED PyObject *__pyx_v_fv = 0;
  CYTHON_UNUSED PyObject *__pyx_v_when = 0;
  CYTHON_UNUSED PyObject *__pyx_v_guess = 0;
  CYTHON_UNUSED PyObject *__pyx_v_tol = 0;
  CYTHON_UNUSED PyObject *__pyx_v_maxiter = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("rate (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__nper,&__pyx_n_s__pmt,&__pyx_n_s__pv,&__pyx_n_s__fv,&__pyx_n_s__when,&__pyx_n_s__guess,&__pyx_n_s__tol,&__pyx_n_s__maxiter,0};
    PyObject* values[8] = {0,0,0,0,0,0,0,0};
    values[4] = ((PyObject *)__pyx_n_s__end);
    values[5] = __pyx_k_40;
    values[6] = __pyx_k_41;
    values[7] = ((PyObject *)__pyx_int_100);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  8: values[7] = PyTuple_GET_ITEM(__pyx_args, 7);
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__nper)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__pmt)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("rate", 0, 4, 8, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9839; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__pv)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("rate", 0, 4, 8, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9839; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__fv)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("rate", 0, 4, 8, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9839; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__when);
          if (value) { values[4] = value; kw_args--; }
        }
        case  5:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__guess);
          if (value) { values[5] = value; kw_args--; }
        }
        case  6:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__tol);
          if (value) { values[6] = value; kw_args--; }
        }
        case  7:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__maxiter);
          if (value) { values[7] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "rate") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9839; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  8: values[7] = PyTuple_GET_ITEM(__pyx_args, 7);
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_nper = values[0];
    __pyx_v_pmt = values[1];
    __pyx_v_pv = values[2];
    __pyx_v_fv = values[3];
    __pyx_v_when = values[4];
    __pyx_v_guess = values[5];
    __pyx_v_tol = values[6];
    __pyx_v_maxiter = values[7];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("rate", 0, 4, 8, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9839; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.rate", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_390rate(__pyx_self, __pyx_v_nper, __pyx_v_pmt, __pyx_v_pv, __pyx_v_fv, __pyx_v_when, __pyx_v_guess, __pyx_v_tol, __pyx_v_maxiter);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":9839
 * 
 * 
 * def rate(nper, pmt, pv, fv, when='end', guess=0.1, tol=1e-06, maxiter=100):             # <<<<<<<<<<<<<<
 *     """Compute the rate of interest per period.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_390rate(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_nper, CYTHON_UNUSED PyObject *__pyx_v_pmt, CYTHON_UNUSED PyObject *__pyx_v_pv, CYTHON_UNUSED PyObject *__pyx_v_fv, CYTHON_UNUSED PyObject *__pyx_v_when, CYTHON_UNUSED PyObject *__pyx_v_guess, CYTHON_UNUSED PyObject *__pyx_v_tol, CYTHON_UNUSED PyObject *__pyx_v_maxiter) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("rate", 0);

  /* "ga4py/gain/notimplemented.pyx":9881
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9881; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.rate", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_393ravel(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_392ravel[] = "Return a flattened array.\n\n    A 1-D array, containing the elements of the input, is returned.  A copy is\n    made only if needed.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.  The elements in ``a`` are read in the order specified by\n        `order`, and packed as a 1-D array.\n    order : {'C','F', 'A', 'K'}, optional\n        The elements of ``a`` are read in this order. 'C' means to view\n        the elements in C (row-major) order. 'F' means to view the elements\n        in Fortran (column-major) order. 'A' means to view the elements\n        in 'F' order if a is Fortran contiguous, 'C' order otherwise.\n        'K' means to view the elements in the order they occur in memory,\n        except for reversing the data when strides are negative.\n        By default, 'C' order is used.\n\n    Returns\n    -------\n    1d_array : ndarray\n        Output of the same dtype as `a`, and of shape ``(a.size(),)``.\n\n    See Also\n    --------\n    ndarray.flat : 1-D iterator over an array.\n    ndarray.flatten : 1-D array copy of the elements of an array\n                      in row-major order.\n\n    Notes\n    -----\n    In row-major order, the row index varies the slowest, and the column\n    index the quickest.  This can be generalized to multiple dimensions,\n    where row-major order implies that the index along the first axis\n    varies slowest, and the index along the last quickest.  The opposite holds\n    for Fortran-, or column-major, mode.\n\n    Examples\n    --------\n    It is equivalent to ``reshape(-1, order=order)``.\n\n    >>> x = np.array([[1, 2, 3], [4, 5, 6]])\n    >>> print np.ravel(x)\n    [1 2 3 4 5 6]\n\n    >>> print x.reshape(-1)\n    [1 2 3 4 5 6]\n\n    >>> print np.ravel(x, order='F')\n    [1 4 2 5 3 6]\n\n    When ``order`` is 'A', it will preserve the array's 'C' or 'F' ordering:\n\n    >>> print np.ravel(x.T)\n    [1 4 2 5 3 6]\n    >>> print np.ravel(x.T, order='A')\n    [1 2 3 4 5 6]\n\n    When ``or""der`` is 'K', it will preserve orderings that are neither 'C'\n    nor 'F', but won't reverse axes:\n\n    >>> a = np.arange(3)[::-1]; a\n    array([2, 1, 0])\n    >>> a.ravel(order='C')\n    array([2, 1, 0])\n    >>> a.ravel(order='K')\n    array([2, 1, 0])\n\n    >>> a = np.arange(12).reshape(2,3,2).swapaxes(1,2); a\n    array([[[ 0,  2,  4],\n            [ 1,  3,  5]],\n           [[ 6,  8, 10],\n            [ 7,  9, 11]]])\n    >>> a.ravel(order='C')\n    array([ 0,  2,  4,  1,  3,  5,  6,  8, 10,  7,  9, 11])\n    >>> a.ravel(order='K')\n    array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_393ravel = {__Pyx_NAMESTR("ravel"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_393ravel, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_392ravel)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_393ravel(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_order = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ravel (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__order,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)__pyx_n_s__C);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__order);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "ravel") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9884; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_order = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("ravel", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9884; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.ravel", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_392ravel(__pyx_self, __pyx_v_a, __pyx_v_order);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":9884
 * 
 * 
 * def ravel(a, order='C'):             # <<<<<<<<<<<<<<
 *     """Return a flattened array.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_392ravel(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_order) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("ravel", 0);

  /* "ga4py/gain/notimplemented.pyx":9965
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9965; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.ravel", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_395ravel_multi_index(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_394ravel_multi_index[] = "ravel_multi_index(multi_index, dims, mode='raise', order='C')\n\n    Converts a tuple of index arrays into an array of flat\n    indices, applying boundary modes to the multi-index.\n\n    Parameters\n    ----------\n    multi_index : tuple of array_like\n        A tuple of integer arrays, one array for each dimension.\n    dims : tuple of ints\n        The shape of array into which the indices from ``multi_index`` apply.\n    mode : {'raise', 'wrap', 'clip'}, optional\n        Specifies how out-of-bounds indices are handled.  Can specify\n        either one mode or a tuple of modes, one mode per index.\n\n        * 'raise' -- raise an error (default)\n        * 'wrap' -- wrap around\n        * 'clip' -- clip to the range\n\n        In 'clip' mode, a negative index which would normally\n        wrap will clip to 0 instead.\n    order : {'C', 'F'}, optional\n        Determines whether the multi-index should be viewed as indexing in\n        C (row-major) order or FORTRAN (column-major) order.\n\n    Returns\n    -------\n    raveled_indices : ndarray\n        An array of indices into the flattened version of an array\n        of dimensions ``dims``.\n\n    See Also\n    --------\n    unravel_index\n\n    Notes\n    -----\n    .. versionadded:: 1.6.0\n\n    Examples\n    --------\n    >>> arr = np.array([[3,6,6],[4,5,1]])\n    >>> np.ravel_multi_index(arr, (7,6))\n    array([22, 41, 37])\n    >>> np.ravel_multi_index(arr, (7,6), order='F')\n    array([31, 41, 13])\n    >>> np.ravel_multi_index(arr, (4,6), mode='clip')\n    array([22, 23, 19])\n    >>> np.ravel_multi_index(arr, (4,4), mode=('clip','wrap'))\n    array([12, 13, 13])\n\n    >>> np.ravel_multi_index((3,1,4,1), (6,7,8,9))\n    1621\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_395ravel_multi_index = {__Pyx_NAMESTR("ravel_multi_index"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_395ravel_multi_index, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_394ravel_multi_index)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_395ravel_multi_index(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_multi_index = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dims = 0;
  CYTHON_UNUSED PyObject *__pyx_v_mode = 0;
  CYTHON_UNUSED PyObject *__pyx_v_order = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ravel_multi_index (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__multi_index,&__pyx_n_s__dims,&__pyx_n_s__mode,&__pyx_n_s__order,0};
    PyObject* values[4] = {0,0,0,0};
    values[2] = ((PyObject *)__pyx_n_s__raise);
    values[3] = ((PyObject *)__pyx_n_s__C);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__multi_index)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__dims)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("ravel_multi_index", 0, 2, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9968; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__mode);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__order);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "ravel_multi_index") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9968; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_multi_index = values[0];
    __pyx_v_dims = values[1];
    __pyx_v_mode = values[2];
    __pyx_v_order = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("ravel_multi_index", 0, 2, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9968; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.ravel_multi_index", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_394ravel_multi_index(__pyx_self, __pyx_v_multi_index, __pyx_v_dims, __pyx_v_mode, __pyx_v_order);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":9968
 * 
 * 
 * def ravel_multi_index(multi_index, dims, mode='raise', order='C'):             # <<<<<<<<<<<<<<
 *     """ravel_multi_index(multi_index, dims, mode='raise', order='C')
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_394ravel_multi_index(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_multi_index, CYTHON_UNUSED PyObject *__pyx_v_dims, CYTHON_UNUSED PyObject *__pyx_v_mode, CYTHON_UNUSED PyObject *__pyx_v_order) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("ravel_multi_index", 0);

  /* "ga4py/gain/notimplemented.pyx":10025
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10025; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.ravel_multi_index", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_397real(PyObject *__pyx_self, PyObject *__pyx_v_val); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_396real[] = "Return the real part of the elements of the array.\n\n    Parameters\n    ----------\n    val : array_like\n        Input array.\n\n    Returns\n    -------\n    out : ndarray\n        Output array. If `val` is real, the type of `val` is used for the\n        output.  If `val` has complex elements, the returned type is float.\n\n    See Also\n    --------\n    real_if_close, imag, angle\n\n    Examples\n    --------\n    >>> a = np.array([1+2j, 3+4j, 5+6j])\n    >>> a.real\n    array([ 1.,  3.,  5.])\n    >>> a.real = 9\n    >>> a\n    array([ 9.+2.j,  9.+4.j,  9.+6.j])\n    >>> a.real = np.array([9, 8, 7])\n    >>> a\n    array([ 9.+2.j,  8.+4.j,  7.+6.j])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_397real = {__Pyx_NAMESTR("real"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_397real, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_396real)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_397real(PyObject *__pyx_self, PyObject *__pyx_v_val) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("real (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_396real(__pyx_self, ((PyObject *)__pyx_v_val));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":10028
 * 
 * 
 * def real(val):             # <<<<<<<<<<<<<<
 *     """Return the real part of the elements of the array.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_396real(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_val) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("real", 0);

  /* "ga4py/gain/notimplemented.pyx":10059
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10059; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.real", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_399real_if_close(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_398real_if_close[] = "If complex input returns a real array if complex parts are close to zero.\n\n    \"Close to zero\" is defined as `tol` * (machine epsilon of the type for\n    `a`).\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    tol : float\n        Tolerance in machine epsilons for the complex part of the elements\n        in the array.\n\n    Returns\n    -------\n    out : ndarray\n        If `a` is real, the type of `a` is used for the output.  If `a`\n        has complex elements, the returned type is float.\n\n    See Also\n    --------\n    real, imag, angle\n\n    Notes\n    -----\n    Machine epsilon varies from machine to machine and between data types\n    but Python floats on most platforms have a machine epsilon equal to\n    2.2204460492503131e-16.  You can use 'np.finfo(np.float).eps' to print\n    out the machine epsilon for floats.\n\n    Examples\n    --------\n    >>> np.finfo(np.float).eps\n    2.2204460492503131e-16\n\n    >>> np.real_if_close([2.1 + 4e-14j], tol=1000)\n    array([ 2.1])\n    >>> np.real_if_close([2.1 + 4e-13j], tol=1000)\n    array([ 2.1 +4.00000000e-13j])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_399real_if_close = {__Pyx_NAMESTR("real_if_close"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_399real_if_close, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_398real_if_close)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_399real_if_close(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_tol = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("real_if_close (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__tol,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)__pyx_int_100);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__tol);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "real_if_close") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10062; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_tol = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("real_if_close", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10062; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.real_if_close", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_398real_if_close(__pyx_self, __pyx_v_a, __pyx_v_tol);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":10062
 * 
 * 
 * def real_if_close(a, tol=100):             # <<<<<<<<<<<<<<
 *     """If complex input returns a real array if complex parts are close to zero.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_398real_if_close(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_tol) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("real_if_close", 0);

  /* "ga4py/gain/notimplemented.pyx":10104
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10104; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.real_if_close", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_401recfromcsv(PyObject *__pyx_self, PyObject *__pyx_v_fname); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_400recfromcsv[] = "Load ASCII data stored in a comma-separated file.\n\n    The returned array is a record array (if ``usemask=False``, see\n    `recarray`) or a masked record array (if ``usemask=True``,\n    see `ma.mrecords.MaskedRecords`).\n\n    For a complete description of all the input parameters, see `genfromtxt`.\n\n    See Also\n    --------\n    numpy.genfromtxt : generic function to load ASCII data.\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_401recfromcsv = {__Pyx_NAMESTR("recfromcsv"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_401recfromcsv, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_400recfromcsv)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_401recfromcsv(PyObject *__pyx_self, PyObject *__pyx_v_fname) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("recfromcsv (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_400recfromcsv(__pyx_self, ((PyObject *)__pyx_v_fname));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":10107
 * 
 * 
 * def recfromcsv(fname):             # <<<<<<<<<<<<<<
 *     """Load ASCII data stored in a comma-separated file.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_400recfromcsv(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_fname) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("recfromcsv", 0);

  /* "ga4py/gain/notimplemented.pyx":10121
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10121; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.recfromcsv", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_403recfromtxt(PyObject *__pyx_self, PyObject *__pyx_v_fname); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_402recfromtxt[] = "Load ASCII data from a file and return it in a record array.\n\n    If ``usemask=False`` a standard `recarray` is returned,\n    if ``usemask=True`` a MaskedRecords array is returned.\n\n    Complete description of all the optional input parameters is available in\n    the docstring of the `genfromtxt` function.\n\n    See Also\n    --------\n    numpy.genfromtxt : generic function\n\n    Notes\n    -----\n    By default, `dtype` is None, which means that the data-type of the output\n    array will be determined from the data.\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_403recfromtxt = {__Pyx_NAMESTR("recfromtxt"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_403recfromtxt, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_402recfromtxt)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_403recfromtxt(PyObject *__pyx_self, PyObject *__pyx_v_fname) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("recfromtxt (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_402recfromtxt(__pyx_self, ((PyObject *)__pyx_v_fname));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":10124
 * 
 * 
 * def recfromtxt(fname):             # <<<<<<<<<<<<<<
 *     """Load ASCII data from a file and return it in a record array.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_402recfromtxt(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_fname) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("recfromtxt", 0);

  /* "ga4py/gain/notimplemented.pyx":10143
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10143; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.recfromtxt", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_405repeat(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_404repeat[] = "Repeat elements of an array.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    repeats : {int, array of ints}\n        The number of repetitions for each element.  `repeats` is broadcasted\n        to fit the shape of the given axis.\n    axis : int, optional\n        The axis along which to repeat values.  By default, use the\n        flattened input array, and return a flat output array.\n\n    Returns\n    -------\n    repeated_array : ndarray\n        Output array which has the same shape as `a`, except along\n        the given axis.\n\n    See Also\n    --------\n    tile : Tile an array.\n\n    Examples\n    --------\n    >>> x = np.array([[1,2],[3,4]])\n    >>> np.repeat(x, 2)\n    array([1, 1, 2, 2, 3, 3, 4, 4])\n    >>> np.repeat(x, 3, axis=1)\n    array([[1, 1, 1, 2, 2, 2],\n           [3, 3, 3, 4, 4, 4]])\n    >>> np.repeat(x, [1, 2], axis=0)\n    array([[1, 2],\n           [3, 4],\n           [3, 4]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_405repeat = {__Pyx_NAMESTR("repeat"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_405repeat, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_404repeat)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_405repeat(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_repeats = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("repeat (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__repeats,&__pyx_n_s__axis,0};
    PyObject* values[3] = {0,0,0};

    /* "ga4py/gain/notimplemented.pyx":10146
 * 
 * 
 * def repeat(a, repeats, axis=None):             # <<<<<<<<<<<<<<
 *     """Repeat elements of an array.
 * 
 */
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__repeats)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("repeat", 0, 2, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10146; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "repeat") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10146; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_repeats = values[1];
    __pyx_v_axis = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("repeat", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10146; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.repeat", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_404repeat(__pyx_self, __pyx_v_a, __pyx_v_repeats, __pyx_v_axis);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_404repeat(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_repeats, CYTHON_UNUSED PyObject *__pyx_v_axis) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("repeat", 0);

  /* "ga4py/gain/notimplemented.pyx":10184
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10184; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.repeat", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_407require(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_406require[] = "Return an ndarray of the provided type that satisfies requirements.\n\n    This function is useful to be sure that an array with the correct flags\n    is returned for passing to compiled code (perhaps through ctypes).\n\n    Parameters\n    ----------\n    a : array_like\n       The object to be converted to a type-and-requirement-satisfying array.\n    dtype : data-type\n       The required data-type, the default data-type is float64).\n    requirements : str or list of str\n       The requirements list can be any of the following\n\n       * 'F_CONTIGUOUS' ('F') - ensure a Fortran-contiguous array\n       * 'C_CONTIGUOUS' ('C') - ensure a C-contiguous array\n       * 'ALIGNED' ('A')      - ensure a data-type aligned array\n       * 'WRITEABLE' ('W')    - ensure a writable array\n       * 'OWNDATA' ('O')      - ensure an array that owns its own data\n\n    See Also\n    --------\n    asarray : Convert input to an ndarray.\n    asanyarray : Convert to an ndarray, but pass through ndarray subclasses.\n    ascontiguousarray : Convert input to a contiguous array.\n    asfortranarray : Convert input to an ndarray with column-major\n                     memory order.\n    ndarray.flags : Information about the memory layout of the array.\n\n    Notes\n    -----\n    The returned array will be guaranteed to have the listed requirements\n    by making a copy if needed.\n\n    Examples\n    --------\n    >>> x = np.arange(6).reshape(2,3)\n    >>> x.flags\n      C_CONTIGUOUS : True\n      F_CONTIGUOUS : False\n      OWNDATA : False\n      WRITEABLE : True\n      ALIGNED : True\n      UPDATEIFCOPY : False\n\n    >>> y = np.require(x, dtype=np.float32, requirements=['A', 'O', 'W', 'F'])\n    >>> y.flags\n      C_CONTIGUOUS : False\n      F_CONTIGUOUS : True\n      OWNDATA : True\n      WRITEABLE : True\n      ALIGNED : True\n      UPDATEIFCOPY : False\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_407require = {__Pyx_NAMESTR("require"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_407require, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_406require)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_407require(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  CYTHON_UNUSED PyObject *__pyx_v_requirements = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("require (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__dtype,&__pyx_n_s__requirements,0};
    PyObject* values[3] = {0,0,0};

    /* "ga4py/gain/notimplemented.pyx":10187
 * 
 * 
 * def require(a, dtype=None, requirements=None):             # <<<<<<<<<<<<<<
 *     """Return an ndarray of the provided type that satisfies requirements.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__dtype);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__requirements);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "require") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10187; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_dtype = values[1];
    __pyx_v_requirements = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("require", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10187; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.require", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_406require(__pyx_self, __pyx_v_a, __pyx_v_dtype, __pyx_v_requirements);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_406require(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_requirements) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("require", 0);

  /* "ga4py/gain/notimplemented.pyx":10243
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10243; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.require", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_409reshape(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_408reshape[] = "Gives a new shape to an array without changing its data.\n\n    Parameters\n    ----------\n    a : array_like\n        Array to be reshaped.\n    newshape : int or tuple of ints\n        The new shape should be compatible with the original shape. If\n        an integer, then the result will be a 1-D array of that length.\n        One shape dimension can be -1. In this case, the value is inferred\n        from the length of the array and remaining dimensions.\n    order : {'C', 'F', 'A'}, optional\n        Determines whether the array data should be viewed as in C\n        (row-major) order, FORTRAN (column-major) order, or the C/FORTRAN\n        order should be preserved.\n\n    Returns\n    -------\n    reshaped_array : ndarray\n        This will be a new view object if possible; otherwise, it will\n        be a copy.\n\n\n    See Also\n    --------\n    ndarray.reshape : Equivalent method.\n\n    Notes\n    -----\n\n    It is not always possible to change the shape of an array without\n    copying the data. If you want an error to be raise if the data is copied,\n    you should assign the new shape to the shape attribute of the array::\n\n     >>> a = np.zeros((10, 2))\n     # A transpose make the array non-contiguous\n     >>> b = a.T\n     # Taking a view makes it possible to modify the shape without modiying the\n     # initial object.\n     >>> c = b.view()\n     >>> c.shape = (20)\n     AttributeError: incompatible shape for a non-contiguous array\n\n\n    Examples\n    --------\n    >>> a = np.array([[1,2,3], [4,5,6]])\n    >>> np.reshape(a, 6)\n    array([1, 2, 3, 4, 5, 6])\n    >>> np.reshape(a, 6, order='F')\n    array([1, 4, 2, 5, 3, 6])\n\n    >>> np.reshape(a, (3,-1))       # the unspecified value is inferred to be 2\n    array([[1, 2],\n           [3, 4],\n           [5, 6]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_409reshape = {__Pyx_NAMESTR("reshape"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_409reshape, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_408reshape)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_409reshape(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_newshape = 0;
  CYTHON_UNUSED PyObject *__pyx_v_order = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("reshape (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__newshape,&__pyx_n_s__order,0};
    PyObject* values[3] = {0,0,0};
    values[2] = ((PyObject *)__pyx_n_s__C);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__newshape)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("reshape", 0, 2, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10246; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__order);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "reshape") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10246; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_newshape = values[1];
    __pyx_v_order = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("reshape", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10246; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.reshape", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_408reshape(__pyx_self, __pyx_v_a, __pyx_v_newshape, __pyx_v_order);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":10246
 * 
 * 
 * def reshape(a, newshape, order='C'):             # <<<<<<<<<<<<<<
 *     """Gives a new shape to an array without changing its data.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_408reshape(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_newshape, CYTHON_UNUSED PyObject *__pyx_v_order) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("reshape", 0);

  /* "ga4py/gain/notimplemented.pyx":10305
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10305; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.reshape", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_411resize(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_410resize[] = "Return a new array with the specified shape.\n\n    If the new array is larger than the original array, then the new\n    array is filled with repeated copies of `a`.  Note that this behavior\n    is different from a.resize(new_shape) which fills with zeros instead\n    of repeated copies of `a`.\n\n    Parameters\n    ----------\n    a : array_like\n        Array to be resized.\n\n    new_shape : int or tuple of int\n        Shape of resized array.\n\n    Returns\n    -------\n    reshaped_array : ndarray\n        The new array is formed from the data in the old array, repeated\n        if necessary to fill out the required number of elements.  The\n        data are repeated in the order that they are stored in memory.\n\n    See Also\n    --------\n    ndarray.resize : resize an array in-place.\n\n    Examples\n    --------\n    >>> a=np.array([[0,1],[2,3]])\n    >>> np.resize(a,(1,4))\n    array([[0, 1, 2, 3]])\n    >>> np.resize(a,(2,4))\n    array([[0, 1, 2, 3],\n           [0, 1, 2, 3]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_411resize = {__Pyx_NAMESTR("resize"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_411resize, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_410resize)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_411resize(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_new_shape = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("resize (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__new_shape,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__new_shape)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("resize", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10308; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "resize") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10308; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_a = values[0];
    __pyx_v_new_shape = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("resize", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10308; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.resize", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_410resize(__pyx_self, __pyx_v_a, __pyx_v_new_shape);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":10308
 * 
 * 
 * def resize(a, new_shape):             # <<<<<<<<<<<<<<
 *     """Return a new array with the specified shape.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_410resize(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_new_shape) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("resize", 0);

  /* "ga4py/gain/notimplemented.pyx":10345
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10345; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.resize", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_413restoredot(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_412restoredot[] = "Restore `dot`, `vdot`, and `innerproduct` to the default non-BLAS\n    implementations.\n\n    Typically, the user will only need to call this when troubleshooting and\n    installation problem, reproducing the conditions of a build without an\n    accelerated BLAS, or when being very careful about benchmarking linear\n    algebra operations.\n\n    See Also\n    --------\n    alterdot : `restoredot` undoes the effects of `alterdot`.\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_413restoredot = {__Pyx_NAMESTR("restoredot"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_413restoredot, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_412restoredot)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_413restoredot(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("restoredot (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_412restoredot(__pyx_self);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":10348
 * 
 * 
 * def restoredot():             # <<<<<<<<<<<<<<
 *     """Restore `dot`, `vdot`, and `innerproduct` to the default non-BLAS
 *     implementations.
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_412restoredot(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("restoredot", 0);

  /* "ga4py/gain/notimplemented.pyx":10363
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10363; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.restoredot", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_415result_type(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_414result_type[] = "result_type(*arrays_and_dtypes)\n\n    Returns the type that results from applying the NumPy\n    type promotion rules to the arguments.\n\n    Type promotion in NumPy works similarly to the rules in languages\n    like C++, with some slight differences.  When both scalars and\n    arrays are used, the array's type takes precedence and the actual value\n    of the scalar is taken into account.\n\n    For example, calculating 3*a, where a is an array of 32-bit floats,\n    intuitively should result in a 32-bit float output.  If the 3 is a\n    32-bit integer, the NumPy rules indicate it can't convert losslessly\n    into a 32-bit float, so a 64-bit float should be the result type.\n    By examining the value of the constant, '3', we see that it fits in\n    an 8-bit integer, which can be cast losslessly into the 32-bit float.\n\n    Parameters\n    ----------\n    arrays_and_dtypes : list of arrays and dtypes\n        The operands of some operation whose result type is needed.\n\n    Returns\n    -------\n    out : dtype\n        The result type.\n\n    See also\n    --------\n    dtype, promote_types, min_scalar_type, can_cast\n\n    Notes\n    -----\n    .. versionadded:: 1.6.0\n\n    The specific algorithm used is as follows.\n\n    Categories are determined by first checking which of boolean,\n    integer (int/uint), or floating point (float/complex) the maximum\n    kind of all the arrays and the scalars are.\n    \n    If there are only scalars or the maximum category of the scalars\n    is higher than the maximum category of the arrays,\n    the data types are combined with :func:`promote_types`\n    to produce the return value.\n\n    Otherwise, `min_scalar_type` is called on each array, and\n    the resulting data types are all combined with :func:`promote_types`\n    to produce the return value.\n\n    The set of int values is not a subset of the uint values for types\n    with the same number of bits, something not reflected in\n    :func:`min_scalar_type`"", but handled as a special case in `result_type`.\n\n    Examples\n    --------\n    >>> np.result_type(3, np.arange(7, dtype='i1'))\n    dtype('int8')\n\n    >>> np.result_type('i4', 'c8')\n    dtype('complex128')\n\n    >>> np.result_type(3.0, -2)\n    dtype('float64')\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_415result_type = {__Pyx_NAMESTR("result_type"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_415result_type, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_414result_type)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_415result_type(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_arrays_and_dtypes = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("result_type (wrapper)", 0);
  if (unlikely(__pyx_kwds) && unlikely(PyDict_Size(__pyx_kwds) > 0) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "result_type", 0))) return NULL;
  __Pyx_INCREF(__pyx_args);
  __pyx_v_arrays_and_dtypes = __pyx_args;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_414result_type(__pyx_self, __pyx_v_arrays_and_dtypes);
  __Pyx_XDECREF(__pyx_v_arrays_and_dtypes);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":10366
 * 
 * 
 * def result_type(*arrays_and_dtypes):             # <<<<<<<<<<<<<<
 *     """result_type(*arrays_and_dtypes)
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_414result_type(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_arrays_and_dtypes) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("result_type", 0);

  /* "ga4py/gain/notimplemented.pyx":10434
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10434; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.result_type", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_417roll(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_416roll[] = "Roll array elements along a given axis.\n\n    Elements that roll beyond the last position are re-introduced at\n    the first.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    shift : int\n        The number of places by which elements are shifted.\n    axis : int, optional\n        The axis along which elements are shifted.  By default, the array\n        is flattened before shifting, after which the original\n        shape is restored.\n\n    Returns\n    -------\n    res : ndarray\n        Output array, with the same shape as `a`.\n\n    See Also\n    --------\n    rollaxis : Roll the specified axis backwards, until it lies in a\n               given position.\n\n    Examples\n    --------\n    >>> x = np.arange(10)\n    >>> np.roll(x, 2)\n    array([8, 9, 0, 1, 2, 3, 4, 5, 6, 7])\n\n    >>> x2 = np.reshape(x, (2,5))\n    >>> x2\n    array([[0, 1, 2, 3, 4],\n           [5, 6, 7, 8, 9]])\n    >>> np.roll(x2, 1)\n    array([[9, 0, 1, 2, 3],\n           [4, 5, 6, 7, 8]])\n    >>> np.roll(x2, 1, axis=0)\n    array([[5, 6, 7, 8, 9],\n           [0, 1, 2, 3, 4]])\n    >>> np.roll(x2, 1, axis=1)\n    array([[4, 0, 1, 2, 3],\n           [9, 5, 6, 7, 8]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_417roll = {__Pyx_NAMESTR("roll"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_417roll, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_416roll)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_417roll(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_shift = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("roll (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__shift,&__pyx_n_s__axis,0};
    PyObject* values[3] = {0,0,0};

    /* "ga4py/gain/notimplemented.pyx":10437
 * 
 * 
 * def roll(a, shift, axis=None):             # <<<<<<<<<<<<<<
 *     """Roll array elements along a given axis.
 * 
 */
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__shift)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("roll", 0, 2, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10437; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "roll") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10437; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_shift = values[1];
    __pyx_v_axis = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("roll", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10437; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.roll", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_416roll(__pyx_self, __pyx_v_a, __pyx_v_shift, __pyx_v_axis);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_416roll(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_shift, CYTHON_UNUSED PyObject *__pyx_v_axis) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("roll", 0);

  /* "ga4py/gain/notimplemented.pyx":10485
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10485; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.roll", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_419rollaxis(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_418rollaxis[] = "Roll the specified axis backwards, until it lies in a given position.\n\n    Parameters\n    ----------\n    a : ndarray\n        Input array.\n    axis : int\n        The axis to roll backwards.  The positions of the other axes do not\n        change relative to one another.\n    start : int, optional\n        The axis is rolled until it lies before this position.  The default,\n        0, results in a \"complete\" roll.\n\n    Returns\n    -------\n    res : ndarray\n        Output array.\n\n    See Also\n    --------\n    roll : Roll the elements of an array by a number of positions along a\n        given axis.\n\n    Examples\n    --------\n    >>> a = np.ones((3,4,5,6))\n    >>> np.rollaxis(a, 3, 1).shape\n    (3, 6, 4, 5)\n    >>> np.rollaxis(a, 2).shape\n    (5, 3, 4, 6)\n    >>> np.rollaxis(a, 1, 4).shape\n    (3, 5, 6, 4)\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_419rollaxis = {__Pyx_NAMESTR("rollaxis"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_419rollaxis, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_418rollaxis)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_419rollaxis(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_start = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("rollaxis (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__axis,&__pyx_n_s__start,0};
    PyObject* values[3] = {0,0,0};
    values[2] = ((PyObject *)__pyx_int_0);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("rollaxis", 0, 2, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10488; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__start);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "rollaxis") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10488; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
    __pyx_v_start = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("rollaxis", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10488; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.rollaxis", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_418rollaxis(__pyx_self, __pyx_v_a, __pyx_v_axis, __pyx_v_start);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":10488
 * 
 * 
 * def rollaxis(a, axis, start=0):             # <<<<<<<<<<<<<<
 *     """Roll the specified axis backwards, until it lies in a given position.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_418rollaxis(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_start) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("rollaxis", 0);

  /* "ga4py/gain/notimplemented.pyx":10523
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10523; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.rollaxis", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_421roots(PyObject *__pyx_self, PyObject *__pyx_v_p); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_420roots[] = "Return the roots of a polynomial with coefficients given in p.\n\n    The values in the rank-1 array `p` are coefficients of a polynomial.\n    If the length of `p` is n+1 then the polynomial is described by::\n\n      p[0] * x**n + p[1] * x**(n-1) + ... + p[n-1]*x + p[n]\n\n    Parameters\n    ----------\n    p : array_like\n        Rank-1 array of polynomial coefficients.\n\n    Returns\n    -------\n    out : ndarray\n        An array containing the complex roots of the polynomial.\n\n    Raises\n    ------\n    ValueError :\n        When `p` cannot be converted to a rank-1 array.\n\n    See also\n    --------\n    poly : Find the coefficients of a polynomial with a given sequence\n           of roots.\n    polyval : Evaluate a polynomial at a point.\n    polyfit : Least squares polynomial fit.\n    poly1d : A one-dimensional polynomial class.\n\n    Notes\n    -----\n    The algorithm relies on computing the eigenvalues of the\n    companion matrix [1]_.\n\n    References\n    ----------\n    .. [1] R. A. Horn & C. R. Johnson, *Matrix Analysis*.  Cambridge, UK:\n        Cambridge University Press, 1999, pp. 146-7.\n\n    Examples\n    --------\n    >>> coeff = [3.2, 2, 1]\n    >>> np.roots(coeff)\n    array([-0.3125+0.46351241j, -0.3125-0.46351241j])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_421roots = {__Pyx_NAMESTR("roots"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_421roots, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_420roots)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_421roots(PyObject *__pyx_self, PyObject *__pyx_v_p) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("roots (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_420roots(__pyx_self, ((PyObject *)__pyx_v_p));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":10526
 * 
 * 
 * def roots(p):             # <<<<<<<<<<<<<<
 *     """Return the roots of a polynomial with coefficients given in p.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_420roots(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_p) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("roots", 0);

  /* "ga4py/gain/notimplemented.pyx":10574
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10574; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.roots", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_423rot90(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_422rot90[] = "Rotate an array by 90 degrees in the counter-clockwise direction.\n\n    The first two dimensions are rotated; therefore, the array must be at\n    least 2-D.\n\n    Parameters\n    ----------\n    m : array_like\n        Array of two or more dimensions.\n    k : integer\n        Number of times the array is rotated by 90 degrees.\n\n    Returns\n    -------\n    y : ndarray\n        Rotated array.\n\n    See Also\n    --------\n    fliplr : Flip an array horizontally.\n    flipud : Flip an array vertically.\n\n    Examples\n    --------\n    >>> m = np.array([[1,2],[3,4]], int)\n    >>> m\n    array([[1, 2],\n           [3, 4]])\n    >>> np.rot90(m)\n    array([[2, 4],\n           [1, 3]])\n    >>> np.rot90(m, 2)\n    array([[4, 3],\n           [2, 1]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_423rot90 = {__Pyx_NAMESTR("rot90"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_423rot90, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_422rot90)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_423rot90(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_m = 0;
  CYTHON_UNUSED PyObject *__pyx_v_k = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("rot90 (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__m,&__pyx_n_s__k,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)__pyx_int_1);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__m)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__k);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "rot90") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10577; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_m = values[0];
    __pyx_v_k = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("rot90", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10577; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.rot90", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_422rot90(__pyx_self, __pyx_v_m, __pyx_v_k);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":10577
 * 
 * 
 * def rot90(m, k=1):             # <<<<<<<<<<<<<<
 *     """Rotate an array by 90 degrees in the counter-clockwise direction.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_422rot90(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_m, CYTHON_UNUSED PyObject *__pyx_v_k) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("rot90", 0);

  /* "ga4py/gain/notimplemented.pyx":10614
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10614; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.rot90", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_425round(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_424round[] = "Round an array to the given number of decimals.\n\n    Refer to `around` for full documentation.\n\n    See Also\n    --------\n    around : equivalent function\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_425round = {__Pyx_NAMESTR("round"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_425round, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_424round)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_425round(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_decimals = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("round (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__decimals,&__pyx_n_s__out,0};
    PyObject* values[3] = {0,0,0};
    values[1] = ((PyObject *)__pyx_int_0);

    /* "ga4py/gain/notimplemented.pyx":10617
 * 
 * 
 * def round(a, decimals=0, out=None):             # <<<<<<<<<<<<<<
 *     """Round an array to the given number of decimals.
 * 
 */
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__decimals);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__out);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "round") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10617; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_decimals = values[1];
    __pyx_v_out = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("round", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10617; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.round", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_424round(__pyx_self, __pyx_v_a, __pyx_v_decimals, __pyx_v_out);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_424round(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_decimals, CYTHON_UNUSED PyObject *__pyx_v_out) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("round", 0);

  /* "ga4py/gain/notimplemented.pyx":10627
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10627; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.round", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_427round_(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_426round_[] = "Round an array to the given number of decimals.\n\n    Refer to `around` for full documentation.\n\n    See Also\n    --------\n    around : equivalent function\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_427round_ = {__Pyx_NAMESTR("round_"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_427round_, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_426round_)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_427round_(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_decimals = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("round_ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__decimals,&__pyx_n_s__out,0};
    PyObject* values[3] = {0,0,0};
    values[1] = ((PyObject *)__pyx_int_0);

    /* "ga4py/gain/notimplemented.pyx":10630
 * 
 * 
 * def round_(a, decimals=0, out=None):             # <<<<<<<<<<<<<<
 *     """Round an array to the given number of decimals.
 * 
 */
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__decimals);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__out);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "round_") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10630; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_decimals = values[1];
    __pyx_v_out = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("round_", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10630; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.round_", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_426round_(__pyx_self, __pyx_v_a, __pyx_v_decimals, __pyx_v_out);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_426round_(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_decimals, CYTHON_UNUSED PyObject *__pyx_v_out) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("round_", 0);

  /* "ga4py/gain/notimplemented.pyx":10640
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10640; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.round_", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_429row_stack(PyObject *__pyx_self, PyObject *__pyx_v_tup); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_428row_stack[] = "Stack arrays in sequence vertically (row wise).\n\n    Take a sequence of arrays and stack them vertically to make a single\n    array. Rebuild arrays divided by `vsplit`.\n\n    Parameters\n    ----------\n    tup : sequence of ndarrays\n        Tuple containing arrays to be stacked. The arrays must have the same\n        shape along all but the first axis.\n\n    Returns\n    -------\n    stacked : ndarray\n        The array formed by stacking the given arrays.\n\n    See Also\n    --------\n    hstack : Stack arrays in sequence horizontally (column wise).\n    dstack : Stack arrays in sequence depth wise (along third dimension).\n    concatenate : Join a sequence of arrays together.\n    vsplit : Split array into a list of multiple sub-arrays vertically.\n\n\n    Notes\n    -----\n    Equivalent to ``np.concatenate(tup, axis=0)``\n\n    Examples\n    --------\n    >>> a = np.array([1, 2, 3])\n    >>> b = np.array([2, 3, 4])\n    >>> np.vstack((a,b))\n    array([[1, 2, 3],\n           [2, 3, 4]])\n\n    >>> a = np.array([[1], [2], [3]])\n    >>> b = np.array([[2], [3], [4]])\n    >>> np.vstack((a,b))\n    array([[1],\n           [2],\n           [3],\n           [2],\n           [3],\n           [4]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_429row_stack = {__Pyx_NAMESTR("row_stack"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_429row_stack, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_428row_stack)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_429row_stack(PyObject *__pyx_self, PyObject *__pyx_v_tup) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("row_stack (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_428row_stack(__pyx_self, ((PyObject *)__pyx_v_tup));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":10643
 * 
 * 
 * def row_stack(tup):             # <<<<<<<<<<<<<<
 *     """Stack arrays in sequence vertically (row wise).
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_428row_stack(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_tup) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("row_stack", 0);

  /* "ga4py/gain/notimplemented.pyx":10691
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10691; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.row_stack", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_431safe_eval(PyObject *__pyx_self, PyObject *__pyx_v_source); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_430safe_eval[] = "Protected string evaluation.\n\n    Evaluate a string containing a Python literal expression without\n    allowing the execution of arbitrary non-literal code.\n\n    Parameters\n    ----------\n    source : str\n        The string to evaluate.\n\n    Returns\n    -------\n    obj : object\n       The result of evaluating `source`.\n\n    Raises\n    ------\n    SyntaxError\n        If the code has invalid Python syntax, or if it contains non-literal\n        code.\n\n    Examples\n    --------\n    >>> np.safe_eval('1')\n    1\n    >>> np.safe_eval('[1, 2, 3]')\n    [1, 2, 3]\n    >>> np.safe_eval('{\"foo\": (\"bar\", 10.0)}')\n    {'foo': ('bar', 10.0)}\n\n    >>> np.safe_eval('import os')\n    Traceback (most recent call last):\n      ...\n    SyntaxError: invalid syntax\n\n    >>> np.safe_eval('open(\"/home/user/.ssh/id_dsa\").read()')\n    Traceback (most recent call last):\n      ...\n    SyntaxError: Unsupported source construct: compiler.ast.CallFunc\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_431safe_eval = {__Pyx_NAMESTR("safe_eval"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_431safe_eval, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_430safe_eval)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_431safe_eval(PyObject *__pyx_self, PyObject *__pyx_v_source) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("safe_eval (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_430safe_eval(__pyx_self, ((PyObject *)__pyx_v_source));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":10694
 * 
 * 
 * def safe_eval(source):             # <<<<<<<<<<<<<<
 *     """Protected string evaluation.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_430safe_eval(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_source) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("safe_eval", 0);

  /* "ga4py/gain/notimplemented.pyx":10736
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10736; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.safe_eval", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_433save(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_432save[] = "Save an array to a binary file in NumPy ``.npy`` format.\n\n    Parameters\n    ----------\n    file : file or str\n        File or filename to which the data is saved.  If file is a file-object,\n        then the filename is unchanged.  If file is a string, a ``.npy``\n        extension will be appended to the file name if it does not already\n        have one.\n    arr : array_like\n        Array data to be saved.\n\n    See Also\n    --------\n    savez : Save several arrays into a ``.npz`` archive\n    savetxt, load\n\n    Notes\n    -----\n    For a description of the ``.npy`` format, see `format`.\n\n    Examples\n    --------\n    >>> from tempfile import TemporaryFile\n    >>> outfile = TemporaryFile()\n\n    >>> x = np.arange(10)\n    >>> np.save(outfile, x)\n\n    >>> outfile.seek(0) # Only needed here to simulate closing & reopening file\n    >>> np.load(outfile)\n    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_433save = {__Pyx_NAMESTR("save"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_433save, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_432save)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_433save(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_file = 0;
  CYTHON_UNUSED PyObject *__pyx_v_arr = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("save (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__file,&__pyx_n_s__arr,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__file)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__arr)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("save", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10739; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "save") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10739; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_file = values[0];
    __pyx_v_arr = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("save", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10739; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.save", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_432save(__pyx_self, __pyx_v_file, __pyx_v_arr);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":10739
 * 
 * 
 * def save(file, arr):             # <<<<<<<<<<<<<<
 *     """Save an array to a binary file in NumPy ``.npy`` format.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_432save(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_file, CYTHON_UNUSED PyObject *__pyx_v_arr) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("save", 0);

  /* "ga4py/gain/notimplemented.pyx":10774
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10774; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.save", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_435savetxt(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_434savetxt[] = "Save an array to a text file.\n\n    Parameters\n    ----------\n    fname : filename or file handle\n        If the filename ends in ``.gz``, the file is automatically saved in\n        compressed gzip format.  `loadtxt` understands gzipped files\n        transparently.\n    X : array_like\n        Data to be saved to a text file.\n    fmt : str or sequence of strs\n        A single format (%10.5f), a sequence of formats, or a\n        multi-format string, e.g. 'Iteration %d -- %10.5f', in which\n        case `delimiter` is ignored.\n    delimiter : str\n        Character separating columns.\n    newline : str\n        .. versionadded:: 1.5.0\n\n        Character separating lines.\n\n\n    See Also\n    --------\n    save : Save an array to a binary file in NumPy ``.npy`` format\n    savez : Save several arrays into a ``.npz`` compressed archive\n\n    Notes\n    -----\n    Further explanation of the `fmt` parameter\n    (``%[flag]width[.precision]specifier``):\n\n    flags:\n        ``-`` : left justify\n\n        ``+`` : Forces to preceed result with + or -.\n\n        ``0`` : Left pad the number with zeros instead of space (see width).\n\n    width:\n        Minimum number of characters to be printed. The value is not truncated\n        if it has more characters.\n\n    precision:\n        - For integer specifiers (eg. ``d,i,o,x``), the minimum number of\n          digits.\n        - For ``e, E`` and ``f`` specifiers, the number of digits to print\n          after the decimal point.\n        - For ``g`` and ``G``, the maximum number of significant digits.\n        - For ``s``, the maximum number of characters.\n\n    specifiers:\n        ``c`` : character\n\n        ``d`` or ``i`` : signed decimal integer\n\n        ``e`` or ``E`` : scientific notation with ``e`` or ``E``.\n\n        ``f`` : decimal floating point\n\n        ``g,G`` : use the shorter of ``e,E`` or ``f``\n\n        ``o`` : signed octal\n\n        ``s`` : string of characters\n\n        ``u`` : un""signed decimal integer\n\n        ``x,X`` : unsigned hexadecimal integer\n\n    This explanation of ``fmt`` is not complete, for an exhaustive\n    specification see [1]_.\n\n    References\n    ----------\n    .. [1] `Format Specification Mini-Language\n           <http://docs.python.org/library/string.html#\n           format-specification-mini-language>`_, Python Documentation.\n\n    Examples\n    --------\n    >>> x = y = z = np.arange(0.0,5.0,1.0)\n    >>> np.savetxt('test.out', x, delimiter=',')   # X is an array\n    >>> np.savetxt('test.out', (x,y,z))   # x,y,z equal sized 1D arrays\n    >>> np.savetxt('test.out', x, fmt='%1.4e')   # use exponential notation\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_435savetxt = {__Pyx_NAMESTR("savetxt"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_435savetxt, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_434savetxt)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_435savetxt(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_fname = 0;
  CYTHON_UNUSED PyObject *__pyx_v_X = 0;
  CYTHON_UNUSED PyObject *__pyx_v_fmt = 0;
  CYTHON_UNUSED PyObject *__pyx_v_delimiter = 0;
  CYTHON_UNUSED PyObject *__pyx_v_newline = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("savetxt (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__fname,&__pyx_n_s__X,&__pyx_n_s__fmt,&__pyx_n_s__delimiter,&__pyx_n_s__newline,0};
    PyObject* values[5] = {0,0,0,0,0};
    values[2] = ((PyObject *)__pyx_kp_s_42);
    values[3] = ((PyObject *)__pyx_kp_s_5);
    values[4] = ((PyObject *)__pyx_kp_s_43);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__fname)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__X)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("savetxt", 0, 2, 5, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10777; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__fmt);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__delimiter);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__newline);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "savetxt") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10777; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_fname = values[0];
    __pyx_v_X = values[1];
    __pyx_v_fmt = values[2];
    __pyx_v_delimiter = values[3];
    __pyx_v_newline = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("savetxt", 0, 2, 5, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10777; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.savetxt", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_434savetxt(__pyx_self, __pyx_v_fname, __pyx_v_X, __pyx_v_fmt, __pyx_v_delimiter, __pyx_v_newline);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":10777
 * 
 * 
 * def savetxt(fname, X, fmt='%.18e', delimiter=' ', newline='\n'):             # <<<<<<<<<<<<<<
 *     """Save an array to a text file.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_434savetxt(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_fname, CYTHON_UNUSED PyObject *__pyx_v_X, CYTHON_UNUSED PyObject *__pyx_v_fmt, CYTHON_UNUSED PyObject *__pyx_v_delimiter, CYTHON_UNUSED PyObject *__pyx_v_newline) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("savetxt", 0);

  /* "ga4py/gain/notimplemented.pyx":10865
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10865; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.savetxt", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_437savez(PyObject *__pyx_self, PyObject *__pyx_v_file); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_436savez[] = "Save several arrays into a single file in uncompressed ``.npz`` format.\n\n    If arguments are passed in with no keywords, the corresponding variable\n    names, in the .npz file, are 'arr_0', 'arr_1', etc. If keyword arguments\n    are given, the corresponding variable names, in the ``.npz`` file will\n    match the keyword names.\n\n    Parameters\n    ----------\n    file : str or file\n        Either the file name (string) or an open file (file-like object)\n        where the data will be saved. If file is a string, the ``.npz``\n        extension will be appended to the file name if it is not already there.\n    *args : Arguments, optional\n        Arrays to save to the file. Since it is not possible for Python to\n        know the names of the arrays outside `savez`, the arrays will be saved\n        with names \"arr_0\", \"arr_1\", and so on. These arguments can be any\n        expression.\n    **kwds : Keyword arguments, optional\n        Arrays to save to the file. Arrays will be saved in the file with the\n        keyword names.\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    save : Save a single array to a binary file in NumPy format.\n    savetxt : Save an array to a file as plain text.\n\n    Notes\n    -----\n    The ``.npz`` file format is a zipped archive of files named after the\n    variables they contain.  The archive is not compressed and each file\n    in the archive contains one variable in ``.npy`` format. For a\n    description of the ``.npy`` format, see `format`.\n\n    When opening the saved ``.npz`` file with `load` a `NpzFile` object is\n    returned. This is a dictionary-like object which can be queried for\n    its list of arrays (with the ``.files`` attribute), and for the arrays\n    themselves.\n\n    Examples\n    --------\n    >>> from tempfile import TemporaryFile\n    >>> outfile = TemporaryFile()\n    >>> x = np.arange(10)\n    >>> y = np.sin(x)\n\n    Using `savez` with *args, the arrays are saved wit""h default names.\n\n    >>> np.savez(outfile, x, y)\n    >>> outfile.seek(0) # Only needed here to simulate closing & reopening file\n    >>> npzfile = np.load(outfile)\n    >>> npzfile.files\n    ['arr_1', 'arr_0']\n    >>> npzfile['arr_0']\n    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n    Using `savez` with **kwds, the arrays are saved with the keyword names.\n\n    >>> outfile = TemporaryFile()\n    >>> np.savez(outfile, x=x, y=y)\n    >>> outfile.seek(0)\n    >>> npzfile = np.load(outfile)\n    >>> npzfile.files\n    ['y', 'x']\n    >>> npzfile['x']\n    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n    See Also\n    --------\n    numpy.savez_compressed : Save several arrays into a compressed .npz file format\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_437savez = {__Pyx_NAMESTR("savez"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_437savez, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_436savez)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_437savez(PyObject *__pyx_self, PyObject *__pyx_v_file) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("savez (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_436savez(__pyx_self, ((PyObject *)__pyx_v_file));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":10868
 * 
 * 
 * def savez(file):             # <<<<<<<<<<<<<<
 *     """Save several arrays into a single file in uncompressed ``.npz`` format.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_436savez(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_file) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("savez", 0);

  /* "ga4py/gain/notimplemented.pyx":10945
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10945; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.savez", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_439savez_compressed(PyObject *__pyx_self, PyObject *__pyx_v_file); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_438savez_compressed[] = "Save several arrays into a single file in compressed ``.npz`` format.\n\n    If keyword arguments are given, then filenames are taken from the keywords.\n    If arguments are passed in with no keywords, then stored file names are\n    arr_0, arr_1, etc.\n\n    Parameters\n    ----------\n    file : str\n        File name of .npz file.\n    args : Arguments\n        Function arguments.\n    kwds : Keyword arguments\n        Keywords.\n\n    See Also\n    --------\n    numpy.savez : Save several arrays into an uncompressed .npz file format\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_439savez_compressed = {__Pyx_NAMESTR("savez_compressed"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_439savez_compressed, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_438savez_compressed)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_439savez_compressed(PyObject *__pyx_self, PyObject *__pyx_v_file) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("savez_compressed (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_438savez_compressed(__pyx_self, ((PyObject *)__pyx_v_file));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":10948
 * 
 * 
 * def savez_compressed(file):             # <<<<<<<<<<<<<<
 *     """Save several arrays into a single file in compressed ``.npz`` format.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_438savez_compressed(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_file) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("savez_compressed", 0);

  /* "ga4py/gain/notimplemented.pyx":10969
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10969; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.savez_compressed", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_441sctype2char(PyObject *__pyx_self, PyObject *__pyx_v_sctype); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_440sctype2char[] = "Return the string representation of a scalar dtype.\n\n    Parameters\n    ----------\n    sctype : scalar dtype or object\n        If a scalar dtype, the corresponding string character is\n        returned. If an object, `sctype2char` tries to infer its scalar type\n        and then return the corresponding string character.\n\n    Returns\n    -------\n    typechar : str\n        The string character corresponding to the scalar type.\n\n    Raises\n    ------\n    ValueError\n        If `sctype` is an object for which the type can not be inferred.\n\n    See Also\n    --------\n    obj2sctype, issctype, issubsctype, mintypecode\n\n    Examples\n    --------\n    >>> for sctype in [np.int32, np.float, np.complex, np.string_, np.ndarray]:\n    ...     print np.sctype2char(sctype)\n    l\n    d\n    D\n    S\n    O\n\n    >>> x = np.array([1., 2-1.j])\n    >>> np.sctype2char(x)\n    'D'\n    >>> np.sctype2char(list)\n    'O'\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_441sctype2char = {__Pyx_NAMESTR("sctype2char"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_441sctype2char, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_440sctype2char)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_441sctype2char(PyObject *__pyx_self, PyObject *__pyx_v_sctype) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("sctype2char (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_440sctype2char(__pyx_self, ((PyObject *)__pyx_v_sctype));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":10972
 * 
 * 
 * def sctype2char(sctype):             # <<<<<<<<<<<<<<
 *     """Return the string representation of a scalar dtype.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_440sctype2char(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_sctype) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("sctype2char", 0);

  /* "ga4py/gain/notimplemented.pyx":11013
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11013; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.sctype2char", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_443searchsorted(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_442searchsorted[] = "Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `a` such that, if the corresponding\n    elements in `v` were inserted before the indices, the order of `a` would\n    be preserved.\n\n    Parameters\n    ----------\n    a : 1-D array_like\n        Input array, sorted in ascending order.\n    v : array_like\n        Values to insert into `a`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.  If\n        'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `a`).\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `v`.\n\n    See Also\n    --------\n    sort : Return a sorted copy of an array.\n    histogram : Produce histogram from 1-D data.\n\n    Notes\n    -----\n    Binary search is used to find the required insertion points.\n\n    As of Numpy 1.4.0 `searchsorted` works with real/complex arrays containing\n    `nan` values. The enhanced sort order is documented in `sort`.\n\n    Examples\n    --------\n    >>> np.searchsorted([1,2,3,4,5], 3)\n    2\n    >>> np.searchsorted([1,2,3,4,5], 3, side='right')\n    3\n    >>> np.searchsorted([1,2,3,4,5], [-10, 10, 2, 3])\n    array([0, 5, 1, 2])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_443searchsorted = {__Pyx_NAMESTR("searchsorted"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_443searchsorted, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_442searchsorted)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_443searchsorted(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_v = 0;
  CYTHON_UNUSED PyObject *__pyx_v_side = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("searchsorted (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__v,&__pyx_n_s__side,0};
    PyObject* values[3] = {0,0,0};
    values[2] = ((PyObject *)__pyx_n_s__left);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__v)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("searchsorted", 0, 2, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11016; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__side);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "searchsorted") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11016; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_v = values[1];
    __pyx_v_side = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("searchsorted", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11016; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.searchsorted", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_442searchsorted(__pyx_self, __pyx_v_a, __pyx_v_v, __pyx_v_side);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":11016
 * 
 * 
 * def searchsorted(a, v, side='left'):             # <<<<<<<<<<<<<<
 *     """Find indices where elements should be inserted to maintain order.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_442searchsorted(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_v, CYTHON_UNUSED PyObject *__pyx_v_side) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("searchsorted", 0);

  /* "ga4py/gain/notimplemented.pyx":11061
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11061; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.searchsorted", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_445select(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_444select[] = "Return an array drawn from elements in choicelist, depending on conditions.\n\n    Parameters\n    ----------\n    condlist : list of bool ndarrays\n        The list of conditions which determine from which array in `choicelist`\n        the output elements are taken. When multiple conditions are satisfied,\n        the first one encountered in `condlist` is used.\n    choicelist : list of ndarrays\n        The list of arrays from which the output elements are taken. It has\n        to be of the same length as `condlist`.\n    default : scalar, optional\n        The element inserted in `output` when all conditions evaluate to False.\n\n    Returns\n    -------\n    output : ndarray\n        The output at position m is the m-th element of the array in\n        `choicelist` where the m-th element of the corresponding array in\n        `condlist` is True.\n\n    See Also\n    --------\n    where : Return elements from one of two arrays depending on condition.\n    take, choose, compress, diag, diagonal\n\n    Examples\n    --------\n    >>> x = np.arange(10)\n    >>> condlist = [x<3, x>5]\n    >>> choicelist = [x, x**2]\n    >>> np.select(condlist, choicelist)\n    array([ 0,  1,  2,  0,  0,  0, 36, 49, 64, 81])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_445select = {__Pyx_NAMESTR("select"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_445select, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_444select)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_445select(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_condlist = 0;
  CYTHON_UNUSED PyObject *__pyx_v_choicelist = 0;
  CYTHON_UNUSED PyObject *__pyx_v_default = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("select (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__condlist,&__pyx_n_s__choicelist,&__pyx_n_s__default,0};
    PyObject* values[3] = {0,0,0};
    values[2] = ((PyObject *)__pyx_int_0);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__condlist)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__choicelist)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("select", 0, 2, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11064; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__default);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "select") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11064; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_condlist = values[0];
    __pyx_v_choicelist = values[1];
    __pyx_v_default = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("select", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11064; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.select", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_444select(__pyx_self, __pyx_v_condlist, __pyx_v_choicelist, __pyx_v_default);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":11064
 * 
 * 
 * def select(condlist, choicelist, default=0):             # <<<<<<<<<<<<<<
 *     """Return an array drawn from elements in choicelist, depending on conditions.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_444select(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_condlist, CYTHON_UNUSED PyObject *__pyx_v_choicelist, CYTHON_UNUSED PyObject *__pyx_v_default) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("select", 0);

  /* "ga4py/gain/notimplemented.pyx":11100
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11100; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.select", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_447set_numeric_ops(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_446set_numeric_ops[] = "set_numeric_ops(op1=func1, op2=func2, ...)\n\n    Set numerical operators for array objects.\n\n    Parameters\n    ----------\n    op1, op2, ... : callable\n        Each ``op = func`` pair describes an operator to be replaced.\n        For example, ``add = lambda x, y: np.add(x, y) % 5`` would replace\n        addition by modulus 5 addition.\n\n    Returns\n    -------\n    saved_ops : list of callables\n        A list of all operators, stored before making replacements.\n\n    Notes\n    -----\n    .. WARNING::\n       Use with care!  Incorrect usage may lead to memory errors.\n\n    A function replacing an operator cannot make use of that operator.\n    For example, when replacing add, you may not use ``+``.  Instead,\n    directly call ufuncs.\n\n    Examples\n    --------\n    >>> def add_mod5(x, y):\n    ...     return np.add(x, y) % 5\n    ...\n    >>> old_funcs = np.set_numeric_ops(add=add_mod5)\n\n    >>> x = np.arange(12).reshape((3, 4))\n    >>> x + x\n    array([[0, 2, 4, 1],\n           [3, 0, 2, 4],\n           [1, 3, 0, 2]])\n\n    >>> ignore = np.set_numeric_ops(**old_funcs) # restore operators\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_447set_numeric_ops = {__Pyx_NAMESTR("set_numeric_ops"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_447set_numeric_ops, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_446set_numeric_ops)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_447set_numeric_ops(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("set_numeric_ops (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_446set_numeric_ops(__pyx_self);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":11103
 * 
 * 
 * def set_numeric_ops():             # <<<<<<<<<<<<<<
 *     """set_numeric_ops(op1=func1, op2=func2, ...)
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_446set_numeric_ops(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("set_numeric_ops", 0);

  /* "ga4py/gain/notimplemented.pyx":11146
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11146; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.set_numeric_ops", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_449set_printoptions(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_448set_printoptions[] = "Set printing options.\n\n    These options determine the way floating point numbers, arrays and\n    other NumPy objects are displayed.\n\n    Parameters\n    ----------\n    precision : int, optional\n        Number of digits of precision for floating point output (default 8).\n    threshold : int, optional\n        Total number of array elements which trigger summarization\n        rather than full repr (default 1000).\n    edgeitems : int, optional\n        Number of array items in summary at beginning and end of\n        each dimension (default 3).\n    linewidth : int, optional\n        The number of characters per line for the purpose of inserting\n        line breaks (default 75).\n    suppress : bool, optional\n        Whether or not suppress printing of small floating point values\n        using scientific notation (default False).\n    nanstr : str, optional\n        String representation of floating point not-a-number (default nan).\n    infstr : str, optional\n        String representation of floating point infinity (default inf).\n\n    See Also\n    --------\n    get_printoptions, set_string_function\n\n    Examples\n    --------\n    Floating point precision can be set:\n\n    >>> np.set_printoptions(precision=4)\n    >>> print np.array([1.123456789])\n    [ 1.1235]\n\n    Long arrays can be summarised:\n\n    >>> np.set_printoptions(threshold=5)\n    >>> print np.arange(10)\n    [0 1 2 ..., 7 8 9]\n\n    Small results can be suppressed:\n\n    >>> eps = np.finfo(float).eps\n    >>> x = np.arange(4.)\n    >>> x**2 - (x + eps)**2\n    array([ -4.9304e-32,  -4.4409e-16,   0.0000e+00,   0.0000e+00])\n    >>> np.set_printoptions(suppress=True)\n    >>> x**2 - (x + eps)**2\n    array([-0., -0.,  0.,  0.])\n\n    To put back the default options, you can use:\n\n    >>> np.set_printoptions(edgeitems=3,infstr='Inf',\n    ... linewidth=75, nanstr='NaN', precision=8,\n    ... suppress=False, threshold=1000)\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_449set_printoptions = {__Pyx_NAMESTR("set_printoptions"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_449set_printoptions, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_448set_printoptions)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_449set_printoptions(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_precision = 0;
  CYTHON_UNUSED PyObject *__pyx_v_threshold = 0;
  CYTHON_UNUSED PyObject *__pyx_v_edgeitems = 0;
  CYTHON_UNUSED PyObject *__pyx_v_linewidth = 0;
  CYTHON_UNUSED PyObject *__pyx_v_suppress = 0;
  CYTHON_UNUSED PyObject *__pyx_v_nanstr = 0;
  CYTHON_UNUSED PyObject *__pyx_v_infstr = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("set_printoptions (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__precision,&__pyx_n_s__threshold,&__pyx_n_s__edgeitems,&__pyx_n_s__linewidth,&__pyx_n_s__suppress,&__pyx_n_s__nanstr,&__pyx_n_s__infstr,0};
    PyObject* values[7] = {0,0,0,0,0,0,0};

    /* "ga4py/gain/notimplemented.pyx":11149
 * 
 * 
 * def set_printoptions(precision=None, threshold=None, edgeitems=None, linewidth=None, suppress=None, nanstr=None, infstr=None):             # <<<<<<<<<<<<<<
 *     """Set printing options.
 * 
 */
    values[0] = ((PyObject *)Py_None);
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    values[3] = ((PyObject *)Py_None);
    values[4] = ((PyObject *)Py_None);
    values[5] = ((PyObject *)Py_None);
    values[6] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__precision);
          if (value) { values[0] = value; kw_args--; }
        }
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__threshold);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__edgeitems);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__linewidth);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__suppress);
          if (value) { values[4] = value; kw_args--; }
        }
        case  5:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__nanstr);
          if (value) { values[5] = value; kw_args--; }
        }
        case  6:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__infstr);
          if (value) { values[6] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "set_printoptions") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11149; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_precision = values[0];
    __pyx_v_threshold = values[1];
    __pyx_v_edgeitems = values[2];
    __pyx_v_linewidth = values[3];
    __pyx_v_suppress = values[4];
    __pyx_v_nanstr = values[5];
    __pyx_v_infstr = values[6];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("set_printoptions", 0, 0, 7, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11149; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.set_printoptions", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_448set_printoptions(__pyx_self, __pyx_v_precision, __pyx_v_threshold, __pyx_v_edgeitems, __pyx_v_linewidth, __pyx_v_suppress, __pyx_v_nanstr, __pyx_v_infstr);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_448set_printoptions(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_precision, CYTHON_UNUSED PyObject *__pyx_v_threshold, CYTHON_UNUSED PyObject *__pyx_v_edgeitems, CYTHON_UNUSED PyObject *__pyx_v_linewidth, CYTHON_UNUSED PyObject *__pyx_v_suppress, CYTHON_UNUSED PyObject *__pyx_v_nanstr, CYTHON_UNUSED PyObject *__pyx_v_infstr) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("set_printoptions", 0);

  /* "ga4py/gain/notimplemented.pyx":11211
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11211; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.set_printoptions", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_451set_string_function(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_450set_string_function[] = "Set a Python function to be used when pretty printing arrays.\n\n    Parameters\n    ----------\n    f : function or None\n        Function to be used to pretty print arrays. The function should expect\n        a single array argument and return a string of the representation of\n        the array. If None, the function is reset to the default NumPy function\n        to print arrays.\n    repr : bool, optional\n        If True (default), the function for pretty printing (``__repr__``)\n        is set, if False the function that returns the default string\n        representation (``__str__``) is set.\n\n    See Also\n    --------\n    set_printoptions, get_printoptions\n\n    Examples\n    --------\n    >>> def pprint(arr):\n    ...     return 'HA! - What are you going to do now?'\n    ...\n    >>> np.set_string_function(pprint)\n    >>> a = np.arange(10)\n    >>> a\n    HA! - What are you going to do now?\n    >>> print a\n    [0 1 2 3 4 5 6 7 8 9]\n\n    We can reset the function to the default:\n\n    >>> np.set_string_function(None)\n    >>> a\n    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n    `repr` affects either pretty printing or normal string representation.\n    Note that ``__repr__`` is still affected by setting ``__str__``\n    because the width of each array element in the returned string becomes\n    equal to the length of the result of ``__str__()``.\n\n    >>> x = np.arange(4)\n    >>> np.set_string_function(lambda x:'random', repr=False)\n    >>> x.__str__()\n    'random'\n    >>> x.__repr__()\n    'array([     0,      1,      2,      3])'\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_451set_string_function = {__Pyx_NAMESTR("set_string_function"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_451set_string_function, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_450set_string_function)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_451set_string_function(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_f = 0;
  CYTHON_UNUSED PyObject *__pyx_v_repr = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("set_string_function (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__f,&__pyx_n_s__repr,0};
    PyObject* values[2] = {0,0};
    values[1] = __pyx_k_44;
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__f)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__repr);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "set_string_function") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11214; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_f = values[0];
    __pyx_v_repr = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("set_string_function", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11214; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.set_string_function", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_450set_string_function(__pyx_self, __pyx_v_f, __pyx_v_repr);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":11214
 * 
 * 
 * def set_string_function(f, repr=True):             # <<<<<<<<<<<<<<
 *     """Set a Python function to be used when pretty printing arrays.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_450set_string_function(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_f, CYTHON_UNUSED PyObject *__pyx_v_repr) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("set_string_function", 0);

  /* "ga4py/gain/notimplemented.pyx":11264
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11264; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.set_string_function", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_453setbufsize(PyObject *__pyx_self, PyObject *__pyx_v_size); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_452setbufsize[] = "Set the size of the buffer used in ufuncs.\n\n    Parameters\n    ----------\n    size : int\n        Size of buffer.\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_453setbufsize = {__Pyx_NAMESTR("setbufsize"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_453setbufsize, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_452setbufsize)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_453setbufsize(PyObject *__pyx_self, PyObject *__pyx_v_size) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("setbufsize (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_452setbufsize(__pyx_self, ((PyObject *)__pyx_v_size));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":11267
 * 
 * 
 * def setbufsize(size):             # <<<<<<<<<<<<<<
 *     """Set the size of the buffer used in ufuncs.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_452setbufsize(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_size) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("setbufsize", 0);

  /* "ga4py/gain/notimplemented.pyx":11276
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11276; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.setbufsize", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_455setdiff1d(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_454setdiff1d[] = "Find the set difference of two arrays.\n\n    Return the sorted, unique values in `ar1` that are not in `ar2`.\n\n    Parameters\n    ----------\n    ar1 : array_like\n        Input array.\n    ar2 : array_like\n        Input comparison array.\n    assume_unique : bool\n        If True, the input arrays are both assumed to be unique, which\n        can speed up the calculation.  Default is False.\n\n    Returns\n    -------\n    difference : ndarray\n        Sorted 1D array of values in `ar1` that are not in `ar2`.\n\n    See Also\n    --------\n    numpy.lib.arraysetops : Module with a number of other functions for\n                            performing set operations on arrays.\n\n    Examples\n    --------\n    >>> a = np.array([1, 2, 3, 2, 4, 1])\n    >>> b = np.array([3, 4, 5, 6])\n    >>> np.setdiff1d(a, b)\n    array([1, 2])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_455setdiff1d = {__Pyx_NAMESTR("setdiff1d"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_455setdiff1d, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_454setdiff1d)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_455setdiff1d(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_ar1 = 0;
  CYTHON_UNUSED PyObject *__pyx_v_ar2 = 0;
  CYTHON_UNUSED PyObject *__pyx_v_assume_unique = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("setdiff1d (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__ar1,&__pyx_n_s__ar2,&__pyx_n_s__assume_unique,0};
    PyObject* values[3] = {0,0,0};
    values[2] = __pyx_k_45;
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__ar1)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__ar2)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("setdiff1d", 0, 2, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11279; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__assume_unique);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "setdiff1d") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11279; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_ar1 = values[0];
    __pyx_v_ar2 = values[1];
    __pyx_v_assume_unique = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("setdiff1d", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11279; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.setdiff1d", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_454setdiff1d(__pyx_self, __pyx_v_ar1, __pyx_v_ar2, __pyx_v_assume_unique);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":11279
 * 
 * 
 * def setdiff1d(ar1, ar2, assume_unique=False):             # <<<<<<<<<<<<<<
 *     """Find the set difference of two arrays.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_454setdiff1d(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_ar1, CYTHON_UNUSED PyObject *__pyx_v_ar2, CYTHON_UNUSED PyObject *__pyx_v_assume_unique) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("setdiff1d", 0);

  /* "ga4py/gain/notimplemented.pyx":11312
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11312; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.setdiff1d", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_457seterr(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_456seterr[] = "Set how floating-point errors are handled.\n\n    Note that operations on integer scalar types (such as `int16`) are\n    handled like floating point, and are affected by these settings.\n\n    Parameters\n    ----------\n    all : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional\n        Set treatment for all types of floating-point errors at once:\n\n        - ignore: Take no action when the exception occurs.\n        - warn: Print a `RuntimeWarning` (via the Python `warnings` module).\n        - raise: Raise a `FloatingPointError`.\n        - call: Call a function specified using the `seterrcall` function.\n        - print: Print a warning directly to ``stdout``.\n        - log: Record error in a Log object specified by `seterrcall`.\n\n        The default is not to change the current behavior.\n    divide : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional\n        Treatment for division by zero.\n    over : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional\n        Treatment for floating-point overflow.\n    under : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional\n        Treatment for floating-point underflow.\n    invalid : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional\n        Treatment for invalid floating-point operation.\n\n    Returns\n    -------\n    old_settings : dict\n        Dictionary containing the old settings.\n\n    See also\n    --------\n    seterrcall : Set a callback function for the 'call' mode.\n    geterr, geterrcall\n\n    Notes\n    -----\n    The floating-point exceptions are defined in the IEEE 754 standard [1]:\n\n    - Division by zero: infinite result obtained from finite numbers.\n    - Overflow: result too large to be expressed.\n    - Underflow: result so close to zero that some precision\n      was lost.\n    - Invalid operation: result is not an expressible number, typically\n      indicates that a NaN was produced.\n\n    .. [1] http://en.wikipedia.org/wiki/""IEEE_754\n\n    Examples\n    --------\n    >>> old_settings = np.seterr(all='ignore')  #seterr to known value\n    >>> np.seterr(over='raise')\n    {'over': 'ignore', 'divide': 'ignore', 'invalid': 'ignore',\n     'under': 'ignore'}\n    >>> np.seterr(all='ignore')  # reset to default\n    {'over': 'raise', 'divide': 'ignore', 'invalid': 'ignore', 'under': 'ignore'}\n\n    >>> np.int16(32000) * np.int16(3)\n    30464\n    >>> old_settings = np.seterr(all='warn', over='raise')\n    >>> np.int16(32000) * np.int16(3)\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    FloatingPointError: overflow encountered in short_scalars\n\n    >>> old_settings = np.seterr(all='print')\n    >>> np.geterr()\n    {'over': 'print', 'divide': 'print', 'invalid': 'print', 'under': 'print'}\n    >>> np.int16(32000) * np.int16(3)\n    Warning: overflow encountered in short_scalars\n    30464\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_457seterr = {__Pyx_NAMESTR("seterr"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_457seterr, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_456seterr)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_457seterr(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_all = 0;
  CYTHON_UNUSED PyObject *__pyx_v_divide = 0;
  CYTHON_UNUSED PyObject *__pyx_v_over = 0;
  CYTHON_UNUSED PyObject *__pyx_v_under = 0;
  CYTHON_UNUSED PyObject *__pyx_v_invalid = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("seterr (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__all,&__pyx_n_s__divide,&__pyx_n_s__over,&__pyx_n_s__under,&__pyx_n_s__invalid,0};
    PyObject* values[5] = {0,0,0,0,0};

    /* "ga4py/gain/notimplemented.pyx":11315
 * 
 * 
 * def seterr(all=None, divide=None, over=None, under=None, invalid=None):             # <<<<<<<<<<<<<<
 *     """Set how floating-point errors are handled.
 * 
 */
    values[0] = ((PyObject *)Py_None);
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    values[3] = ((PyObject *)Py_None);
    values[4] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__all);
          if (value) { values[0] = value; kw_args--; }
        }
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__divide);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__over);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__under);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__invalid);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "seterr") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11315; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_all = values[0];
    __pyx_v_divide = values[1];
    __pyx_v_over = values[2];
    __pyx_v_under = values[3];
    __pyx_v_invalid = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("seterr", 0, 0, 5, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11315; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.seterr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_456seterr(__pyx_self, __pyx_v_all, __pyx_v_divide, __pyx_v_over, __pyx_v_under, __pyx_v_invalid);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_456seterr(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_all, CYTHON_UNUSED PyObject *__pyx_v_divide, CYTHON_UNUSED PyObject *__pyx_v_over, CYTHON_UNUSED PyObject *__pyx_v_under, CYTHON_UNUSED PyObject *__pyx_v_invalid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("seterr", 0);

  /* "ga4py/gain/notimplemented.pyx":11391
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11391; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.seterr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_459seterrcall(PyObject *__pyx_self, PyObject *__pyx_v_func); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_458seterrcall[] = "Set the floating-point error callback function or log object.\n\n    There are two ways to capture floating-point error messages.  The first\n    is to set the error-handler to 'call', using `seterr`.  Then, set\n    the function to call using this function.\n\n    The second is to set the error-handler to 'log', using `seterr`.\n    Floating-point errors then trigger a call to the 'write' method of\n    the provided object.\n\n    Parameters\n    ----------\n    func : callable f(err, flag) or object with write method\n        Function to call upon floating-point errors ('call'-mode) or\n        object whose 'write' method is used to log such message ('log'-mode).\n\n        The call function takes two arguments. The first is the\n        type of error (one of \"divide\", \"over\", \"under\", or \"invalid\"),\n        and the second is the status flag.  The flag is a byte, whose\n        least-significant bits indicate the status::\n\n          [0 0 0 0 invalid over under invalid]\n\n        In other words, ``flags = divide + 2*over + 4*under + 8*invalid``.\n\n        If an object is provided, its write method should take one argument,\n        a string.\n\n    Returns\n    -------\n    h : callable, log instance or None\n        The old error handler.\n\n    See Also\n    --------\n    seterr, geterr, geterrcall\n\n    Examples\n    --------\n    Callback upon error:\n\n    >>> def err_handler(type, flag):\n    ...     print \"Floating point error (%s), with flag %s\" % (type, flag)\n    ...\n\n    >>> saved_handler = np.seterrcall(err_handler)\n    >>> save_err = np.seterr(all='call')\n\n    >>> np.array([1, 2, 3]) / 0.0\n    Floating point error (divide by zero), with flag 1\n    array([ Inf,  Inf,  Inf])\n\n    >>> np.seterrcall(saved_handler)\n    <function err_handler at 0x...>\n    >>> np.seterr(**save_err)\n    {'over': 'call', 'divide': 'call', 'invalid': 'call', 'under': 'call'}\n\n    Log error message:\n\n    >>> class Log(object):\n    ...     def writ""e(self, msg):\n    ...         print \"LOG: %s\" % msg\n    ...\n\n    >>> log = Log()\n    >>> saved_handler = np.seterrcall(log)\n    >>> save_err = np.seterr(all='log')\n\n    >>> np.array([1, 2, 3]) / 0.0\n    LOG: Warning: divide by zero encountered in divide\n    <BLANKLINE>\n    array([ Inf,  Inf,  Inf])\n\n    >>> np.seterrcall(saved_handler)\n    <__main__.Log object at 0x...>\n    >>> np.seterr(**save_err)\n    {'over': 'log', 'divide': 'log', 'invalid': 'log', 'under': 'log'}\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_459seterrcall = {__Pyx_NAMESTR("seterrcall"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_459seterrcall, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_458seterrcall)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_459seterrcall(PyObject *__pyx_self, PyObject *__pyx_v_func) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("seterrcall (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_458seterrcall(__pyx_self, ((PyObject *)__pyx_v_func));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":11394
 * 
 * 
 * def seterrcall(func):             # <<<<<<<<<<<<<<
 *     """Set the floating-point error callback function or log object.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_458seterrcall(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_func) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("seterrcall", 0);

  /* "ga4py/gain/notimplemented.pyx":11474
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11474; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.seterrcall", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_461seterrobj(PyObject *__pyx_self, PyObject *__pyx_v_errobj); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_460seterrobj[] = "seterrobj(errobj)\n\n    Set the object that defines floating-point error handling.\n\n    The error object contains all information that defines the error handling\n    behavior in Numpy. `seterrobj` is used internally by the other\n    functions that set error handling behavior (`seterr`, `seterrcall`).\n\n    Parameters\n    ----------\n    errobj : list\n        The error object, a list containing three elements:\n        [internal numpy buffer size, error mask, error callback function].\n\n        The error mask is a single integer that holds the treatment information\n        on all four floating point errors. The information for each error type\n        is contained in three bits of the integer. If we print it in base 8, we\n        can see what treatment is set for \"invalid\", \"under\", \"over\", and\n        \"divide\" (in that order). The printed string can be interpreted with\n\n        * 0 : 'ignore'\n        * 1 : 'warn'\n        * 2 : 'raise'\n        * 3 : 'call'\n        * 4 : 'print'\n        * 5 : 'log'\n\n    See Also\n    --------\n    geterrobj, seterr, geterr, seterrcall, geterrcall\n    getbufsize, setbufsize\n\n    Notes\n    -----\n    For complete documentation of the types of floating-point exceptions and\n    treatment options, see `seterr`.\n\n    Examples\n    --------\n    >>> old_errobj = np.geterrobj()  # first get the defaults\n    >>> old_errobj\n    [10000, 0, None]\n\n    >>> def err_handler(type, flag):\n    ...     print \"Floating point error (%s), with flag %s\" % (type, flag)\n    ...\n    >>> new_errobj = [20000, 12, err_handler]\n    >>> np.seterrobj(new_errobj)\n    >>> np.base_repr(12, 8)  # int for divide=4 ('print') and over=1 ('warn')\n    '14'\n    >>> np.geterr()\n    {'over': 'warn', 'divide': 'print', 'invalid': 'ignore', 'under': 'ignore'}\n    >>> np.geterrcall() is err_handler\n    True\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_461seterrobj = {__Pyx_NAMESTR("seterrobj"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_461seterrobj, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_460seterrobj)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_461seterrobj(PyObject *__pyx_self, PyObject *__pyx_v_errobj) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("seterrobj (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_460seterrobj(__pyx_self, ((PyObject *)__pyx_v_errobj));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":11477
 * 
 * 
 * def seterrobj(errobj):             # <<<<<<<<<<<<<<
 *     """seterrobj(errobj)
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_460seterrobj(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_errobj) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("seterrobj", 0);

  /* "ga4py/gain/notimplemented.pyx":11535
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11535; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.seterrobj", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_463setxor1d(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_462setxor1d[] = "Find the set exclusive-or of two arrays.\n\n    Return the sorted, unique values that are in only one (not both) of the\n    input arrays.\n\n    Parameters\n    ----------\n    ar1, ar2 : array_like\n        Input arrays.\n    assume_unique : bool\n        If True, the input arrays are both assumed to be unique, which\n        can speed up the calculation.  Default is False.\n\n    Returns\n    -------\n    xor : ndarray\n        Sorted 1D array of unique values that are in only one of the input\n        arrays.\n\n    Examples\n    --------\n    >>> a = np.array([1, 2, 3, 2, 4])\n    >>> b = np.array([2, 3, 5, 7, 5])\n    >>> np.setxor1d(a,b)\n    array([1, 4, 5, 7])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_463setxor1d = {__Pyx_NAMESTR("setxor1d"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_463setxor1d, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_462setxor1d)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_463setxor1d(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_ar1 = 0;
  CYTHON_UNUSED PyObject *__pyx_v_ar2 = 0;
  CYTHON_UNUSED PyObject *__pyx_v_assume_unique = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("setxor1d (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__ar1,&__pyx_n_s__ar2,&__pyx_n_s__assume_unique,0};
    PyObject* values[3] = {0,0,0};
    values[2] = __pyx_k_46;
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__ar1)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__ar2)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("setxor1d", 0, 2, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11538; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__assume_unique);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "setxor1d") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11538; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_ar1 = values[0];
    __pyx_v_ar2 = values[1];
    __pyx_v_assume_unique = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("setxor1d", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11538; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.setxor1d", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_462setxor1d(__pyx_self, __pyx_v_ar1, __pyx_v_ar2, __pyx_v_assume_unique);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":11538
 * 
 * 
 * def setxor1d(ar1, ar2, assume_unique=False):             # <<<<<<<<<<<<<<
 *     """Find the set exclusive-or of two arrays.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_462setxor1d(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_ar1, CYTHON_UNUSED PyObject *__pyx_v_ar2, CYTHON_UNUSED PyObject *__pyx_v_assume_unique) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("setxor1d", 0);

  /* "ga4py/gain/notimplemented.pyx":11566
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11566; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.setxor1d", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_465show_config(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_464show_config[] = "\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_465show_config = {__Pyx_NAMESTR("show_config"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_465show_config, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_464show_config)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_465show_config(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("show_config (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_464show_config(__pyx_self);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":11569
 * 
 * 
 * def show_config():             # <<<<<<<<<<<<<<
 *     """
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_464show_config(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("show_config", 0);

  /* "ga4py/gain/notimplemented.pyx":11573
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11573; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.show_config", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_467sinc(PyObject *__pyx_self, PyObject *__pyx_v_x); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_466sinc[] = "Return the sinc function.\n\n    The sinc function is :math:`\\sin(\\pi x)/(\\pi x)`.\n\n    Parameters\n    ----------\n    x : ndarray\n        Array (possibly multi-dimensional) of values for which to to\n        calculate ``sinc(x)``.\n\n    Returns\n    -------\n    out : ndarray\n        ``sinc(x)``, which has the same shape as the input.\n\n    Notes\n    -----\n    ``sinc(0)`` is the limit value 1.\n\n    The name sinc is short for \"sine cardinal\" or \"sinus cardinalis\".\n\n    The sinc function is used in various signal processing applications,\n    including in anti-aliasing, in the construction of a\n    Lanczos resampling filter, and in interpolation.\n\n    For bandlimited interpolation of discrete-time signals, the ideal\n    interpolation kernel is proportional to the sinc function.\n\n    References\n    ----------\n    .. [1] Weisstein, Eric W. \"Sinc Function.\" From MathWorld--A Wolfram Web\n           Resource. http://mathworld.wolfram.com/SincFunction.html\n    .. [2] Wikipedia, \"Sinc function\",\n           http://en.wikipedia.org/wiki/Sinc_function\n\n    Examples\n    --------\n    >>> x = np.arange(-20., 21.)/5.\n    >>> np.sinc(x)\n    array([ -3.89804309e-17,  -4.92362781e-02,  -8.40918587e-02,\n            -8.90384387e-02,  -5.84680802e-02,   3.89804309e-17,\n             6.68206631e-02,   1.16434881e-01,   1.26137788e-01,\n             8.50444803e-02,  -3.89804309e-17,  -1.03943254e-01,\n            -1.89206682e-01,  -2.16236208e-01,  -1.55914881e-01,\n             3.89804309e-17,   2.33872321e-01,   5.04551152e-01,\n             7.56826729e-01,   9.35489284e-01,   1.00000000e+00,\n             9.35489284e-01,   7.56826729e-01,   5.04551152e-01,\n             2.33872321e-01,   3.89804309e-17,  -1.55914881e-01,\n            -2.16236208e-01,  -1.89206682e-01,  -1.03943254e-01,\n            -3.89804309e-17,   8.50444803e-02,   1.26137788e-01,\n             1.16434881e-01,   6.68206631e-02,   3.89804309e-17,\n            -5.84680802e-02,""  -8.90384387e-02,  -8.40918587e-02,\n            -4.92362781e-02,  -3.89804309e-17])\n\n    >>> import matplotlib.pyplot as plt\n    >>> plt.plot(x, np.sinc(x))\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Sinc Function\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.ylabel(\"Amplitude\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.xlabel(\"X\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.show()\n\n    It works in 2-D as well:\n\n    >>> x = np.arange(-200., 201.)/50.\n    >>> xx = np.outer(x, x)\n    >>> plt.imshow(np.sinc(xx))\n    <matplotlib.image.AxesImage object at 0x...>\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_467sinc = {__Pyx_NAMESTR("sinc"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_467sinc, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_466sinc)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_467sinc(PyObject *__pyx_self, PyObject *__pyx_v_x) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("sinc (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_466sinc(__pyx_self, ((PyObject *)__pyx_v_x));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":11576
 * 
 * 
 * def sinc(x):             # <<<<<<<<<<<<<<
 *     """Return the sinc function.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_466sinc(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("sinc", 0);

  /* "ga4py/gain/notimplemented.pyx":11650
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11650; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.sinc", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_469size(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_468size[] = "Return the number of elements along a given axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    axis : int, optional\n        Axis along which the elements are counted.  By default, give\n        the total number of elements.\n\n    Returns\n    -------\n    element_count : int\n        Number of elements along the specified axis.\n\n    See Also\n    --------\n    shape : dimensions of array\n    ndarray.shape : dimensions of array\n    ndarray.size : number of elements in array\n\n    Examples\n    --------\n    >>> a = np.array([[1,2,3],[4,5,6]])\n    >>> np.size(a)\n    6\n    >>> np.size(a,1)\n    3\n    >>> np.size(a,0)\n    2\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_469size = {__Pyx_NAMESTR("size"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_469size, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_468size)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_469size(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("size (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__axis,0};
    PyObject* values[2] = {0,0};

    /* "ga4py/gain/notimplemented.pyx":11653
 * 
 * 
 * def size(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Return the number of elements along a given axis.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "size") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11653; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("size", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11653; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.size", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_468size(__pyx_self, __pyx_v_a, __pyx_v_axis);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_468size(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("size", 0);

  /* "ga4py/gain/notimplemented.pyx":11686
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11686; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.size", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_471sometrue(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_470sometrue[] = "Check whether some values are true.\n\n    Refer to `any` for full documentation.\n\n    See Also\n    --------\n    any : equivalent function\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_471sometrue = {__Pyx_NAMESTR("sometrue"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_471sometrue, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_470sometrue)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_471sometrue(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("sometrue (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__axis,&__pyx_n_s__out,0};
    PyObject* values[3] = {0,0,0};

    /* "ga4py/gain/notimplemented.pyx":11689
 * 
 * 
 * def sometrue(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Check whether some values are true.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__out);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "sometrue") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11689; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
    __pyx_v_out = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("sometrue", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11689; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.sometrue", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_470sometrue(__pyx_self, __pyx_v_a, __pyx_v_axis, __pyx_v_out);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_470sometrue(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("sometrue", 0);

  /* "ga4py/gain/notimplemented.pyx":11699
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11699; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.sometrue", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_473sort(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_472sort[] = "Return a sorted copy of an array.\n\n    Parameters\n    ----------\n    a : array_like\n        Array to be sorted.\n    axis : int or None, optional\n        Axis along which to sort. If None, the array is flattened before\n        sorting. The default is -1, which sorts along the last axis.\n    kind : {'quicksort', 'mergesort', 'heapsort'}, optional\n        Sorting algorithm. Default is 'quicksort'.\n    order : list, optional\n        When `a` is a structured array, this argument specifies which fields\n        to compare first, second, and so on.  This list does not need to\n        include all of the fields.\n\n    Returns\n    -------\n    sorted_array : ndarray\n        Array of the same type and shape as `a`.\n\n    See Also\n    --------\n    ndarray.sort : Method to sort an array in-place.\n    argsort : Indirect sort.\n    lexsort : Indirect stable sort on multiple keys.\n    searchsorted : Find elements in a sorted array.\n\n    Notes\n    -----\n    The various sorting algorithms are characterized by their average speed,\n    worst case performance, work space size, and whether they are stable. A\n    stable sort keeps items with the same key in the same relative\n    order. The three available algorithms have the following\n    properties:\n\n    =========== ======= ============= ============ =======\n       kind      speed   worst case    work space  stable\n    =========== ======= ============= ============ =======\n    'quicksort'    1     O(n^2)            0          no\n    'mergesort'    2     O(n*log(n))      ~n/2        yes\n    'heapsort'     3     O(n*log(n))       0          no\n    =========== ======= ============= ============ =======\n\n    All the sort algorithms make temporary copies of the data when\n    sorting along any but the last axis.  Consequently, sorting along\n    the last axis is faster and uses less space than sorting along\n    any other axis.\n\n    The sort order for complex numbers is lexicographic. If both the real""\n    and imaginary parts are non-nan then the order is determined by the\n    real parts except when they are equal, in which case the order is\n    determined by the imaginary parts.\n\n    Previous to numpy 1.4.0 sorting real and complex arrays containing nan\n    values led to undefined behaviour. In numpy versions >= 1.4.0 nan\n    values are sorted to the end. The extended sort order is:\n\n      * Real: [R, nan]\n      * Complex: [R + Rj, R + nanj, nan + Rj, nan + nanj]\n\n    where R is a non-nan real value. Complex values with the same nan\n    placements are sorted according to the non-nan part if it exists.\n    Non-nan values are sorted as before.\n\n    Examples\n    --------\n    >>> a = np.array([[1,4],[3,1]])\n    >>> np.sort(a)                # sort along the last axis\n    array([[1, 4],\n           [1, 3]])\n    >>> np.sort(a, axis=None)     # sort the flattened array\n    array([1, 1, 3, 4])\n    >>> np.sort(a, axis=0)        # sort along the first axis\n    array([[1, 1],\n           [3, 4]])\n\n    Use the `order` keyword to specify a field to use when sorting a\n    structured array:\n\n    >>> dtype = [('name', 'S10'), ('height', float), ('age', int)]\n    >>> values = [('Arthur', 1.8, 41), ('Lancelot', 1.9, 38),\n    ...           ('Galahad', 1.7, 38)]\n    >>> a = np.array(values, dtype=dtype)       # create a structured array\n    >>> np.sort(a, order='height')                        # doctest: +SKIP\n    array([('Galahad', 1.7, 38), ('Arthur', 1.8, 41),\n           ('Lancelot', 1.8999999999999999, 38)],\n          dtype=[('name', '|S10'), ('height', '<f8'), ('age', '<i4')])\n\n    Sort by age, then height if ages are equal:\n\n    >>> np.sort(a, order=['age', 'height'])               # doctest: +SKIP\n    array([('Galahad', 1.7, 38), ('Lancelot', 1.8999999999999999, 38),\n           ('Arthur', 1.8, 41)],\n          dtype=[('name', '|S10'), ('height', '<f8'), ('age', '<i4')])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_473sort = {__Pyx_NAMESTR("sort"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_473sort, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_472sort)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_473sort(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_kind = 0;
  CYTHON_UNUSED PyObject *__pyx_v_order = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("sort (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__axis,&__pyx_n_s__kind,&__pyx_n_s__order,0};
    PyObject* values[4] = {0,0,0,0};
    values[1] = ((PyObject *)__pyx_int_neg_1);
    values[2] = ((PyObject *)__pyx_n_s__quicksort);

    /* "ga4py/gain/notimplemented.pyx":11702
 * 
 * 
 * def sort(a, axis=-1, kind='quicksort', order=None):             # <<<<<<<<<<<<<<
 *     """Return a sorted copy of an array.
 * 
 */
    values[3] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__kind);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__order);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "sort") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11702; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
    __pyx_v_kind = values[2];
    __pyx_v_order = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("sort", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11702; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.sort", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_472sort(__pyx_self, __pyx_v_a, __pyx_v_axis, __pyx_v_kind, __pyx_v_order);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_472sort(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_kind, CYTHON_UNUSED PyObject *__pyx_v_order) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("sort", 0);

  /* "ga4py/gain/notimplemented.pyx":11800
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11800; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.sort", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_475sort_complex(PyObject *__pyx_self, PyObject *__pyx_v_a); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_474sort_complex[] = "Sort a complex array using the real part first, then the imaginary part.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array\n\n    Returns\n    -------\n    out : complex ndarray\n        Always returns a sorted complex array.\n\n    Examples\n    --------\n    >>> np.sort_complex([5, 3, 6, 2, 1])\n    array([ 1.+0.j,  2.+0.j,  3.+0.j,  5.+0.j,  6.+0.j])\n\n    >>> np.sort_complex([1 + 2j, 2 - 1j, 3 - 2j, 3 - 3j, 3 + 5j])\n    array([ 1.+2.j,  2.-1.j,  3.-3.j,  3.-2.j,  3.+5.j])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_475sort_complex = {__Pyx_NAMESTR("sort_complex"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_475sort_complex, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_474sort_complex)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_475sort_complex(PyObject *__pyx_self, PyObject *__pyx_v_a) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("sort_complex (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_474sort_complex(__pyx_self, ((PyObject *)__pyx_v_a));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":11803
 * 
 * 
 * def sort_complex(a):             # <<<<<<<<<<<<<<
 *     """Sort a complex array using the real part first, then the imaginary part.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_474sort_complex(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("sort_complex", 0);

  /* "ga4py/gain/notimplemented.pyx":11825
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11825; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.sort_complex", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_477source(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_476source[] = "Print or write to a file the source code for a Numpy object.\n\n    The source code is only returned for objects written in Python. Many\n    functions and classes are defined in C and will therefore not return\n    useful information.\n\n    Parameters\n    ----------\n    object : numpy object\n        Input object. This can be any object (function, class, module, ...).\n    output : file object, optional\n        If `output` not supplied then source code is printed to screen\n        (sys.stdout).  File object must be created with either write 'w' or\n        append 'a' modes.\n\n    See Also\n    --------\n    lookfor, info\n\n    Examples\n    --------\n    >>> np.source(np.interp)                        #doctest: +SKIP\n    In file: /usr/lib/python2.6/dist-packages/numpy/lib/function_base.py\n    def interp(x, xp, fp, left=None, right=None):\n        '''.... (full docstring printed)'''\n        if isinstance(x, (float, int, number)):\n            return compiled_interp([x], xp, fp, left, right).item()\n        else:\n            return compiled_interp(x, xp, fp, left, right)\n\n    The source code is only returned for objects written in Python.\n\n    >>> np.source(np.array)                         #doctest: +SKIP\n    Not available for this object.\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_477source = {__Pyx_NAMESTR("source"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_477source, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_476source)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_477source(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_object = 0;
  CYTHON_UNUSED PyObject *__pyx_v_output = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("source (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__object,&__pyx_n_s__output,0};
    PyObject* values[2] = {0,0};
    values[1] = __pyx_k_47;
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__object)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__output);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "source") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11828; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_object = values[0];
    __pyx_v_output = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("source", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11828; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.source", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_476source(__pyx_self, __pyx_v_object, __pyx_v_output);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":11828
 * 
 * 
 * def source(object, output=sys.stdout):             # <<<<<<<<<<<<<<
 *     """Print or write to a file the source code for a Numpy object.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_476source(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_object, CYTHON_UNUSED PyObject *__pyx_v_output) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("source", 0);

  /* "ga4py/gain/notimplemented.pyx":11865
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11865; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.source", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_479split(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_478split[] = "Split an array into multiple sub-arrays of equal size.\n\n    Parameters\n    ----------\n    ary : ndarray\n        Array to be divided into sub-arrays.\n    indices_or_sections : int or 1-D array\n        If `indices_or_sections` is an integer, N, the array will be divided\n        into N equal arrays along `axis`.  If such a split is not possible,\n        an error is raised.\n\n        If `indices_or_sections` is a 1-D array of sorted integers, the entries\n        indicate where along `axis` the array is split.  For example,\n        ``[2, 3]`` would, for ``axis=0``, result in\n\n          - ary[:2]\n          - ary[2:3]\n          - ary[3:]\n\n        If an index exceeds the dimension of the array along `axis`,\n        an empty sub-array is returned correspondingly.\n    axis : int, optional\n        The axis along which to split, default is 0.\n\n    Returns\n    -------\n    sub-arrays : list of ndarrays\n        A list of sub-arrays.\n\n    Raises\n    ------\n    ValueError\n        If `indices_or_sections` is given as an integer, but\n        a split does not result in equal division.\n\n    See Also\n    --------\n    array_split : Split an array into multiple sub-arrays of equal or\n                  near-equal size.  Does not raise an exception if\n                  an equal division cannot be made.\n    hsplit : Split array into multiple sub-arrays horizontally (column-wise).\n    vsplit : Split array into multiple sub-arrays vertically (row wise).\n    dsplit : Split array into multiple sub-arrays along the 3rd axis (depth).\n    concatenate : Join arrays together.\n    hstack : Stack arrays in sequence horizontally (column wise).\n    vstack : Stack arrays in sequence vertically (row wise).\n    dstack : Stack arrays in sequence depth wise (along third dimension).\n\n    Examples\n    --------\n    >>> x = np.arange(9.0)\n    >>> np.split(x, 3)\n    [array([ 0.,  1.,  2.]), array([ 3.,  4.,  5.]), array([ 6.,  7.,  8.])]\n\n    >>> x = np.arange(8.""0)\n    >>> np.split(x, [3, 5, 6, 10])\n    [array([ 0.,  1.,  2.]),\n     array([ 3.,  4.]),\n     array([ 5.]),\n     array([ 6.,  7.]),\n     array([], dtype=float64)]\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_479split = {__Pyx_NAMESTR("split"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_479split, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_478split)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_479split(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_ary = 0;
  CYTHON_UNUSED PyObject *__pyx_v_indices_or_sections = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("split (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__ary,&__pyx_n_s__indices_or_sections,&__pyx_n_s__axis,0};
    PyObject* values[3] = {0,0,0};
    values[2] = ((PyObject *)__pyx_int_0);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__ary)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__indices_or_sections)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("split", 0, 2, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11868; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "split") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11868; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_ary = values[0];
    __pyx_v_indices_or_sections = values[1];
    __pyx_v_axis = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("split", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11868; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.split", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_478split(__pyx_self, __pyx_v_ary, __pyx_v_indices_or_sections, __pyx_v_axis);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":11868
 * 
 * 
 * def split(ary, indices_or_sections, axis=0):             # <<<<<<<<<<<<<<
 *     """Split an array into multiple sub-arrays of equal size.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_478split(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_ary, CYTHON_UNUSED PyObject *__pyx_v_indices_or_sections, CYTHON_UNUSED PyObject *__pyx_v_axis) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("split", 0);

  /* "ga4py/gain/notimplemented.pyx":11932
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11932; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.split", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_481squeeze(PyObject *__pyx_self, PyObject *__pyx_v_a); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_480squeeze[] = "Remove single-dimensional entries from the shape of an array.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n\n    Returns\n    -------\n    squeezed : ndarray\n        The input array, but with with all dimensions of length 1\n        removed.  Whenever possible, a view on `a` is returned.\n\n    Examples\n    --------\n    >>> x = np.array([[[0], [1], [2]]])\n    >>> x.shape\n    (1, 3, 1)\n    >>> np.squeeze(x).shape\n    (3,)\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_481squeeze = {__Pyx_NAMESTR("squeeze"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_481squeeze, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_480squeeze)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_481squeeze(PyObject *__pyx_self, PyObject *__pyx_v_a) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("squeeze (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_480squeeze(__pyx_self, ((PyObject *)__pyx_v_a));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":11935
 * 
 * 
 * def squeeze(a):             # <<<<<<<<<<<<<<
 *     """Remove single-dimensional entries from the shape of an array.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_480squeeze(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("squeeze", 0);

  /* "ga4py/gain/notimplemented.pyx":11958
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11958; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.squeeze", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_483std(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_482std[] = "Compute the standard deviation along the specified axis.\n\n    Returns the standard deviation, a measure of the spread of a distribution,\n    of the array elements. The standard deviation is computed for the\n    flattened array by default, otherwise over the specified axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Calculate the standard deviation of these values.\n    axis : int, optional\n        Axis along which the standard deviation is computed. The default is\n        to compute the standard deviation of the flattened array.\n    dtype : dtype, optional\n        Type to use in computing the standard deviation. For arrays of\n        integer type the default is float64, for arrays of float types it is\n        the same as the array type.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must have\n        the same shape as the expected output but the type (of the calculated\n        values) will be cast if necessary.\n    ddof : int, optional\n        Means Delta Degrees of Freedom.  The divisor used in calculations\n        is ``N - ddof``, where ``N`` represents the number of elements.\n        By default `ddof` is zero.\n\n    Returns\n    -------\n    standard_deviation : ndarray, see dtype parameter above.\n        If `out` is None, return a new array containing the standard deviation,\n        otherwise return a reference to the output array.\n\n    See Also\n    --------\n    var, mean\n    numpy.doc.ufuncs : Section \"Output arguments\"\n\n    Notes\n    -----\n    The standard deviation is the square root of the average of the squared\n    deviations from the mean, i.e., ``std = sqrt(mean(abs(x - x.mean())**2))``.\n\n    The average squared deviation is normally calculated as ``x.sum() / N``, where\n    ``N = len(x)``.  If, however, `ddof` is specified, the divisor ``N - ddof``\n    is used instead. In standard statistical practice, ``ddof=1`` provides an\n    unbiased estimator of t""he variance of the infinite population. ``ddof=0``\n    provides a maximum likelihood estimate of the variance for normally\n    distributed variables. The standard deviation computed in this function\n    is the square root of the estimated variance, so even with ``ddof=1``, it\n    will not be an unbiased estimate of the standard deviation per se.\n\n    Note that, for complex numbers, `std` takes the absolute\n    value before squaring, so that the result is always real and nonnegative.\n\n    For floating-point input, the *std* is computed using the same\n    precision the input has. Depending on the input data, this can cause\n    the results to be inaccurate, especially for float32 (see example below).\n    Specifying a higher-accuracy accumulator using the `dtype` keyword can\n    alleviate this issue.\n\n    Examples\n    --------\n    >>> a = np.array([[1, 2], [3, 4]])\n    >>> np.std(a)\n    1.1180339887498949\n    >>> np.std(a, axis=0)\n    array([ 1.,  1.])\n    >>> np.std(a, axis=1)\n    array([ 0.5,  0.5])\n\n    In single precision, std() can be inaccurate:\n\n    >>> a = np.zeros((2,512*512), dtype=np.float32)\n    >>> a[0,:] = 1.0\n    >>> a[1,:] = 0.1\n    >>> np.std(a)\n    0.45172946707416706\n\n    Computing the standard deviation in float64 is more accurate:\n\n    >>> np.std(a, dtype=np.float64)\n    0.44999999925552653\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_483std = {__Pyx_NAMESTR("std"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_483std, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_482std)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_483std(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  CYTHON_UNUSED PyObject *__pyx_v_ddof = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("std (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__axis,&__pyx_n_s__dtype,&__pyx_n_s__out,&__pyx_n_s__ddof,0};
    PyObject* values[5] = {0,0,0,0,0};

    /* "ga4py/gain/notimplemented.pyx":11961
 * 
 * 
 * def std(a, axis=None, dtype=None, out=None, ddof=0):             # <<<<<<<<<<<<<<
 *     """Compute the standard deviation along the specified axis.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    values[3] = ((PyObject *)Py_None);
    values[4] = ((PyObject *)__pyx_int_0);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__dtype);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__out);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__ddof);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "std") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11961; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
    __pyx_v_dtype = values[2];
    __pyx_v_out = values[3];
    __pyx_v_ddof = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("std", 0, 1, 5, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11961; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.std", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_482std(__pyx_self, __pyx_v_a, __pyx_v_axis, __pyx_v_dtype, __pyx_v_out, __pyx_v_ddof);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_482std(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_out, CYTHON_UNUSED PyObject *__pyx_v_ddof) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("std", 0);

  /* "ga4py/gain/notimplemented.pyx":12046
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12046; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.std", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_485sum(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_484sum[] = "Sum of array elements over a given axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Elements to sum.\n    axis : integer, optional\n        Axis over which the sum is taken. By default `axis` is None,\n        and all elements are summed.\n    dtype : dtype, optional\n        The type of the returned array and of the accumulator in which\n        the elements are summed.  By default, the dtype of `a` is used.\n        An exception is when `a` has an integer type with less precision\n        than the default platform integer.  In that case, the default\n        platform integer is used instead.\n    out : ndarray, optional\n        Array into which the output is placed.  By default, a new array is\n        created.  If `out` is given, it must be of the appropriate shape\n        (the shape of `a` with `axis` removed, i.e.,\n        ``numpy.delete(a.shape, axis)``).  Its type is preserved. See\n        `doc.ufuncs` (Section \"Output arguments\") for more details.\n\n    Returns\n    -------\n    sum_along_axis : ndarray\n        An array with the same shape as `a`, with the specified\n        axis removed.   If `a` is a 0-d array, or if `axis` is None, a scalar\n        is returned.  If an output array is specified, a reference to\n        `out` is returned.\n\n    See Also\n    --------\n    ndarray.sum : Equivalent method.\n\n    cumsum : Cumulative sum of array elements.\n\n    trapz : Integration of array values using the composite trapezoidal rule.\n\n    mean, average\n\n    Notes\n    -----\n    Arithmetic is modular when using integer types, and no error is\n    raised on overflow.\n\n    Examples\n    --------\n    >>> np.sum([0.5, 1.5])\n    2.0\n    >>> np.sum([0.5, 0.7, 0.2, 1.5], dtype=np.int32)\n    1\n    >>> np.sum([[0, 1], [0, 5]])\n    6\n    >>> np.sum([[0, 1], [0, 5]], axis=0)\n    array([0, 6])\n    >>> np.sum([[0, 1], [0, 5]], axis=1)\n    array([1, 5])\n\n    If the accumulator is too small, overflow occurs:\n\n    >>> np.one""s(128, dtype=np.int8).sum(dtype=np.int8)\n    -128\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_485sum = {__Pyx_NAMESTR("sum"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_485sum, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_484sum)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_485sum(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("sum (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__axis,&__pyx_n_s__dtype,&__pyx_n_s__out,0};
    PyObject* values[4] = {0,0,0,0};

    /* "ga4py/gain/notimplemented.pyx":12049
 * 
 * 
 * def sum(a, axis=None, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Sum of array elements over a given axis.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    values[3] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__dtype);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__out);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "sum") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12049; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
    __pyx_v_dtype = values[2];
    __pyx_v_out = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("sum", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12049; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.sum", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_484sum(__pyx_self, __pyx_v_a, __pyx_v_axis, __pyx_v_dtype, __pyx_v_out);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_484sum(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_out) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("sum", 0);

  /* "ga4py/gain/notimplemented.pyx":12114
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12114; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.sum", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_487swapaxes(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_486swapaxes[] = "Interchange two axes of an array.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    axis1 : int\n        First axis.\n    axis2 : int\n        Second axis.\n\n    Returns\n    -------\n    a_swapped : ndarray\n        If `a` is an ndarray, then a view of `a` is returned; otherwise\n        a new array is created.\n\n    Examples\n    --------\n    >>> x = np.array([[1,2,3]])\n    >>> np.swapaxes(x,0,1)\n    array([[1],\n           [2],\n           [3]])\n\n    >>> x = np.array([[[0,1],[2,3]],[[4,5],[6,7]]])\n    >>> x\n    array([[[0, 1],\n            [2, 3]],\n           [[4, 5],\n            [6, 7]]])\n\n    >>> np.swapaxes(x,0,2)\n    array([[[0, 4],\n            [2, 6]],\n           [[1, 5],\n            [3, 7]]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_487swapaxes = {__Pyx_NAMESTR("swapaxes"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_487swapaxes, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_486swapaxes)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_487swapaxes(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis1 = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis2 = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("swapaxes (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__axis1,&__pyx_n_s__axis2,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis1)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("swapaxes", 1, 3, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12117; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis2)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("swapaxes", 1, 3, 3, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12117; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "swapaxes") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12117; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_a = values[0];
    __pyx_v_axis1 = values[1];
    __pyx_v_axis2 = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("swapaxes", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12117; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.swapaxes", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_486swapaxes(__pyx_self, __pyx_v_a, __pyx_v_axis1, __pyx_v_axis2);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":12117
 * 
 * 
 * def swapaxes(a, axis1, axis2):             # <<<<<<<<<<<<<<
 *     """Interchange two axes of an array.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_486swapaxes(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis1, CYTHON_UNUSED PyObject *__pyx_v_axis2) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("swapaxes", 0);

  /* "ga4py/gain/notimplemented.pyx":12157
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12157; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.swapaxes", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_489take(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_488take[] = "Take elements from an array along an axis.\n\n    This function does the same thing as \"fancy\" indexing (indexing arrays\n    using arrays); however, it can be easier to use if you need elements\n    along a given axis.\n\n    Parameters\n    ----------\n    a : array_like\n        The source array.\n    indices : array_like\n        The indices of the values to extract.\n    axis : int, optional\n        The axis over which to select values. By default, the flattened\n        input array is used.\n    out : ndarray, optional\n        If provided, the result will be placed in this array. It should\n        be of the appropriate shape and dtype.\n    mode : {'raise', 'wrap', 'clip'}, optional\n        Specifies how out-of-bounds indices will behave.\n\n        * 'raise' -- raise an error (default)\n        * 'wrap' -- wrap around\n        * 'clip' -- clip to the range\n\n        'clip' mode means that all indices that are too large are replaced\n        by the index that addresses the last element along that axis. Note\n        that this disables indexing with negative numbers.\n\n    Returns\n    -------\n    subarray : ndarray\n        The returned array has the same type as `a`.\n\n    See Also\n    --------\n    ndarray.take : equivalent method\n\n    Examples\n    --------\n    >>> a = [4, 3, 5, 7, 6, 8]\n    >>> indices = [0, 1, 4]\n    >>> np.take(a, indices)\n    array([4, 3, 6])\n\n    In this example if `a` is an ndarray, \"fancy\" indexing can be used.\n\n    >>> a = np.array(a)\n    >>> a[indices]\n    array([4, 3, 6])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_489take = {__Pyx_NAMESTR("take"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_489take, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_488take)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_489take(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_indices = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  CYTHON_UNUSED PyObject *__pyx_v_mode = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("take (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__indices,&__pyx_n_s__axis,&__pyx_n_s__out,&__pyx_n_s__mode,0};
    PyObject* values[5] = {0,0,0,0,0};

    /* "ga4py/gain/notimplemented.pyx":12160
 * 
 * 
 * def take(a, indices, axis=None, out=None, mode='raise'):             # <<<<<<<<<<<<<<
 *     """Take elements from an array along an axis.
 * 
 */
    values[2] = ((PyObject *)Py_None);
    values[3] = ((PyObject *)Py_None);
    values[4] = ((PyObject *)__pyx_n_s__raise);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__indices)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("take", 0, 2, 5, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12160; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__out);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__mode);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "take") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12160; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_indices = values[1];
    __pyx_v_axis = values[2];
    __pyx_v_out = values[3];
    __pyx_v_mode = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("take", 0, 2, 5, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12160; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.take", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_488take(__pyx_self, __pyx_v_a, __pyx_v_indices, __pyx_v_axis, __pyx_v_out, __pyx_v_mode);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_488take(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_indices, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out, CYTHON_UNUSED PyObject *__pyx_v_mode) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("take", 0);

  /* "ga4py/gain/notimplemented.pyx":12213
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12213; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.take", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_491tensordot(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_490tensordot[] = "Compute tensor dot product along specified axes for arrays >= 1-D.\n\n    Given two tensors (arrays of dimension greater than or equal to one),\n    ``a`` and ``b``, and an array_like object containing two array_like\n    objects, ``(a_axes, b_axes)``, sum the products of ``a``'s and ``b``'s\n    elements (components) over the axes specified by ``a_axes`` and\n    ``b_axes``. The third argument can be a single non-negative\n    integer_like scalar, ``N``; if it is such, then the last ``N``\n    dimensions of ``a`` and the first ``N`` dimensions of ``b`` are summed\n    over.\n\n    Parameters\n    ----------\n    a, b : array_like, len(shape) >= 1\n        Tensors to \"dot\".\n\n    axes : variable type\n\n    * integer_like scalar\n      Number of axes to sum over (applies to both arrays); or\n\n    * array_like, shape = (2,), both elements array_like\n      Axes to be summed over, first sequence applying to ``a``, second\n      to ``b``.\n\n    See Also\n    --------\n    dot, einsum\n\n    Notes\n    -----\n    When there is more than one axis to sum over - and they are not the last\n    (first) axes of ``a`` (``b``) - the argument ``axes`` should consist of\n    two sequences of the same length, with the first axis to sum over given\n    first in both sequences, the second axis second, and so forth.\n\n    Examples\n    --------\n    A \"traditional\" example:\n\n    >>> a = np.arange(60.).reshape(3,4,5)\n    >>> b = np.arange(24.).reshape(4,3,2)\n    >>> c = np.tensordot(a,b, axes=([1,0],[0,1]))\n    >>> c.shape\n    (5, 2)\n    >>> c\n    array([[ 4400.,  4730.],\n           [ 4532.,  4874.],\n           [ 4664.,  5018.],\n           [ 4796.,  5162.],\n           [ 4928.,  5306.]])\n    >>> # A slower but equivalent way of computing the same...\n    >>> d = np.zeros((5,2))\n    >>> for i in range(5):\n    ...   for j in range(2):\n    ...     for k in range(3):\n    ...       for n in range(4):\n    ...         d[i,j] += a[k,n,i] * b[n,k,j]\n    >>> c == d""\n    array([[ True,  True],\n           [ True,  True],\n           [ True,  True],\n           [ True,  True],\n           [ True,  True]], dtype=bool)\n\n    An extended example taking advantage of the overloading of + and \\*:\n\n    >>> a = np.array(range(1, 9))\n    >>> a.shape = (2, 2, 2)\n    >>> A = np.array(('a', 'b', 'c', 'd'), dtype=object)\n    >>> A.shape = (2, 2)\n    >>> a; A\n    array([[[1, 2],\n            [3, 4]],\n           [[5, 6],\n            [7, 8]]])\n    array([[a, b],\n           [c, d]], dtype=object)\n\n    >>> np.tensordot(a, A) # third argument default is 2\n    array([abbcccdddd, aaaaabbbbbbcccccccdddddddd], dtype=object)\n\n    >>> np.tensordot(a, A, 1)\n    array([[[acc, bdd],\n            [aaacccc, bbbdddd]],\n           [[aaaaacccccc, bbbbbdddddd],\n            [aaaaaaacccccccc, bbbbbbbdddddddd]]], dtype=object)\n\n    >>> np.tensordot(a, A, 0) # \"Left for reader\" (result too long to incl.)\n    array([[[[[a, b],\n              [c, d]],\n              ...\n\n    >>> np.tensordot(a, A, (0, 1))\n    array([[[abbbbb, cddddd],\n            [aabbbbbb, ccdddddd]],\n           [[aaabbbbbbb, cccddddddd],\n            [aaaabbbbbbbb, ccccdddddddd]]], dtype=object)\n\n    >>> np.tensordot(a, A, (2, 1))\n    array([[[abb, cdd],\n            [aaabbbb, cccdddd]],\n           [[aaaaabbbbbb, cccccdddddd],\n            [aaaaaaabbbbbbbb, cccccccdddddddd]]], dtype=object)\n\n    >>> np.tensordot(a, A, ((0, 1), (0, 1)))\n    array([abbbcccccddddddd, aabbbbccccccdddddddd], dtype=object)\n\n    >>> np.tensordot(a, A, ((2, 1), (1, 0)))\n    array([acccbbdddd, aaaaacccccccbbbbbbdddddddd], dtype=object)\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_491tensordot = {__Pyx_NAMESTR("tensordot"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_491tensordot, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_490tensordot)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_491tensordot(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_b = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axes = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("tensordot (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__b,&__pyx_n_s__axes,0};
    PyObject* values[3] = {0,0,0};
    values[2] = ((PyObject *)__pyx_int_2);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__b)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("tensordot", 0, 2, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12216; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axes);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "tensordot") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12216; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_b = values[1];
    __pyx_v_axes = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("tensordot", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12216; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.tensordot", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_490tensordot(__pyx_self, __pyx_v_a, __pyx_v_b, __pyx_v_axes);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":12216
 * 
 * 
 * def tensordot(a, b, axes=2):             # <<<<<<<<<<<<<<
 *     """Compute tensor dot product along specified axes for arrays >= 1-D.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_490tensordot(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_b, CYTHON_UNUSED PyObject *__pyx_v_axes) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("tensordot", 0);

  /* "ga4py/gain/notimplemented.pyx":12329
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12329; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.tensordot", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_493tile(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_492tile[] = "Construct an array by repeating A the number of times given by reps.\n\n    If `reps` has length ``d``, the result will have dimension of\n    ``max(d, A.ndim)``.\n\n    If ``A.ndim < d``, `A` is promoted to be d-dimensional by prepending new\n    axes. So a shape (3,) array is promoted to (1, 3) for 2-D replication,\n    or shape (1, 1, 3) for 3-D replication. If this is not the desired\n    behavior, promote `A` to d-dimensions manually before calling this\n    function.\n\n    If ``A.ndim > d``, `reps` is promoted to `A`.ndim by pre-pending 1's to it.\n    Thus for an `A` of shape (2, 3, 4, 5), a `reps` of (2, 2) is treated as\n    (1, 1, 2, 2).\n\n    Parameters\n    ----------\n    A : array_like\n        The input array.\n    reps : array_like\n        The number of repetitions of `A` along each axis.\n\n    Returns\n    -------\n    c : ndarray\n        The tiled output array.\n\n    See Also\n    --------\n    repeat : Repeat elements of an array.\n\n    Examples\n    --------\n    >>> a = np.array([0, 1, 2])\n    >>> np.tile(a, 2)\n    array([0, 1, 2, 0, 1, 2])\n    >>> np.tile(a, (2, 2))\n    array([[0, 1, 2, 0, 1, 2],\n           [0, 1, 2, 0, 1, 2]])\n    >>> np.tile(a, (2, 1, 2))\n    array([[[0, 1, 2, 0, 1, 2]],\n           [[0, 1, 2, 0, 1, 2]]])\n\n    >>> b = np.array([[1, 2], [3, 4]])\n    >>> np.tile(b, 2)\n    array([[1, 2, 1, 2],\n           [3, 4, 3, 4]])\n    >>> np.tile(b, (2, 1))\n    array([[1, 2],\n           [3, 4],\n           [1, 2],\n           [3, 4]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_493tile = {__Pyx_NAMESTR("tile"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_493tile, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_492tile)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_493tile(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_A = 0;
  CYTHON_UNUSED PyObject *__pyx_v_reps = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("tile (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__A,&__pyx_n_s__reps,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__A)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__reps)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("tile", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12332; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "tile") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12332; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_A = values[0];
    __pyx_v_reps = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("tile", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12332; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.tile", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_492tile(__pyx_self, __pyx_v_A, __pyx_v_reps);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":12332
 * 
 * 
 * def tile(A, reps):             # <<<<<<<<<<<<<<
 *     """Construct an array by repeating A the number of times given by reps.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_492tile(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_A, CYTHON_UNUSED PyObject *__pyx_v_reps) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("tile", 0);

  /* "ga4py/gain/notimplemented.pyx":12387
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12387; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.tile", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_495trace(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_494trace[] = "Return the sum along diagonals of the array.\n\n    If `a` is 2-D, the sum along its diagonal with the given offset\n    is returned, i.e., the sum of elements ``a[i,i+offset]`` for all i.\n\n    If `a` has more than two dimensions, then the axes specified by axis1 and\n    axis2 are used to determine the 2-D sub-arrays whose traces are returned.\n    The shape of the resulting array is the same as that of `a` with `axis1`\n    and `axis2` removed.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array, from which the diagonals are taken.\n    offset : int, optional\n        Offset of the diagonal from the main diagonal. Can be both positive\n        and negative. Defaults to 0.\n    axis1, axis2 : int, optional\n        Axes to be used as the first and second axis of the 2-D sub-arrays\n        from which the diagonals should be taken. Defaults are the first two\n        axes of `a`.\n    dtype : dtype, optional\n        Determines the data-type of the returned array and of the accumulator\n        where the elements are summed. If dtype has the value None and `a` is\n        of integer type of precision less than the default integer\n        precision, then the default integer precision is used. Otherwise,\n        the precision is the same as that of `a`.\n    out : ndarray, optional\n        Array into which the output is placed. Its type is preserved and\n        it must be of the right shape to hold the output.\n\n    Returns\n    -------\n    sum_along_diagonals : ndarray\n        If `a` is 2-D, the sum along the diagonal is returned.  If `a` has\n        larger dimensions, then an array of sums along diagonals is returned.\n\n    See Also\n    --------\n    diag, diagonal, diagflat\n\n    Examples\n    --------\n    >>> np.trace(np.eye(3))\n    3.0\n    >>> a = np.arange(8).reshape((2,2,2))\n    >>> np.trace(a)\n    array([6, 8])\n\n    >>> a = np.arange(24).reshape((2,2,2,3))\n    >>> np.trace(a).shape\n    (2, 3)\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_495trace = {__Pyx_NAMESTR("trace"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_495trace, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_494trace)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_495trace(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_offset = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis1 = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis2 = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("trace (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__offset,&__pyx_n_s__axis1,&__pyx_n_s__axis2,&__pyx_n_s__dtype,&__pyx_n_s__out,0};
    PyObject* values[6] = {0,0,0,0,0,0};
    values[1] = ((PyObject *)__pyx_int_0);
    values[2] = ((PyObject *)__pyx_int_0);
    values[3] = ((PyObject *)__pyx_int_1);

    /* "ga4py/gain/notimplemented.pyx":12390
 * 
 * 
 * def trace(a, offset=0, axis1=0, axis2=1, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the sum along diagonals of the array.
 * 
 */
    values[4] = ((PyObject *)Py_None);
    values[5] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__offset);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis1);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis2);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__dtype);
          if (value) { values[4] = value; kw_args--; }
        }
        case  5:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__out);
          if (value) { values[5] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "trace") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12390; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_offset = values[1];
    __pyx_v_axis1 = values[2];
    __pyx_v_axis2 = values[3];
    __pyx_v_dtype = values[4];
    __pyx_v_out = values[5];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("trace", 0, 1, 6, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12390; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.trace", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_494trace(__pyx_self, __pyx_v_a, __pyx_v_offset, __pyx_v_axis1, __pyx_v_axis2, __pyx_v_dtype, __pyx_v_out);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_494trace(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_offset, CYTHON_UNUSED PyObject *__pyx_v_axis1, CYTHON_UNUSED PyObject *__pyx_v_axis2, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_out) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("trace", 0);

  /* "ga4py/gain/notimplemented.pyx":12445
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12445; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.trace", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_497transpose(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_496transpose[] = "Permute the dimensions of an array.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    axes : list of ints, optional\n        By default, reverse the dimensions, otherwise permute the axes\n        according to the values given.\n\n    Returns\n    -------\n    p : ndarray\n        `a` with its axes permuted.  A view is returned whenever\n        possible.\n\n    See Also\n    --------\n    rollaxis\n\n    Examples\n    --------\n    >>> x = np.arange(4).reshape((2,2))\n    >>> x\n    array([[0, 1],\n           [2, 3]])\n\n    >>> np.transpose(x)\n    array([[0, 2],\n           [1, 3]])\n\n    >>> x = np.ones((1, 2, 3))\n    >>> np.transpose(x, (1, 0, 2)).shape\n    (2, 1, 3)\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_497transpose = {__Pyx_NAMESTR("transpose"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_497transpose, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_496transpose)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_497transpose(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axes = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("transpose (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__axes,0};
    PyObject* values[2] = {0,0};

    /* "ga4py/gain/notimplemented.pyx":12448
 * 
 * 
 * def transpose(a, axes=None):             # <<<<<<<<<<<<<<
 *     """Permute the dimensions of an array.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axes);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "transpose") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12448; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axes = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("transpose", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12448; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.transpose", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_496transpose(__pyx_self, __pyx_v_a, __pyx_v_axes);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_496transpose(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axes) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("transpose", 0);

  /* "ga4py/gain/notimplemented.pyx":12485
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12485; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.transpose", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_499trapz(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_498trapz[] = "Integrate along the given axis using the composite trapezoidal rule.\n\n    Integrate `y` (`x`) along given axis.\n\n    Parameters\n    ----------\n    y : array_like\n        Input array to integrate.\n    x : array_like, optional\n        If `x` is None, then spacing between all `y` elements is `dx`.\n    dx : scalar, optional\n        If `x` is None, spacing given by `dx` is assumed. Default is 1.\n    axis : int, optional\n        Specify the axis.\n\n    Returns\n    -------\n    out : float\n        Definite integral as approximated by trapezoidal rule.\n\n    See Also\n    --------\n    sum, cumsum\n\n    Notes\n    -----\n    Image [2]_ illustrates trapezoidal rule -- y-axis locations of points will\n    be taken from `y` array, by default x-axis distances between points will be\n    1.0, alternatively they can be provided with `x` array or with `dx` scalar.\n    Return value will be equal to combined area under the red lines.\n\n\n    References\n    ----------\n    .. [1] Wikipedia page: http://en.wikipedia.org/wiki/Trapezoidal_rule\n\n    .. [2] Illustration image:\n           http://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png\n\n    Examples\n    --------\n    >>> np.trapz([1,2,3])\n    4.0\n    >>> np.trapz([1,2,3], x=[4,6,8])\n    8.0\n    >>> np.trapz([1,2,3], dx=2)\n    8.0\n    >>> a = np.arange(6).reshape(2, 3)\n    >>> a\n    array([[0, 1, 2],\n           [3, 4, 5]])\n    >>> np.trapz(a, axis=0)\n    array([ 1.5,  2.5,  3.5])\n    >>> np.trapz(a, axis=1)\n    array([ 2.,  8.])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_499trapz = {__Pyx_NAMESTR("trapz"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_499trapz, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_498trapz)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_499trapz(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_y = 0;
  CYTHON_UNUSED PyObject *__pyx_v_x = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dx = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("trapz (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__y,&__pyx_n_s__x,&__pyx_n_s__dx,&__pyx_n_s__axis,0};
    PyObject* values[4] = {0,0,0,0};

    /* "ga4py/gain/notimplemented.pyx":12488
 * 
 * 
 * def trapz(y, x=None, dx=1.0, axis=-1):             # <<<<<<<<<<<<<<
 *     """Integrate along the given axis using the composite trapezoidal rule.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    values[2] = __pyx_k_48;
    values[3] = ((PyObject *)__pyx_int_neg_1);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__y)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__x);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__dx);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "trapz") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12488; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_y = values[0];
    __pyx_v_x = values[1];
    __pyx_v_dx = values[2];
    __pyx_v_axis = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("trapz", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12488; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.trapz", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_498trapz(__pyx_self, __pyx_v_y, __pyx_v_x, __pyx_v_dx, __pyx_v_axis);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_498trapz(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_y, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_dx, CYTHON_UNUSED PyObject *__pyx_v_axis) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("trapz", 0);

  /* "ga4py/gain/notimplemented.pyx":12546
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12546; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.trapz", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_501tri(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_500tri[] = "An array with ones at and below the given diagonal and zeros elsewhere.\n\n    Parameters\n    ----------\n    N : int\n        Number of rows in the array.\n    M : int, optional\n        Number of columns in the array.\n        By default, `M` is taken equal to `N`.\n    k : int, optional\n        The sub-diagonal at and below which the array is filled.\n        `k` = 0 is the main diagonal, while `k` < 0 is below it,\n        and `k` > 0 is above.  The default is 0.\n    dtype : dtype, optional\n        Data type of the returned array.  The default is float.\n\n    Returns\n    -------\n    T : ndarray of shape (N, M)\n        Array with its lower triangle filled with ones and zero elsewhere;\n        in other words ``T[i,j] == 1`` for ``i <= j + k``, 0 otherwise.\n\n    Examples\n    --------\n    >>> np.tri(3, 5, 2, dtype=int)\n    array([[1, 1, 1, 0, 0],\n           [1, 1, 1, 1, 0],\n           [1, 1, 1, 1, 1]])\n\n    >>> np.tri(3, 5, -1)\n    array([[ 0.,  0.,  0.,  0.,  0.],\n           [ 1.,  0.,  0.,  0.,  0.],\n           [ 1.,  1.,  0.,  0.,  0.]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_501tri = {__Pyx_NAMESTR("tri"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_501tri, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_500tri)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_501tri(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_N = 0;
  CYTHON_UNUSED PyObject *__pyx_v_M = 0;
  CYTHON_UNUSED PyObject *__pyx_v_k = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("tri (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__N,&__pyx_n_s__M,&__pyx_n_s__k,&__pyx_n_s__dtype,0};
    PyObject* values[4] = {0,0,0,0};

    /* "ga4py/gain/notimplemented.pyx":12549
 * 
 * 
 * def tri(N, M=None, k=0, dtype=float):             # <<<<<<<<<<<<<<
 *     """An array with ones at and below the given diagonal and zeros elsewhere.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)__pyx_int_0);
    values[3] = __pyx_k_49;
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__N)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__M);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__k);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__dtype);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "tri") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12549; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_N = values[0];
    __pyx_v_M = values[1];
    __pyx_v_k = values[2];
    __pyx_v_dtype = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("tri", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12549; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.tri", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_500tri(__pyx_self, __pyx_v_N, __pyx_v_M, __pyx_v_k, __pyx_v_dtype);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_500tri(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_N, CYTHON_UNUSED PyObject *__pyx_v_M, CYTHON_UNUSED PyObject *__pyx_v_k, CYTHON_UNUSED PyObject *__pyx_v_dtype) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("tri", 0);

  /* "ga4py/gain/notimplemented.pyx":12585
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12585; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.tri", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_503tril(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_502tril[] = "Lower triangle of an array.\n\n    Return a copy of an array with elements above the `k`-th diagonal zeroed.\n\n    Parameters\n    ----------\n    m : array_like, shape (M, N)\n        Input array.\n    k : int, optional\n        Diagonal above which to zero elements.  `k = 0` (the default) is the\n        main diagonal, `k < 0` is below it and `k > 0` is above.\n\n    Returns\n    -------\n    L : ndarray, shape (M, N)\n        Lower triangle of `m`, of same shape and data-type as `m`.\n\n    See Also\n    --------\n    triu : same thing, only for the upper triangle\n\n    Examples\n    --------\n    >>> np.tril([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)\n    array([[ 0,  0,  0],\n           [ 4,  0,  0],\n           [ 7,  8,  0],\n           [10, 11, 12]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_503tril = {__Pyx_NAMESTR("tril"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_503tril, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_502tril)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_503tril(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_m = 0;
  CYTHON_UNUSED PyObject *__pyx_v_k = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("tril (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__m,&__pyx_n_s__k,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)__pyx_int_0);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__m)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__k);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "tril") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12588; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_m = values[0];
    __pyx_v_k = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("tril", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12588; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.tril", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_502tril(__pyx_self, __pyx_v_m, __pyx_v_k);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":12588
 * 
 * 
 * def tril(m, k=0):             # <<<<<<<<<<<<<<
 *     """Lower triangle of an array.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_502tril(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_m, CYTHON_UNUSED PyObject *__pyx_v_k) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("tril", 0);

  /* "ga4py/gain/notimplemented.pyx":12619
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12619; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.tril", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_505tril_indices(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_504tril_indices[] = "Return the indices for the lower-triangle of an (n, n) array.\n\n    Parameters\n    ----------\n    n : int\n        The row dimension of the square arrays for which the returned\n        indices will be valid.\n    k : int, optional\n        Diagonal offset (see `tril` for details).\n\n    Returns\n    -------\n    inds : tuple of arrays\n        The indices for the triangle. The returned tuple contains two arrays,\n        each with the indices along one dimension of the array.\n\n    See also\n    --------\n    triu_indices : similar function, for upper-triangular.\n    mask_indices : generic function accepting an arbitrary mask function.\n    tril, triu\n\n    Notes\n    -----\n    .. versionadded:: 1.4.0\n\n    Examples\n    --------\n    Compute two different sets of indices to access 4x4 arrays, one for the\n    lower triangular part starting at the main diagonal, and one starting two\n    diagonals further right:\n\n    >>> il1 = np.tril_indices(4)\n    >>> il2 = np.tril_indices(4, 2)\n\n    Here is how they can be used with a sample array:\n\n    >>> a = np.arange(16).reshape(4, 4)\n    >>> a\n    array([[ 0,  1,  2,  3],\n           [ 4,  5,  6,  7],\n           [ 8,  9, 10, 11],\n           [12, 13, 14, 15]])\n\n    Both for indexing:\n\n    >>> a[il1]\n    array([ 0,  4,  5,  8,  9, 10, 12, 13, 14, 15])\n\n    And for assigning values:\n\n    >>> a[il1] = -1\n    >>> a\n    array([[-1,  1,  2,  3],\n           [-1, -1,  6,  7],\n           [-1, -1, -1, 11],\n           [-1, -1, -1, -1]])\n\n    These cover almost the whole array (two diagonals right of the main one):\n\n    >>> a[il2] = -10\n    >>> a\n    array([[-10, -10, -10,   3],\n           [-10, -10, -10, -10],\n           [-10, -10, -10, -10],\n           [-10, -10, -10, -10]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_505tril_indices = {__Pyx_NAMESTR("tril_indices"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_505tril_indices, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_504tril_indices)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_505tril_indices(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_n = 0;
  CYTHON_UNUSED PyObject *__pyx_v_k = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("tril_indices (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__n,&__pyx_n_s__k,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)__pyx_int_0);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__n)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__k);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "tril_indices") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12622; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_n = values[0];
    __pyx_v_k = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("tril_indices", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12622; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.tril_indices", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_504tril_indices(__pyx_self, __pyx_v_n, __pyx_v_k);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":12622
 * 
 * 
 * def tril_indices(n, k=0):             # <<<<<<<<<<<<<<
 *     """Return the indices for the lower-triangle of an (n, n) array.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_504tril_indices(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_n, CYTHON_UNUSED PyObject *__pyx_v_k) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("tril_indices", 0);

  /* "ga4py/gain/notimplemented.pyx":12691
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12691; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.tril_indices", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_507tril_indices_from(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_506tril_indices_from[] = "Return the indices for the lower-triangle of arr.\n\n    See `tril_indices` for full details.\n\n    Parameters\n    ----------\n    arr : array_like\n        The indices will be valid for square arrays whose dimensions are\n        the same as arr.\n    k : int, optional\n        Diagonal offset (see `tril` for details).\n\n    See Also\n    --------\n    tril_indices, tril\n\n    Notes\n    -----\n    .. versionadded:: 1.4.0\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_507tril_indices_from = {__Pyx_NAMESTR("tril_indices_from"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_507tril_indices_from, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_506tril_indices_from)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_507tril_indices_from(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_arr = 0;
  CYTHON_UNUSED PyObject *__pyx_v_k = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("tril_indices_from (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__arr,&__pyx_n_s__k,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)__pyx_int_0);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__arr)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__k);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "tril_indices_from") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12694; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_arr = values[0];
    __pyx_v_k = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("tril_indices_from", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12694; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.tril_indices_from", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_506tril_indices_from(__pyx_self, __pyx_v_arr, __pyx_v_k);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":12694
 * 
 * 
 * def tril_indices_from(arr, k=0):             # <<<<<<<<<<<<<<
 *     """Return the indices for the lower-triangle of arr.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_506tril_indices_from(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_arr, CYTHON_UNUSED PyObject *__pyx_v_k) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("tril_indices_from", 0);

  /* "ga4py/gain/notimplemented.pyx":12716
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12716; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.tril_indices_from", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_509trim_zeros(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_508trim_zeros[] = "Trim the leading and/or trailing zeros from a 1-D array or sequence.\n\n    Parameters\n    ----------\n    filt : 1-D array or sequence\n        Input array.\n    trim : str, optional\n        A string with 'f' representing trim from front and 'b' to trim from\n        back. Default is 'fb', trim zeros from both front and back of the\n        array.\n\n    Returns\n    -------\n    trimmed : 1-D array or sequence\n        The result of trimming the input. The input data type is preserved.\n\n    Examples\n    --------\n    >>> a = np.array((0, 0, 0, 1, 2, 3, 0, 2, 1, 0))\n    >>> np.trim_zeros(a)\n    array([1, 2, 3, 0, 2, 1])\n\n    >>> np.trim_zeros(a, 'b')\n    array([0, 0, 0, 1, 2, 3, 0, 2, 1])\n\n    The input data type is preserved, list/tuple in means list/tuple out.\n\n    >>> np.trim_zeros([0, 1, 2, 0])\n    [1, 2]\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_509trim_zeros = {__Pyx_NAMESTR("trim_zeros"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_509trim_zeros, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_508trim_zeros)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_509trim_zeros(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_filt = 0;
  CYTHON_UNUSED PyObject *__pyx_v_trim = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("trim_zeros (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__filt,&__pyx_n_s__trim,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)__pyx_n_s__fb);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__filt)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__trim);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "trim_zeros") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12719; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_filt = values[0];
    __pyx_v_trim = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("trim_zeros", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12719; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.trim_zeros", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_508trim_zeros(__pyx_self, __pyx_v_filt, __pyx_v_trim);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":12719
 * 
 * 
 * def trim_zeros(filt, trim='fb'):             # <<<<<<<<<<<<<<
 *     """Trim the leading and/or trailing zeros from a 1-D array or sequence.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_508trim_zeros(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_filt, CYTHON_UNUSED PyObject *__pyx_v_trim) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("trim_zeros", 0);

  /* "ga4py/gain/notimplemented.pyx":12751
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12751; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.trim_zeros", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_511triu(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_510triu[] = "Upper triangle of an array.\n\n    Return a copy of a matrix with the elements below the `k`-th diagonal\n    zeroed.\n\n    Please refer to the documentation for `tril` for further details.\n\n    See Also\n    --------\n    tril : lower triangle of an array\n\n    Examples\n    --------\n    >>> np.triu([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)\n    array([[ 1,  2,  3],\n           [ 4,  5,  6],\n           [ 0,  8,  9],\n           [ 0,  0, 12]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_511triu = {__Pyx_NAMESTR("triu"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_511triu, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_510triu)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_511triu(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_m = 0;
  CYTHON_UNUSED PyObject *__pyx_v_k = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("triu (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__m,&__pyx_n_s__k,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)__pyx_int_0);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__m)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__k);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "triu") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12754; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_m = values[0];
    __pyx_v_k = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("triu", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12754; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.triu", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_510triu(__pyx_self, __pyx_v_m, __pyx_v_k);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":12754
 * 
 * 
 * def triu(m, k=0):             # <<<<<<<<<<<<<<
 *     """Upper triangle of an array.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_510triu(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_m, CYTHON_UNUSED PyObject *__pyx_v_k) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("triu", 0);

  /* "ga4py/gain/notimplemented.pyx":12775
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12775; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.triu", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_513triu_indices(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_512triu_indices[] = "Return the indices for the upper-triangle of an (n, n) array.\n\n    Parameters\n    ----------\n    n : int\n        The size of the arrays for which the returned indices will\n        be valid.\n    k : int, optional\n        Diagonal offset (see `triu` for details).\n\n    Returns\n    -------\n    inds : tuple of arrays\n        The indices for the triangle. The returned tuple contains two arrays,\n        each with the indices along one dimension of the array.\n\n    See also\n    --------\n    tril_indices : similar function, for lower-triangular.\n    mask_indices : generic function accepting an arbitrary mask function.\n    triu, tril\n\n    Notes\n    -----\n    .. versionadded:: 1.4.0\n\n    Examples\n    --------\n    Compute two different sets of indices to access 4x4 arrays, one for the\n    upper triangular part starting at the main diagonal, and one starting two\n    diagonals further right:\n\n    >>> iu1 = np.triu_indices(4)\n    >>> iu2 = np.triu_indices(4, 2)\n\n    Here is how they can be used with a sample array:\n\n    >>> a = np.arange(16).reshape(4, 4)\n    >>> a\n    array([[ 0,  1,  2,  3],\n           [ 4,  5,  6,  7],\n           [ 8,  9, 10, 11],\n           [12, 13, 14, 15]])\n\n    Both for indexing:\n\n    >>> a[iu1]\n    array([ 0,  1,  2,  3,  5,  6,  7, 10, 11, 15])\n\n    And for assigning values:\n\n    >>> a[iu1] = -1\n    >>> a\n    array([[-1, -1, -1, -1],\n           [ 4, -1, -1, -1],\n           [ 8,  9, -1, -1],\n           [12, 13, 14, -1]])\n\n    These cover only a small part of the whole array (two diagonals right\n    of the main one):\n\n    >>> a[iu2] = -10\n    >>> a\n    array([[ -1,  -1, -10, -10],\n           [  4,  -1,  -1, -10],\n           [  8,   9,  -1,  -1],\n           [ 12,  13,  14,  -1]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_513triu_indices = {__Pyx_NAMESTR("triu_indices"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_513triu_indices, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_512triu_indices)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_513triu_indices(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_n = 0;
  CYTHON_UNUSED PyObject *__pyx_v_k = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("triu_indices (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__n,&__pyx_n_s__k,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)__pyx_int_0);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__n)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__k);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "triu_indices") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12778; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_n = values[0];
    __pyx_v_k = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("triu_indices", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12778; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.triu_indices", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_512triu_indices(__pyx_self, __pyx_v_n, __pyx_v_k);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":12778
 * 
 * 
 * def triu_indices(n, k=0):             # <<<<<<<<<<<<<<
 *     """Return the indices for the upper-triangle of an (n, n) array.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_512triu_indices(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_n, CYTHON_UNUSED PyObject *__pyx_v_k) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("triu_indices", 0);

  /* "ga4py/gain/notimplemented.pyx":12848
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12848; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.triu_indices", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_515triu_indices_from(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_514triu_indices_from[] = "Return the indices for the upper-triangle of an (n, n) array.\n\n    See `triu_indices` for full details.\n\n    Parameters\n    ----------\n    arr : array_like\n        The indices will be valid for square arrays whose dimensions are\n        the same as arr.\n    k : int, optional\n      Diagonal offset (see `triu` for details).\n\n    See Also\n    --------\n    triu_indices, triu\n\n    Notes\n    -----\n    .. versionadded:: 1.4.0\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_515triu_indices_from = {__Pyx_NAMESTR("triu_indices_from"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_515triu_indices_from, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_514triu_indices_from)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_515triu_indices_from(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_arr = 0;
  CYTHON_UNUSED PyObject *__pyx_v_k = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("triu_indices_from (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__arr,&__pyx_n_s__k,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)__pyx_int_0);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__arr)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__k);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "triu_indices_from") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12851; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_arr = values[0];
    __pyx_v_k = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("triu_indices_from", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12851; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.triu_indices_from", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_514triu_indices_from(__pyx_self, __pyx_v_arr, __pyx_v_k);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":12851
 * 
 * 
 * def triu_indices_from(arr, k=0):             # <<<<<<<<<<<<<<
 *     """Return the indices for the upper-triangle of an (n, n) array.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_514triu_indices_from(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_arr, CYTHON_UNUSED PyObject *__pyx_v_k) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("triu_indices_from", 0);

  /* "ga4py/gain/notimplemented.pyx":12873
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12873; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.triu_indices_from", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_517typename(PyObject *__pyx_self, PyObject *__pyx_v_char_); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_516typename[] = "Return a description for the given data type code.\n\n    Parameters\n    ----------\n    char : str\n        Data type code.\n\n    Returns\n    -------\n    out : str\n        Description of the input data type code.\n\n    See Also\n    --------\n    dtype, typecodes\n\n    Examples\n    --------\n    >>> typechars = ['S1', '?', 'B', 'D', 'G', 'F', 'I', 'H', 'L', 'O', 'Q',\n    ...              'S', 'U', 'V', 'b', 'd', 'g', 'f', 'i', 'h', 'l', 'q']\n    >>> for typechar in typechars:\n    ...     print typechar, ' : ', np.typename(typechar)\n    ...\n    S1  :  character\n    ?  :  bool\n    B  :  unsigned char\n    D  :  complex double precision\n    G  :  complex long double precision\n    F  :  complex single precision\n    I  :  unsigned integer\n    H  :  unsigned short\n    L  :  unsigned long integer\n    O  :  object\n    Q  :  unsigned long long integer\n    S  :  string\n    U  :  unicode\n    V  :  void\n    b  :  signed char\n    d  :  double precision\n    g  :  long precision\n    f  :  single precision\n    i  :  integer\n    h  :  short\n    l  :  long integer\n    q  :  long long integer\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_517typename = {__Pyx_NAMESTR("typename"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_517typename, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_516typename)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_517typename(PyObject *__pyx_self, PyObject *__pyx_v_char_) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("typename (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_516typename(__pyx_self, ((PyObject *)__pyx_v_char_));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":12876
 * 
 * 
 * def typename(char_):             # <<<<<<<<<<<<<<
 *     """Return a description for the given data type code.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_516typename(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_char_) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("typename", 0);

  /* "ga4py/gain/notimplemented.pyx":12924
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12924; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.typename", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_519union1d(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_518union1d[] = "Find the union of two arrays.\n\n    Return the unique, sorted array of values that are in either of the two\n    input arrays.\n\n    Parameters\n    ----------\n    ar1, ar2 : array_like\n        Input arrays. They are flattened if they are not already 1D.\n\n    Returns\n    -------\n    union : ndarray\n        Unique, sorted union of the input arrays.\n\n    See Also\n    --------\n    numpy.lib.arraysetops : Module with a number of other functions for\n                            performing set operations on arrays.\n\n    Examples\n    --------\n    >>> np.union1d([-1, 0, 1], [-2, 0, 2])\n    array([-2, -1,  0,  1,  2])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_519union1d = {__Pyx_NAMESTR("union1d"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_519union1d, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_518union1d)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_519union1d(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_ar1 = 0;
  CYTHON_UNUSED PyObject *__pyx_v_ar2 = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("union1d (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__ar1,&__pyx_n_s__ar2,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__ar1)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__ar2)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("union1d", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12927; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "union1d") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12927; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_ar1 = values[0];
    __pyx_v_ar2 = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("union1d", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12927; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.union1d", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_518union1d(__pyx_self, __pyx_v_ar1, __pyx_v_ar2);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":12927
 * 
 * 
 * def union1d(ar1, ar2):             # <<<<<<<<<<<<<<
 *     """Find the union of two arrays.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_518union1d(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_ar1, CYTHON_UNUSED PyObject *__pyx_v_ar2) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("union1d", 0);

  /* "ga4py/gain/notimplemented.pyx":12954
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12954; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.union1d", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_521unique(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_520unique[] = "Find the unique elements of an array.\n\n    Returns the sorted unique elements of an array. There are two optional\n    outputs in addition to the unique elements: the indices of the input array\n    that give the unique values, and the indices of the unique array that\n    reconstruct the input array.\n\n    Parameters\n    ----------\n    ar : array_like\n        Input array. This will be flattened if it is not already 1-D.\n    return_index : bool, optional\n        If True, also return the indices of `ar` that result in the unique\n        array.\n    return_inverse : bool, optional\n        If True, also return the indices of the unique array that can be used\n        to reconstruct `ar`.\n\n    Returns\n    -------\n    unique : ndarray\n        The sorted unique values.\n    unique_indices : ndarray, optional\n        The indices of the unique values in the (flattened) original array.\n        Only provided if `return_index` is True.\n    unique_inverse : ndarray, optional\n        The indices to reconstruct the (flattened) original array from the\n        unique array. Only provided if `return_inverse` is True.\n\n    See Also\n    --------\n    numpy.lib.arraysetops : Module with a number of other functions for\n                            performing set operations on arrays.\n\n    Examples\n    --------\n    >>> np.unique([1, 1, 2, 2, 3, 3])\n    array([1, 2, 3])\n    >>> a = np.array([[1, 1], [2, 3]])\n    >>> np.unique(a)\n    array([1, 2, 3])\n\n    Return the indices of the original array that give the unique values:\n\n    >>> a = np.array(['a', 'b', 'b', 'c', 'a'])\n    >>> u, indices = np.unique(a, return_index=True)\n    >>> u\n    array(['a', 'b', 'c'],\n           dtype='|S1')\n    >>> indices\n    array([0, 1, 3])\n    >>> a[indices]\n    array(['a', 'b', 'c'],\n           dtype='|S1')\n\n    Reconstruct the input array from the unique values:\n\n    >>> a = np.array([1, 2, 6, 4, 2, 3, 2])\n    >>> u, indices = np.unique(a, return_inverse=True"")\n    >>> u\n    array([1, 2, 3, 4, 6])\n    >>> indices\n    array([0, 1, 4, 3, 1, 2, 1])\n    >>> u[indices]\n    array([1, 2, 6, 4, 2, 3, 2])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_521unique = {__Pyx_NAMESTR("unique"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_521unique, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_520unique)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_521unique(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_ar = 0;
  CYTHON_UNUSED PyObject *__pyx_v_return_index = 0;
  CYTHON_UNUSED PyObject *__pyx_v_return_inverse = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("unique (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__ar,&__pyx_n_s__return_index,&__pyx_n_s__return_inverse,0};
    PyObject* values[3] = {0,0,0};
    values[1] = __pyx_k_50;
    values[2] = __pyx_k_51;
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__ar)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__return_index);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__return_inverse);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "unique") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12957; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_ar = values[0];
    __pyx_v_return_index = values[1];
    __pyx_v_return_inverse = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("unique", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12957; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.unique", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_520unique(__pyx_self, __pyx_v_ar, __pyx_v_return_index, __pyx_v_return_inverse);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":12957
 * 
 * 
 * def unique(ar, return_index=False, return_inverse=False):             # <<<<<<<<<<<<<<
 *     """Find the unique elements of an array.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_520unique(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_ar, CYTHON_UNUSED PyObject *__pyx_v_return_index, CYTHON_UNUSED PyObject *__pyx_v_return_inverse) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("unique", 0);

  /* "ga4py/gain/notimplemented.pyx":13025
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13025; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.unique", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_523unpackbits(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_522unpackbits[] = "unpackbits(myarray, axis=None)\n\n    Unpacks elements of a uint8 array into a binary-valued output array.\n\n    Each element of `myarray` represents a bit-field that should be unpacked\n    into a binary-valued output array. The shape of the output array is either\n    1-D (if `axis` is None) or the same shape as the input array with unpacking\n    done along the axis specified.\n\n    Parameters\n    ----------\n    myarray : ndarray, uint8 type\n       Input array.\n    axis : int, optional\n       Unpacks along this axis.\n\n    Returns\n    -------\n    unpacked : ndarray, uint8 type\n       The elements are binary-valued (0 or 1).\n\n    See Also\n    --------\n    packbits : Packs the elements of a binary-valued array into bits in a uint8\n               array.\n\n    Examples\n    --------\n    >>> a = np.array([[2], [7], [23]], dtype=np.uint8)\n    >>> a\n    array([[ 2],\n           [ 7],\n           [23]], dtype=uint8)\n    >>> b = np.unpackbits(a, axis=1)\n    >>> b\n    array([[0, 0, 0, 0, 0, 0, 1, 0],\n           [0, 0, 0, 0, 0, 1, 1, 1],\n           [0, 0, 0, 1, 0, 1, 1, 1]], dtype=uint8)\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_523unpackbits = {__Pyx_NAMESTR("unpackbits"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_523unpackbits, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_522unpackbits)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_523unpackbits(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_myarray = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("unpackbits (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__myarray,&__pyx_n_s__axis,0};
    PyObject* values[2] = {0,0};

    /* "ga4py/gain/notimplemented.pyx":13028
 * 
 * 
 * def unpackbits(myarray, axis=None):             # <<<<<<<<<<<<<<
 *     """unpackbits(myarray, axis=None)
 * 
 */
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__myarray)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "unpackbits") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13028; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_myarray = values[0];
    __pyx_v_axis = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("unpackbits", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13028; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.unpackbits", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_522unpackbits(__pyx_self, __pyx_v_myarray, __pyx_v_axis);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_522unpackbits(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_myarray, CYTHON_UNUSED PyObject *__pyx_v_axis) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("unpackbits", 0);

  /* "ga4py/gain/notimplemented.pyx":13070
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13070; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.unpackbits", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_525unravel_index(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_524unravel_index[] = "unravel_index(indices, dims, order='C')\n\n    Converts a flat index or array of flat indices into a tuple\n    of coordinate arrays.\n\n    Parameters\n    ----------\n    indices : array_like\n        An integer array whose elements are indices into the flattened\n        version of an array of dimensions ``dims``. Before version 1.6.0,\n        this function accepted just one index value.\n    dims : tuple of ints\n        The shape of the array to use for unraveling ``indices``.\n    order : {'C', 'F'}, optional\n        .. versionadded:: 1.6.0\n\n        Determines whether the indices should be viewed as indexing in\n        C (row-major) order or FORTRAN (column-major) order.\n\n    Returns\n    -------\n    unraveled_coords : tuple of ndarray\n        Each array in the tuple has the same shape as the ``indices``\n        array.\n\n    See Also\n    --------\n    ravel_multi_index\n\n    Examples\n    --------\n    >>> np.unravel_index([22, 41, 37], (7,6))\n    (array([3, 6, 6]), array([4, 5, 1]))\n    >>> np.unravel_index([31, 41, 13], (7,6), order='F')\n    (array([3, 6, 6]), array([4, 5, 1]))\n\n    >>> np.unravel_index(1621, (6,7,8,9))\n    (3, 1, 4, 1)\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_525unravel_index = {__Pyx_NAMESTR("unravel_index"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_525unravel_index, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_524unravel_index)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_525unravel_index(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_indices = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dims = 0;
  CYTHON_UNUSED PyObject *__pyx_v_order = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("unravel_index (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__indices,&__pyx_n_s__dims,&__pyx_n_s__order,0};
    PyObject* values[3] = {0,0,0};
    values[2] = ((PyObject *)__pyx_n_s__C);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__indices)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__dims)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("unravel_index", 0, 2, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13073; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__order);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "unravel_index") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13073; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_indices = values[0];
    __pyx_v_dims = values[1];
    __pyx_v_order = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("unravel_index", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13073; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.unravel_index", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_524unravel_index(__pyx_self, __pyx_v_indices, __pyx_v_dims, __pyx_v_order);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":13073
 * 
 * 
 * def unravel_index(indices, dims, order='C'):             # <<<<<<<<<<<<<<
 *     """unravel_index(indices, dims, order='C')
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_524unravel_index(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_indices, CYTHON_UNUSED PyObject *__pyx_v_dims, CYTHON_UNUSED PyObject *__pyx_v_order) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("unravel_index", 0);

  /* "ga4py/gain/notimplemented.pyx":13115
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13115; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.unravel_index", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_527unwrap(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_526unwrap[] = "Unwrap by changing deltas between values to 2*pi complement.\n\n    Unwrap radian phase `p` by changing absolute jumps greater than\n    `discont` to their 2*pi complement along the given axis.\n\n    Parameters\n    ----------\n    p : array_like\n        Input array.\n    discont : float, optional\n        Maximum discontinuity between values, default is ``pi``.\n    axis : int, optional\n        Axis along which unwrap will operate, default is the last axis.\n\n    Returns\n    -------\n    out : ndarray\n        Output array.\n\n    See Also\n    --------\n    rad2deg, deg2rad\n\n    Notes\n    -----\n    If the discontinuity in `p` is smaller than ``pi``, but larger than\n    `discont`, no unwrapping is done because taking the 2*pi complement\n    would only make the discontinuity larger.\n\n    Examples\n    --------\n    >>> phase = np.linspace(0, np.pi, num=5)\n    >>> phase[3:] += np.pi\n    >>> phase\n    array([ 0.        ,  0.78539816,  1.57079633,  5.49778714,  6.28318531])\n    >>> np.unwrap(phase)\n    array([ 0.        ,  0.78539816,  1.57079633, -0.78539816,  0.        ])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_527unwrap = {__Pyx_NAMESTR("unwrap"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_527unwrap, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_526unwrap)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_527unwrap(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_p = 0;
  CYTHON_UNUSED PyObject *__pyx_v_discont = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("unwrap (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__p,&__pyx_n_s__discont,&__pyx_n_s__axis,0};
    PyObject* values[3] = {0,0,0};
    values[1] = __pyx_k_52;
    values[2] = ((PyObject *)__pyx_int_neg_1);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__p)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__discont);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "unwrap") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13118; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_p = values[0];
    __pyx_v_discont = values[1];
    __pyx_v_axis = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("unwrap", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13118; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.unwrap", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_526unwrap(__pyx_self, __pyx_v_p, __pyx_v_discont, __pyx_v_axis);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":13118
 * 
 * 
 * def unwrap(p, discont=3.14159265359, axis=-1):             # <<<<<<<<<<<<<<
 *     """Unwrap by changing deltas between values to 2*pi complement.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_526unwrap(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_p, CYTHON_UNUSED PyObject *__pyx_v_discont, CYTHON_UNUSED PyObject *__pyx_v_axis) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("unwrap", 0);

  /* "ga4py/gain/notimplemented.pyx":13158
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13158; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.unwrap", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_529vander(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_528vander[] = "Generate a Van der Monde matrix.\n\n    The columns of the output matrix are decreasing powers of the input\n    vector.  Specifically, the `i`-th output column is the input vector\n    raised element-wise to the power of ``N - i - 1``.  Such a matrix with\n    a geometric progression in each row is named for Alexandre-Theophile\n    Vandermonde.\n\n    Parameters\n    ----------\n    x : array_like\n        1-D input array.\n    N : int, optional\n        Order of (number of columns in) the output.  If `N` is not specified,\n        a square array is returned (``N = len(x)``).\n\n    Returns\n    -------\n    out : ndarray\n        Van der Monde matrix of order `N`.  The first column is ``x^(N-1)``,\n        the second ``x^(N-2)`` and so forth.\n\n    Examples\n    --------\n    >>> x = np.array([1, 2, 3, 5])\n    >>> N = 3\n    >>> np.vander(x, N)\n    array([[ 1,  1,  1],\n           [ 4,  2,  1],\n           [ 9,  3,  1],\n           [25,  5,  1]])\n\n    >>> np.column_stack([x**(N-1-i) for i in range(N)])\n    array([[ 1,  1,  1],\n           [ 4,  2,  1],\n           [ 9,  3,  1],\n           [25,  5,  1]])\n\n    >>> x = np.array([1, 2, 3, 5])\n    >>> np.vander(x)\n    array([[  1,   1,   1,   1],\n           [  8,   4,   2,   1],\n           [ 27,   9,   3,   1],\n           [125,  25,   5,   1]])\n\n    The determinant of a square Vandermonde matrix is the product\n    of the differences between the values of the input vector:\n\n    >>> np.linalg.det(np.vander(x))\n    48.000000000000043\n    >>> (5-3)*(5-2)*(5-1)*(3-2)*(3-1)*(2-1)\n    48\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_529vander = {__Pyx_NAMESTR("vander"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_529vander, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_528vander)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_529vander(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_x = 0;
  CYTHON_UNUSED PyObject *__pyx_v_N = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("vander (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__x,&__pyx_n_s__N,0};
    PyObject* values[2] = {0,0};

    /* "ga4py/gain/notimplemented.pyx":13161
 * 
 * 
 * def vander(x, N=None):             # <<<<<<<<<<<<<<
 *     """Generate a Van der Monde matrix.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__x)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__N);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "vander") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13161; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_x = values[0];
    __pyx_v_N = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("vander", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13161; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.vander", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_528vander(__pyx_self, __pyx_v_x, __pyx_v_N);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_528vander(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_N) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("vander", 0);

  /* "ga4py/gain/notimplemented.pyx":13216
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13216; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.vander", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_531var(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_530var[] = "Compute the variance along the specified axis.\n\n    Returns the variance of the array elements, a measure of the spread of a\n    distribution.  The variance is computed for the flattened array by\n    default, otherwise over the specified axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Array containing numbers whose variance is desired.  If `a` is not an\n        array, a conversion is attempted.\n    axis : int, optional\n        Axis along which the variance is computed.  The default is to compute\n        the variance of the flattened array.\n    dtype : data-type, optional\n        Type to use in computing the variance.  For arrays of integer type\n        the default is `float32`; for arrays of float types it is the same as\n        the array type.\n    out : ndarray, optional\n        Alternate output array in which to place the result.  It must have\n        the same shape as the expected output, but the type is cast if\n        necessary.\n    ddof : int, optional\n        \"Delta Degrees of Freedom\": the divisor used in the calculation is\n        ``N - ddof``, where ``N`` represents the number of elements. By\n        default `ddof` is zero.\n\n    Returns\n    -------\n    variance : ndarray, see dtype parameter above\n        If ``out=None``, returns a new array containing the variance;\n        otherwise, a reference to the output array is returned.\n\n    See Also\n    --------\n    std : Standard deviation\n    mean : Average\n    numpy.doc.ufuncs : Section \"Output arguments\"\n\n    Notes\n    -----\n    The variance is the average of the squared deviations from the mean,\n    i.e.,  ``var = mean(abs(x - x.mean())**2)``.\n\n    The mean is normally calculated as ``x.sum() / N``, where ``N = len(x)``.\n    If, however, `ddof` is specified, the divisor ``N - ddof`` is used\n    instead.  In standard statistical practice, ``ddof=1`` provides an\n    unbiased estimator of the variance of a hypothetical infinite population.\n    ""``ddof=0`` provides a maximum likelihood estimate of the variance for\n    normally distributed variables.\n\n    Note that for complex numbers, the absolute value is taken before\n    squaring, so that the result is always real and nonnegative.\n\n    For floating-point input, the variance is computed using the same\n    precision the input has.  Depending on the input data, this can cause\n    the results to be inaccurate, especially for `float32` (see example\n    below).  Specifying a higher-accuracy accumulator using the ``dtype``\n    keyword can alleviate this issue.\n\n    Examples\n    --------\n    >>> a = np.array([[1,2],[3,4]])\n    >>> np.var(a)\n    1.25\n    >>> np.var(a,0)\n    array([ 1.,  1.])\n    >>> np.var(a,1)\n    array([ 0.25,  0.25])\n\n    In single precision, var() can be inaccurate:\n\n    >>> a = np.zeros((2,512*512), dtype=np.float32)\n    >>> a[0,:] = 1.0\n    >>> a[1,:] = 0.1\n    >>> np.var(a)\n    0.20405951142311096\n\n    Computing the standard deviation in float64 is more accurate:\n\n    >>> np.var(a, dtype=np.float64)\n    0.20249999932997387\n    >>> ((1-0.55)**2 + (0.1-0.55)**2)/2\n    0.20250000000000001\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_531var = {__Pyx_NAMESTR("var"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_531var, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_530var)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_531var(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  CYTHON_UNUSED PyObject *__pyx_v_ddof = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("var (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__a,&__pyx_n_s__axis,&__pyx_n_s__dtype,&__pyx_n_s__out,&__pyx_n_s__ddof,0};
    PyObject* values[5] = {0,0,0,0,0};

    /* "ga4py/gain/notimplemented.pyx":13219
 * 
 * 
 * def var(a, axis=None, dtype=None, out=None, ddof=0):             # <<<<<<<<<<<<<<
 *     """Compute the variance along the specified axis.
 * 
 */
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    values[3] = ((PyObject *)Py_None);
    values[4] = ((PyObject *)__pyx_int_0);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__axis);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__dtype);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__out);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__ddof);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "var") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13219; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
    __pyx_v_dtype = values[2];
    __pyx_v_out = values[3];
    __pyx_v_ddof = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("var", 0, 1, 5, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13219; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.var", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_530var(__pyx_self, __pyx_v_a, __pyx_v_axis, __pyx_v_dtype, __pyx_v_out, __pyx_v_ddof);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_530var(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_out, CYTHON_UNUSED PyObject *__pyx_v_ddof) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("var", 0);

  /* "ga4py/gain/notimplemented.pyx":13306
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13306; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.var", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_533vdot(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_532vdot[] = "Return the dot product of two vectors.\n\n    The vdot(`a`, `b`) function handles complex numbers differently than\n    dot(`a`, `b`).  If the first argument is complex the complex conjugate\n    of the first argument is used for the calculation of the dot product.\n\n    Note that `vdot` handles multidimensional arrays differently than `dot`:\n    it does *not* perform a matrix product, but flattens input arguments\n    to 1-D vectors first. Consequently, it should only be used for vectors.\n\n    Parameters\n    ----------\n    a : array_like\n        If `a` is complex the complex conjugate is taken before calculation\n        of the dot product.\n    b : array_like\n        Second argument to the dot product.\n\n    Returns\n    -------\n    output : ndarray\n        Dot product of `a` and `b`.  Can be an int, float, or\n        complex depending on the types of `a` and `b`.\n\n    See Also\n    --------\n    dot : Return the dot product without using the complex conjugate of the\n          first argument.\n\n    Examples\n    --------\n    >>> a = np.array([1+2j,3+4j])\n    >>> b = np.array([5+6j,7+8j])\n    >>> np.vdot(a, b)\n    (70-8j)\n    >>> np.vdot(b, a)\n    (70+8j)\n\n    Note that higher-dimensional arrays are flattened!\n\n    >>> a = np.array([[1, 4], [5, 6]])\n    >>> b = np.array([[4, 1], [2, 2]])\n    >>> np.vdot(a, b)\n    30\n    >>> np.vdot(b, a)\n    30\n    >>> 1*4 + 4*1 + 5*2 + 6*2\n    30\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_533vdot = {__Pyx_NAMESTR("vdot"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_533vdot, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_532vdot)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_533vdot(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("vdot (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_532vdot(__pyx_self);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":13309
 * 
 * 
 * def vdot():             # <<<<<<<<<<<<<<
 *     """Return the dot product of two vectors.
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_532vdot(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("vdot", 0);

  /* "ga4py/gain/notimplemented.pyx":13361
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13361; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.vdot", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_535vsplit(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_534vsplit[] = "Split an array into multiple sub-arrays vertically (row-wise).\n\n    Please refer to the ``split`` documentation.  ``vsplit`` is equivalent\n    to ``split`` with `axis=0` (default), the array is always split along the\n    first axis regardless of the array dimension.\n\n    See Also\n    --------\n    split : Split an array into multiple sub-arrays of equal size.\n\n    Examples\n    --------\n    >>> x = np.arange(16.0).reshape(4, 4)\n    >>> x\n    array([[  0.,   1.,   2.,   3.],\n           [  4.,   5.,   6.,   7.],\n           [  8.,   9.,  10.,  11.],\n           [ 12.,  13.,  14.,  15.]])\n    >>> np.vsplit(x, 2)\n    [array([[ 0.,  1.,  2.,  3.],\n           [ 4.,  5.,  6.,  7.]]),\n     array([[  8.,   9.,  10.,  11.],\n           [ 12.,  13.,  14.,  15.]])]\n    >>> np.vsplit(x, np.array([3, 6]))\n    [array([[  0.,   1.,   2.,   3.],\n           [  4.,   5.,   6.,   7.],\n           [  8.,   9.,  10.,  11.]]),\n     array([[ 12.,  13.,  14.,  15.]]),\n     array([], dtype=float64)]\n\n    With a higher dimensional array the split is still along the first axis.\n\n    >>> x = np.arange(8.0).reshape(2, 2, 2)\n    >>> x\n    array([[[ 0.,  1.],\n            [ 2.,  3.]],\n           [[ 4.,  5.],\n            [ 6.,  7.]]])\n    >>> np.vsplit(x, 2)\n    [array([[[ 0.,  1.],\n            [ 2.,  3.]]]),\n     array([[[ 4.,  5.],\n            [ 6.,  7.]]])]\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_535vsplit = {__Pyx_NAMESTR("vsplit"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_535vsplit, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_534vsplit)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_535vsplit(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_ary = 0;
  CYTHON_UNUSED PyObject *__pyx_v_indices_or_sections = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("vsplit (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__ary,&__pyx_n_s__indices_or_sections,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__ary)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__indices_or_sections)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("vsplit", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13364; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "vsplit") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13364; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_ary = values[0];
    __pyx_v_indices_or_sections = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("vsplit", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13364; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.vsplit", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_534vsplit(__pyx_self, __pyx_v_ary, __pyx_v_indices_or_sections);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":13364
 * 
 * 
 * def vsplit(ary, indices_or_sections):             # <<<<<<<<<<<<<<
 *     """Split an array into multiple sub-arrays vertically (row-wise).
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_534vsplit(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_ary, CYTHON_UNUSED PyObject *__pyx_v_indices_or_sections) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("vsplit", 0);

  /* "ga4py/gain/notimplemented.pyx":13410
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13410; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.vsplit", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_537vstack(PyObject *__pyx_self, PyObject *__pyx_v_tup); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_536vstack[] = "Stack arrays in sequence vertically (row wise).\n\n    Take a sequence of arrays and stack them vertically to make a single\n    array. Rebuild arrays divided by `vsplit`.\n\n    Parameters\n    ----------\n    tup : sequence of ndarrays\n        Tuple containing arrays to be stacked. The arrays must have the same\n        shape along all but the first axis.\n\n    Returns\n    -------\n    stacked : ndarray\n        The array formed by stacking the given arrays.\n\n    See Also\n    --------\n    hstack : Stack arrays in sequence horizontally (column wise).\n    dstack : Stack arrays in sequence depth wise (along third dimension).\n    concatenate : Join a sequence of arrays together.\n    vsplit : Split array into a list of multiple sub-arrays vertically.\n\n\n    Notes\n    -----\n    Equivalent to ``np.concatenate(tup, axis=0)``\n\n    Examples\n    --------\n    >>> a = np.array([1, 2, 3])\n    >>> b = np.array([2, 3, 4])\n    >>> np.vstack((a,b))\n    array([[1, 2, 3],\n           [2, 3, 4]])\n\n    >>> a = np.array([[1], [2], [3]])\n    >>> b = np.array([[2], [3], [4]])\n    >>> np.vstack((a,b))\n    array([[1],\n           [2],\n           [3],\n           [2],\n           [3],\n           [4]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_537vstack = {__Pyx_NAMESTR("vstack"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_537vstack, METH_O, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_536vstack)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_537vstack(PyObject *__pyx_self, PyObject *__pyx_v_tup) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("vstack (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_536vstack(__pyx_self, ((PyObject *)__pyx_v_tup));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":13413
 * 
 * 
 * def vstack(tup):             # <<<<<<<<<<<<<<
 *     """Stack arrays in sequence vertically (row wise).
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_536vstack(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_tup) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("vstack", 0);

  /* "ga4py/gain/notimplemented.pyx":13461
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13461; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.vstack", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_539where(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_538where[] = "where(condition, [x, y])\n\n    Return elements, either from `x` or `y`, depending on `condition`.\n\n    If only `condition` is given, return ``condition.nonzero()``.\n\n    Parameters\n    ----------\n    condition : array_like, bool\n        When True, yield `x`, otherwise yield `y`.\n    x, y : array_like, optional\n        Values from which to choose. `x` and `y` need to have the same\n        shape as `condition`.\n\n    Returns\n    -------\n    out : ndarray or tuple of ndarrays\n        If both `x` and `y` are specified, the output array contains\n        elements of `x` where `condition` is True, and elements from\n        `y` elsewhere.\n\n        If only `condition` is given, return the tuple\n        ``condition.nonzero()``, the indices where `condition` is True.\n\n    See Also\n    --------\n    nonzero, choose\n\n    Notes\n    -----\n    If `x` and `y` are given and input arrays are 1-D, `where` is\n    equivalent to::\n\n        [xv if c else yv for (c,xv,yv) in zip(condition,x,y)]\n\n    Examples\n    --------\n    >>> np.where([[True, False], [True, True]],\n    ...          [[1, 2], [3, 4]],\n    ...          [[9, 8], [7, 6]])\n    array([[1, 8],\n           [3, 4]])\n\n    >>> np.where([[0, 1], [1, 0]])\n    (array([0, 1]), array([1, 0]))\n\n    >>> x = np.arange(9.).reshape(3, 3)\n    >>> np.where( x > 5 )\n    (array([2, 2, 2]), array([0, 1, 2]))\n    >>> x[np.where( x > 3.0 )]               # Note: result is 1D.\n    array([ 4.,  5.,  6.,  7.,  8.])\n    >>> np.where(x < 5, x, -1)               # Note: broadcasting.\n    array([[ 0.,  1.,  2.],\n           [ 3.,  4., -1.],\n           [-1., -1., -1.]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_539where = {__Pyx_NAMESTR("where"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_539where, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_538where)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_539where(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("where (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_538where(__pyx_self);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":13464
 * 
 * 
 * def where():             # <<<<<<<<<<<<<<
 *     """where(condition, [x, y])
 * 
 */

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_538where(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("where", 0);

  /* "ga4py/gain/notimplemented.pyx":13523
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13523; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.where", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_541who(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_540who[] = "Print the Numpy arrays in the given dictionary.\n\n    If there is no dictionary passed in or `vardict` is None then returns\n    Numpy arrays in the globals() dictionary (all Numpy arrays in the\n    namespace).\n\n    Parameters\n    ----------\n    vardict : dict, optional\n        A dictionary possibly containing ndarrays.  Default is globals().\n\n    Returns\n    -------\n    out : None\n        Returns 'None'.\n\n    Notes\n    -----\n    Prints out the name, shape, bytes and type of all of the ndarrays present\n    in `vardict`.\n\n    Examples\n    --------\n    >>> a = np.arange(10)\n    >>> b = np.ones(20)\n    >>> np.who()\n    Name            Shape            Bytes            Type\n    ===========================================================\n    a               10               40               int32\n    b               20               160              float64\n    Upper bound on total bytes  =       200\n\n    >>> d = {'x': np.arange(2.0), 'y': np.arange(3.0), 'txt': 'Some str',\n    ... 'idx':5}\n    >>> np.who(d)\n    Name            Shape            Bytes            Type\n    ===========================================================\n    y               3                24               float64\n    x               2                16               float64\n    Upper bound on total bytes  =       40\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_541who = {__Pyx_NAMESTR("who"), (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_541who, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5ga4py_4gain_14notimplemented_540who)};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_541who(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_vardict = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("who (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__vardict,0};
    PyObject* values[1] = {0};

    /* "ga4py/gain/notimplemented.pyx":13526
 * 
 * 
 * def who(vardict=None):             # <<<<<<<<<<<<<<
 *     """Print the Numpy arrays in the given dictionary.
 * 
 */
    values[0] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__vardict);
          if (value) { values[0] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "who") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13526; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_vardict = values[0];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("who", 0, 0, 1, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13526; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.who", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_540who(__pyx_self, __pyx_v_vardict);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_540who(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_vardict) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("who", 0);

  /* "ga4py/gain/notimplemented.pyx":13569
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13569; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.who", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static CYTHON_UNUSED int __pyx_pw_5numpy_7ndarray_1__getbuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /*proto*/
static CYTHON_UNUSED int __pyx_pw_5numpy_7ndarray_1__getbuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__getbuffer__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5numpy_7ndarray___getbuffer__(((PyArrayObject *)__pyx_v_self), ((Py_buffer *)__pyx_v_info), ((int)__pyx_v_flags));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "numpy.pxd":194
 *         # experimental exception made for __getbuffer__ and __releasebuffer__
 *         # -- the details of this may change.
 *         def __getbuffer__(ndarray self, Py_buffer* info, int flags):             # <<<<<<<<<<<<<<
 *             # This implementation of getbuffer is geared towards Cython
 *             # requirements, and does not yet fullfill the PEP.
 */

static int __pyx_pf_5numpy_7ndarray___getbuffer__(PyArrayObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags) {
  int __pyx_v_copy_shape;
  int __pyx_v_i;
  int __pyx_v_ndim;
  int __pyx_v_endian_detector;
  int __pyx_v_little_endian;
  int __pyx_v_t;
  char *__pyx_v_f;
  PyArray_Descr *__pyx_v_descr = 0;
  int __pyx_v_offset;
  int __pyx_v_hasfields;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  int __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  int __pyx_t_6;
  int __pyx_t_7;
  PyObject *__pyx_t_8 = NULL;
  char *__pyx_t_9;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__getbuffer__", 0);
  if (__pyx_v_info != NULL) {
    __pyx_v_info->obj = Py_None; __Pyx_INCREF(Py_None);
    __Pyx_GIVEREF(__pyx_v_info->obj);
  }

  /* "numpy.pxd":200
 *             # of flags
 * 
 *             if info == NULL: return             # <<<<<<<<<<<<<<
 * 
 *             cdef int copy_shape, i, ndim
 */
  __pyx_t_1 = ((__pyx_v_info == NULL) != 0);
  if (__pyx_t_1) {
    __pyx_r = 0;
    goto __pyx_L0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "numpy.pxd":203
 * 
 *             cdef int copy_shape, i, ndim
 *             cdef int endian_detector = 1             # <<<<<<<<<<<<<<
 *             cdef bint little_endian = ((<char*>&endian_detector)[0] != 0)
 * 
 */
  __pyx_v_endian_detector = 1;

  /* "numpy.pxd":204
 *             cdef int copy_shape, i, ndim
 *             cdef int endian_detector = 1
 *             cdef bint little_endian = ((<char*>&endian_detector)[0] != 0)             # <<<<<<<<<<<<<<
 * 
 *             ndim = PyArray_NDIM(self)
 */
  __pyx_v_little_endian = ((((char *)(&__pyx_v_endian_detector))[0]) != 0);

  /* "numpy.pxd":206
 *             cdef bint little_endian = ((<char*>&endian_detector)[0] != 0)
 * 
 *             ndim = PyArray_NDIM(self)             # <<<<<<<<<<<<<<
 * 
 *             if sizeof(npy_intp) != sizeof(Py_ssize_t):
 */
  __pyx_v_ndim = PyArray_NDIM(__pyx_v_self);

  /* "numpy.pxd":208
 *             ndim = PyArray_NDIM(self)
 * 
 *             if sizeof(npy_intp) != sizeof(Py_ssize_t):             # <<<<<<<<<<<<<<
 *                 copy_shape = 1
 *             else:
 */
  __pyx_t_1 = (((sizeof(npy_intp)) != (sizeof(Py_ssize_t))) != 0);
  if (__pyx_t_1) {

    /* "numpy.pxd":209
 * 
 *             if sizeof(npy_intp) != sizeof(Py_ssize_t):
 *                 copy_shape = 1             # <<<<<<<<<<<<<<
 *             else:
 *                 copy_shape = 0
 */
    __pyx_v_copy_shape = 1;
    goto __pyx_L4;
  }
  /*else*/ {

    /* "numpy.pxd":211
 *                 copy_shape = 1
 *             else:
 *                 copy_shape = 0             # <<<<<<<<<<<<<<
 * 
 *             if ((flags & pybuf.PyBUF_C_CONTIGUOUS == pybuf.PyBUF_C_CONTIGUOUS)
 */
    __pyx_v_copy_shape = 0;
  }
  __pyx_L4:;

  /* "numpy.pxd":213
 *                 copy_shape = 0
 * 
 *             if ((flags & pybuf.PyBUF_C_CONTIGUOUS == pybuf.PyBUF_C_CONTIGUOUS)             # <<<<<<<<<<<<<<
 *                 and not PyArray_CHKFLAGS(self, NPY_C_CONTIGUOUS)):
 *                 raise ValueError(u"ndarray is not C contiguous")
 */
  __pyx_t_1 = (((__pyx_v_flags & PyBUF_C_CONTIGUOUS) == PyBUF_C_CONTIGUOUS) != 0);
  if (__pyx_t_1) {

    /* "numpy.pxd":214
 * 
 *             if ((flags & pybuf.PyBUF_C_CONTIGUOUS == pybuf.PyBUF_C_CONTIGUOUS)
 *                 and not PyArray_CHKFLAGS(self, NPY_C_CONTIGUOUS)):             # <<<<<<<<<<<<<<
 *                 raise ValueError(u"ndarray is not C contiguous")
 * 
 */
    __pyx_t_2 = ((!(PyArray_CHKFLAGS(__pyx_v_self, NPY_C_CONTIGUOUS) != 0)) != 0);
    __pyx_t_3 = __pyx_t_2;
  } else {
    __pyx_t_3 = __pyx_t_1;
  }
  if (__pyx_t_3) {

    /* "numpy.pxd":215
 *             if ((flags & pybuf.PyBUF_C_CONTIGUOUS == pybuf.PyBUF_C_CONTIGUOUS)
 *                 and not PyArray_CHKFLAGS(self, NPY_C_CONTIGUOUS)):
 *                 raise ValueError(u"ndarray is not C contiguous")             # <<<<<<<<<<<<<<
 * 
 *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)
 */
    __pyx_t_4 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_k_tuple_54), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 215; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    {__pyx_filename = __pyx_f[1]; __pyx_lineno = 215; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "numpy.pxd":217
 *                 raise ValueError(u"ndarray is not C contiguous")
 * 
 *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)             # <<<<<<<<<<<<<<
 *                 and not PyArray_CHKFLAGS(self, NPY_F_CONTIGUOUS)):
 *                 raise ValueError(u"ndarray is not Fortran contiguous")
 */
  __pyx_t_3 = (((__pyx_v_flags & PyBUF_F_CONTIGUOUS) == PyBUF_F_CONTIGUOUS) != 0);
  if (__pyx_t_3) {

    /* "numpy.pxd":218
 * 
 *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)
 *                 and not PyArray_CHKFLAGS(self, NPY_F_CONTIGUOUS)):             # <<<<<<<<<<<<<<
 *                 raise ValueError(u"ndarray is not Fortran contiguous")
 * 
 */
    __pyx_t_1 = ((!(PyArray_CHKFLAGS(__pyx_v_self, NPY_F_CONTIGUOUS) != 0)) != 0);
    __pyx_t_2 = __pyx_t_1;
  } else {
    __pyx_t_2 = __pyx_t_3;
  }
  if (__pyx_t_2) {

    /* "numpy.pxd":219
 *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)
 *                 and not PyArray_CHKFLAGS(self, NPY_F_CONTIGUOUS)):
 *                 raise ValueError(u"ndarray is not Fortran contiguous")             # <<<<<<<<<<<<<<
 * 
 *             info.buf = PyArray_DATA(self)
 */
    __pyx_t_4 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_k_tuple_56), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 219; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    {__pyx_filename = __pyx_f[1]; __pyx_lineno = 219; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "numpy.pxd":221
 *                 raise ValueError(u"ndarray is not Fortran contiguous")
 * 
 *             info.buf = PyArray_DATA(self)             # <<<<<<<<<<<<<<
 *             info.ndim = ndim
 *             if copy_shape:
 */
  __pyx_v_info->buf = PyArray_DATA(__pyx_v_self);

  /* "numpy.pxd":222
 * 
 *             info.buf = PyArray_DATA(self)
 *             info.ndim = ndim             # <<<<<<<<<<<<<<
 *             if copy_shape:
 *                 # Allocate new buffer for strides and shape info.
 */
  __pyx_v_info->ndim = __pyx_v_ndim;

  /* "numpy.pxd":223
 *             info.buf = PyArray_DATA(self)
 *             info.ndim = ndim
 *             if copy_shape:             # <<<<<<<<<<<<<<
 *                 # Allocate new buffer for strides and shape info.
 *                 # This is allocated as one block, strides first.
 */
  __pyx_t_2 = (__pyx_v_copy_shape != 0);
  if (__pyx_t_2) {

    /* "numpy.pxd":226
 *                 # Allocate new buffer for strides and shape info.
 *                 # This is allocated as one block, strides first.
 *                 info.strides = <Py_ssize_t*>stdlib.malloc(sizeof(Py_ssize_t) * <size_t>ndim * 2)             # <<<<<<<<<<<<<<
 *                 info.shape = info.strides + ndim
 *                 for i in range(ndim):
 */
    __pyx_v_info->strides = ((Py_ssize_t *)malloc((((sizeof(Py_ssize_t)) * ((size_t)__pyx_v_ndim)) * 2)));

    /* "numpy.pxd":227
 *                 # This is allocated as one block, strides first.
 *                 info.strides = <Py_ssize_t*>stdlib.malloc(sizeof(Py_ssize_t) * <size_t>ndim * 2)
 *                 info.shape = info.strides + ndim             # <<<<<<<<<<<<<<
 *                 for i in range(ndim):
 *                     info.strides[i] = PyArray_STRIDES(self)[i]
 */
    __pyx_v_info->shape = (__pyx_v_info->strides + __pyx_v_ndim);

    /* "numpy.pxd":228
 *                 info.strides = <Py_ssize_t*>stdlib.malloc(sizeof(Py_ssize_t) * <size_t>ndim * 2)
 *                 info.shape = info.strides + ndim
 *                 for i in range(ndim):             # <<<<<<<<<<<<<<
 *                     info.strides[i] = PyArray_STRIDES(self)[i]
 *                     info.shape[i] = PyArray_DIMS(self)[i]
 */
    __pyx_t_5 = __pyx_v_ndim;
    for (__pyx_t_6 = 0; __pyx_t_6 < __pyx_t_5; __pyx_t_6+=1) {
      __pyx_v_i = __pyx_t_6;

      /* "numpy.pxd":229
 *                 info.shape = info.strides + ndim
 *                 for i in range(ndim):
 *                     info.strides[i] = PyArray_STRIDES(self)[i]             # <<<<<<<<<<<<<<
 *                     info.shape[i] = PyArray_DIMS(self)[i]
 *             else:
 */
      (__pyx_v_info->strides[__pyx_v_i]) = (PyArray_STRIDES(__pyx_v_self)[__pyx_v_i]);

      /* "numpy.pxd":230
 *                 for i in range(ndim):
 *                     info.strides[i] = PyArray_STRIDES(self)[i]
 *                     info.shape[i] = PyArray_DIMS(self)[i]             # <<<<<<<<<<<<<<
 *             else:
 *                 info.strides = <Py_ssize_t*>PyArray_STRIDES(self)
 */
      (__pyx_v_info->shape[__pyx_v_i]) = (PyArray_DIMS(__pyx_v_self)[__pyx_v_i]);
    }
    goto __pyx_L7;
  }
  /*else*/ {

    /* "numpy.pxd":232
 *                     info.shape[i] = PyArray_DIMS(self)[i]
 *             else:
 *                 info.strides = <Py_ssize_t*>PyArray_STRIDES(self)             # <<<<<<<<<<<<<<
 *                 info.shape = <Py_ssize_t*>PyArray_DIMS(self)
 *             info.suboffsets = NULL
 */
    __pyx_v_info->strides = ((Py_ssize_t *)PyArray_STRIDES(__pyx_v_self));

    /* "numpy.pxd":233
 *             else:
 *                 info.strides = <Py_ssize_t*>PyArray_STRIDES(self)
 *                 info.shape = <Py_ssize_t*>PyArray_DIMS(self)             # <<<<<<<<<<<<<<
 *             info.suboffsets = NULL
 *             info.itemsize = PyArray_ITEMSIZE(self)
 */
    __pyx_v_info->shape = ((Py_ssize_t *)PyArray_DIMS(__pyx_v_self));
  }
  __pyx_L7:;

  /* "numpy.pxd":234
 *                 info.strides = <Py_ssize_t*>PyArray_STRIDES(self)
 *                 info.shape = <Py_ssize_t*>PyArray_DIMS(self)
 *             info.suboffsets = NULL             # <<<<<<<<<<<<<<
 *             info.itemsize = PyArray_ITEMSIZE(self)
 *             info.readonly = not PyArray_ISWRITEABLE(self)
 */
  __pyx_v_info->suboffsets = NULL;

  /* "numpy.pxd":235
 *                 info.shape = <Py_ssize_t*>PyArray_DIMS(self)
 *             info.suboffsets = NULL
 *             info.itemsize = PyArray_ITEMSIZE(self)             # <<<<<<<<<<<<<<
 *             info.readonly = not PyArray_ISWRITEABLE(self)
 * 
 */
  __pyx_v_info->itemsize = PyArray_ITEMSIZE(__pyx_v_self);

  /* "numpy.pxd":236
 *             info.suboffsets = NULL
 *             info.itemsize = PyArray_ITEMSIZE(self)
 *             info.readonly = not PyArray_ISWRITEABLE(self)             # <<<<<<<<<<<<<<
 * 
 *             cdef int t
 */
  __pyx_v_info->readonly = (!(PyArray_ISWRITEABLE(__pyx_v_self) != 0));

  /* "numpy.pxd":239
 * 
 *             cdef int t
 *             cdef char* f = NULL             # <<<<<<<<<<<<<<
 *             cdef dtype descr = self.descr
 *             cdef list stack
 */
  __pyx_v_f = NULL;

  /* "numpy.pxd":240
 *             cdef int t
 *             cdef char* f = NULL
 *             cdef dtype descr = self.descr             # <<<<<<<<<<<<<<
 *             cdef list stack
 *             cdef int offset
 */
  __pyx_t_4 = ((PyObject *)__pyx_v_self->descr);
  __Pyx_INCREF(__pyx_t_4);
  __pyx_v_descr = ((PyArray_Descr *)__pyx_t_4);
  __pyx_t_4 = 0;

  /* "numpy.pxd":244
 *             cdef int offset
 * 
 *             cdef bint hasfields = PyDataType_HASFIELDS(descr)             # <<<<<<<<<<<<<<
 * 
 *             if not hasfields and not copy_shape:
 */
  __pyx_v_hasfields = PyDataType_HASFIELDS(__pyx_v_descr);

  /* "numpy.pxd":246
 *             cdef bint hasfields = PyDataType_HASFIELDS(descr)
 * 
 *             if not hasfields and not copy_shape:             # <<<<<<<<<<<<<<
 *                 # do not call releasebuffer
 *                 info.obj = None
 */
  __pyx_t_2 = ((!(__pyx_v_hasfields != 0)) != 0);
  if (__pyx_t_2) {
    __pyx_t_3 = ((!(__pyx_v_copy_shape != 0)) != 0);
    __pyx_t_1 = __pyx_t_3;
  } else {
    __pyx_t_1 = __pyx_t_2;
  }
  if (__pyx_t_1) {

    /* "numpy.pxd":248
 *             if not hasfields and not copy_shape:
 *                 # do not call releasebuffer
 *                 info.obj = None             # <<<<<<<<<<<<<<
 *             else:
 *                 # need to call releasebuffer
 */
    __Pyx_INCREF(Py_None);
    __Pyx_GIVEREF(Py_None);
    __Pyx_GOTREF(__pyx_v_info->obj);
    __Pyx_DECREF(__pyx_v_info->obj);
    __pyx_v_info->obj = Py_None;
    goto __pyx_L10;
  }
  /*else*/ {

    /* "numpy.pxd":251
 *             else:
 *                 # need to call releasebuffer
 *                 info.obj = self             # <<<<<<<<<<<<<<
 * 
 *             if not hasfields:
 */
    __Pyx_INCREF(((PyObject *)__pyx_v_self));
    __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
    __Pyx_GOTREF(__pyx_v_info->obj);
    __Pyx_DECREF(__pyx_v_info->obj);
    __pyx_v_info->obj = ((PyObject *)__pyx_v_self);
  }
  __pyx_L10:;

  /* "numpy.pxd":253
 *                 info.obj = self
 * 
 *             if not hasfields:             # <<<<<<<<<<<<<<
 *                 t = descr.type_num
 *                 if ((descr.byteorder == c'>' and little_endian) or
 */
  __pyx_t_1 = ((!(__pyx_v_hasfields != 0)) != 0);
  if (__pyx_t_1) {

    /* "numpy.pxd":254
 * 
 *             if not hasfields:
 *                 t = descr.type_num             # <<<<<<<<<<<<<<
 *                 if ((descr.byteorder == c'>' and little_endian) or
 *                     (descr.byteorder == c'<' and not little_endian)):
 */
    __pyx_t_5 = __pyx_v_descr->type_num;
    __pyx_v_t = __pyx_t_5;

    /* "numpy.pxd":255
 *             if not hasfields:
 *                 t = descr.type_num
 *                 if ((descr.byteorder == c'>' and little_endian) or             # <<<<<<<<<<<<<<
 *                     (descr.byteorder == c'<' and not little_endian)):
 *                     raise ValueError(u"Non-native byte order not supported")
 */
    __pyx_t_1 = ((__pyx_v_descr->byteorder == '>') != 0);
    if (__pyx_t_1) {
      __pyx_t_2 = (__pyx_v_little_endian != 0);
    } else {
      __pyx_t_2 = __pyx_t_1;
    }
    if (!__pyx_t_2) {

      /* "numpy.pxd":256
 *                 t = descr.type_num
 *                 if ((descr.byteorder == c'>' and little_endian) or
 *                     (descr.byteorder == c'<' and not little_endian)):             # <<<<<<<<<<<<<<
 *                     raise ValueError(u"Non-native byte order not supported")
 *                 if   t == NPY_BYTE:        f = "b"
 */
      __pyx_t_1 = ((__pyx_v_descr->byteorder == '<') != 0);
      if (__pyx_t_1) {
        __pyx_t_3 = ((!(__pyx_v_little_endian != 0)) != 0);
        __pyx_t_7 = __pyx_t_3;
      } else {
        __pyx_t_7 = __pyx_t_1;
      }
      __pyx_t_1 = __pyx_t_7;
    } else {
      __pyx_t_1 = __pyx_t_2;
    }
    if (__pyx_t_1) {

      /* "numpy.pxd":257
 *                 if ((descr.byteorder == c'>' and little_endian) or
 *                     (descr.byteorder == c'<' and not little_endian)):
 *                     raise ValueError(u"Non-native byte order not supported")             # <<<<<<<<<<<<<<
 *                 if   t == NPY_BYTE:        f = "b"
 *                 elif t == NPY_UBYTE:       f = "B"
 */
      __pyx_t_4 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_k_tuple_58), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 257; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_Raise(__pyx_t_4, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      {__pyx_filename = __pyx_f[1]; __pyx_lineno = 257; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      goto __pyx_L12;
    }
    __pyx_L12:;

    /* "numpy.pxd":274
 *                 elif t == NPY_CDOUBLE:     f = "Zd"
 *                 elif t == NPY_CLONGDOUBLE: f = "Zg"
 *                 elif t == NPY_OBJECT:      f = "O"             # <<<<<<<<<<<<<<
 *                 else:
 *                     raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)
 */
    switch (__pyx_v_t) {

      /* "numpy.pxd":258
 *                     (descr.byteorder == c'<' and not little_endian)):
 *                     raise ValueError(u"Non-native byte order not supported")
 *                 if   t == NPY_BYTE:        f = "b"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_UBYTE:       f = "B"
 *                 elif t == NPY_SHORT:       f = "h"
 */
      case NPY_BYTE:
      __pyx_v_f = __pyx_k__b;
      break;

      /* "numpy.pxd":259
 *                     raise ValueError(u"Non-native byte order not supported")
 *                 if   t == NPY_BYTE:        f = "b"
 *                 elif t == NPY_UBYTE:       f = "B"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_SHORT:       f = "h"
 *                 elif t == NPY_USHORT:      f = "H"
 */
      case NPY_UBYTE:
      __pyx_v_f = __pyx_k__B;
      break;

      /* "numpy.pxd":260
 *                 if   t == NPY_BYTE:        f = "b"
 *                 elif t == NPY_UBYTE:       f = "B"
 *                 elif t == NPY_SHORT:       f = "h"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_USHORT:      f = "H"
 *                 elif t == NPY_INT:         f = "i"
 */
      case NPY_SHORT:
      __pyx_v_f = __pyx_k__h;
      break;

      /* "numpy.pxd":261
 *                 elif t == NPY_UBYTE:       f = "B"
 *                 elif t == NPY_SHORT:       f = "h"
 *                 elif t == NPY_USHORT:      f = "H"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_INT:         f = "i"
 *                 elif t == NPY_UINT:        f = "I"
 */
      case NPY_USHORT:
      __pyx_v_f = __pyx_k__H;
      break;

      /* "numpy.pxd":262
 *                 elif t == NPY_SHORT:       f = "h"
 *                 elif t == NPY_USHORT:      f = "H"
 *                 elif t == NPY_INT:         f = "i"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_UINT:        f = "I"
 *                 elif t == NPY_LONG:        f = "l"
 */
      case NPY_INT:
      __pyx_v_f = __pyx_k__i;
      break;

      /* "numpy.pxd":263
 *                 elif t == NPY_USHORT:      f = "H"
 *                 elif t == NPY_INT:         f = "i"
 *                 elif t == NPY_UINT:        f = "I"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_LONG:        f = "l"
 *                 elif t == NPY_ULONG:       f = "L"
 */
      case NPY_UINT:
      __pyx_v_f = __pyx_k__I;
      break;

      /* "numpy.pxd":264
 *                 elif t == NPY_INT:         f = "i"
 *                 elif t == NPY_UINT:        f = "I"
 *                 elif t == NPY_LONG:        f = "l"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_ULONG:       f = "L"
 *                 elif t == NPY_LONGLONG:    f = "q"
 */
      case NPY_LONG:
      __pyx_v_f = __pyx_k__l;
      break;

      /* "numpy.pxd":265
 *                 elif t == NPY_UINT:        f = "I"
 *                 elif t == NPY_LONG:        f = "l"
 *                 elif t == NPY_ULONG:       f = "L"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_LONGLONG:    f = "q"
 *                 elif t == NPY_ULONGLONG:   f = "Q"
 */
      case NPY_ULONG:
      __pyx_v_f = __pyx_k__L;
      break;

      /* "numpy.pxd":266
 *                 elif t == NPY_LONG:        f = "l"
 *                 elif t == NPY_ULONG:       f = "L"
 *                 elif t == NPY_LONGLONG:    f = "q"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_ULONGLONG:   f = "Q"
 *                 elif t == NPY_FLOAT:       f = "f"
 */
      case NPY_LONGLONG:
      __pyx_v_f = __pyx_k__q;
      break;

      /* "numpy.pxd":267
 *                 elif t == NPY_ULONG:       f = "L"
 *                 elif t == NPY_LONGLONG:    f = "q"
 *                 elif t == NPY_ULONGLONG:   f = "Q"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_FLOAT:       f = "f"
 *                 elif t == NPY_DOUBLE:      f = "d"
 */
      case NPY_ULONGLONG:
      __pyx_v_f = __pyx_k__Q;
      break;

      /* "numpy.pxd":268
 *                 elif t == NPY_LONGLONG:    f = "q"
 *                 elif t == NPY_ULONGLONG:   f = "Q"
 *                 elif t == NPY_FLOAT:       f = "f"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_DOUBLE:      f = "d"
 *                 elif t == NPY_LONGDOUBLE:  f = "g"
 */
      case NPY_FLOAT:
      __pyx_v_f = __pyx_k__f;
      break;

      /* "numpy.pxd":269
 *                 elif t == NPY_ULONGLONG:   f = "Q"
 *                 elif t == NPY_FLOAT:       f = "f"
 *                 elif t == NPY_DOUBLE:      f = "d"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_LONGDOUBLE:  f = "g"
 *                 elif t == NPY_CFLOAT:      f = "Zf"
 */
      case NPY_DOUBLE:
      __pyx_v_f = __pyx_k__d;
      break;

      /* "numpy.pxd":270
 *                 elif t == NPY_FLOAT:       f = "f"
 *                 elif t == NPY_DOUBLE:      f = "d"
 *                 elif t == NPY_LONGDOUBLE:  f = "g"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_CFLOAT:      f = "Zf"
 *                 elif t == NPY_CDOUBLE:     f = "Zd"
 */
      case NPY_LONGDOUBLE:
      __pyx_v_f = __pyx_k__g;
      break;

      /* "numpy.pxd":271
 *                 elif t == NPY_DOUBLE:      f = "d"
 *                 elif t == NPY_LONGDOUBLE:  f = "g"
 *                 elif t == NPY_CFLOAT:      f = "Zf"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_CDOUBLE:     f = "Zd"
 *                 elif t == NPY_CLONGDOUBLE: f = "Zg"
 */
      case NPY_CFLOAT:
      __pyx_v_f = __pyx_k__Zf;
      break;

      /* "numpy.pxd":272
 *                 elif t == NPY_LONGDOUBLE:  f = "g"
 *                 elif t == NPY_CFLOAT:      f = "Zf"
 *                 elif t == NPY_CDOUBLE:     f = "Zd"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_CLONGDOUBLE: f = "Zg"
 *                 elif t == NPY_OBJECT:      f = "O"
 */
      case NPY_CDOUBLE:
      __pyx_v_f = __pyx_k__Zd;
      break;

      /* "numpy.pxd":273
 *                 elif t == NPY_CFLOAT:      f = "Zf"
 *                 elif t == NPY_CDOUBLE:     f = "Zd"
 *                 elif t == NPY_CLONGDOUBLE: f = "Zg"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_OBJECT:      f = "O"
 *                 else:
 */
      case NPY_CLONGDOUBLE:
      __pyx_v_f = __pyx_k__Zg;
      break;

      /* "numpy.pxd":274
 *                 elif t == NPY_CDOUBLE:     f = "Zd"
 *                 elif t == NPY_CLONGDOUBLE: f = "Zg"
 *                 elif t == NPY_OBJECT:      f = "O"             # <<<<<<<<<<<<<<
 *                 else:
 *                     raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)
 */
      case NPY_OBJECT:
      __pyx_v_f = __pyx_k__O;
      break;
      default:

      /* "numpy.pxd":276
 *                 elif t == NPY_OBJECT:      f = "O"
 *                 else:
 *                     raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)             # <<<<<<<<<<<<<<
 *                 info.format = f
 *                 return
 */
      __pyx_t_4 = PyInt_FromLong(__pyx_v_t); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 276; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_t_8 = PyNumber_Remainder(((PyObject *)__pyx_kp_u_59), __pyx_t_4); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 276; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(((PyObject *)__pyx_t_8));
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 276; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_4);
      PyTuple_SET_ITEM(__pyx_t_4, 0, ((PyObject *)__pyx_t_8));
      __Pyx_GIVEREF(((PyObject *)__pyx_t_8));
      __pyx_t_8 = 0;
      __pyx_t_8 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_t_4), NULL); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 276; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_8);
      __Pyx_DECREF(((PyObject *)__pyx_t_4)); __pyx_t_4 = 0;
      __Pyx_Raise(__pyx_t_8, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      {__pyx_filename = __pyx_f[1]; __pyx_lineno = 276; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      break;
    }

    /* "numpy.pxd":277
 *                 else:
 *                     raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)
 *                 info.format = f             # <<<<<<<<<<<<<<
 *                 return
 *             else:
 */
    __pyx_v_info->format = __pyx_v_f;

    /* "numpy.pxd":278
 *                     raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)
 *                 info.format = f
 *                 return             # <<<<<<<<<<<<<<
 *             else:
 *                 info.format = <char*>stdlib.malloc(_buffer_format_string_len)
 */
    __pyx_r = 0;
    goto __pyx_L0;
    goto __pyx_L11;
  }
  /*else*/ {

    /* "numpy.pxd":280
 *                 return
 *             else:
 *                 info.format = <char*>stdlib.malloc(_buffer_format_string_len)             # <<<<<<<<<<<<<<
 *                 info.format[0] = c'^' # Native data types, manual alignment
 *                 offset = 0
 */
    __pyx_v_info->format = ((char *)malloc(255));

    /* "numpy.pxd":281
 *             else:
 *                 info.format = <char*>stdlib.malloc(_buffer_format_string_len)
 *                 info.format[0] = c'^' # Native data types, manual alignment             # <<<<<<<<<<<<<<
 *                 offset = 0
 *                 f = _util_dtypestring(descr, info.format + 1,
 */
    (__pyx_v_info->format[0]) = '^';

    /* "numpy.pxd":282
 *                 info.format = <char*>stdlib.malloc(_buffer_format_string_len)
 *                 info.format[0] = c'^' # Native data types, manual alignment
 *                 offset = 0             # <<<<<<<<<<<<<<
 *                 f = _util_dtypestring(descr, info.format + 1,
 *                                       info.format + _buffer_format_string_len,
 */
    __pyx_v_offset = 0;

    /* "numpy.pxd":285
 *                 f = _util_dtypestring(descr, info.format + 1,
 *                                       info.format + _buffer_format_string_len,
 *                                       &offset)             # <<<<<<<<<<<<<<
 *                 f[0] = c'\0' # Terminate format string
 * 
 */
    __pyx_t_9 = __pyx_f_5numpy__util_dtypestring(__pyx_v_descr, (__pyx_v_info->format + 1), (__pyx_v_info->format + 255), (&__pyx_v_offset)); if (unlikely(__pyx_t_9 == NULL)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 283; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __pyx_v_f = __pyx_t_9;

    /* "numpy.pxd":286
 *                                       info.format + _buffer_format_string_len,
 *                                       &offset)
 *                 f[0] = c'\0' # Terminate format string             # <<<<<<<<<<<<<<
 * 
 *         def __releasebuffer__(ndarray self, Py_buffer* info):
 */
    (__pyx_v_f[0]) = '\x00';
  }
  __pyx_L11:;

  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_AddTraceback("numpy.ndarray.__getbuffer__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  if (__pyx_v_info != NULL && __pyx_v_info->obj != NULL) {
    __Pyx_GOTREF(__pyx_v_info->obj);
    __Pyx_DECREF(__pyx_v_info->obj); __pyx_v_info->obj = NULL;
  }
  goto __pyx_L2;
  __pyx_L0:;
  if (__pyx_v_info != NULL && __pyx_v_info->obj == Py_None) {
    __Pyx_GOTREF(Py_None);
    __Pyx_DECREF(Py_None); __pyx_v_info->obj = NULL;
  }
  __pyx_L2:;
  __Pyx_XDECREF((PyObject *)__pyx_v_descr);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static CYTHON_UNUSED void __pyx_pw_5numpy_7ndarray_3__releasebuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info); /*proto*/
static CYTHON_UNUSED void __pyx_pw_5numpy_7ndarray_3__releasebuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__releasebuffer__ (wrapper)", 0);
  __pyx_pf_5numpy_7ndarray_2__releasebuffer__(((PyArrayObject *)__pyx_v_self), ((Py_buffer *)__pyx_v_info));
  __Pyx_RefNannyFinishContext();
}

/* "numpy.pxd":288
 *                 f[0] = c'\0' # Terminate format string
 * 
 *         def __releasebuffer__(ndarray self, Py_buffer* info):             # <<<<<<<<<<<<<<
 *             if PyArray_HASFIELDS(self):
 *                 stdlib.free(info.format)
 */

static void __pyx_pf_5numpy_7ndarray_2__releasebuffer__(PyArrayObject *__pyx_v_self, Py_buffer *__pyx_v_info) {
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  __Pyx_RefNannySetupContext("__releasebuffer__", 0);

  /* "numpy.pxd":289
 * 
 *         def __releasebuffer__(ndarray self, Py_buffer* info):
 *             if PyArray_HASFIELDS(self):             # <<<<<<<<<<<<<<
 *                 stdlib.free(info.format)
 *             if sizeof(npy_intp) != sizeof(Py_ssize_t):
 */
  __pyx_t_1 = (PyArray_HASFIELDS(__pyx_v_self) != 0);
  if (__pyx_t_1) {

    /* "numpy.pxd":290
 *         def __releasebuffer__(ndarray self, Py_buffer* info):
 *             if PyArray_HASFIELDS(self):
 *                 stdlib.free(info.format)             # <<<<<<<<<<<<<<
 *             if sizeof(npy_intp) != sizeof(Py_ssize_t):
 *                 stdlib.free(info.strides)
 */
    free(__pyx_v_info->format);
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "numpy.pxd":291
 *             if PyArray_HASFIELDS(self):
 *                 stdlib.free(info.format)
 *             if sizeof(npy_intp) != sizeof(Py_ssize_t):             # <<<<<<<<<<<<<<
 *                 stdlib.free(info.strides)
 *                 # info.shape was stored after info.strides in the same block
 */
  __pyx_t_1 = (((sizeof(npy_intp)) != (sizeof(Py_ssize_t))) != 0);
  if (__pyx_t_1) {

    /* "numpy.pxd":292
 *                 stdlib.free(info.format)
 *             if sizeof(npy_intp) != sizeof(Py_ssize_t):
 *                 stdlib.free(info.strides)             # <<<<<<<<<<<<<<
 *                 # info.shape was stored after info.strides in the same block
 * 
 */
    free(__pyx_v_info->strides);
    goto __pyx_L4;
  }
  __pyx_L4:;

  __Pyx_RefNannyFinishContext();
}

/* "numpy.pxd":768
 * ctypedef npy_cdouble     complex_t
 * 
 * cdef inline object PyArray_MultiIterNew1(a):             # <<<<<<<<<<<<<<
 *     return PyArray_MultiIterNew(1, <void*>a)
 * 
 */

static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew1(PyObject *__pyx_v_a) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("PyArray_MultiIterNew1", 0);

  /* "numpy.pxd":769
 * 
 * cdef inline object PyArray_MultiIterNew1(a):
 *     return PyArray_MultiIterNew(1, <void*>a)             # <<<<<<<<<<<<<<
 * 
 * cdef inline object PyArray_MultiIterNew2(a, b):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyArray_MultiIterNew(1, ((void *)__pyx_v_a)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 769; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("numpy.PyArray_MultiIterNew1", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "numpy.pxd":771
 *     return PyArray_MultiIterNew(1, <void*>a)
 * 
 * cdef inline object PyArray_MultiIterNew2(a, b):             # <<<<<<<<<<<<<<
 *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)
 * 
 */

static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew2(PyObject *__pyx_v_a, PyObject *__pyx_v_b) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("PyArray_MultiIterNew2", 0);

  /* "numpy.pxd":772
 * 
 * cdef inline object PyArray_MultiIterNew2(a, b):
 *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)             # <<<<<<<<<<<<<<
 * 
 * cdef inline object PyArray_MultiIterNew3(a, b, c):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyArray_MultiIterNew(2, ((void *)__pyx_v_a), ((void *)__pyx_v_b)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 772; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("numpy.PyArray_MultiIterNew2", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "numpy.pxd":774
 *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)
 * 
 * cdef inline object PyArray_MultiIterNew3(a, b, c):             # <<<<<<<<<<<<<<
 *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)
 * 
 */

static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew3(PyObject *__pyx_v_a, PyObject *__pyx_v_b, PyObject *__pyx_v_c) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("PyArray_MultiIterNew3", 0);

  /* "numpy.pxd":775
 * 
 * cdef inline object PyArray_MultiIterNew3(a, b, c):
 *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)             # <<<<<<<<<<<<<<
 * 
 * cdef inline object PyArray_MultiIterNew4(a, b, c, d):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyArray_MultiIterNew(3, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 775; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("numpy.PyArray_MultiIterNew3", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "numpy.pxd":777
 *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)
 * 
 * cdef inline object PyArray_MultiIterNew4(a, b, c, d):             # <<<<<<<<<<<<<<
 *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)
 * 
 */

static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew4(PyObject *__pyx_v_a, PyObject *__pyx_v_b, PyObject *__pyx_v_c, PyObject *__pyx_v_d) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("PyArray_MultiIterNew4", 0);

  /* "numpy.pxd":778
 * 
 * cdef inline object PyArray_MultiIterNew4(a, b, c, d):
 *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)             # <<<<<<<<<<<<<<
 * 
 * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyArray_MultiIterNew(4, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c), ((void *)__pyx_v_d)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 778; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("numpy.PyArray_MultiIterNew4", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "numpy.pxd":780
 *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)
 * 
 * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):             # <<<<<<<<<<<<<<
 *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)
 * 
 */

static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew5(PyObject *__pyx_v_a, PyObject *__pyx_v_b, PyObject *__pyx_v_c, PyObject *__pyx_v_d, PyObject *__pyx_v_e) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("PyArray_MultiIterNew5", 0);

  /* "numpy.pxd":781
 * 
 * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):
 *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)             # <<<<<<<<<<<<<<
 * 
 * cdef inline char* _util_dtypestring(dtype descr, char* f, char* end, int* offset) except NULL:
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyArray_MultiIterNew(5, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c), ((void *)__pyx_v_d), ((void *)__pyx_v_e)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 781; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("numpy.PyArray_MultiIterNew5", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "numpy.pxd":783
 *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)
 * 
 * cdef inline char* _util_dtypestring(dtype descr, char* f, char* end, int* offset) except NULL:             # <<<<<<<<<<<<<<
 *     # Recursive utility function used in __getbuffer__ to get format
 *     # string. The new location in the format string is returned.
 */

static CYTHON_INLINE char *__pyx_f_5numpy__util_dtypestring(PyArray_Descr *__pyx_v_descr, char *__pyx_v_f, char *__pyx_v_end, int *__pyx_v_offset) {
  PyArray_Descr *__pyx_v_child = 0;
  int __pyx_v_endian_detector;
  int __pyx_v_little_endian;
  PyObject *__pyx_v_fields = 0;
  PyObject *__pyx_v_childname = NULL;
  PyObject *__pyx_v_new_offset = NULL;
  PyObject *__pyx_v_t = NULL;
  char *__pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  Py_ssize_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *(*__pyx_t_6)(PyObject *);
  int __pyx_t_7;
  int __pyx_t_8;
  int __pyx_t_9;
  int __pyx_t_10;
  long __pyx_t_11;
  char *__pyx_t_12;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_util_dtypestring", 0);

  /* "numpy.pxd":790
 *     cdef int delta_offset
 *     cdef tuple i
 *     cdef int endian_detector = 1             # <<<<<<<<<<<<<<
 *     cdef bint little_endian = ((<char*>&endian_detector)[0] != 0)
 *     cdef tuple fields
 */
  __pyx_v_endian_detector = 1;

  /* "numpy.pxd":791
 *     cdef tuple i
 *     cdef int endian_detector = 1
 *     cdef bint little_endian = ((<char*>&endian_detector)[0] != 0)             # <<<<<<<<<<<<<<
 *     cdef tuple fields
 * 
 */
  __pyx_v_little_endian = ((((char *)(&__pyx_v_endian_detector))[0]) != 0);

  /* "numpy.pxd":794
 *     cdef tuple fields
 * 
 *     for childname in descr.names:             # <<<<<<<<<<<<<<
 *         fields = descr.fields[childname]
 *         child, new_offset = fields
 */
  if (unlikely(((PyObject *)__pyx_v_descr->names) == Py_None)) {
    PyErr_SetString(PyExc_TypeError, "'NoneType' object is not iterable");
    {__pyx_filename = __pyx_f[1]; __pyx_lineno = 794; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_t_1 = ((PyObject *)__pyx_v_descr->names); __Pyx_INCREF(__pyx_t_1); __pyx_t_2 = 0;
  for (;;) {
    if (__pyx_t_2 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
    #if CYTHON_COMPILING_IN_CPYTHON
    __pyx_t_3 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_3); __pyx_t_2++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 794; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    #else
    __pyx_t_3 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 794; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    #endif
    __Pyx_XDECREF_SET(__pyx_v_childname, __pyx_t_3);
    __pyx_t_3 = 0;

    /* "numpy.pxd":795
 * 
 *     for childname in descr.names:
 *         fields = descr.fields[childname]             # <<<<<<<<<<<<<<
 *         child, new_offset = fields
 * 
 */
    __pyx_t_3 = PyObject_GetItem(__pyx_v_descr->fields, __pyx_v_childname); if (!__pyx_t_3) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 795; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    if (!(likely(PyTuple_CheckExact(__pyx_t_3))||((__pyx_t_3) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected tuple, got %.200s", Py_TYPE(__pyx_t_3)->tp_name), 0))) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 795; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_XDECREF_SET(__pyx_v_fields, ((PyObject*)__pyx_t_3));
    __pyx_t_3 = 0;

    /* "numpy.pxd":796
 *     for childname in descr.names:
 *         fields = descr.fields[childname]
 *         child, new_offset = fields             # <<<<<<<<<<<<<<
 * 
 *         if (end - f) - (new_offset - offset[0]) < 15:
 */
    if (likely(PyTuple_CheckExact(((PyObject *)__pyx_v_fields)))) {
      PyObject* sequence = ((PyObject *)__pyx_v_fields);
      #if CYTHON_COMPILING_IN_CPYTHON
      Py_ssize_t size = Py_SIZE(sequence);
      #else
      Py_ssize_t size = PySequence_Size(sequence);
      #endif
      if (unlikely(size != 2)) {
        if (size > 2) __Pyx_RaiseTooManyValuesError(2);
        else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
        {__pyx_filename = __pyx_f[1]; __pyx_lineno = 796; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      }
      #if CYTHON_COMPILING_IN_CPYTHON
      __pyx_t_3 = PyTuple_GET_ITEM(sequence, 0); 
      __pyx_t_4 = PyTuple_GET_ITEM(sequence, 1); 
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_4);
      #else
      __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 796; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_4 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 796; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_4);
      #endif
    } else if (1) {
      __Pyx_RaiseNoneNotIterableError(); {__pyx_filename = __pyx_f[1]; __pyx_lineno = 796; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    } else
    {
      Py_ssize_t index = -1;
      __pyx_t_5 = PyObject_GetIter(((PyObject *)__pyx_v_fields)); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 796; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_6 = Py_TYPE(__pyx_t_5)->tp_iternext;
      index = 0; __pyx_t_3 = __pyx_t_6(__pyx_t_5); if (unlikely(!__pyx_t_3)) goto __pyx_L5_unpacking_failed;
      __Pyx_GOTREF(__pyx_t_3);
      index = 1; __pyx_t_4 = __pyx_t_6(__pyx_t_5); if (unlikely(!__pyx_t_4)) goto __pyx_L5_unpacking_failed;
      __Pyx_GOTREF(__pyx_t_4);
      if (__Pyx_IternextUnpackEndCheck(__pyx_t_6(__pyx_t_5), 2) < 0) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 796; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __pyx_t_6 = NULL;
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      goto __pyx_L6_unpacking_done;
      __pyx_L5_unpacking_failed:;
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_6 = NULL;
      if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
      {__pyx_filename = __pyx_f[1]; __pyx_lineno = 796; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __pyx_L6_unpacking_done:;
    }
    if (!(likely(((__pyx_t_3) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_3, __pyx_ptype_5numpy_dtype))))) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 796; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_XDECREF_SET(__pyx_v_child, ((PyArray_Descr *)__pyx_t_3));
    __pyx_t_3 = 0;
    __Pyx_XDECREF_SET(__pyx_v_new_offset, __pyx_t_4);
    __pyx_t_4 = 0;

    /* "numpy.pxd":798
 *         child, new_offset = fields
 * 
 *         if (end - f) - (new_offset - offset[0]) < 15:             # <<<<<<<<<<<<<<
 *             raise RuntimeError(u"Format string allocated too short, see comment in numpy.pxd")
 * 
 */
    __pyx_t_4 = PyInt_FromLong((__pyx_v_end - __pyx_v_f)); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 798; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_3 = PyInt_FromLong((__pyx_v_offset[0])); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 798; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_5 = PyNumber_Subtract(__pyx_v_new_offset, __pyx_t_3); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 798; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_3 = PyNumber_Subtract(__pyx_t_4, __pyx_t_5); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 798; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_5 = PyObject_RichCompare(__pyx_t_3, __pyx_int_15, Py_LT); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 798; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 798; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    if (__pyx_t_7) {

      /* "numpy.pxd":799
 * 
 *         if (end - f) - (new_offset - offset[0]) < 15:
 *             raise RuntimeError(u"Format string allocated too short, see comment in numpy.pxd")             # <<<<<<<<<<<<<<
 * 
 *         if ((child.byteorder == c'>' and little_endian) or
 */
      __pyx_t_5 = PyObject_Call(__pyx_builtin_RuntimeError, ((PyObject *)__pyx_k_tuple_61), NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 799; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_Raise(__pyx_t_5, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      {__pyx_filename = __pyx_f[1]; __pyx_lineno = 799; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      goto __pyx_L7;
    }
    __pyx_L7:;

    /* "numpy.pxd":801
 *             raise RuntimeError(u"Format string allocated too short, see comment in numpy.pxd")
 * 
 *         if ((child.byteorder == c'>' and little_endian) or             # <<<<<<<<<<<<<<
 *             (child.byteorder == c'<' and not little_endian)):
 *             raise ValueError(u"Non-native byte order not supported")
 */
    __pyx_t_7 = ((__pyx_v_child->byteorder == '>') != 0);
    if (__pyx_t_7) {
      __pyx_t_8 = (__pyx_v_little_endian != 0);
    } else {
      __pyx_t_8 = __pyx_t_7;
    }
    if (!__pyx_t_8) {

      /* "numpy.pxd":802
 * 
 *         if ((child.byteorder == c'>' and little_endian) or
 *             (child.byteorder == c'<' and not little_endian)):             # <<<<<<<<<<<<<<
 *             raise ValueError(u"Non-native byte order not supported")
 *             # One could encode it in the format string and have Cython
 */
      __pyx_t_7 = ((__pyx_v_child->byteorder == '<') != 0);
      if (__pyx_t_7) {
        __pyx_t_9 = ((!(__pyx_v_little_endian != 0)) != 0);
        __pyx_t_10 = __pyx_t_9;
      } else {
        __pyx_t_10 = __pyx_t_7;
      }
      __pyx_t_7 = __pyx_t_10;
    } else {
      __pyx_t_7 = __pyx_t_8;
    }
    if (__pyx_t_7) {

      /* "numpy.pxd":803
 *         if ((child.byteorder == c'>' and little_endian) or
 *             (child.byteorder == c'<' and not little_endian)):
 *             raise ValueError(u"Non-native byte order not supported")             # <<<<<<<<<<<<<<
 *             # One could encode it in the format string and have Cython
 *             # complain instead, BUT: < and > in format strings also imply
 */
      __pyx_t_5 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_k_tuple_62), NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 803; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_Raise(__pyx_t_5, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      {__pyx_filename = __pyx_f[1]; __pyx_lineno = 803; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      goto __pyx_L8;
    }
    __pyx_L8:;

    /* "numpy.pxd":813
 * 
 *         # Output padding bytes
 *         while offset[0] < new_offset:             # <<<<<<<<<<<<<<
 *             f[0] = 120 # "x"; pad byte
 *             f += 1
 */
    while (1) {
      __pyx_t_5 = PyInt_FromLong((__pyx_v_offset[0])); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 813; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_3 = PyObject_RichCompare(__pyx_t_5, __pyx_v_new_offset, Py_LT); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 813; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 813; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (!__pyx_t_7) break;

      /* "numpy.pxd":814
 *         # Output padding bytes
 *         while offset[0] < new_offset:
 *             f[0] = 120 # "x"; pad byte             # <<<<<<<<<<<<<<
 *             f += 1
 *             offset[0] += 1
 */
      (__pyx_v_f[0]) = 120;

      /* "numpy.pxd":815
 *         while offset[0] < new_offset:
 *             f[0] = 120 # "x"; pad byte
 *             f += 1             # <<<<<<<<<<<<<<
 *             offset[0] += 1
 * 
 */
      __pyx_v_f = (__pyx_v_f + 1);

      /* "numpy.pxd":816
 *             f[0] = 120 # "x"; pad byte
 *             f += 1
 *             offset[0] += 1             # <<<<<<<<<<<<<<
 * 
 *         offset[0] += child.itemsize
 */
      __pyx_t_11 = 0;
      (__pyx_v_offset[__pyx_t_11]) = ((__pyx_v_offset[__pyx_t_11]) + 1);
    }

    /* "numpy.pxd":818
 *             offset[0] += 1
 * 
 *         offset[0] += child.itemsize             # <<<<<<<<<<<<<<
 * 
 *         if not PyDataType_HASFIELDS(child):
 */
    __pyx_t_11 = 0;
    (__pyx_v_offset[__pyx_t_11]) = ((__pyx_v_offset[__pyx_t_11]) + __pyx_v_child->elsize);

    /* "numpy.pxd":820
 *         offset[0] += child.itemsize
 * 
 *         if not PyDataType_HASFIELDS(child):             # <<<<<<<<<<<<<<
 *             t = child.type_num
 *             if end - f < 5:
 */
    __pyx_t_7 = ((!(PyDataType_HASFIELDS(__pyx_v_child) != 0)) != 0);
    if (__pyx_t_7) {

      /* "numpy.pxd":821
 * 
 *         if not PyDataType_HASFIELDS(child):
 *             t = child.type_num             # <<<<<<<<<<<<<<
 *             if end - f < 5:
 *                 raise RuntimeError(u"Format string allocated too short.")
 */
      __pyx_t_3 = PyInt_FromLong(__pyx_v_child->type_num); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 821; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_XDECREF_SET(__pyx_v_t, __pyx_t_3);
      __pyx_t_3 = 0;

      /* "numpy.pxd":822
 *         if not PyDataType_HASFIELDS(child):
 *             t = child.type_num
 *             if end - f < 5:             # <<<<<<<<<<<<<<
 *                 raise RuntimeError(u"Format string allocated too short.")
 * 
 */
      __pyx_t_7 = (((__pyx_v_end - __pyx_v_f) < 5) != 0);
      if (__pyx_t_7) {

        /* "numpy.pxd":823
 *             t = child.type_num
 *             if end - f < 5:
 *                 raise RuntimeError(u"Format string allocated too short.")             # <<<<<<<<<<<<<<
 * 
 *             # Until ticket #99 is fixed, use integers to avoid warnings
 */
        __pyx_t_3 = PyObject_Call(__pyx_builtin_RuntimeError, ((PyObject *)__pyx_k_tuple_64), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 823; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_Raise(__pyx_t_3, 0, 0, 0);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        {__pyx_filename = __pyx_f[1]; __pyx_lineno = 823; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        goto __pyx_L12;
      }
      __pyx_L12:;

      /* "numpy.pxd":826
 * 
 *             # Until ticket #99 is fixed, use integers to avoid warnings
 *             if   t == NPY_BYTE:        f[0] =  98 #"b"             # <<<<<<<<<<<<<<
 *             elif t == NPY_UBYTE:       f[0] =  66 #"B"
 *             elif t == NPY_SHORT:       f[0] = 104 #"h"
 */
      __pyx_t_3 = PyInt_FromLong(NPY_BYTE); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 826; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 826; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 826; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      if (__pyx_t_7) {
        (__pyx_v_f[0]) = 98;
        goto __pyx_L13;
      }

      /* "numpy.pxd":827
 *             # Until ticket #99 is fixed, use integers to avoid warnings
 *             if   t == NPY_BYTE:        f[0] =  98 #"b"
 *             elif t == NPY_UBYTE:       f[0] =  66 #"B"             # <<<<<<<<<<<<<<
 *             elif t == NPY_SHORT:       f[0] = 104 #"h"
 *             elif t == NPY_USHORT:      f[0] =  72 #"H"
 */
      __pyx_t_5 = PyInt_FromLong(NPY_UBYTE); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 827; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 827; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 827; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (__pyx_t_7) {
        (__pyx_v_f[0]) = 66;
        goto __pyx_L13;
      }

      /* "numpy.pxd":828
 *             if   t == NPY_BYTE:        f[0] =  98 #"b"
 *             elif t == NPY_UBYTE:       f[0] =  66 #"B"
 *             elif t == NPY_SHORT:       f[0] = 104 #"h"             # <<<<<<<<<<<<<<
 *             elif t == NPY_USHORT:      f[0] =  72 #"H"
 *             elif t == NPY_INT:         f[0] = 105 #"i"
 */
      __pyx_t_3 = PyInt_FromLong(NPY_SHORT); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 828; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 828; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 828; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      if (__pyx_t_7) {
        (__pyx_v_f[0]) = 104;
        goto __pyx_L13;
      }

      /* "numpy.pxd":829
 *             elif t == NPY_UBYTE:       f[0] =  66 #"B"
 *             elif t == NPY_SHORT:       f[0] = 104 #"h"
 *             elif t == NPY_USHORT:      f[0] =  72 #"H"             # <<<<<<<<<<<<<<
 *             elif t == NPY_INT:         f[0] = 105 #"i"
 *             elif t == NPY_UINT:        f[0] =  73 #"I"
 */
      __pyx_t_5 = PyInt_FromLong(NPY_USHORT); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 829; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 829; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 829; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (__pyx_t_7) {
        (__pyx_v_f[0]) = 72;
        goto __pyx_L13;
      }

      /* "numpy.pxd":830
 *             elif t == NPY_SHORT:       f[0] = 104 #"h"
 *             elif t == NPY_USHORT:      f[0] =  72 #"H"
 *             elif t == NPY_INT:         f[0] = 105 #"i"             # <<<<<<<<<<<<<<
 *             elif t == NPY_UINT:        f[0] =  73 #"I"
 *             elif t == NPY_LONG:        f[0] = 108 #"l"
 */
      __pyx_t_3 = PyInt_FromLong(NPY_INT); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 830; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 830; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 830; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      if (__pyx_t_7) {
        (__pyx_v_f[0]) = 105;
        goto __pyx_L13;
      }

      /* "numpy.pxd":831
 *             elif t == NPY_USHORT:      f[0] =  72 #"H"
 *             elif t == NPY_INT:         f[0] = 105 #"i"
 *             elif t == NPY_UINT:        f[0] =  73 #"I"             # <<<<<<<<<<<<<<
 *             elif t == NPY_LONG:        f[0] = 108 #"l"
 *             elif t == NPY_ULONG:       f[0] = 76  #"L"
 */
      __pyx_t_5 = PyInt_FromLong(NPY_UINT); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 831; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 831; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 831; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (__pyx_t_7) {
        (__pyx_v_f[0]) = 73;
        goto __pyx_L13;
      }

      /* "numpy.pxd":832
 *             elif t == NPY_INT:         f[0] = 105 #"i"
 *             elif t == NPY_UINT:        f[0] =  73 #"I"
 *             elif t == NPY_LONG:        f[0] = 108 #"l"             # <<<<<<<<<<<<<<
 *             elif t == NPY_ULONG:       f[0] = 76  #"L"
 *             elif t == NPY_LONGLONG:    f[0] = 113 #"q"
 */
      __pyx_t_3 = PyInt_FromLong(NPY_LONG); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 832; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 832; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 832; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      if (__pyx_t_7) {
        (__pyx_v_f[0]) = 108;
        goto __pyx_L13;
      }

      /* "numpy.pxd":833
 *             elif t == NPY_UINT:        f[0] =  73 #"I"
 *             elif t == NPY_LONG:        f[0] = 108 #"l"
 *             elif t == NPY_ULONG:       f[0] = 76  #"L"             # <<<<<<<<<<<<<<
 *             elif t == NPY_LONGLONG:    f[0] = 113 #"q"
 *             elif t == NPY_ULONGLONG:   f[0] = 81  #"Q"
 */
      __pyx_t_5 = PyInt_FromLong(NPY_ULONG); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 833; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 833; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 833; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (__pyx_t_7) {
        (__pyx_v_f[0]) = 76;
        goto __pyx_L13;
      }

      /* "numpy.pxd":834
 *             elif t == NPY_LONG:        f[0] = 108 #"l"
 *             elif t == NPY_ULONG:       f[0] = 76  #"L"
 *             elif t == NPY_LONGLONG:    f[0] = 113 #"q"             # <<<<<<<<<<<<<<
 *             elif t == NPY_ULONGLONG:   f[0] = 81  #"Q"
 *             elif t == NPY_FLOAT:       f[0] = 102 #"f"
 */
      __pyx_t_3 = PyInt_FromLong(NPY_LONGLONG); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 834; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 834; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 834; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      if (__pyx_t_7) {
        (__pyx_v_f[0]) = 113;
        goto __pyx_L13;
      }

      /* "numpy.pxd":835
 *             elif t == NPY_ULONG:       f[0] = 76  #"L"
 *             elif t == NPY_LONGLONG:    f[0] = 113 #"q"
 *             elif t == NPY_ULONGLONG:   f[0] = 81  #"Q"             # <<<<<<<<<<<<<<
 *             elif t == NPY_FLOAT:       f[0] = 102 #"f"
 *             elif t == NPY_DOUBLE:      f[0] = 100 #"d"
 */
      __pyx_t_5 = PyInt_FromLong(NPY_ULONGLONG); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 835; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 835; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 835; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (__pyx_t_7) {
        (__pyx_v_f[0]) = 81;
        goto __pyx_L13;
      }

      /* "numpy.pxd":836
 *             elif t == NPY_LONGLONG:    f[0] = 113 #"q"
 *             elif t == NPY_ULONGLONG:   f[0] = 81  #"Q"
 *             elif t == NPY_FLOAT:       f[0] = 102 #"f"             # <<<<<<<<<<<<<<
 *             elif t == NPY_DOUBLE:      f[0] = 100 #"d"
 *             elif t == NPY_LONGDOUBLE:  f[0] = 103 #"g"
 */
      __pyx_t_3 = PyInt_FromLong(NPY_FLOAT); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 836; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 836; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 836; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      if (__pyx_t_7) {
        (__pyx_v_f[0]) = 102;
        goto __pyx_L13;
      }

      /* "numpy.pxd":837
 *             elif t == NPY_ULONGLONG:   f[0] = 81  #"Q"
 *             elif t == NPY_FLOAT:       f[0] = 102 #"f"
 *             elif t == NPY_DOUBLE:      f[0] = 100 #"d"             # <<<<<<<<<<<<<<
 *             elif t == NPY_LONGDOUBLE:  f[0] = 103 #"g"
 *             elif t == NPY_CFLOAT:      f[0] = 90; f[1] = 102; f += 1 # Zf
 */
      __pyx_t_5 = PyInt_FromLong(NPY_DOUBLE); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 837; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 837; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 837; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (__pyx_t_7) {
        (__pyx_v_f[0]) = 100;
        goto __pyx_L13;
      }

      /* "numpy.pxd":838
 *             elif t == NPY_FLOAT:       f[0] = 102 #"f"
 *             elif t == NPY_DOUBLE:      f[0] = 100 #"d"
 *             elif t == NPY_LONGDOUBLE:  f[0] = 103 #"g"             # <<<<<<<<<<<<<<
 *             elif t == NPY_CFLOAT:      f[0] = 90; f[1] = 102; f += 1 # Zf
 *             elif t == NPY_CDOUBLE:     f[0] = 90; f[1] = 100; f += 1 # Zd
 */
      __pyx_t_3 = PyInt_FromLong(NPY_LONGDOUBLE); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 838; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 838; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 838; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      if (__pyx_t_7) {
        (__pyx_v_f[0]) = 103;
        goto __pyx_L13;
      }

      /* "numpy.pxd":839
 *             elif t == NPY_DOUBLE:      f[0] = 100 #"d"
 *             elif t == NPY_LONGDOUBLE:  f[0] = 103 #"g"
 *             elif t == NPY_CFLOAT:      f[0] = 90; f[1] = 102; f += 1 # Zf             # <<<<<<<<<<<<<<
 *             elif t == NPY_CDOUBLE:     f[0] = 90; f[1] = 100; f += 1 # Zd
 *             elif t == NPY_CLONGDOUBLE: f[0] = 90; f[1] = 103; f += 1 # Zg
 */
      __pyx_t_5 = PyInt_FromLong(NPY_CFLOAT); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 839; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 839; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 839; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (__pyx_t_7) {
        (__pyx_v_f[0]) = 90;
        (__pyx_v_f[1]) = 102;
        __pyx_v_f = (__pyx_v_f + 1);
        goto __pyx_L13;
      }

      /* "numpy.pxd":840
 *             elif t == NPY_LONGDOUBLE:  f[0] = 103 #"g"
 *             elif t == NPY_CFLOAT:      f[0] = 90; f[1] = 102; f += 1 # Zf
 *             elif t == NPY_CDOUBLE:     f[0] = 90; f[1] = 100; f += 1 # Zd             # <<<<<<<<<<<<<<
 *             elif t == NPY_CLONGDOUBLE: f[0] = 90; f[1] = 103; f += 1 # Zg
 *             elif t == NPY_OBJECT:      f[0] = 79 #"O"
 */
      __pyx_t_3 = PyInt_FromLong(NPY_CDOUBLE); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 840; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 840; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 840; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      if (__pyx_t_7) {
        (__pyx_v_f[0]) = 90;
        (__pyx_v_f[1]) = 100;
        __pyx_v_f = (__pyx_v_f + 1);
        goto __pyx_L13;
      }

      /* "numpy.pxd":841
 *             elif t == NPY_CFLOAT:      f[0] = 90; f[1] = 102; f += 1 # Zf
 *             elif t == NPY_CDOUBLE:     f[0] = 90; f[1] = 100; f += 1 # Zd
 *             elif t == NPY_CLONGDOUBLE: f[0] = 90; f[1] = 103; f += 1 # Zg             # <<<<<<<<<<<<<<
 *             elif t == NPY_OBJECT:      f[0] = 79 #"O"
 *             else:
 */
      __pyx_t_5 = PyInt_FromLong(NPY_CLONGDOUBLE); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 841; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 841; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 841; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (__pyx_t_7) {
        (__pyx_v_f[0]) = 90;
        (__pyx_v_f[1]) = 103;
        __pyx_v_f = (__pyx_v_f + 1);
        goto __pyx_L13;
      }

      /* "numpy.pxd":842
 *             elif t == NPY_CDOUBLE:     f[0] = 90; f[1] = 100; f += 1 # Zd
 *             elif t == NPY_CLONGDOUBLE: f[0] = 90; f[1] = 103; f += 1 # Zg
 *             elif t == NPY_OBJECT:      f[0] = 79 #"O"             # <<<<<<<<<<<<<<
 *             else:
 *                 raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)
 */
      __pyx_t_3 = PyInt_FromLong(NPY_OBJECT); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 842; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 842; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 842; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      if (__pyx_t_7) {
        (__pyx_v_f[0]) = 79;
        goto __pyx_L13;
      }
      /*else*/ {

        /* "numpy.pxd":844
 *             elif t == NPY_OBJECT:      f[0] = 79 #"O"
 *             else:
 *                 raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)             # <<<<<<<<<<<<<<
 *             f += 1
 *         else:
 */
        __pyx_t_5 = PyNumber_Remainder(((PyObject *)__pyx_kp_u_59), __pyx_v_t); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 844; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_GOTREF(((PyObject *)__pyx_t_5));
        __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 844; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_GOTREF(__pyx_t_3);
        PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)__pyx_t_5));
        __Pyx_GIVEREF(((PyObject *)__pyx_t_5));
        __pyx_t_5 = 0;
        __pyx_t_5 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 844; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_GOTREF(__pyx_t_5);
        __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
        __Pyx_Raise(__pyx_t_5, 0, 0, 0);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
        {__pyx_filename = __pyx_f[1]; __pyx_lineno = 844; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      }
      __pyx_L13:;

      /* "numpy.pxd":845
 *             else:
 *                 raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)
 *             f += 1             # <<<<<<<<<<<<<<
 *         else:
 *             # Cython ignores struct boundary information ("T{...}"),
 */
      __pyx_v_f = (__pyx_v_f + 1);
      goto __pyx_L11;
    }
    /*else*/ {

      /* "numpy.pxd":849
 *             # Cython ignores struct boundary information ("T{...}"),
 *             # so don't output it
 *             f = _util_dtypestring(child, f, end, offset)             # <<<<<<<<<<<<<<
 *     return f
 * 
 */
      __pyx_t_12 = __pyx_f_5numpy__util_dtypestring(__pyx_v_child, __pyx_v_f, __pyx_v_end, __pyx_v_offset); if (unlikely(__pyx_t_12 == NULL)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 849; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __pyx_v_f = __pyx_t_12;
    }
    __pyx_L11:;
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "numpy.pxd":850
 *             # so don't output it
 *             f = _util_dtypestring(child, f, end, offset)
 *     return f             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_r = __pyx_v_f;
  goto __pyx_L0;

  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("numpy._util_dtypestring", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_child);
  __Pyx_XDECREF(__pyx_v_fields);
  __Pyx_XDECREF(__pyx_v_childname);
  __Pyx_XDECREF(__pyx_v_new_offset);
  __Pyx_XDECREF(__pyx_v_t);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "numpy.pxd":965
 * 
 * 
 * cdef inline void set_array_base(ndarray arr, object base):             # <<<<<<<<<<<<<<
 *      cdef PyObject* baseptr
 *      if base is None:
 */

static CYTHON_INLINE void __pyx_f_5numpy_set_array_base(PyArrayObject *__pyx_v_arr, PyObject *__pyx_v_base) {
  PyObject *__pyx_v_baseptr;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  __Pyx_RefNannySetupContext("set_array_base", 0);

  /* "numpy.pxd":967
 * cdef inline void set_array_base(ndarray arr, object base):
 *      cdef PyObject* baseptr
 *      if base is None:             # <<<<<<<<<<<<<<
 *          baseptr = NULL
 *      else:
 */
  __pyx_t_1 = (__pyx_v_base == Py_None);
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "numpy.pxd":968
 *      cdef PyObject* baseptr
 *      if base is None:
 *          baseptr = NULL             # <<<<<<<<<<<<<<
 *      else:
 *          Py_INCREF(base) # important to do this before decref below!
 */
    __pyx_v_baseptr = NULL;
    goto __pyx_L3;
  }
  /*else*/ {

    /* "numpy.pxd":970
 *          baseptr = NULL
 *      else:
 *          Py_INCREF(base) # important to do this before decref below!             # <<<<<<<<<<<<<<
 *          baseptr = <PyObject*>base
 *      Py_XDECREF(arr.base)
 */
    Py_INCREF(__pyx_v_base);

    /* "numpy.pxd":971
 *      else:
 *          Py_INCREF(base) # important to do this before decref below!
 *          baseptr = <PyObject*>base             # <<<<<<<<<<<<<<
 *      Py_XDECREF(arr.base)
 *      arr.base = baseptr
 */
    __pyx_v_baseptr = ((PyObject *)__pyx_v_base);
  }
  __pyx_L3:;

  /* "numpy.pxd":972
 *          Py_INCREF(base) # important to do this before decref below!
 *          baseptr = <PyObject*>base
 *      Py_XDECREF(arr.base)             # <<<<<<<<<<<<<<
 *      arr.base = baseptr
 * 
 */
  Py_XDECREF(__pyx_v_arr->base);

  /* "numpy.pxd":973
 *          baseptr = <PyObject*>base
 *      Py_XDECREF(arr.base)
 *      arr.base = baseptr             # <<<<<<<<<<<<<<
 * 
 * cdef inline object get_array_base(ndarray arr):
 */
  __pyx_v_arr->base = __pyx_v_baseptr;

  __Pyx_RefNannyFinishContext();
}

/* "numpy.pxd":975
 *      arr.base = baseptr
 * 
 * cdef inline object get_array_base(ndarray arr):             # <<<<<<<<<<<<<<
 *     if arr.base is NULL:
 *         return None
 */

static CYTHON_INLINE PyObject *__pyx_f_5numpy_get_array_base(PyArrayObject *__pyx_v_arr) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  __Pyx_RefNannySetupContext("get_array_base", 0);

  /* "numpy.pxd":976
 * 
 * cdef inline object get_array_base(ndarray arr):
 *     if arr.base is NULL:             # <<<<<<<<<<<<<<
 *         return None
 *     else:
 */
  __pyx_t_1 = ((__pyx_v_arr->base == NULL) != 0);
  if (__pyx_t_1) {

    /* "numpy.pxd":977
 * cdef inline object get_array_base(ndarray arr):
 *     if arr.base is NULL:
 *         return None             # <<<<<<<<<<<<<<
 *     else:
 *         return <object>arr.base
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_None);
    __pyx_r = Py_None;
    goto __pyx_L0;
    goto __pyx_L3;
  }
  /*else*/ {

    /* "numpy.pxd":979
 *         return None
 *     else:
 *         return <object>arr.base             # <<<<<<<<<<<<<<
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(((PyObject *)__pyx_v_arr->base));
    __pyx_r = ((PyObject *)__pyx_v_arr->base);
    goto __pyx_L0;
  }
  __pyx_L3:;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyMethodDef __pyx_methods[] = {
  {0, 0, 0, 0}
};

#if PY_MAJOR_VERSION >= 3
static struct PyModuleDef __pyx_moduledef = {
  #if PY_VERSION_HEX < 0x03020000
    { PyObject_HEAD_INIT(NULL) NULL, 0, NULL },
  #else
    PyModuleDef_HEAD_INIT,
  #endif
    __Pyx_NAMESTR("notimplemented"),
    0, /* m_doc */
    -1, /* m_size */
    __pyx_methods /* m_methods */,
    NULL, /* m_reload */
    NULL, /* m_traverse */
    NULL, /* m_clear */
    NULL /* m_free */
};
#endif

static __Pyx_StringTabEntry __pyx_string_tab[] = {
  {&__pyx_kp_u_1000, __pyx_k_1000, sizeof(__pyx_k_1000), 0, 1, 0, 0},
  {&__pyx_kp_u_1001, __pyx_k_1001, sizeof(__pyx_k_1001), 0, 1, 0, 0},
  {&__pyx_kp_u_1002, __pyx_k_1002, sizeof(__pyx_k_1002), 0, 1, 0, 0},
  {&__pyx_kp_u_1003, __pyx_k_1003, sizeof(__pyx_k_1003), 0, 1, 0, 0},
  {&__pyx_kp_u_1004, __pyx_k_1004, sizeof(__pyx_k_1004), 0, 1, 0, 0},
  {&__pyx_kp_u_1005, __pyx_k_1005, sizeof(__pyx_k_1005), 0, 1, 0, 0},
  {&__pyx_kp_u_1006, __pyx_k_1006, sizeof(__pyx_k_1006), 0, 1, 0, 0},
  {&__pyx_kp_u_1007, __pyx_k_1007, sizeof(__pyx_k_1007), 0, 1, 0, 0},
  {&__pyx_kp_u_1008, __pyx_k_1008, sizeof(__pyx_k_1008), 0, 1, 0, 0},
  {&__pyx_kp_u_1009, __pyx_k_1009, sizeof(__pyx_k_1009), 0, 1, 0, 0},
  {&__pyx_kp_u_1010, __pyx_k_1010, sizeof(__pyx_k_1010), 0, 1, 0, 0},
  {&__pyx_kp_u_1011, __pyx_k_1011, sizeof(__pyx_k_1011), 0, 1, 0, 0},
  {&__pyx_kp_u_1012, __pyx_k_1012, sizeof(__pyx_k_1012), 0, 1, 0, 0},
  {&__pyx_kp_u_1013, __pyx_k_1013, sizeof(__pyx_k_1013), 0, 1, 0, 0},
  {&__pyx_kp_u_1014, __pyx_k_1014, sizeof(__pyx_k_1014), 0, 1, 0, 0},
  {&__pyx_kp_u_1015, __pyx_k_1015, sizeof(__pyx_k_1015), 0, 1, 0, 0},
  {&__pyx_kp_u_1016, __pyx_k_1016, sizeof(__pyx_k_1016), 0, 1, 0, 0},
  {&__pyx_kp_u_1017, __pyx_k_1017, sizeof(__pyx_k_1017), 0, 1, 0, 0},
  {&__pyx_kp_u_1018, __pyx_k_1018, sizeof(__pyx_k_1018), 0, 1, 0, 0},
  {&__pyx_kp_u_1019, __pyx_k_1019, sizeof(__pyx_k_1019), 0, 1, 0, 0},
  {&__pyx_kp_u_1020, __pyx_k_1020, sizeof(__pyx_k_1020), 0, 1, 0, 0},
  {&__pyx_kp_u_1021, __pyx_k_1021, sizeof(__pyx_k_1021), 0, 1, 0, 0},
  {&__pyx_kp_u_1022, __pyx_k_1022, sizeof(__pyx_k_1022), 0, 1, 0, 0},
  {&__pyx_kp_u_1023, __pyx_k_1023, sizeof(__pyx_k_1023), 0, 1, 0, 0},
  {&__pyx_kp_u_1024, __pyx_k_1024, sizeof(__pyx_k_1024), 0, 1, 0, 0},
  {&__pyx_kp_u_1025, __pyx_k_1025, sizeof(__pyx_k_1025), 0, 1, 0, 0},
  {&__pyx_kp_u_1026, __pyx_k_1026, sizeof(__pyx_k_1026), 0, 1, 0, 0},
  {&__pyx_kp_u_1027, __pyx_k_1027, sizeof(__pyx_k_1027), 0, 1, 0, 0},
  {&__pyx_kp_u_1028, __pyx_k_1028, sizeof(__pyx_k_1028), 0, 1, 0, 0},
  {&__pyx_kp_u_1029, __pyx_k_1029, sizeof(__pyx_k_1029), 0, 1, 0, 0},
  {&__pyx_kp_u_1030, __pyx_k_1030, sizeof(__pyx_k_1030), 0, 1, 0, 0},
  {&__pyx_kp_u_1031, __pyx_k_1031, sizeof(__pyx_k_1031), 0, 1, 0, 0},
  {&__pyx_kp_u_1032, __pyx_k_1032, sizeof(__pyx_k_1032), 0, 1, 0, 0},
  {&__pyx_kp_u_1033, __pyx_k_1033, sizeof(__pyx_k_1033), 0, 1, 0, 0},
  {&__pyx_kp_u_1034, __pyx_k_1034, sizeof(__pyx_k_1034), 0, 1, 0, 0},
  {&__pyx_kp_u_1035, __pyx_k_1035, sizeof(__pyx_k_1035), 0, 1, 0, 0},
  {&__pyx_kp_u_1036, __pyx_k_1036, sizeof(__pyx_k_1036), 0, 1, 0, 0},
  {&__pyx_kp_u_1037, __pyx_k_1037, sizeof(__pyx_k_1037), 0, 1, 0, 0},
  {&__pyx_kp_s_16, __pyx_k_16, sizeof(__pyx_k_16), 0, 0, 1, 0},
  {&__pyx_kp_s_19, __pyx_k_19, sizeof(__pyx_k_19), 0, 0, 1, 0},
  {&__pyx_n_s_212, __pyx_k_212, sizeof(__pyx_k_212), 0, 0, 1, 1},
  {&__pyx_n_s_245, __pyx_k_245, sizeof(__pyx_k_245), 0, 0, 1, 1},
  {&__pyx_kp_s_42, __pyx_k_42, sizeof(__pyx_k_42), 0, 0, 1, 0},
  {&__pyx_kp_s_43, __pyx_k_43, sizeof(__pyx_k_43), 0, 0, 1, 0},
  {&__pyx_kp_s_5, __pyx_k_5, sizeof(__pyx_k_5), 0, 0, 1, 0},
  {&__pyx_kp_u_53, __pyx_k_53, sizeof(__pyx_k_53), 0, 1, 0, 0},
  {&__pyx_kp_u_55, __pyx_k_55, sizeof(__pyx_k_55), 0, 1, 0, 0},
  {&__pyx_kp_u_57, __pyx_k_57, sizeof(__pyx_k_57), 0, 1, 0, 0},
  {&__pyx_kp_u_582, __pyx_k_582, sizeof(__pyx_k_582), 0, 1, 0, 0},
  {&__pyx_kp_u_583, __pyx_k_583, sizeof(__pyx_k_583), 0, 1, 0, 0},
  {&__pyx_kp_u_584, __pyx_k_584, sizeof(__pyx_k_584), 0, 1, 0, 0},
  {&__pyx_kp_u_585, __pyx_k_585, sizeof(__pyx_k_585), 0, 1, 0, 0},
  {&__pyx_kp_u_586, __pyx_k_586, sizeof(__pyx_k_586), 0, 1, 0, 0},
  {&__pyx_kp_u_587, __pyx_k_587, sizeof(__pyx_k_587), 0, 1, 0, 0},
  {&__pyx_kp_u_588, __pyx_k_588, sizeof(__pyx_k_588), 0, 1, 0, 0},
  {&__pyx_kp_u_589, __pyx_k_589, sizeof(__pyx_k_589), 0, 1, 0, 0},
  {&__pyx_kp_u_59, __pyx_k_59, sizeof(__pyx_k_59), 0, 1, 0, 0},
  {&__pyx_kp_u_590, __pyx_k_590, sizeof(__pyx_k_590), 0, 1, 0, 0},
  {&__pyx_kp_u_591, __pyx_k_591, sizeof(__pyx_k_591), 0, 1, 0, 0},
  {&__pyx_kp_u_592, __pyx_k_592, sizeof(__pyx_k_592), 0, 1, 0, 0},
  {&__pyx_kp_u_593, __pyx_k_593, sizeof(__pyx_k_593), 0, 1, 0, 0},
  {&__pyx_kp_u_594, __pyx_k_594, sizeof(__pyx_k_594), 0, 1, 0, 0},
  {&__pyx_kp_u_595, __pyx_k_595, sizeof(__pyx_k_595), 0, 1, 0, 0},
  {&__pyx_kp_u_596, __pyx_k_596, sizeof(__pyx_k_596), 0, 1, 0, 0},
  {&__pyx_kp_u_597, __pyx_k_597, sizeof(__pyx_k_597), 0, 1, 0, 0},
  {&__pyx_kp_u_598, __pyx_k_598, sizeof(__pyx_k_598), 0, 1, 0, 0},
  {&__pyx_kp_u_599, __pyx_k_599, sizeof(__pyx_k_599), 0, 1, 0, 0},
  {&__pyx_kp_s_6, __pyx_k_6, sizeof(__pyx_k_6), 0, 0, 1, 0},
  {&__pyx_kp_u_60, __pyx_k_60, sizeof(__pyx_k_60), 0, 1, 0, 0},
  {&__pyx_kp_u_600, __pyx_k_600, sizeof(__pyx_k_600), 0, 1, 0, 0},
  {&__pyx_kp_u_601, __pyx_k_601, sizeof(__pyx_k_601), 0, 1, 0, 0},
  {&__pyx_kp_u_602, __pyx_k_602, sizeof(__pyx_k_602), 0, 1, 0, 0},
  {&__pyx_kp_u_603, __pyx_k_603, sizeof(__pyx_k_603), 0, 1, 0, 0},
  {&__pyx_kp_u_604, __pyx_k_604, sizeof(__pyx_k_604), 0, 1, 0, 0},
  {&__pyx_kp_u_605, __pyx_k_605, sizeof(__pyx_k_605), 0, 1, 0, 0},
  {&__pyx_kp_u_606, __pyx_k_606, sizeof(__pyx_k_606), 0, 1, 0, 0},
  {&__pyx_kp_u_607, __pyx_k_607, sizeof(__pyx_k_607), 0, 1, 0, 0},
  {&__pyx_kp_u_608, __pyx_k_608, sizeof(__pyx_k_608), 0, 1, 0, 0},
  {&__pyx_kp_u_609, __pyx_k_609, sizeof(__pyx_k_609), 0, 1, 0, 0},
  {&__pyx_kp_u_610, __pyx_k_610, sizeof(__pyx_k_610), 0, 1, 0, 0},
  {&__pyx_kp_u_611, __pyx_k_611, sizeof(__pyx_k_611), 0, 1, 0, 0},
  {&__pyx_kp_u_612, __pyx_k_612, sizeof(__pyx_k_612), 0, 1, 0, 0},
  {&__pyx_kp_u_613, __pyx_k_613, sizeof(__pyx_k_613), 0, 1, 0, 0},
  {&__pyx_kp_u_614, __pyx_k_614, sizeof(__pyx_k_614), 0, 1, 0, 0},
  {&__pyx_kp_u_615, __pyx_k_615, sizeof(__pyx_k_615), 0, 1, 0, 0},
  {&__pyx_kp_u_616, __pyx_k_616, sizeof(__pyx_k_616), 0, 1, 0, 0},
  {&__pyx_kp_u_617, __pyx_k_617, sizeof(__pyx_k_617), 0, 1, 0, 0},
  {&__pyx_kp_u_618, __pyx_k_618, sizeof(__pyx_k_618), 0, 1, 0, 0},
  {&__pyx_kp_u_619, __pyx_k_619, sizeof(__pyx_k_619), 0, 1, 0, 0},
  {&__pyx_kp_u_620, __pyx_k_620, sizeof(__pyx_k_620), 0, 1, 0, 0},
  {&__pyx_kp_u_621, __pyx_k_621, sizeof(__pyx_k_621), 0, 1, 0, 0},
  {&__pyx_kp_u_622, __pyx_k_622, sizeof(__pyx_k_622), 0, 1, 0, 0},
  {&__pyx_kp_u_623, __pyx_k_623, sizeof(__pyx_k_623), 0, 1, 0, 0},
  {&__pyx_kp_u_624, __pyx_k_624, sizeof(__pyx_k_624), 0, 1, 0, 0},
  {&__pyx_kp_u_625, __pyx_k_625, sizeof(__pyx_k_625), 0, 1, 0, 0},
  {&__pyx_kp_u_626, __pyx_k_626, sizeof(__pyx_k_626), 0, 1, 0, 0},
  {&__pyx_kp_u_627, __pyx_k_627, sizeof(__pyx_k_627), 0, 1, 0, 0},
  {&__pyx_kp_u_628, __pyx_k_628, sizeof(__pyx_k_628), 0, 1, 0, 0},
  {&__pyx_kp_u_629, __pyx_k_629, sizeof(__pyx_k_629), 0, 1, 0, 0},
  {&__pyx_kp_u_63, __pyx_k_63, sizeof(__pyx_k_63), 0, 1, 0, 0},
  {&__pyx_kp_u_630, __pyx_k_630, sizeof(__pyx_k_630), 0, 1, 0, 0},
  {&__pyx_kp_u_631, __pyx_k_631, sizeof(__pyx_k_631), 0, 1, 0, 0},
  {&__pyx_kp_u_632, __pyx_k_632, sizeof(__pyx_k_632), 0, 1, 0, 0},
  {&__pyx_kp_u_633, __pyx_k_633, sizeof(__pyx_k_633), 0, 1, 0, 0},
  {&__pyx_kp_u_634, __pyx_k_634, sizeof(__pyx_k_634), 0, 1, 0, 0},
  {&__pyx_kp_u_635, __pyx_k_635, sizeof(__pyx_k_635), 0, 1, 0, 0},
  {&__pyx_kp_u_636, __pyx_k_636, sizeof(__pyx_k_636), 0, 1, 0, 0},
  {&__pyx_kp_u_637, __pyx_k_637, sizeof(__pyx_k_637), 0, 1, 0, 0},
  {&__pyx_kp_u_638, __pyx_k_638, sizeof(__pyx_k_638), 0, 1, 0, 0},
  {&__pyx_kp_u_639, __pyx_k_639, sizeof(__pyx_k_639), 0, 1, 0, 0},
  {&__pyx_kp_u_640, __pyx_k_640, sizeof(__pyx_k_640), 0, 1, 0, 0},
  {&__pyx_kp_u_641, __pyx_k_641, sizeof(__pyx_k_641), 0, 1, 0, 0},
  {&__pyx_kp_u_642, __pyx_k_642, sizeof(__pyx_k_642), 0, 1, 0, 0},
  {&__pyx_kp_u_643, __pyx_k_643, sizeof(__pyx_k_643), 0, 1, 0, 0},
  {&__pyx_kp_u_644, __pyx_k_644, sizeof(__pyx_k_644), 0, 1, 0, 0},
  {&__pyx_kp_u_645, __pyx_k_645, sizeof(__pyx_k_645), 0, 1, 0, 0},
  {&__pyx_kp_u_646, __pyx_k_646, sizeof(__pyx_k_646), 0, 1, 0, 0},
  {&__pyx_kp_u_647, __pyx_k_647, sizeof(__pyx_k_647), 0, 1, 0, 0},
  {&__pyx_kp_u_648, __pyx_k_648, sizeof(__pyx_k_648), 0, 1, 0, 0},
  {&__pyx_kp_u_649, __pyx_k_649, sizeof(__pyx_k_649), 0, 1, 0, 0},
  {&__pyx_kp_u_650, __pyx_k_650, sizeof(__pyx_k_650), 0, 1, 0, 0},
  {&__pyx_kp_u_651, __pyx_k_651, sizeof(__pyx_k_651), 0, 1, 0, 0},
  {&__pyx_kp_u_652, __pyx_k_652, sizeof(__pyx_k_652), 0, 1, 0, 0},
  {&__pyx_kp_u_653, __pyx_k_653, sizeof(__pyx_k_653), 0, 1, 0, 0},
  {&__pyx_kp_u_654, __pyx_k_654, sizeof(__pyx_k_654), 0, 1, 0, 0},
  {&__pyx_kp_u_655, __pyx_k_655, sizeof(__pyx_k_655), 0, 1, 0, 0},
  {&__pyx_kp_u_656, __pyx_k_656, sizeof(__pyx_k_656), 0, 1, 0, 0},
  {&__pyx_kp_u_657, __pyx_k_657, sizeof(__pyx_k_657), 0, 1, 0, 0},
  {&__pyx_kp_u_658, __pyx_k_658, sizeof(__pyx_k_658), 0, 1, 0, 0},
  {&__pyx_kp_u_659, __pyx_k_659, sizeof(__pyx_k_659), 0, 1, 0, 0},
  {&__pyx_kp_u_660, __pyx_k_660, sizeof(__pyx_k_660), 0, 1, 0, 0},
  {&__pyx_kp_u_661, __pyx_k_661, sizeof(__pyx_k_661), 0, 1, 0, 0},
  {&__pyx_kp_u_662, __pyx_k_662, sizeof(__pyx_k_662), 0, 1, 0, 0},
  {&__pyx_kp_u_663, __pyx_k_663, sizeof(__pyx_k_663), 0, 1, 0, 0},
  {&__pyx_kp_u_664, __pyx_k_664, sizeof(__pyx_k_664), 0, 1, 0, 0},
  {&__pyx_kp_u_665, __pyx_k_665, sizeof(__pyx_k_665), 0, 1, 0, 0},
  {&__pyx_kp_u_666, __pyx_k_666, sizeof(__pyx_k_666), 0, 1, 0, 0},
  {&__pyx_kp_u_667, __pyx_k_667, sizeof(__pyx_k_667), 0, 1, 0, 0},
  {&__pyx_kp_u_668, __pyx_k_668, sizeof(__pyx_k_668), 0, 1, 0, 0},
  {&__pyx_kp_u_669, __pyx_k_669, sizeof(__pyx_k_669), 0, 1, 0, 0},
  {&__pyx_kp_s_67, __pyx_k_67, sizeof(__pyx_k_67), 0, 0, 1, 0},
  {&__pyx_kp_u_670, __pyx_k_670, sizeof(__pyx_k_670), 0, 1, 0, 0},
  {&__pyx_kp_u_671, __pyx_k_671, sizeof(__pyx_k_671), 0, 1, 0, 0},
  {&__pyx_kp_u_672, __pyx_k_672, sizeof(__pyx_k_672), 0, 1, 0, 0},
  {&__pyx_kp_u_673, __pyx_k_673, sizeof(__pyx_k_673), 0, 1, 0, 0},
  {&__pyx_kp_u_674, __pyx_k_674, sizeof(__pyx_k_674), 0, 1, 0, 0},
  {&__pyx_kp_u_675, __pyx_k_675, sizeof(__pyx_k_675), 0, 1, 0, 0},
  {&__pyx_kp_u_676, __pyx_k_676, sizeof(__pyx_k_676), 0, 1, 0, 0},
  {&__pyx_kp_u_677, __pyx_k_677, sizeof(__pyx_k_677), 0, 1, 0, 0},
  {&__pyx_kp_u_678, __pyx_k_678, sizeof(__pyx_k_678), 0, 1, 0, 0},
  {&__pyx_kp_u_679, __pyx_k_679, sizeof(__pyx_k_679), 0, 1, 0, 0},
  {&__pyx_n_s_68, __pyx_k_68, sizeof(__pyx_k_68), 0, 0, 1, 1},
  {&__pyx_kp_u_680, __pyx_k_680, sizeof(__pyx_k_680), 0, 1, 0, 0},
  {&__pyx_kp_u_681, __pyx_k_681, sizeof(__pyx_k_681), 0, 1, 0, 0},
  {&__pyx_kp_u_682, __pyx_k_682, sizeof(__pyx_k_682), 0, 1, 0, 0},
  {&__pyx_kp_u_683, __pyx_k_683, sizeof(__pyx_k_683), 0, 1, 0, 0},
  {&__pyx_kp_u_684, __pyx_k_684, sizeof(__pyx_k_684), 0, 1, 0, 0},
  {&__pyx_kp_u_685, __pyx_k_685, sizeof(__pyx_k_685), 0, 1, 0, 0},
  {&__pyx_kp_u_686, __pyx_k_686, sizeof(__pyx_k_686), 0, 1, 0, 0},
  {&__pyx_kp_u_687, __pyx_k_687, sizeof(__pyx_k_687), 0, 1, 0, 0},
  {&__pyx_kp_u_688, __pyx_k_688, sizeof(__pyx_k_688), 0, 1, 0, 0},
  {&__pyx_kp_u_689, __pyx_k_689, sizeof(__pyx_k_689), 0, 1, 0, 0},
  {&__pyx_kp_u_690, __pyx_k_690, sizeof(__pyx_k_690), 0, 1, 0, 0},
  {&__pyx_kp_u_691, __pyx_k_691, sizeof(__pyx_k_691), 0, 1, 0, 0},
  {&__pyx_kp_u_692, __pyx_k_692, sizeof(__pyx_k_692), 0, 1, 0, 0},
  {&__pyx_kp_u_693, __pyx_k_693, sizeof(__pyx_k_693), 0, 1, 0, 0},
  {&__pyx_kp_u_694, __pyx_k_694, sizeof(__pyx_k_694), 0, 1, 0, 0},
  {&__pyx_kp_u_695, __pyx_k_695, sizeof(__pyx_k_695), 0, 1, 0, 0},
  {&__pyx_kp_u_696, __pyx_k_696, sizeof(__pyx_k_696), 0, 1, 0, 0},
  {&__pyx_kp_u_697, __pyx_k_697, sizeof(__pyx_k_697), 0, 1, 0, 0},
  {&__pyx_kp_u_698, __pyx_k_698, sizeof(__pyx_k_698), 0, 1, 0, 0},
  {&__pyx_kp_u_699, __pyx_k_699, sizeof(__pyx_k_699), 0, 1, 0, 0},
  {&__pyx_kp_u_700, __pyx_k_700, sizeof(__pyx_k_700), 0, 1, 0, 0},
  {&__pyx_kp_u_701, __pyx_k_701, sizeof(__pyx_k_701), 0, 1, 0, 0},
  {&__pyx_kp_u_702, __pyx_k_702, sizeof(__pyx_k_702), 0, 1, 0, 0},
  {&__pyx_kp_u_703, __pyx_k_703, sizeof(__pyx_k_703), 0, 1, 0, 0},
  {&__pyx_kp_u_704, __pyx_k_704, sizeof(__pyx_k_704), 0, 1, 0, 0},
  {&__pyx_kp_u_705, __pyx_k_705, sizeof(__pyx_k_705), 0, 1, 0, 0},
  {&__pyx_kp_u_706, __pyx_k_706, sizeof(__pyx_k_706), 0, 1, 0, 0},
  {&__pyx_kp_u_707, __pyx_k_707, sizeof(__pyx_k_707), 0, 1, 0, 0},
  {&__pyx_kp_u_708, __pyx_k_708, sizeof(__pyx_k_708), 0, 1, 0, 0},
  {&__pyx_kp_u_709, __pyx_k_709, sizeof(__pyx_k_709), 0, 1, 0, 0},
  {&__pyx_kp_u_710, __pyx_k_710, sizeof(__pyx_k_710), 0, 1, 0, 0},
  {&__pyx_kp_u_711, __pyx_k_711, sizeof(__pyx_k_711), 0, 1, 0, 0},
  {&__pyx_kp_u_712, __pyx_k_712, sizeof(__pyx_k_712), 0, 1, 0, 0},
  {&__pyx_kp_u_713, __pyx_k_713, sizeof(__pyx_k_713), 0, 1, 0, 0},
  {&__pyx_kp_u_714, __pyx_k_714, sizeof(__pyx_k_714), 0, 1, 0, 0},
  {&__pyx_kp_u_715, __pyx_k_715, sizeof(__pyx_k_715), 0, 1, 0, 0},
  {&__pyx_kp_u_716, __pyx_k_716, sizeof(__pyx_k_716), 0, 1, 0, 0},
  {&__pyx_kp_u_717, __pyx_k_717, sizeof(__pyx_k_717), 0, 1, 0, 0},
  {&__pyx_kp_u_718, __pyx_k_718, sizeof(__pyx_k_718), 0, 1, 0, 0},
  {&__pyx_kp_u_719, __pyx_k_719, sizeof(__pyx_k_719), 0, 1, 0, 0},
  {&__pyx_kp_u_720, __pyx_k_720, sizeof(__pyx_k_720), 0, 1, 0, 0},
  {&__pyx_kp_u_721, __pyx_k_721, sizeof(__pyx_k_721), 0, 1, 0, 0},
  {&__pyx_kp_u_722, __pyx_k_722, sizeof(__pyx_k_722), 0, 1, 0, 0},
  {&__pyx_kp_u_723, __pyx_k_723, sizeof(__pyx_k_723), 0, 1, 0, 0},
  {&__pyx_kp_u_724, __pyx_k_724, sizeof(__pyx_k_724), 0, 1, 0, 0},
  {&__pyx_kp_u_725, __pyx_k_725, sizeof(__pyx_k_725), 0, 1, 0, 0},
  {&__pyx_kp_u_726, __pyx_k_726, sizeof(__pyx_k_726), 0, 1, 0, 0},
  {&__pyx_kp_u_727, __pyx_k_727, sizeof(__pyx_k_727), 0, 1, 0, 0},
  {&__pyx_kp_u_728, __pyx_k_728, sizeof(__pyx_k_728), 0, 1, 0, 0},
  {&__pyx_kp_u_729, __pyx_k_729, sizeof(__pyx_k_729), 0, 1, 0, 0},
  {&__pyx_kp_u_730, __pyx_k_730, sizeof(__pyx_k_730), 0, 1, 0, 0},
  {&__pyx_kp_u_731, __pyx_k_731, sizeof(__pyx_k_731), 0, 1, 0, 0},
  {&__pyx_kp_u_732, __pyx_k_732, sizeof(__pyx_k_732), 0, 1, 0, 0},
  {&__pyx_kp_u_733, __pyx_k_733, sizeof(__pyx_k_733), 0, 1, 0, 0},
  {&__pyx_kp_u_734, __pyx_k_734, sizeof(__pyx_k_734), 0, 1, 0, 0},
  {&__pyx_kp_u_735, __pyx_k_735, sizeof(__pyx_k_735), 0, 1, 0, 0},
  {&__pyx_kp_u_736, __pyx_k_736, sizeof(__pyx_k_736), 0, 1, 0, 0},
  {&__pyx_kp_u_737, __pyx_k_737, sizeof(__pyx_k_737), 0, 1, 0, 0},
  {&__pyx_kp_u_738, __pyx_k_738, sizeof(__pyx_k_738), 0, 1, 0, 0},
  {&__pyx_kp_u_739, __pyx_k_739, sizeof(__pyx_k_739), 0, 1, 0, 0},
  {&__pyx_kp_u_740, __pyx_k_740, sizeof(__pyx_k_740), 0, 1, 0, 0},
  {&__pyx_kp_u_741, __pyx_k_741, sizeof(__pyx_k_741), 0, 1, 0, 0},
  {&__pyx_kp_u_742, __pyx_k_742, sizeof(__pyx_k_742), 0, 1, 0, 0},
  {&__pyx_kp_u_743, __pyx_k_743, sizeof(__pyx_k_743), 0, 1, 0, 0},
  {&__pyx_kp_u_744, __pyx_k_744, sizeof(__pyx_k_744), 0, 1, 0, 0},
  {&__pyx_kp_u_745, __pyx_k_745, sizeof(__pyx_k_745), 0, 1, 0, 0},
  {&__pyx_kp_u_746, __pyx_k_746, sizeof(__pyx_k_746), 0, 1, 0, 0},
  {&__pyx_kp_u_747, __pyx_k_747, sizeof(__pyx_k_747), 0, 1, 0, 0},
  {&__pyx_kp_u_748, __pyx_k_748, sizeof(__pyx_k_748), 0, 1, 0, 0},
  {&__pyx_kp_u_749, __pyx_k_749, sizeof(__pyx_k_749), 0, 1, 0, 0},
  {&__pyx_kp_u_750, __pyx_k_750, sizeof(__pyx_k_750), 0, 1, 0, 0},
  {&__pyx_kp_u_751, __pyx_k_751, sizeof(__pyx_k_751), 0, 1, 0, 0},
  {&__pyx_kp_u_752, __pyx_k_752, sizeof(__pyx_k_752), 0, 1, 0, 0},
  {&__pyx_kp_u_753, __pyx_k_753, sizeof(__pyx_k_753), 0, 1, 0, 0},
  {&__pyx_kp_u_754, __pyx_k_754, sizeof(__pyx_k_754), 0, 1, 0, 0},
  {&__pyx_kp_u_755, __pyx_k_755, sizeof(__pyx_k_755), 0, 1, 0, 0},
  {&__pyx_kp_u_756, __pyx_k_756, sizeof(__pyx_k_756), 0, 1, 0, 0},
  {&__pyx_kp_u_757, __pyx_k_757, sizeof(__pyx_k_757), 0, 1, 0, 0},
  {&__pyx_kp_u_758, __pyx_k_758, sizeof(__pyx_k_758), 0, 1, 0, 0},
  {&__pyx_kp_u_759, __pyx_k_759, sizeof(__pyx_k_759), 0, 1, 0, 0},
  {&__pyx_kp_u_760, __pyx_k_760, sizeof(__pyx_k_760), 0, 1, 0, 0},
  {&__pyx_kp_u_761, __pyx_k_761, sizeof(__pyx_k_761), 0, 1, 0, 0},
  {&__pyx_kp_u_762, __pyx_k_762, sizeof(__pyx_k_762), 0, 1, 0, 0},
  {&__pyx_kp_u_763, __pyx_k_763, sizeof(__pyx_k_763), 0, 1, 0, 0},
  {&__pyx_kp_u_764, __pyx_k_764, sizeof(__pyx_k_764), 0, 1, 0, 0},
  {&__pyx_kp_u_765, __pyx_k_765, sizeof(__pyx_k_765), 0, 1, 0, 0},
  {&__pyx_kp_u_766, __pyx_k_766, sizeof(__pyx_k_766), 0, 1, 0, 0},
  {&__pyx_kp_u_767, __pyx_k_767, sizeof(__pyx_k_767), 0, 1, 0, 0},
  {&__pyx_kp_u_768, __pyx_k_768, sizeof(__pyx_k_768), 0, 1, 0, 0},
  {&__pyx_kp_u_769, __pyx_k_769, sizeof(__pyx_k_769), 0, 1, 0, 0},
  {&__pyx_kp_u_770, __pyx_k_770, sizeof(__pyx_k_770), 0, 1, 0, 0},
  {&__pyx_kp_u_771, __pyx_k_771, sizeof(__pyx_k_771), 0, 1, 0, 0},
  {&__pyx_kp_u_772, __pyx_k_772, sizeof(__pyx_k_772), 0, 1, 0, 0},
  {&__pyx_kp_u_773, __pyx_k_773, sizeof(__pyx_k_773), 0, 1, 0, 0},
  {&__pyx_kp_u_774, __pyx_k_774, sizeof(__pyx_k_774), 0, 1, 0, 0},
  {&__pyx_kp_u_775, __pyx_k_775, sizeof(__pyx_k_775), 0, 1, 0, 0},
  {&__pyx_kp_u_776, __pyx_k_776, sizeof(__pyx_k_776), 0, 1, 0, 0},
  {&__pyx_kp_u_777, __pyx_k_777, sizeof(__pyx_k_777), 0, 1, 0, 0},
  {&__pyx_kp_u_778, __pyx_k_778, sizeof(__pyx_k_778), 0, 1, 0, 0},
  {&__pyx_kp_u_779, __pyx_k_779, sizeof(__pyx_k_779), 0, 1, 0, 0},
  {&__pyx_kp_u_780, __pyx_k_780, sizeof(__pyx_k_780), 0, 1, 0, 0},
  {&__pyx_kp_u_781, __pyx_k_781, sizeof(__pyx_k_781), 0, 1, 0, 0},
  {&__pyx_kp_u_782, __pyx_k_782, sizeof(__pyx_k_782), 0, 1, 0, 0},
  {&__pyx_kp_u_783, __pyx_k_783, sizeof(__pyx_k_783), 0, 1, 0, 0},
  {&__pyx_kp_u_784, __pyx_k_784, sizeof(__pyx_k_784), 0, 1, 0, 0},
  {&__pyx_kp_u_785, __pyx_k_785, sizeof(__pyx_k_785), 0, 1, 0, 0},
  {&__pyx_kp_u_786, __pyx_k_786, sizeof(__pyx_k_786), 0, 1, 0, 0},
  {&__pyx_kp_u_787, __pyx_k_787, sizeof(__pyx_k_787), 0, 1, 0, 0},
  {&__pyx_kp_u_788, __pyx_k_788, sizeof(__pyx_k_788), 0, 1, 0, 0},
  {&__pyx_kp_u_789, __pyx_k_789, sizeof(__pyx_k_789), 0, 1, 0, 0},
  {&__pyx_kp_u_790, __pyx_k_790, sizeof(__pyx_k_790), 0, 1, 0, 0},
  {&__pyx_kp_u_791, __pyx_k_791, sizeof(__pyx_k_791), 0, 1, 0, 0},
  {&__pyx_kp_u_792, __pyx_k_792, sizeof(__pyx_k_792), 0, 1, 0, 0},
  {&__pyx_kp_u_793, __pyx_k_793, sizeof(__pyx_k_793), 0, 1, 0, 0},
  {&__pyx_kp_u_794, __pyx_k_794, sizeof(__pyx_k_794), 0, 1, 0, 0},
  {&__pyx_kp_u_795, __pyx_k_795, sizeof(__pyx_k_795), 0, 1, 0, 0},
  {&__pyx_kp_u_796, __pyx_k_796, sizeof(__pyx_k_796), 0, 1, 0, 0},
  {&__pyx_kp_u_797, __pyx_k_797, sizeof(__pyx_k_797), 0, 1, 0, 0},
  {&__pyx_kp_u_798, __pyx_k_798, sizeof(__pyx_k_798), 0, 1, 0, 0},
  {&__pyx_kp_u_799, __pyx_k_799, sizeof(__pyx_k_799), 0, 1, 0, 0},
  {&__pyx_kp_u_800, __pyx_k_800, sizeof(__pyx_k_800), 0, 1, 0, 0},
  {&__pyx_kp_u_801, __pyx_k_801, sizeof(__pyx_k_801), 0, 1, 0, 0},
  {&__pyx_kp_u_802, __pyx_k_802, sizeof(__pyx_k_802), 0, 1, 0, 0},
  {&__pyx_kp_u_803, __pyx_k_803, sizeof(__pyx_k_803), 0, 1, 0, 0},
  {&__pyx_kp_u_804, __pyx_k_804, sizeof(__pyx_k_804), 0, 1, 0, 0},
  {&__pyx_kp_u_805, __pyx_k_805, sizeof(__pyx_k_805), 0, 1, 0, 0},
  {&__pyx_kp_u_806, __pyx_k_806, sizeof(__pyx_k_806), 0, 1, 0, 0},
  {&__pyx_kp_u_807, __pyx_k_807, sizeof(__pyx_k_807), 0, 1, 0, 0},
  {&__pyx_kp_u_808, __pyx_k_808, sizeof(__pyx_k_808), 0, 1, 0, 0},
  {&__pyx_kp_u_809, __pyx_k_809, sizeof(__pyx_k_809), 0, 1, 0, 0},
  {&__pyx_kp_u_810, __pyx_k_810, sizeof(__pyx_k_810), 0, 1, 0, 0},
  {&__pyx_kp_u_811, __pyx_k_811, sizeof(__pyx_k_811), 0, 1, 0, 0},
  {&__pyx_kp_u_812, __pyx_k_812, sizeof(__pyx_k_812), 0, 1, 0, 0},
  {&__pyx_kp_u_813, __pyx_k_813, sizeof(__pyx_k_813), 0, 1, 0, 0},
  {&__pyx_kp_u_814, __pyx_k_814, sizeof(__pyx_k_814), 0, 1, 0, 0},
  {&__pyx_kp_u_815, __pyx_k_815, sizeof(__pyx_k_815), 0, 1, 0, 0},
  {&__pyx_kp_u_816, __pyx_k_816, sizeof(__pyx_k_816), 0, 1, 0, 0},
  {&__pyx_kp_u_817, __pyx_k_817, sizeof(__pyx_k_817), 0, 1, 0, 0},
  {&__pyx_kp_u_818, __pyx_k_818, sizeof(__pyx_k_818), 0, 1, 0, 0},
  {&__pyx_kp_u_819, __pyx_k_819, sizeof(__pyx_k_819), 0, 1, 0, 0},
  {&__pyx_kp_u_820, __pyx_k_820, sizeof(__pyx_k_820), 0, 1, 0, 0},
  {&__pyx_kp_u_821, __pyx_k_821, sizeof(__pyx_k_821), 0, 1, 0, 0},
  {&__pyx_kp_u_822, __pyx_k_822, sizeof(__pyx_k_822), 0, 1, 0, 0},
  {&__pyx_kp_u_823, __pyx_k_823, sizeof(__pyx_k_823), 0, 1, 0, 0},
  {&__pyx_kp_u_824, __pyx_k_824, sizeof(__pyx_k_824), 0, 1, 0, 0},
  {&__pyx_kp_u_825, __pyx_k_825, sizeof(__pyx_k_825), 0, 1, 0, 0},
  {&__pyx_kp_u_826, __pyx_k_826, sizeof(__pyx_k_826), 0, 1, 0, 0},
  {&__pyx_kp_u_827, __pyx_k_827, sizeof(__pyx_k_827), 0, 1, 0, 0},
  {&__pyx_kp_u_828, __pyx_k_828, sizeof(__pyx_k_828), 0, 1, 0, 0},
  {&__pyx_kp_u_829, __pyx_k_829, sizeof(__pyx_k_829), 0, 1, 0, 0},
  {&__pyx_kp_u_830, __pyx_k_830, sizeof(__pyx_k_830), 0, 1, 0, 0},
  {&__pyx_kp_u_831, __pyx_k_831, sizeof(__pyx_k_831), 0, 1, 0, 0},
  {&__pyx_kp_u_832, __pyx_k_832, sizeof(__pyx_k_832), 0, 1, 0, 0},
  {&__pyx_kp_u_833, __pyx_k_833, sizeof(__pyx_k_833), 0, 1, 0, 0},
  {&__pyx_kp_u_834, __pyx_k_834, sizeof(__pyx_k_834), 0, 1, 0, 0},
  {&__pyx_kp_u_835, __pyx_k_835, sizeof(__pyx_k_835), 0, 1, 0, 0},
  {&__pyx_kp_u_836, __pyx_k_836, sizeof(__pyx_k_836), 0, 1, 0, 0},
  {&__pyx_kp_u_837, __pyx_k_837, sizeof(__pyx_k_837), 0, 1, 0, 0},
  {&__pyx_kp_u_838, __pyx_k_838, sizeof(__pyx_k_838), 0, 1, 0, 0},
  {&__pyx_kp_u_839, __pyx_k_839, sizeof(__pyx_k_839), 0, 1, 0, 0},
  {&__pyx_kp_u_840, __pyx_k_840, sizeof(__pyx_k_840), 0, 1, 0, 0},
  {&__pyx_kp_u_841, __pyx_k_841, sizeof(__pyx_k_841), 0, 1, 0, 0},
  {&__pyx_kp_u_842, __pyx_k_842, sizeof(__pyx_k_842), 0, 1, 0, 0},
  {&__pyx_kp_u_843, __pyx_k_843, sizeof(__pyx_k_843), 0, 1, 0, 0},
  {&__pyx_kp_u_844, __pyx_k_844, sizeof(__pyx_k_844), 0, 1, 0, 0},
  {&__pyx_kp_u_845, __pyx_k_845, sizeof(__pyx_k_845), 0, 1, 0, 0},
  {&__pyx_kp_u_846, __pyx_k_846, sizeof(__pyx_k_846), 0, 1, 0, 0},
  {&__pyx_kp_u_847, __pyx_k_847, sizeof(__pyx_k_847), 0, 1, 0, 0},
  {&__pyx_kp_u_848, __pyx_k_848, sizeof(__pyx_k_848), 0, 1, 0, 0},
  {&__pyx_kp_u_849, __pyx_k_849, sizeof(__pyx_k_849), 0, 1, 0, 0},
  {&__pyx_kp_u_850, __pyx_k_850, sizeof(__pyx_k_850), 0, 1, 0, 0},
  {&__pyx_kp_u_851, __pyx_k_851, sizeof(__pyx_k_851), 0, 1, 0, 0},
  {&__pyx_kp_u_852, __pyx_k_852, sizeof(__pyx_k_852), 0, 1, 0, 0},
  {&__pyx_kp_u_853, __pyx_k_853, sizeof(__pyx_k_853), 0, 1, 0, 0},
  {&__pyx_kp_u_854, __pyx_k_854, sizeof(__pyx_k_854), 0, 1, 0, 0},
  {&__pyx_kp_u_855, __pyx_k_855, sizeof(__pyx_k_855), 0, 1, 0, 0},
  {&__pyx_kp_u_856, __pyx_k_856, sizeof(__pyx_k_856), 0, 1, 0, 0},
  {&__pyx_kp_u_857, __pyx_k_857, sizeof(__pyx_k_857), 0, 1, 0, 0},
  {&__pyx_kp_u_858, __pyx_k_858, sizeof(__pyx_k_858), 0, 1, 0, 0},
  {&__pyx_kp_u_859, __pyx_k_859, sizeof(__pyx_k_859), 0, 1, 0, 0},
  {&__pyx_kp_u_860, __pyx_k_860, sizeof(__pyx_k_860), 0, 1, 0, 0},
  {&__pyx_kp_u_861, __pyx_k_861, sizeof(__pyx_k_861), 0, 1, 0, 0},
  {&__pyx_kp_u_862, __pyx_k_862, sizeof(__pyx_k_862), 0, 1, 0, 0},
  {&__pyx_kp_u_863, __pyx_k_863, sizeof(__pyx_k_863), 0, 1, 0, 0},
  {&__pyx_kp_u_864, __pyx_k_864, sizeof(__pyx_k_864), 0, 1, 0, 0},
  {&__pyx_kp_u_865, __pyx_k_865, sizeof(__pyx_k_865), 0, 1, 0, 0},
  {&__pyx_kp_u_866, __pyx_k_866, sizeof(__pyx_k_866), 0, 1, 0, 0},
  {&__pyx_kp_u_867, __pyx_k_867, sizeof(__pyx_k_867), 0, 1, 0, 0},
  {&__pyx_kp_u_868, __pyx_k_868, sizeof(__pyx_k_868), 0, 1, 0, 0},
  {&__pyx_kp_u_869, __pyx_k_869, sizeof(__pyx_k_869), 0, 1, 0, 0},
  {&__pyx_kp_u_870, __pyx_k_870, sizeof(__pyx_k_870), 0, 1, 0, 0},
  {&__pyx_kp_u_871, __pyx_k_871, sizeof(__pyx_k_871), 0, 1, 0, 0},
  {&__pyx_kp_u_872, __pyx_k_872, sizeof(__pyx_k_872), 0, 1, 0, 0},
  {&__pyx_kp_u_873, __pyx_k_873, sizeof(__pyx_k_873), 0, 1, 0, 0},
  {&__pyx_kp_u_874, __pyx_k_874, sizeof(__pyx_k_874), 0, 1, 0, 0},
  {&__pyx_kp_u_875, __pyx_k_875, sizeof(__pyx_k_875), 0, 1, 0, 0},
  {&__pyx_kp_u_876, __pyx_k_876, sizeof(__pyx_k_876), 0, 1, 0, 0},
  {&__pyx_kp_u_877, __pyx_k_877, sizeof(__pyx_k_877), 0, 1, 0, 0},
  {&__pyx_kp_u_878, __pyx_k_878, sizeof(__pyx_k_878), 0, 1, 0, 0},
  {&__pyx_kp_u_879, __pyx_k_879, sizeof(__pyx_k_879), 0, 1, 0, 0},
  {&__pyx_kp_u_880, __pyx_k_880, sizeof(__pyx_k_880), 0, 1, 0, 0},
  {&__pyx_kp_u_881, __pyx_k_881, sizeof(__pyx_k_881), 0, 1, 0, 0},
  {&__pyx_kp_u_882, __pyx_k_882, sizeof(__pyx_k_882), 0, 1, 0, 0},
  {&__pyx_kp_u_883, __pyx_k_883, sizeof(__pyx_k_883), 0, 1, 0, 0},
  {&__pyx_kp_u_884, __pyx_k_884, sizeof(__pyx_k_884), 0, 1, 0, 0},
  {&__pyx_kp_u_885, __pyx_k_885, sizeof(__pyx_k_885), 0, 1, 0, 0},
  {&__pyx_kp_u_886, __pyx_k_886, sizeof(__pyx_k_886), 0, 1, 0, 0},
  {&__pyx_kp_u_887, __pyx_k_887, sizeof(__pyx_k_887), 0, 1, 0, 0},
  {&__pyx_kp_u_888, __pyx_k_888, sizeof(__pyx_k_888), 0, 1, 0, 0},
  {&__pyx_kp_u_889, __pyx_k_889, sizeof(__pyx_k_889), 0, 1, 0, 0},
  {&__pyx_kp_u_890, __pyx_k_890, sizeof(__pyx_k_890), 0, 1, 0, 0},
  {&__pyx_kp_u_891, __pyx_k_891, sizeof(__pyx_k_891), 0, 1, 0, 0},
  {&__pyx_kp_u_892, __pyx_k_892, sizeof(__pyx_k_892), 0, 1, 0, 0},
  {&__pyx_kp_u_893, __pyx_k_893, sizeof(__pyx_k_893), 0, 1, 0, 0},
  {&__pyx_kp_u_894, __pyx_k_894, sizeof(__pyx_k_894), 0, 1, 0, 0},
  {&__pyx_kp_u_895, __pyx_k_895, sizeof(__pyx_k_895), 0, 1, 0, 0},
  {&__pyx_kp_u_896, __pyx_k_896, sizeof(__pyx_k_896), 0, 1, 0, 0},
  {&__pyx_kp_u_897, __pyx_k_897, sizeof(__pyx_k_897), 0, 1, 0, 0},
  {&__pyx_kp_u_898, __pyx_k_898, sizeof(__pyx_k_898), 0, 1, 0, 0},
  {&__pyx_kp_u_899, __pyx_k_899, sizeof(__pyx_k_899), 0, 1, 0, 0},
  {&__pyx_kp_u_900, __pyx_k_900, sizeof(__pyx_k_900), 0, 1, 0, 0},
  {&__pyx_kp_u_901, __pyx_k_901, sizeof(__pyx_k_901), 0, 1, 0, 0},
  {&__pyx_kp_u_902, __pyx_k_902, sizeof(__pyx_k_902), 0, 1, 0, 0},
  {&__pyx_kp_u_903, __pyx_k_903, sizeof(__pyx_k_903), 0, 1, 0, 0},
  {&__pyx_kp_u_904, __pyx_k_904, sizeof(__pyx_k_904), 0, 1, 0, 0},
  {&__pyx_kp_u_905, __pyx_k_905, sizeof(__pyx_k_905), 0, 1, 0, 0},
  {&__pyx_kp_u_906, __pyx_k_906, sizeof(__pyx_k_906), 0, 1, 0, 0},
  {&__pyx_kp_u_907, __pyx_k_907, sizeof(__pyx_k_907), 0, 1, 0, 0},
  {&__pyx_kp_u_908, __pyx_k_908, sizeof(__pyx_k_908), 0, 1, 0, 0},
  {&__pyx_kp_u_909, __pyx_k_909, sizeof(__pyx_k_909), 0, 1, 0, 0},
  {&__pyx_kp_u_910, __pyx_k_910, sizeof(__pyx_k_910), 0, 1, 0, 0},
  {&__pyx_kp_u_911, __pyx_k_911, sizeof(__pyx_k_911), 0, 1, 0, 0},
  {&__pyx_kp_u_912, __pyx_k_912, sizeof(__pyx_k_912), 0, 1, 0, 0},
  {&__pyx_kp_u_913, __pyx_k_913, sizeof(__pyx_k_913), 0, 1, 0, 0},
  {&__pyx_kp_u_914, __pyx_k_914, sizeof(__pyx_k_914), 0, 1, 0, 0},
  {&__pyx_kp_u_915, __pyx_k_915, sizeof(__pyx_k_915), 0, 1, 0, 0},
  {&__pyx_kp_u_916, __pyx_k_916, sizeof(__pyx_k_916), 0, 1, 0, 0},
  {&__pyx_kp_u_917, __pyx_k_917, sizeof(__pyx_k_917), 0, 1, 0, 0},
  {&__pyx_kp_u_918, __pyx_k_918, sizeof(__pyx_k_918), 0, 1, 0, 0},
  {&__pyx_kp_u_919, __pyx_k_919, sizeof(__pyx_k_919), 0, 1, 0, 0},
  {&__pyx_kp_u_920, __pyx_k_920, sizeof(__pyx_k_920), 0, 1, 0, 0},
  {&__pyx_kp_u_921, __pyx_k_921, sizeof(__pyx_k_921), 0, 1, 0, 0},
  {&__pyx_kp_u_922, __pyx_k_922, sizeof(__pyx_k_922), 0, 1, 0, 0},
  {&__pyx_kp_u_923, __pyx_k_923, sizeof(__pyx_k_923), 0, 1, 0, 0},
  {&__pyx_kp_u_924, __pyx_k_924, sizeof(__pyx_k_924), 0, 1, 0, 0},
  {&__pyx_kp_u_925, __pyx_k_925, sizeof(__pyx_k_925), 0, 1, 0, 0},
  {&__pyx_kp_u_926, __pyx_k_926, sizeof(__pyx_k_926), 0, 1, 0, 0},
  {&__pyx_kp_u_927, __pyx_k_927, sizeof(__pyx_k_927), 0, 1, 0, 0},
  {&__pyx_kp_u_928, __pyx_k_928, sizeof(__pyx_k_928), 0, 1, 0, 0},
  {&__pyx_kp_u_929, __pyx_k_929, sizeof(__pyx_k_929), 0, 1, 0, 0},
  {&__pyx_kp_u_930, __pyx_k_930, sizeof(__pyx_k_930), 0, 1, 0, 0},
  {&__pyx_kp_u_931, __pyx_k_931, sizeof(__pyx_k_931), 0, 1, 0, 0},
  {&__pyx_kp_u_932, __pyx_k_932, sizeof(__pyx_k_932), 0, 1, 0, 0},
  {&__pyx_kp_u_933, __pyx_k_933, sizeof(__pyx_k_933), 0, 1, 0, 0},
  {&__pyx_kp_u_934, __pyx_k_934, sizeof(__pyx_k_934), 0, 1, 0, 0},
  {&__pyx_kp_u_935, __pyx_k_935, sizeof(__pyx_k_935), 0, 1, 0, 0},
  {&__pyx_kp_u_936, __pyx_k_936, sizeof(__pyx_k_936), 0, 1, 0, 0},
  {&__pyx_kp_u_937, __pyx_k_937, sizeof(__pyx_k_937), 0, 1, 0, 0},
  {&__pyx_kp_u_938, __pyx_k_938, sizeof(__pyx_k_938), 0, 1, 0, 0},
  {&__pyx_kp_u_939, __pyx_k_939, sizeof(__pyx_k_939), 0, 1, 0, 0},
  {&__pyx_kp_u_940, __pyx_k_940, sizeof(__pyx_k_940), 0, 1, 0, 0},
  {&__pyx_kp_u_941, __pyx_k_941, sizeof(__pyx_k_941), 0, 1, 0, 0},
  {&__pyx_kp_u_942, __pyx_k_942, sizeof(__pyx_k_942), 0, 1, 0, 0},
  {&__pyx_kp_u_943, __pyx_k_943, sizeof(__pyx_k_943), 0, 1, 0, 0},
  {&__pyx_kp_u_944, __pyx_k_944, sizeof(__pyx_k_944), 0, 1, 0, 0},
  {&__pyx_kp_u_945, __pyx_k_945, sizeof(__pyx_k_945), 0, 1, 0, 0},
  {&__pyx_kp_u_946, __pyx_k_946, sizeof(__pyx_k_946), 0, 1, 0, 0},
  {&__pyx_kp_u_947, __pyx_k_947, sizeof(__pyx_k_947), 0, 1, 0, 0},
  {&__pyx_kp_u_948, __pyx_k_948, sizeof(__pyx_k_948), 0, 1, 0, 0},
  {&__pyx_kp_u_949, __pyx_k_949, sizeof(__pyx_k_949), 0, 1, 0, 0},
  {&__pyx_kp_u_950, __pyx_k_950, sizeof(__pyx_k_950), 0, 1, 0, 0},
  {&__pyx_kp_u_951, __pyx_k_951, sizeof(__pyx_k_951), 0, 1, 0, 0},
  {&__pyx_kp_u_952, __pyx_k_952, sizeof(__pyx_k_952), 0, 1, 0, 0},
  {&__pyx_kp_u_953, __pyx_k_953, sizeof(__pyx_k_953), 0, 1, 0, 0},
  {&__pyx_kp_u_954, __pyx_k_954, sizeof(__pyx_k_954), 0, 1, 0, 0},
  {&__pyx_kp_u_955, __pyx_k_955, sizeof(__pyx_k_955), 0, 1, 0, 0},
  {&__pyx_kp_u_956, __pyx_k_956, sizeof(__pyx_k_956), 0, 1, 0, 0},
  {&__pyx_kp_u_957, __pyx_k_957, sizeof(__pyx_k_957), 0, 1, 0, 0},
  {&__pyx_kp_u_958, __pyx_k_958, sizeof(__pyx_k_958), 0, 1, 0, 0},
  {&__pyx_kp_u_959, __pyx_k_959, sizeof(__pyx_k_959), 0, 1, 0, 0},
  {&__pyx_kp_u_960, __pyx_k_960, sizeof(__pyx_k_960), 0, 1, 0, 0},
  {&__pyx_kp_u_961, __pyx_k_961, sizeof(__pyx_k_961), 0, 1, 0, 0},
  {&__pyx_kp_u_962, __pyx_k_962, sizeof(__pyx_k_962), 0, 1, 0, 0},
  {&__pyx_kp_u_963, __pyx_k_963, sizeof(__pyx_k_963), 0, 1, 0, 0},
  {&__pyx_kp_u_964, __pyx_k_964, sizeof(__pyx_k_964), 0, 1, 0, 0},
  {&__pyx_kp_u_965, __pyx_k_965, sizeof(__pyx_k_965), 0, 1, 0, 0},
  {&__pyx_kp_u_966, __pyx_k_966, sizeof(__pyx_k_966), 0, 1, 0, 0},
  {&__pyx_kp_u_967, __pyx_k_967, sizeof(__pyx_k_967), 0, 1, 0, 0},
  {&__pyx_kp_u_968, __pyx_k_968, sizeof(__pyx_k_968), 0, 1, 0, 0},
  {&__pyx_kp_u_969, __pyx_k_969, sizeof(__pyx_k_969), 0, 1, 0, 0},
  {&__pyx_kp_u_970, __pyx_k_970, sizeof(__pyx_k_970), 0, 1, 0, 0},
  {&__pyx_kp_u_971, __pyx_k_971, sizeof(__pyx_k_971), 0, 1, 0, 0},
  {&__pyx_kp_u_972, __pyx_k_972, sizeof(__pyx_k_972), 0, 1, 0, 0},
  {&__pyx_kp_u_973, __pyx_k_973, sizeof(__pyx_k_973), 0, 1, 0, 0},
  {&__pyx_kp_u_974, __pyx_k_974, sizeof(__pyx_k_974), 0, 1, 0, 0},
  {&__pyx_kp_u_975, __pyx_k_975, sizeof(__pyx_k_975), 0, 1, 0, 0},
  {&__pyx_kp_u_976, __pyx_k_976, sizeof(__pyx_k_976), 0, 1, 0, 0},
  {&__pyx_kp_u_977, __pyx_k_977, sizeof(__pyx_k_977), 0, 1, 0, 0},
  {&__pyx_kp_u_978, __pyx_k_978, sizeof(__pyx_k_978), 0, 1, 0, 0},
  {&__pyx_kp_u_979, __pyx_k_979, sizeof(__pyx_k_979), 0, 1, 0, 0},
  {&__pyx_kp_u_980, __pyx_k_980, sizeof(__pyx_k_980), 0, 1, 0, 0},
  {&__pyx_kp_u_981, __pyx_k_981, sizeof(__pyx_k_981), 0, 1, 0, 0},
  {&__pyx_kp_u_982, __pyx_k_982, sizeof(__pyx_k_982), 0, 1, 0, 0},
  {&__pyx_kp_u_983, __pyx_k_983, sizeof(__pyx_k_983), 0, 1, 0, 0},
  {&__pyx_kp_u_984, __pyx_k_984, sizeof(__pyx_k_984), 0, 1, 0, 0},
  {&__pyx_kp_u_985, __pyx_k_985, sizeof(__pyx_k_985), 0, 1, 0, 0},
  {&__pyx_kp_u_986, __pyx_k_986, sizeof(__pyx_k_986), 0, 1, 0, 0},
  {&__pyx_kp_u_987, __pyx_k_987, sizeof(__pyx_k_987), 0, 1, 0, 0},
  {&__pyx_kp_u_988, __pyx_k_988, sizeof(__pyx_k_988), 0, 1, 0, 0},
  {&__pyx_kp_u_989, __pyx_k_989, sizeof(__pyx_k_989), 0, 1, 0, 0},
  {&__pyx_kp_u_990, __pyx_k_990, sizeof(__pyx_k_990), 0, 1, 0, 0},
  {&__pyx_kp_u_991, __pyx_k_991, sizeof(__pyx_k_991), 0, 1, 0, 0},
  {&__pyx_kp_u_992, __pyx_k_992, sizeof(__pyx_k_992), 0, 1, 0, 0},
  {&__pyx_kp_u_993, __pyx_k_993, sizeof(__pyx_k_993), 0, 1, 0, 0},
  {&__pyx_kp_u_994, __pyx_k_994, sizeof(__pyx_k_994), 0, 1, 0, 0},
  {&__pyx_kp_u_995, __pyx_k_995, sizeof(__pyx_k_995), 0, 1, 0, 0},
  {&__pyx_kp_u_996, __pyx_k_996, sizeof(__pyx_k_996), 0, 1, 0, 0},
  {&__pyx_kp_u_997, __pyx_k_997, sizeof(__pyx_k_997), 0, 1, 0, 0},
  {&__pyx_kp_u_998, __pyx_k_998, sizeof(__pyx_k_998), 0, 1, 0, 0},
  {&__pyx_kp_u_999, __pyx_k_999, sizeof(__pyx_k_999), 0, 1, 0, 0},
  {&__pyx_n_s__A, __pyx_k__A, sizeof(__pyx_k__A), 0, 0, 1, 1},
  {&__pyx_n_s__C, __pyx_k__C, sizeof(__pyx_k__C), 0, 0, 1, 1},
  {&__pyx_n_s__GDFgdf, __pyx_k__GDFgdf, sizeof(__pyx_k__GDFgdf), 0, 0, 1, 1},
  {&__pyx_n_s__M, __pyx_k__M, sizeof(__pyx_k__M), 0, 0, 1, 1},
  {&__pyx_n_s__N, __pyx_k__N, sizeof(__pyx_k__N), 0, 0, 1, 1},
  {&__pyx_n_s__NotImplementedError, __pyx_k__NotImplementedError, sizeof(__pyx_k__NotImplementedError), 0, 0, 1, 1},
  {&__pyx_n_s__RuntimeError, __pyx_k__RuntimeError, sizeof(__pyx_k__RuntimeError), 0, 0, 1, 1},
  {&__pyx_n_s__ValueError, __pyx_k__ValueError, sizeof(__pyx_k__ValueError), 0, 0, 1, 1},
  {&__pyx_n_s__X, __pyx_k__X, sizeof(__pyx_k__X), 0, 0, 1, 1},
  {&__pyx_n_s___, __pyx_k___, sizeof(__pyx_k___), 0, 0, 1, 1},
  {&__pyx_n_s____import__, __pyx_k____import__, sizeof(__pyx_k____import__), 0, 0, 1, 1},
  {&__pyx_n_s____main__, __pyx_k____main__, sizeof(__pyx_k____main__), 0, 0, 1, 1},
  {&__pyx_n_s____test__, __pyx_k____test__, sizeof(__pyx_k____test__), 0, 0, 1, 1},
  {&__pyx_n_s__a, __pyx_k__a, sizeof(__pyx_k__a), 0, 0, 1, 1},
  {&__pyx_n_s__a1, __pyx_k__a1, sizeof(__pyx_k__a1), 0, 0, 1, 1},
  {&__pyx_n_s__a2, __pyx_k__a2, sizeof(__pyx_k__a2), 0, 0, 1, 1},
  {&__pyx_n_s__add_newdoc, __pyx_k__add_newdoc, sizeof(__pyx_k__add_newdoc), 0, 0, 1, 1},
  {&__pyx_n_s__all, __pyx_k__all, sizeof(__pyx_k__all), 0, 0, 1, 1},
  {&__pyx_n_s__allclose, __pyx_k__allclose, sizeof(__pyx_k__allclose), 0, 0, 1, 1},
  {&__pyx_n_s__alltrue, __pyx_k__alltrue, sizeof(__pyx_k__alltrue), 0, 0, 1, 1},
  {&__pyx_n_s__alterdot, __pyx_k__alterdot, sizeof(__pyx_k__alterdot), 0, 0, 1, 1},
  {&__pyx_n_s__amax, __pyx_k__amax, sizeof(__pyx_k__amax), 0, 0, 1, 1},
  {&__pyx_n_s__amin, __pyx_k__amin, sizeof(__pyx_k__amin), 0, 0, 1, 1},
  {&__pyx_n_s__angle, __pyx_k__angle, sizeof(__pyx_k__angle), 0, 0, 1, 1},
  {&__pyx_n_s__any, __pyx_k__any, sizeof(__pyx_k__any), 0, 0, 1, 1},
  {&__pyx_n_s__append, __pyx_k__append, sizeof(__pyx_k__append), 0, 0, 1, 1},
  {&__pyx_n_s__apply_along_axis, __pyx_k__apply_along_axis, sizeof(__pyx_k__apply_along_axis), 0, 0, 1, 1},
  {&__pyx_n_s__apply_over_axes, __pyx_k__apply_over_axes, sizeof(__pyx_k__apply_over_axes), 0, 0, 1, 1},
  {&__pyx_n_s__ar, __pyx_k__ar, sizeof(__pyx_k__ar), 0, 0, 1, 1},
  {&__pyx_n_s__ar1, __pyx_k__ar1, sizeof(__pyx_k__ar1), 0, 0, 1, 1},
  {&__pyx_n_s__ar2, __pyx_k__ar2, sizeof(__pyx_k__ar2), 0, 0, 1, 1},
  {&__pyx_n_s__arg1, __pyx_k__arg1, sizeof(__pyx_k__arg1), 0, 0, 1, 1},
  {&__pyx_n_s__arg2, __pyx_k__arg2, sizeof(__pyx_k__arg2), 0, 0, 1, 1},
  {&__pyx_n_s__argmax, __pyx_k__argmax, sizeof(__pyx_k__argmax), 0, 0, 1, 1},
  {&__pyx_n_s__argmin, __pyx_k__argmin, sizeof(__pyx_k__argmin), 0, 0, 1, 1},
  {&__pyx_n_s__argsort, __pyx_k__argsort, sizeof(__pyx_k__argsort), 0, 0, 1, 1},
  {&__pyx_n_s__argwhere, __pyx_k__argwhere, sizeof(__pyx_k__argwhere), 0, 0, 1, 1},
  {&__pyx_n_s__around, __pyx_k__around, sizeof(__pyx_k__around), 0, 0, 1, 1},
  {&__pyx_n_s__arr, __pyx_k__arr, sizeof(__pyx_k__arr), 0, 0, 1, 1},
  {&__pyx_n_s__array, __pyx_k__array, sizeof(__pyx_k__array), 0, 0, 1, 1},
  {&__pyx_n_s__array2string, __pyx_k__array2string, sizeof(__pyx_k__array2string), 0, 0, 1, 1},
  {&__pyx_n_s__array_equal, __pyx_k__array_equal, sizeof(__pyx_k__array_equal), 0, 0, 1, 1},
  {&__pyx_n_s__array_equiv, __pyx_k__array_equiv, sizeof(__pyx_k__array_equiv), 0, 0, 1, 1},
  {&__pyx_n_s__array_repr, __pyx_k__array_repr, sizeof(__pyx_k__array_repr), 0, 0, 1, 1},
  {&__pyx_n_s__array_split, __pyx_k__array_split, sizeof(__pyx_k__array_split), 0, 0, 1, 1},
  {&__pyx_n_s__array_str, __pyx_k__array_str, sizeof(__pyx_k__array_str), 0, 0, 1, 1},
  {&__pyx_n_s__array_types, __pyx_k__array_types, sizeof(__pyx_k__array_types), 0, 0, 1, 1},
  {&__pyx_n_s__arrays_and_dtypes, __pyx_k__arrays_and_dtypes, sizeof(__pyx_k__arrays_and_dtypes), 0, 0, 1, 1},
  {&__pyx_n_s__ary, __pyx_k__ary, sizeof(__pyx_k__ary), 0, 0, 1, 1},
  {&__pyx_n_s__asanyarray, __pyx_k__asanyarray, sizeof(__pyx_k__asanyarray), 0, 0, 1, 1},
  {&__pyx_n_s__asarray_chkfinite, __pyx_k__asarray_chkfinite, sizeof(__pyx_k__asarray_chkfinite), 0, 0, 1, 1},
  {&__pyx_n_s__ascontiguousarray, __pyx_k__ascontiguousarray, sizeof(__pyx_k__ascontiguousarray), 0, 0, 1, 1},
  {&__pyx_n_s__asfarray, __pyx_k__asfarray, sizeof(__pyx_k__asfarray), 0, 0, 1, 1},
  {&__pyx_n_s__asfortranarray, __pyx_k__asfortranarray, sizeof(__pyx_k__asfortranarray), 0, 0, 1, 1},
  {&__pyx_n_s__asmatrix, __pyx_k__asmatrix, sizeof(__pyx_k__asmatrix), 0, 0, 1, 1},
  {&__pyx_n_s__asscalar, __pyx_k__asscalar, sizeof(__pyx_k__asscalar), 0, 0, 1, 1},
  {&__pyx_n_s__assume_unique, __pyx_k__assume_unique, sizeof(__pyx_k__assume_unique), 0, 0, 1, 1},
  {&__pyx_n_s__atleast_1d, __pyx_k__atleast_1d, sizeof(__pyx_k__atleast_1d), 0, 0, 1, 1},
  {&__pyx_n_s__atleast_2d, __pyx_k__atleast_2d, sizeof(__pyx_k__atleast_2d), 0, 0, 1, 1},
  {&__pyx_n_s__atleast_3d, __pyx_k__atleast_3d, sizeof(__pyx_k__atleast_3d), 0, 0, 1, 1},
  {&__pyx_n_s__atol, __pyx_k__atol, sizeof(__pyx_k__atol), 0, 0, 1, 1},
  {&__pyx_n_s__autostrip, __pyx_k__autostrip, sizeof(__pyx_k__autostrip), 0, 0, 1, 1},
  {&__pyx_n_s__average, __pyx_k__average, sizeof(__pyx_k__average), 0, 0, 1, 1},
  {&__pyx_n_s__axes, __pyx_k__axes, sizeof(__pyx_k__axes), 0, 0, 1, 1},
  {&__pyx_n_s__axis, __pyx_k__axis, sizeof(__pyx_k__axis), 0, 0, 1, 1},
  {&__pyx_n_s__axis1, __pyx_k__axis1, sizeof(__pyx_k__axis1), 0, 0, 1, 1},
  {&__pyx_n_s__axis2, __pyx_k__axis2, sizeof(__pyx_k__axis2), 0, 0, 1, 1},
  {&__pyx_n_s__axisa, __pyx_k__axisa, sizeof(__pyx_k__axisa), 0, 0, 1, 1},
  {&__pyx_n_s__axisb, __pyx_k__axisb, sizeof(__pyx_k__axisb), 0, 0, 1, 1},
  {&__pyx_n_s__axisc, __pyx_k__axisc, sizeof(__pyx_k__axisc), 0, 0, 1, 1},
  {&__pyx_n_s__b, __pyx_k__b, sizeof(__pyx_k__b), 0, 0, 1, 1},
  {&__pyx_n_s__bartlett, __pyx_k__bartlett, sizeof(__pyx_k__bartlett), 0, 0, 1, 1},
  {&__pyx_n_s__base, __pyx_k__base, sizeof(__pyx_k__base), 0, 0, 1, 1},
  {&__pyx_n_s__base_repr, __pyx_k__base_repr, sizeof(__pyx_k__base_repr), 0, 0, 1, 1},
  {&__pyx_n_s__beta, __pyx_k__beta, sizeof(__pyx_k__beta), 0, 0, 1, 1},
  {&__pyx_n_s__bias, __pyx_k__bias, sizeof(__pyx_k__bias), 0, 0, 1, 1},
  {&__pyx_n_s__binary_repr, __pyx_k__binary_repr, sizeof(__pyx_k__binary_repr), 0, 0, 1, 1},
  {&__pyx_n_s__bincount, __pyx_k__bincount, sizeof(__pyx_k__bincount), 0, 0, 1, 1},
  {&__pyx_n_s__bins, __pyx_k__bins, sizeof(__pyx_k__bins), 0, 0, 1, 1},
  {&__pyx_n_s__blackman, __pyx_k__blackman, sizeof(__pyx_k__blackman), 0, 0, 1, 1},
  {&__pyx_n_s__bmat, __pyx_k__bmat, sizeof(__pyx_k__bmat), 0, 0, 1, 1},
  {&__pyx_n_s__broadcast_arrays, __pyx_k__broadcast_arrays, sizeof(__pyx_k__broadcast_arrays), 0, 0, 1, 1},
  {&__pyx_n_s__buffer, __pyx_k__buffer, sizeof(__pyx_k__buffer), 0, 0, 1, 1},
  {&__pyx_n_s__byte_bounds, __pyx_k__byte_bounds, sizeof(__pyx_k__byte_bounds), 0, 0, 1, 1},
  {&__pyx_n_s__can_cast, __pyx_k__can_cast, sizeof(__pyx_k__can_cast), 0, 0, 1, 1},
  {&__pyx_n_s__case_sensitive, __pyx_k__case_sensitive, sizeof(__pyx_k__case_sensitive), 0, 0, 1, 1},
  {&__pyx_n_s__char_, __pyx_k__char_, sizeof(__pyx_k__char_), 0, 0, 1, 1},
  {&__pyx_n_s__choicelist, __pyx_k__choicelist, sizeof(__pyx_k__choicelist), 0, 0, 1, 1},
  {&__pyx_n_s__choices, __pyx_k__choices, sizeof(__pyx_k__choices), 0, 0, 1, 1},
  {&__pyx_n_s__choose, __pyx_k__choose, sizeof(__pyx_k__choose), 0, 0, 1, 1},
  {&__pyx_n_s__column_stack, __pyx_k__column_stack, sizeof(__pyx_k__column_stack), 0, 0, 1, 1},
  {&__pyx_n_s__comments, __pyx_k__comments, sizeof(__pyx_k__comments), 0, 0, 1, 1},
  {&__pyx_n_s__common_type, __pyx_k__common_type, sizeof(__pyx_k__common_type), 0, 0, 1, 1},
  {&__pyx_n_s__compare_chararrays, __pyx_k__compare_chararrays, sizeof(__pyx_k__compare_chararrays), 0, 0, 1, 1},
  {&__pyx_n_s__compress, __pyx_k__compress, sizeof(__pyx_k__compress), 0, 0, 1, 1},
  {&__pyx_n_s__concatenate, __pyx_k__concatenate, sizeof(__pyx_k__concatenate), 0, 0, 1, 1},
  {&__pyx_n_s__condition, __pyx_k__condition, sizeof(__pyx_k__condition), 0, 0, 1, 1},
  {&__pyx_n_s__condlist, __pyx_k__condlist, sizeof(__pyx_k__condlist), 0, 0, 1, 1},
  {&__pyx_n_s__converters, __pyx_k__converters, sizeof(__pyx_k__converters), 0, 0, 1, 1},
  {&__pyx_n_s__convolve, __pyx_k__convolve, sizeof(__pyx_k__convolve), 0, 0, 1, 1},
  {&__pyx_n_s__copy, __pyx_k__copy, sizeof(__pyx_k__copy), 0, 0, 1, 1},
  {&__pyx_n_s__corrcoef, __pyx_k__corrcoef, sizeof(__pyx_k__corrcoef), 0, 0, 1, 1},
  {&__pyx_n_s__correlate, __pyx_k__correlate, sizeof(__pyx_k__correlate), 0, 0, 1, 1},
  {&__pyx_n_s__count, __pyx_k__count, sizeof(__pyx_k__count), 0, 0, 1, 1},
  {&__pyx_n_s__count_nonzero, __pyx_k__count_nonzero, sizeof(__pyx_k__count_nonzero), 0, 0, 1, 1},
  {&__pyx_n_s__cov, __pyx_k__cov, sizeof(__pyx_k__cov), 0, 0, 1, 1},
  {&__pyx_n_s__cross, __pyx_k__cross, sizeof(__pyx_k__cross), 0, 0, 1, 1},
  {&__pyx_n_s__cumprod, __pyx_k__cumprod, sizeof(__pyx_k__cumprod), 0, 0, 1, 1},
  {&__pyx_n_s__cumproduct, __pyx_k__cumproduct, sizeof(__pyx_k__cumproduct), 0, 0, 1, 1},
  {&__pyx_n_s__cumsum, __pyx_k__cumsum, sizeof(__pyx_k__cumsum), 0, 0, 1, 1},
  {&__pyx_n_s__d, __pyx_k__d, sizeof(__pyx_k__d), 0, 0, 1, 1},
  {&__pyx_n_s__data, __pyx_k__data, sizeof(__pyx_k__data), 0, 0, 1, 1},
  {&__pyx_n_s__datetime_data, __pyx_k__datetime_data, sizeof(__pyx_k__datetime_data), 0, 0, 1, 1},
  {&__pyx_n_s__ddof, __pyx_k__ddof, sizeof(__pyx_k__ddof), 0, 0, 1, 1},
  {&__pyx_n_s__decimals, __pyx_k__decimals, sizeof(__pyx_k__decimals), 0, 0, 1, 1},
  {&__pyx_n_s__default, __pyx_k__default, sizeof(__pyx_k__default), 0, 0, 1, 1},
  {&__pyx_n_s__defaultfmt, __pyx_k__defaultfmt, sizeof(__pyx_k__defaultfmt), 0, 0, 1, 1},
  {&__pyx_n_s__deg, __pyx_k__deg, sizeof(__pyx_k__deg), 0, 0, 1, 1},
  {&__pyx_n_s__delete, __pyx_k__delete, sizeof(__pyx_k__delete), 0, 0, 1, 1},
  {&__pyx_n_s__deletechars, __pyx_k__deletechars, sizeof(__pyx_k__deletechars), 0, 0, 1, 1},
  {&__pyx_n_s__delimiter, __pyx_k__delimiter, sizeof(__pyx_k__delimiter), 0, 0, 1, 1},
  {&__pyx_n_s__density, __pyx_k__density, sizeof(__pyx_k__density), 0, 0, 1, 1},
  {&__pyx_n_s__deprecate, __pyx_k__deprecate, sizeof(__pyx_k__deprecate), 0, 0, 1, 1},
  {&__pyx_n_s__deprecate_with_doc, __pyx_k__deprecate_with_doc, sizeof(__pyx_k__deprecate_with_doc), 0, 0, 1, 1},
  {&__pyx_n_s__device, __pyx_k__device, sizeof(__pyx_k__device), 0, 0, 1, 1},
  {&__pyx_n_s__diag_indices, __pyx_k__diag_indices, sizeof(__pyx_k__diag_indices), 0, 0, 1, 1},
  {&__pyx_n_s__diag_indices_from, __pyx_k__diag_indices_from, sizeof(__pyx_k__diag_indices_from), 0, 0, 1, 1},
  {&__pyx_n_s__diagflat, __pyx_k__diagflat, sizeof(__pyx_k__diagflat), 0, 0, 1, 1},
  {&__pyx_n_s__diff, __pyx_k__diff, sizeof(__pyx_k__diff), 0, 0, 1, 1},
  {&__pyx_n_s__digitize, __pyx_k__digitize, sizeof(__pyx_k__digitize), 0, 0, 1, 1},
  {&__pyx_n_s__dimensions, __pyx_k__dimensions, sizeof(__pyx_k__dimensions), 0, 0, 1, 1},
  {&__pyx_n_s__dims, __pyx_k__dims, sizeof(__pyx_k__dims), 0, 0, 1, 1},
  {&__pyx_n_s__discont, __pyx_k__discont, sizeof(__pyx_k__discont), 0, 0, 1, 1},
  {&__pyx_n_s__disp, __pyx_k__disp, sizeof(__pyx_k__disp), 0, 0, 1, 1},
  {&__pyx_n_s__divide, __pyx_k__divide, sizeof(__pyx_k__divide), 0, 0, 1, 1},
  {&__pyx_n_s__doc, __pyx_k__doc, sizeof(__pyx_k__doc), 0, 0, 1, 1},
  {&__pyx_n_s__docstring, __pyx_k__docstring, sizeof(__pyx_k__docstring), 0, 0, 1, 1},
  {&__pyx_n_s__dsplit, __pyx_k__dsplit, sizeof(__pyx_k__dsplit), 0, 0, 1, 1},
  {&__pyx_n_s__dstack, __pyx_k__dstack, sizeof(__pyx_k__dstack), 0, 0, 1, 1},
  {&__pyx_n_s__dtype, __pyx_k__dtype, sizeof(__pyx_k__dtype), 0, 0, 1, 1},
  {&__pyx_n_s__dx, __pyx_k__dx, sizeof(__pyx_k__dx), 0, 0, 1, 1},
  {&__pyx_n_s__edgeitems, __pyx_k__edgeitems, sizeof(__pyx_k__edgeitems), 0, 0, 1, 1},
  {&__pyx_n_s__ediff1d, __pyx_k__ediff1d, sizeof(__pyx_k__ediff1d), 0, 0, 1, 1},
  {&__pyx_n_s__einsum, __pyx_k__einsum, sizeof(__pyx_k__einsum), 0, 0, 1, 1},
  {&__pyx_n_s__end, __pyx_k__end, sizeof(__pyx_k__end), 0, 0, 1, 1},
  {&__pyx_n_s__errobj, __pyx_k__errobj, sizeof(__pyx_k__errobj), 0, 0, 1, 1},
  {&__pyx_n_s__excludelist, __pyx_k__excludelist, sizeof(__pyx_k__excludelist), 0, 0, 1, 1},
  {&__pyx_n_s__expand_dims, __pyx_k__expand_dims, sizeof(__pyx_k__expand_dims), 0, 0, 1, 1},
  {&__pyx_n_s__extract, __pyx_k__extract, sizeof(__pyx_k__extract), 0, 0, 1, 1},
  {&__pyx_n_s__f, __pyx_k__f, sizeof(__pyx_k__f), 0, 0, 1, 1},
  {&__pyx_n_s__fb, __pyx_k__fb, sizeof(__pyx_k__fb), 0, 0, 1, 1},
  {&__pyx_n_s__file, __pyx_k__file, sizeof(__pyx_k__file), 0, 0, 1, 1},
  {&__pyx_n_s__fill_diagonal, __pyx_k__fill_diagonal, sizeof(__pyx_k__fill_diagonal), 0, 0, 1, 1},
  {&__pyx_n_s__filling_values, __pyx_k__filling_values, sizeof(__pyx_k__filling_values), 0, 0, 1, 1},
  {&__pyx_n_s__filt, __pyx_k__filt, sizeof(__pyx_k__filt), 0, 0, 1, 1},
  {&__pyx_n_s__finance_rate, __pyx_k__finance_rate, sizeof(__pyx_k__finance_rate), 0, 0, 1, 1},
  {&__pyx_n_s__find_common_type, __pyx_k__find_common_type, sizeof(__pyx_k__find_common_type), 0, 0, 1, 1},
  {&__pyx_n_s__fix, __pyx_k__fix, sizeof(__pyx_k__fix), 0, 0, 1, 1},
  {&__pyx_n_s__flatnonzero, __pyx_k__flatnonzero, sizeof(__pyx_k__flatnonzero), 0, 0, 1, 1},
  {&__pyx_n_s__fliplr, __pyx_k__fliplr, sizeof(__pyx_k__fliplr), 0, 0, 1, 1},
  {&__pyx_n_s__flipud, __pyx_k__flipud, sizeof(__pyx_k__flipud), 0, 0, 1, 1},
  {&__pyx_n_s__float64, __pyx_k__float64, sizeof(__pyx_k__float64), 0, 0, 1, 1},
  {&__pyx_n_s__fmt, __pyx_k__fmt, sizeof(__pyx_k__fmt), 0, 0, 1, 1},
  {&__pyx_n_s__fname, __pyx_k__fname, sizeof(__pyx_k__fname), 0, 0, 1, 1},
  {&__pyx_n_s__fp, __pyx_k__fp, sizeof(__pyx_k__fp), 0, 0, 1, 1},
  {&__pyx_n_s__frombuffer, __pyx_k__frombuffer, sizeof(__pyx_k__frombuffer), 0, 0, 1, 1},
  {&__pyx_n_s__fromfile, __pyx_k__fromfile, sizeof(__pyx_k__fromfile), 0, 0, 1, 1},
  {&__pyx_n_s__fromiter, __pyx_k__fromiter, sizeof(__pyx_k__fromiter), 0, 0, 1, 1},
  {&__pyx_n_s__frompyfunc, __pyx_k__frompyfunc, sizeof(__pyx_k__frompyfunc), 0, 0, 1, 1},
  {&__pyx_n_s__fromregex, __pyx_k__fromregex, sizeof(__pyx_k__fromregex), 0, 0, 1, 1},
  {&__pyx_n_s__fromstring, __pyx_k__fromstring, sizeof(__pyx_k__fromstring), 0, 0, 1, 1},
  {&__pyx_n_s__full, __pyx_k__full, sizeof(__pyx_k__full), 0, 0, 1, 1},
  {&__pyx_n_s__func, __pyx_k__func, sizeof(__pyx_k__func), 0, 0, 1, 1},
  {&__pyx_n_s__func1d, __pyx_k__func1d, sizeof(__pyx_k__func1d), 0, 0, 1, 1},
  {&__pyx_n_s__funclist, __pyx_k__funclist, sizeof(__pyx_k__funclist), 0, 0, 1, 1},
  {&__pyx_n_s__fv, __pyx_k__fv, sizeof(__pyx_k__fv), 0, 0, 1, 1},
  {&__pyx_n_s__gdict, __pyx_k__gdict, sizeof(__pyx_k__gdict), 0, 0, 1, 1},
  {&__pyx_n_s__genfromtxt, __pyx_k__genfromtxt, sizeof(__pyx_k__genfromtxt), 0, 0, 1, 1},
  {&__pyx_n_s__get_array_wrap, __pyx_k__get_array_wrap, sizeof(__pyx_k__get_array_wrap), 0, 0, 1, 1},
  {&__pyx_n_s__get_include, __pyx_k__get_include, sizeof(__pyx_k__get_include), 0, 0, 1, 1},
  {&__pyx_n_s__get_printoptions, __pyx_k__get_printoptions, sizeof(__pyx_k__get_printoptions), 0, 0, 1, 1},
  {&__pyx_n_s__getbuffer, __pyx_k__getbuffer, sizeof(__pyx_k__getbuffer), 0, 0, 1, 1},
  {&__pyx_n_s__getbufsize, __pyx_k__getbufsize, sizeof(__pyx_k__getbufsize), 0, 0, 1, 1},
  {&__pyx_n_s__geterr, __pyx_k__geterr, sizeof(__pyx_k__geterr), 0, 0, 1, 1},
  {&__pyx_n_s__geterrcall, __pyx_k__geterrcall, sizeof(__pyx_k__geterrcall), 0, 0, 1, 1},
  {&__pyx_n_s__geterrobj, __pyx_k__geterrobj, sizeof(__pyx_k__geterrobj), 0, 0, 1, 1},
  {&__pyx_n_s__gradient, __pyx_k__gradient, sizeof(__pyx_k__gradient), 0, 0, 1, 1},
  {&__pyx_n_s__guess, __pyx_k__guess, sizeof(__pyx_k__guess), 0, 0, 1, 1},
  {&__pyx_n_s__hamming, __pyx_k__hamming, sizeof(__pyx_k__hamming), 0, 0, 1, 1},
  {&__pyx_n_s__hanning, __pyx_k__hanning, sizeof(__pyx_k__hanning), 0, 0, 1, 1},
  {&__pyx_n_s__histogram, __pyx_k__histogram, sizeof(__pyx_k__histogram), 0, 0, 1, 1},
  {&__pyx_n_s__histogram2d, __pyx_k__histogram2d, sizeof(__pyx_k__histogram2d), 0, 0, 1, 1},
  {&__pyx_n_s__histogramdd, __pyx_k__histogramdd, sizeof(__pyx_k__histogramdd), 0, 0, 1, 1},
  {&__pyx_n_s__hsplit, __pyx_k__hsplit, sizeof(__pyx_k__hsplit), 0, 0, 1, 1},
  {&__pyx_n_s__hstack, __pyx_k__hstack, sizeof(__pyx_k__hstack), 0, 0, 1, 1},
  {&__pyx_n_s__i0, __pyx_k__i0, sizeof(__pyx_k__i0), 0, 0, 1, 1},
  {&__pyx_n_s__imag, __pyx_k__imag, sizeof(__pyx_k__imag), 0, 0, 1, 1},
  {&__pyx_n_s__import_modules, __pyx_k__import_modules, sizeof(__pyx_k__import_modules), 0, 0, 1, 1},
  {&__pyx_n_s__in1d, __pyx_k__in1d, sizeof(__pyx_k__in1d), 0, 0, 1, 1},
  {&__pyx_n_s__ind, __pyx_k__ind, sizeof(__pyx_k__ind), 0, 0, 1, 1},
  {&__pyx_n_s__indices, __pyx_k__indices, sizeof(__pyx_k__indices), 0, 0, 1, 1},
  {&__pyx_n_s__indices_or_sections, __pyx_k__indices_or_sections, sizeof(__pyx_k__indices_or_sections), 0, 0, 1, 1},
  {&__pyx_n_s__info, __pyx_k__info, sizeof(__pyx_k__info), 0, 0, 1, 1},
  {&__pyx_n_s__infstr, __pyx_k__infstr, sizeof(__pyx_k__infstr), 0, 0, 1, 1},
  {&__pyx_n_s__inner, __pyx_k__inner, sizeof(__pyx_k__inner), 0, 0, 1, 1},
  {&__pyx_n_s__insert, __pyx_k__insert, sizeof(__pyx_k__insert), 0, 0, 1, 1},
  {&__pyx_n_s__int_asbuffer, __pyx_k__int_asbuffer, sizeof(__pyx_k__int_asbuffer), 0, 0, 1, 1},
  {&__pyx_n_s__interp, __pyx_k__interp, sizeof(__pyx_k__interp), 0, 0, 1, 1},
  {&__pyx_n_s__intersect1d, __pyx_k__intersect1d, sizeof(__pyx_k__intersect1d), 0, 0, 1, 1},
  {&__pyx_n_s__invalid, __pyx_k__invalid, sizeof(__pyx_k__invalid), 0, 0, 1, 1},
  {&__pyx_n_s__invalid_raise, __pyx_k__invalid_raise, sizeof(__pyx_k__invalid_raise), 0, 0, 1, 1},
  {&__pyx_n_s__ipmt, __pyx_k__ipmt, sizeof(__pyx_k__ipmt), 0, 0, 1, 1},
  {&__pyx_n_s__irr, __pyx_k__irr, sizeof(__pyx_k__irr), 0, 0, 1, 1},
  {&__pyx_n_s__iscomplex, __pyx_k__iscomplex, sizeof(__pyx_k__iscomplex), 0, 0, 1, 1},
  {&__pyx_n_s__iscomplexobj, __pyx_k__iscomplexobj, sizeof(__pyx_k__iscomplexobj), 0, 0, 1, 1},
  {&__pyx_n_s__isfortran, __pyx_k__isfortran, sizeof(__pyx_k__isfortran), 0, 0, 1, 1},
  {&__pyx_n_s__isneginf, __pyx_k__isneginf, sizeof(__pyx_k__isneginf), 0, 0, 1, 1},
  {&__pyx_n_s__isposinf, __pyx_k__isposinf, sizeof(__pyx_k__isposinf), 0, 0, 1, 1},
  {&__pyx_n_s__isreal, __pyx_k__isreal, sizeof(__pyx_k__isreal), 0, 0, 1, 1},
  {&__pyx_n_s__isrealobj, __pyx_k__isrealobj, sizeof(__pyx_k__isrealobj), 0, 0, 1, 1},
  {&__pyx_n_s__isscalar, __pyx_k__isscalar, sizeof(__pyx_k__isscalar), 0, 0, 1, 1},
  {&__pyx_n_s__issctype, __pyx_k__issctype, sizeof(__pyx_k__issctype), 0, 0, 1, 1},
  {&__pyx_n_s__issubclass_, __pyx_k__issubclass_, sizeof(__pyx_k__issubclass_), 0, 0, 1, 1},
  {&__pyx_n_s__issubdtype, __pyx_k__issubdtype, sizeof(__pyx_k__issubdtype), 0, 0, 1, 1},
  {&__pyx_n_s__issubsctype, __pyx_k__issubsctype, sizeof(__pyx_k__issubsctype), 0, 0, 1, 1},
  {&__pyx_n_s__iterable, __pyx_k__iterable, sizeof(__pyx_k__iterable), 0, 0, 1, 1},
  {&__pyx_n_s__ix_, __pyx_k__ix_, sizeof(__pyx_k__ix_), 0, 0, 1, 1},
  {&__pyx_n_s__k, __pyx_k__k, sizeof(__pyx_k__k), 0, 0, 1, 1},
  {&__pyx_n_s__kaiser, __pyx_k__kaiser, sizeof(__pyx_k__kaiser), 0, 0, 1, 1},
  {&__pyx_n_s__keys, __pyx_k__keys, sizeof(__pyx_k__keys), 0, 0, 1, 1},
  {&__pyx_n_s__kind, __pyx_k__kind, sizeof(__pyx_k__kind), 0, 0, 1, 1},
  {&__pyx_n_s__kron, __pyx_k__kron, sizeof(__pyx_k__kron), 0, 0, 1, 1},
  {&__pyx_n_s__ldict, __pyx_k__ldict, sizeof(__pyx_k__ldict), 0, 0, 1, 1},
  {&__pyx_n_s__left, __pyx_k__left, sizeof(__pyx_k__left), 0, 0, 1, 1},
  {&__pyx_n_s__lexsort, __pyx_k__lexsort, sizeof(__pyx_k__lexsort), 0, 0, 1, 1},
  {&__pyx_n_s__linefeed, __pyx_k__linefeed, sizeof(__pyx_k__linefeed), 0, 0, 1, 1},
  {&__pyx_n_s__linewidth, __pyx_k__linewidth, sizeof(__pyx_k__linewidth), 0, 0, 1, 1},
  {&__pyx_n_s__load, __pyx_k__load, sizeof(__pyx_k__load), 0, 0, 1, 1},
  {&__pyx_n_s__loads, __pyx_k__loads, sizeof(__pyx_k__loads), 0, 0, 1, 1},
  {&__pyx_n_s__loadtxt, __pyx_k__loadtxt, sizeof(__pyx_k__loadtxt), 0, 0, 1, 1},
  {&__pyx_n_s__lookfor, __pyx_k__lookfor, sizeof(__pyx_k__lookfor), 0, 0, 1, 1},
  {&__pyx_n_s__loose, __pyx_k__loose, sizeof(__pyx_k__loose), 0, 0, 1, 1},
  {&__pyx_n_s__m, __pyx_k__m, sizeof(__pyx_k__m), 0, 0, 1, 1},
  {&__pyx_n_s__mafromtxt, __pyx_k__mafromtxt, sizeof(__pyx_k__mafromtxt), 0, 0, 1, 1},
  {&__pyx_n_s__mask, __pyx_k__mask, sizeof(__pyx_k__mask), 0, 0, 1, 1},
  {&__pyx_n_s__mask_func, __pyx_k__mask_func, sizeof(__pyx_k__mask_func), 0, 0, 1, 1},
  {&__pyx_n_s__mask_indices, __pyx_k__mask_indices, sizeof(__pyx_k__mask_indices), 0, 0, 1, 1},
  {&__pyx_n_s__mat, __pyx_k__mat, sizeof(__pyx_k__mat), 0, 0, 1, 1},
  {&__pyx_n_s__max, __pyx_k__max, sizeof(__pyx_k__max), 0, 0, 1, 1},
  {&__pyx_n_s__max_line_width, __pyx_k__max_line_width, sizeof(__pyx_k__max_line_width), 0, 0, 1, 1},
  {&__pyx_n_s__maximum_sctype, __pyx_k__maximum_sctype, sizeof(__pyx_k__maximum_sctype), 0, 0, 1, 1},
  {&__pyx_n_s__maxiter, __pyx_k__maxiter, sizeof(__pyx_k__maxiter), 0, 0, 1, 1},
  {&__pyx_n_s__maxwidth, __pyx_k__maxwidth, sizeof(__pyx_k__maxwidth), 0, 0, 1, 1},
  {&__pyx_n_s__may_share_memory, __pyx_k__may_share_memory, sizeof(__pyx_k__may_share_memory), 0, 0, 1, 1},
  {&__pyx_n_s__mean, __pyx_k__mean, sizeof(__pyx_k__mean), 0, 0, 1, 1},
  {&__pyx_n_s__median, __pyx_k__median, sizeof(__pyx_k__median), 0, 0, 1, 1},
  {&__pyx_n_s__mesg, __pyx_k__mesg, sizeof(__pyx_k__mesg), 0, 0, 1, 1},
  {&__pyx_n_s__meshgrid, __pyx_k__meshgrid, sizeof(__pyx_k__meshgrid), 0, 0, 1, 1},
  {&__pyx_n_s__min, __pyx_k__min, sizeof(__pyx_k__min), 0, 0, 1, 1},
  {&__pyx_n_s__min_scalar_type, __pyx_k__min_scalar_type, sizeof(__pyx_k__min_scalar_type), 0, 0, 1, 1},
  {&__pyx_n_s__minlength, __pyx_k__minlength, sizeof(__pyx_k__minlength), 0, 0, 1, 1},
  {&__pyx_n_s__mintypecode, __pyx_k__mintypecode, sizeof(__pyx_k__mintypecode), 0, 0, 1, 1},
  {&__pyx_n_s__mirr, __pyx_k__mirr, sizeof(__pyx_k__mirr), 0, 0, 1, 1},
  {&__pyx_n_s__missing, __pyx_k__missing, sizeof(__pyx_k__missing), 0, 0, 1, 1},
  {&__pyx_n_s__missing_values, __pyx_k__missing_values, sizeof(__pyx_k__missing_values), 0, 0, 1, 1},
  {&__pyx_n_s__mmap_mode, __pyx_k__mmap_mode, sizeof(__pyx_k__mmap_mode), 0, 0, 1, 1},
  {&__pyx_n_s__mode, __pyx_k__mode, sizeof(__pyx_k__mode), 0, 0, 1, 1},
  {&__pyx_n_s__module, __pyx_k__module, sizeof(__pyx_k__module), 0, 0, 1, 1},
  {&__pyx_n_s__msg, __pyx_k__msg, sizeof(__pyx_k__msg), 0, 0, 1, 1},
  {&__pyx_n_s__msort, __pyx_k__msort, sizeof(__pyx_k__msort), 0, 0, 1, 1},
  {&__pyx_n_s__multi_index, __pyx_k__multi_index, sizeof(__pyx_k__multi_index), 0, 0, 1, 1},
  {&__pyx_n_s__myarray, __pyx_k__myarray, sizeof(__pyx_k__myarray), 0, 0, 1, 1},
  {&__pyx_n_s__n, __pyx_k__n, sizeof(__pyx_k__n), 0, 0, 1, 1},
  {&__pyx_n_s__names, __pyx_k__names, sizeof(__pyx_k__names), 0, 0, 1, 1},
  {&__pyx_n_s__nan_to_num, __pyx_k__nan_to_num, sizeof(__pyx_k__nan_to_num), 0, 0, 1, 1},
  {&__pyx_n_s__nanargmax, __pyx_k__nanargmax, sizeof(__pyx_k__nanargmax), 0, 0, 1, 1},
  {&__pyx_n_s__nanargmin, __pyx_k__nanargmin, sizeof(__pyx_k__nanargmin), 0, 0, 1, 1},
  {&__pyx_n_s__nanmax, __pyx_k__nanmax, sizeof(__pyx_k__nanmax), 0, 0, 1, 1},
  {&__pyx_n_s__nanmin, __pyx_k__nanmin, sizeof(__pyx_k__nanmin), 0, 0, 1, 1},
  {&__pyx_n_s__nanstr, __pyx_k__nanstr, sizeof(__pyx_k__nanstr), 0, 0, 1, 1},
  {&__pyx_n_s__nansum, __pyx_k__nansum, sizeof(__pyx_k__nansum), 0, 0, 1, 1},
  {&__pyx_n_s__ndfromtxt, __pyx_k__ndfromtxt, sizeof(__pyx_k__ndfromtxt), 0, 0, 1, 1},
  {&__pyx_n_s__ndim, __pyx_k__ndim, sizeof(__pyx_k__ndim), 0, 0, 1, 1},
  {&__pyx_n_s__ndmin, __pyx_k__ndmin, sizeof(__pyx_k__ndmin), 0, 0, 1, 1},
  {&__pyx_n_s__nested_iters, __pyx_k__nested_iters, sizeof(__pyx_k__nested_iters), 0, 0, 1, 1},
  {&__pyx_n_s__new_shape, __pyx_k__new_shape, sizeof(__pyx_k__new_shape), 0, 0, 1, 1},
  {&__pyx_n_s__newbuffer, __pyx_k__newbuffer, sizeof(__pyx_k__newbuffer), 0, 0, 1, 1},
  {&__pyx_n_s__newline, __pyx_k__newline, sizeof(__pyx_k__newline), 0, 0, 1, 1},
  {&__pyx_n_s__newshape, __pyx_k__newshape, sizeof(__pyx_k__newshape), 0, 0, 1, 1},
  {&__pyx_n_s__nin, __pyx_k__nin, sizeof(__pyx_k__nin), 0, 0, 1, 1},
  {&__pyx_n_s__nonzero, __pyx_k__nonzero, sizeof(__pyx_k__nonzero), 0, 0, 1, 1},
  {&__pyx_n_s__normed, __pyx_k__normed, sizeof(__pyx_k__normed), 0, 0, 1, 1},
  {&__pyx_n_s__nout, __pyx_k__nout, sizeof(__pyx_k__nout), 0, 0, 1, 1},
  {&__pyx_n_s__np, __pyx_k__np, sizeof(__pyx_k__np), 0, 0, 1, 1},
  {&__pyx_n_s__nper, __pyx_k__nper, sizeof(__pyx_k__nper), 0, 0, 1, 1},
  {&__pyx_n_s__npv, __pyx_k__npv, sizeof(__pyx_k__npv), 0, 0, 1, 1},
  {&__pyx_n_s__num, __pyx_k__num, sizeof(__pyx_k__num), 0, 0, 1, 1},
  {&__pyx_n_s__number, __pyx_k__number, sizeof(__pyx_k__number), 0, 0, 1, 1},
  {&__pyx_n_s__numpy, __pyx_k__numpy, sizeof(__pyx_k__numpy), 0, 0, 1, 1},
  {&__pyx_n_s__obj, __pyx_k__obj, sizeof(__pyx_k__obj), 0, 0, 1, 1},
  {&__pyx_n_s__obj2sctype, __pyx_k__obj2sctype, sizeof(__pyx_k__obj2sctype), 0, 0, 1, 1},
  {&__pyx_n_s__object, __pyx_k__object, sizeof(__pyx_k__object), 0, 0, 1, 1},
  {&__pyx_n_s__offset, __pyx_k__offset, sizeof(__pyx_k__offset), 0, 0, 1, 1},
  {&__pyx_n_s__old_behavior, __pyx_k__old_behavior, sizeof(__pyx_k__old_behavior), 0, 0, 1, 1},
  {&__pyx_n_s__order, __pyx_k__order, sizeof(__pyx_k__order), 0, 0, 1, 1},
  {&__pyx_n_s__out, __pyx_k__out, sizeof(__pyx_k__out), 0, 0, 1, 1},
  {&__pyx_n_s__outer, __pyx_k__outer, sizeof(__pyx_k__outer), 0, 0, 1, 1},
  {&__pyx_n_s__output, __pyx_k__output, sizeof(__pyx_k__output), 0, 0, 1, 1},
  {&__pyx_n_s__over, __pyx_k__over, sizeof(__pyx_k__over), 0, 0, 1, 1},
  {&__pyx_n_s__overwrite_input, __pyx_k__overwrite_input, sizeof(__pyx_k__overwrite_input), 0, 0, 1, 1},
  {&__pyx_n_s__p, __pyx_k__p, sizeof(__pyx_k__p), 0, 0, 1, 1},
  {&__pyx_n_s__packbits, __pyx_k__packbits, sizeof(__pyx_k__packbits), 0, 0, 1, 1},
  {&__pyx_n_s__padding, __pyx_k__padding, sizeof(__pyx_k__padding), 0, 0, 1, 1},
  {&__pyx_n_s__per, __pyx_k__per, sizeof(__pyx_k__per), 0, 0, 1, 1},
  {&__pyx_n_s__percentile, __pyx_k__percentile, sizeof(__pyx_k__percentile), 0, 0, 1, 1},
  {&__pyx_n_s__piecewise, __pyx_k__piecewise, sizeof(__pyx_k__piecewise), 0, 0, 1, 1},
  {&__pyx_n_s__pkgload, __pyx_k__pkgload, sizeof(__pyx_k__pkgload), 0, 0, 1, 1},
  {&__pyx_n_s__place, __pyx_k__place, sizeof(__pyx_k__place), 0, 0, 1, 1},
  {&__pyx_n_s__pmt, __pyx_k__pmt, sizeof(__pyx_k__pmt), 0, 0, 1, 1},
  {&__pyx_n_s__poly, __pyx_k__poly, sizeof(__pyx_k__poly), 0, 0, 1, 1},
  {&__pyx_n_s__polyadd, __pyx_k__polyadd, sizeof(__pyx_k__polyadd), 0, 0, 1, 1},
  {&__pyx_n_s__polyder, __pyx_k__polyder, sizeof(__pyx_k__polyder), 0, 0, 1, 1},
  {&__pyx_n_s__polydiv, __pyx_k__polydiv, sizeof(__pyx_k__polydiv), 0, 0, 1, 1},
  {&__pyx_n_s__polyfit, __pyx_k__polyfit, sizeof(__pyx_k__polyfit), 0, 0, 1, 1},
  {&__pyx_n_s__polyint, __pyx_k__polyint, sizeof(__pyx_k__polyint), 0, 0, 1, 1},
  {&__pyx_n_s__polymul, __pyx_k__polymul, sizeof(__pyx_k__polymul), 0, 0, 1, 1},
  {&__pyx_n_s__polysub, __pyx_k__polysub, sizeof(__pyx_k__polysub), 0, 0, 1, 1},
  {&__pyx_n_s__polyval, __pyx_k__polyval, sizeof(__pyx_k__polyval), 0, 0, 1, 1},
  {&__pyx_n_s__ppmt, __pyx_k__ppmt, sizeof(__pyx_k__ppmt), 0, 0, 1, 1},
  {&__pyx_n_s__precision, __pyx_k__precision, sizeof(__pyx_k__precision), 0, 0, 1, 1},
  {&__pyx_n_s__prefix, __pyx_k__prefix, sizeof(__pyx_k__prefix), 0, 0, 1, 1},
  {&__pyx_n_s__prod, __pyx_k__prod, sizeof(__pyx_k__prod), 0, 0, 1, 1},
  {&__pyx_n_s__product, __pyx_k__product, sizeof(__pyx_k__product), 0, 0, 1, 1},
  {&__pyx_n_s__promote_types, __pyx_k__promote_types, sizeof(__pyx_k__promote_types), 0, 0, 1, 1},
  {&__pyx_n_s__ptp, __pyx_k__ptp, sizeof(__pyx_k__ptp), 0, 0, 1, 1},
  {&__pyx_n_s__put, __pyx_k__put, sizeof(__pyx_k__put), 0, 0, 1, 1},
  {&__pyx_n_s__putmask, __pyx_k__putmask, sizeof(__pyx_k__putmask), 0, 0, 1, 1},
  {&__pyx_n_s__pv, __pyx_k__pv, sizeof(__pyx_k__pv), 0, 0, 1, 1},
  {&__pyx_n_s__q, __pyx_k__q, sizeof(__pyx_k__q), 0, 0, 1, 1},
  {&__pyx_n_s__quicksort, __pyx_k__quicksort, sizeof(__pyx_k__quicksort), 0, 0, 1, 1},
  {&__pyx_n_s__raise, __pyx_k__raise, sizeof(__pyx_k__raise), 0, 0, 1, 1},
  {&__pyx_n_s__range, __pyx_k__range, sizeof(__pyx_k__range), 0, 0, 1, 1},
  {&__pyx_n_s__rank, __pyx_k__rank, sizeof(__pyx_k__rank), 0, 0, 1, 1},
  {&__pyx_n_s__rate, __pyx_k__rate, sizeof(__pyx_k__rate), 0, 0, 1, 1},
  {&__pyx_n_s__ravel, __pyx_k__ravel, sizeof(__pyx_k__ravel), 0, 0, 1, 1},
  {&__pyx_n_s__ravel_multi_index, __pyx_k__ravel_multi_index, sizeof(__pyx_k__ravel_multi_index), 0, 0, 1, 1},
  {&__pyx_n_s__rcond, __pyx_k__rcond, sizeof(__pyx_k__rcond), 0, 0, 1, 1},
  {&__pyx_n_s__real, __pyx_k__real, sizeof(__pyx_k__real), 0, 0, 1, 1},
  {&__pyx_n_s__real_if_close, __pyx_k__real_if_close, sizeof(__pyx_k__real_if_close), 0, 0, 1, 1},
  {&__pyx_n_s__recfromcsv, __pyx_k__recfromcsv, sizeof(__pyx_k__recfromcsv), 0, 0, 1, 1},
  {&__pyx_n_s__recfromtxt, __pyx_k__recfromtxt, sizeof(__pyx_k__recfromtxt), 0, 0, 1, 1},
  {&__pyx_n_s__regenerate, __pyx_k__regenerate, sizeof(__pyx_k__regenerate), 0, 0, 1, 1},
  {&__pyx_n_s__regexp, __pyx_k__regexp, sizeof(__pyx_k__regexp), 0, 0, 1, 1},
  {&__pyx_n_s__reinvest_rate, __pyx_k__reinvest_rate, sizeof(__pyx_k__reinvest_rate), 0, 0, 1, 1},
  {&__pyx_n_s__rep, __pyx_k__rep, sizeof(__pyx_k__rep), 0, 0, 1, 1},
  {&__pyx_n_s__repeat, __pyx_k__repeat, sizeof(__pyx_k__repeat), 0, 0, 1, 1},
  {&__pyx_n_s__repeats, __pyx_k__repeats, sizeof(__pyx_k__repeats), 0, 0, 1, 1},
  {&__pyx_n_s__replace_space, __pyx_k__replace_space, sizeof(__pyx_k__replace_space), 0, 0, 1, 1},
  {&__pyx_n_s__repr, __pyx_k__repr, sizeof(__pyx_k__repr), 0, 0, 1, 1},
  {&__pyx_n_s__reps, __pyx_k__reps, sizeof(__pyx_k__reps), 0, 0, 1, 1},
  {&__pyx_n_s__require, __pyx_k__require, sizeof(__pyx_k__require), 0, 0, 1, 1},
  {&__pyx_n_s__requirements, __pyx_k__requirements, sizeof(__pyx_k__requirements), 0, 0, 1, 1},
  {&__pyx_n_s__reshape, __pyx_k__reshape, sizeof(__pyx_k__reshape), 0, 0, 1, 1},
  {&__pyx_n_s__resize, __pyx_k__resize, sizeof(__pyx_k__resize), 0, 0, 1, 1},
  {&__pyx_n_s__restoredot, __pyx_k__restoredot, sizeof(__pyx_k__restoredot), 0, 0, 1, 1},
  {&__pyx_n_s__result_type, __pyx_k__result_type, sizeof(__pyx_k__result_type), 0, 0, 1, 1},
  {&__pyx_n_s__return_index, __pyx_k__return_index, sizeof(__pyx_k__return_index), 0, 0, 1, 1},
  {&__pyx_n_s__return_inverse, __pyx_k__return_inverse, sizeof(__pyx_k__return_inverse), 0, 0, 1, 1},
  {&__pyx_n_s__returned, __pyx_k__returned, sizeof(__pyx_k__returned), 0, 0, 1, 1},
  {&__pyx_n_s__right, __pyx_k__right, sizeof(__pyx_k__right), 0, 0, 1, 1},
  {&__pyx_n_s__roll, __pyx_k__roll, sizeof(__pyx_k__roll), 0, 0, 1, 1},
  {&__pyx_n_s__rollaxis, __pyx_k__rollaxis, sizeof(__pyx_k__rollaxis), 0, 0, 1, 1},
  {&__pyx_n_s__roots, __pyx_k__roots, sizeof(__pyx_k__roots), 0, 0, 1, 1},
  {&__pyx_n_s__rot90, __pyx_k__rot90, sizeof(__pyx_k__rot90), 0, 0, 1, 1},
  {&__pyx_n_s__round, __pyx_k__round, sizeof(__pyx_k__round), 0, 0, 1, 1},
  {&__pyx_n_s__round_, __pyx_k__round_, sizeof(__pyx_k__round_), 0, 0, 1, 1},
  {&__pyx_n_s__row_stack, __pyx_k__row_stack, sizeof(__pyx_k__row_stack), 0, 0, 1, 1},
  {&__pyx_n_s__rowvar, __pyx_k__rowvar, sizeof(__pyx_k__rowvar), 0, 0, 1, 1},
  {&__pyx_n_s__rtol, __pyx_k__rtol, sizeof(__pyx_k__rtol), 0, 0, 1, 1},
  {&__pyx_n_s__safe_eval, __pyx_k__safe_eval, sizeof(__pyx_k__safe_eval), 0, 0, 1, 1},
  {&__pyx_n_s__sample, __pyx_k__sample, sizeof(__pyx_k__sample), 0, 0, 1, 1},
  {&__pyx_n_s__save, __pyx_k__save, sizeof(__pyx_k__save), 0, 0, 1, 1},
  {&__pyx_n_s__savetxt, __pyx_k__savetxt, sizeof(__pyx_k__savetxt), 0, 0, 1, 1},
  {&__pyx_n_s__savez, __pyx_k__savez, sizeof(__pyx_k__savez), 0, 0, 1, 1},
  {&__pyx_n_s__savez_compressed, __pyx_k__savez_compressed, sizeof(__pyx_k__savez_compressed), 0, 0, 1, 1},
  {&__pyx_n_s__scalar_types, __pyx_k__scalar_types, sizeof(__pyx_k__scalar_types), 0, 0, 1, 1},
  {&__pyx_n_s__sctype, __pyx_k__sctype, sizeof(__pyx_k__sctype), 0, 0, 1, 1},
  {&__pyx_n_s__sctype2char, __pyx_k__sctype2char, sizeof(__pyx_k__sctype2char), 0, 0, 1, 1},
  {&__pyx_n_s__searchsorted, __pyx_k__searchsorted, sizeof(__pyx_k__searchsorted), 0, 0, 1, 1},
  {&__pyx_n_s__select, __pyx_k__select, sizeof(__pyx_k__select), 0, 0, 1, 1},
  {&__pyx_n_s__sep, __pyx_k__sep, sizeof(__pyx_k__sep), 0, 0, 1, 1},
  {&__pyx_n_s__separator, __pyx_k__separator, sizeof(__pyx_k__separator), 0, 0, 1, 1},
  {&__pyx_n_s__seq_of_zeros, __pyx_k__seq_of_zeros, sizeof(__pyx_k__seq_of_zeros), 0, 0, 1, 1},
  {&__pyx_n_s__set_numeric_ops, __pyx_k__set_numeric_ops, sizeof(__pyx_k__set_numeric_ops), 0, 0, 1, 1},
  {&__pyx_n_s__set_printoptions, __pyx_k__set_printoptions, sizeof(__pyx_k__set_printoptions), 0, 0, 1, 1},
  {&__pyx_n_s__set_string_function, __pyx_k__set_string_function, sizeof(__pyx_k__set_string_function), 0, 0, 1, 1},
  {&__pyx_n_s__setbufsize, __pyx_k__setbufsize, sizeof(__pyx_k__setbufsize), 0, 0, 1, 1},
  {&__pyx_n_s__setdiff1d, __pyx_k__setdiff1d, sizeof(__pyx_k__setdiff1d), 0, 0, 1, 1},
  {&__pyx_n_s__seterr, __pyx_k__seterr, sizeof(__pyx_k__seterr), 0, 0, 1, 1},
  {&__pyx_n_s__seterrcall, __pyx_k__seterrcall, sizeof(__pyx_k__seterrcall), 0, 0, 1, 1},
  {&__pyx_n_s__seterrobj, __pyx_k__seterrobj, sizeof(__pyx_k__seterrobj), 0, 0, 1, 1},
  {&__pyx_n_s__setxor1d, __pyx_k__setxor1d, sizeof(__pyx_k__setxor1d), 0, 0, 1, 1},
  {&__pyx_n_s__shift, __pyx_k__shift, sizeof(__pyx_k__shift), 0, 0, 1, 1},
  {&__pyx_n_s__show_config, __pyx_k__show_config, sizeof(__pyx_k__show_config), 0, 0, 1, 1},
  {&__pyx_n_s__side, __pyx_k__side, sizeof(__pyx_k__side), 0, 0, 1, 1},
  {&__pyx_n_s__sinc, __pyx_k__sinc, sizeof(__pyx_k__sinc), 0, 0, 1, 1},
  {&__pyx_n_s__size, __pyx_k__size, sizeof(__pyx_k__size), 0, 0, 1, 1},
  {&__pyx_n_s__skip_footer, __pyx_k__skip_footer, sizeof(__pyx_k__skip_footer), 0, 0, 1, 1},
  {&__pyx_n_s__skip_header, __pyx_k__skip_header, sizeof(__pyx_k__skip_header), 0, 0, 1, 1},
  {&__pyx_n_s__skiprows, __pyx_k__skiprows, sizeof(__pyx_k__skiprows), 0, 0, 1, 1},
  {&__pyx_n_s__sometrue, __pyx_k__sometrue, sizeof(__pyx_k__sometrue), 0, 0, 1, 1},
  {&__pyx_n_s__sort, __pyx_k__sort, sizeof(__pyx_k__sort), 0, 0, 1, 1},
  {&__pyx_n_s__sort_complex, __pyx_k__sort_complex, sizeof(__pyx_k__sort_complex), 0, 0, 1, 1},
  {&__pyx_n_s__source, __pyx_k__source, sizeof(__pyx_k__source), 0, 0, 1, 1},
  {&__pyx_n_s__split, __pyx_k__split, sizeof(__pyx_k__split), 0, 0, 1, 1},
  {&__pyx_n_s__squeeze, __pyx_k__squeeze, sizeof(__pyx_k__squeeze), 0, 0, 1, 1},
  {&__pyx_n_s__start, __pyx_k__start, sizeof(__pyx_k__start), 0, 0, 1, 1},
  {&__pyx_n_s__std, __pyx_k__std, sizeof(__pyx_k__std), 0, 0, 1, 1},
  {&__pyx_n_s__stdout, __pyx_k__stdout, sizeof(__pyx_k__stdout), 0, 0, 1, 1},
  {&__pyx_n_s__string, __pyx_k__string, sizeof(__pyx_k__string), 0, 0, 1, 1},
  {&__pyx_n_s__style, __pyx_k__style, sizeof(__pyx_k__style), 0, 0, 1, 1},
  {&__pyx_n_s__subok, __pyx_k__subok, sizeof(__pyx_k__subok), 0, 0, 1, 1},
  {&__pyx_n_s__sum, __pyx_k__sum, sizeof(__pyx_k__sum), 0, 0, 1, 1},
  {&__pyx_n_s__suppress, __pyx_k__suppress, sizeof(__pyx_k__suppress), 0, 0, 1, 1},
  {&__pyx_n_s__suppress_small, __pyx_k__suppress_small, sizeof(__pyx_k__suppress_small), 0, 0, 1, 1},
  {&__pyx_n_s__swapaxes, __pyx_k__swapaxes, sizeof(__pyx_k__swapaxes), 0, 0, 1, 1},
  {&__pyx_n_s__sys, __pyx_k__sys, sizeof(__pyx_k__sys), 0, 0, 1, 1},
  {&__pyx_n_s__t, __pyx_k__t, sizeof(__pyx_k__t), 0, 0, 1, 1},
  {&__pyx_n_s__take, __pyx_k__take, sizeof(__pyx_k__take), 0, 0, 1, 1},
  {&__pyx_n_s__tensordot, __pyx_k__tensordot, sizeof(__pyx_k__tensordot), 0, 0, 1, 1},
  {&__pyx_n_s__threshold, __pyx_k__threshold, sizeof(__pyx_k__threshold), 0, 0, 1, 1},
  {&__pyx_n_s__tile, __pyx_k__tile, sizeof(__pyx_k__tile), 0, 0, 1, 1},
  {&__pyx_n_s__to_begin, __pyx_k__to_begin, sizeof(__pyx_k__to_begin), 0, 0, 1, 1},
  {&__pyx_n_s__to_end, __pyx_k__to_end, sizeof(__pyx_k__to_end), 0, 0, 1, 1},
  {&__pyx_n_s__tol, __pyx_k__tol, sizeof(__pyx_k__tol), 0, 0, 1, 1},
  {&__pyx_n_s__toplevel, __pyx_k__toplevel, sizeof(__pyx_k__toplevel), 0, 0, 1, 1},
  {&__pyx_n_s__trace, __pyx_k__trace, sizeof(__pyx_k__trace), 0, 0, 1, 1},
  {&__pyx_n_s__transpose, __pyx_k__transpose, sizeof(__pyx_k__transpose), 0, 0, 1, 1},
  {&__pyx_n_s__trapz, __pyx_k__trapz, sizeof(__pyx_k__trapz), 0, 0, 1, 1},
  {&__pyx_n_s__tri, __pyx_k__tri, sizeof(__pyx_k__tri), 0, 0, 1, 1},
  {&__pyx_n_s__tril, __pyx_k__tril, sizeof(__pyx_k__tril), 0, 0, 1, 1},
  {&__pyx_n_s__tril_indices, __pyx_k__tril_indices, sizeof(__pyx_k__tril_indices), 0, 0, 1, 1},
  {&__pyx_n_s__tril_indices_from, __pyx_k__tril_indices_from, sizeof(__pyx_k__tril_indices_from), 0, 0, 1, 1},
  {&__pyx_n_s__trim, __pyx_k__trim, sizeof(__pyx_k__trim), 0, 0, 1, 1},
  {&__pyx_n_s__trim_zeros, __pyx_k__trim_zeros, sizeof(__pyx_k__trim_zeros), 0, 0, 1, 1},
  {&__pyx_n_s__triu, __pyx_k__triu, sizeof(__pyx_k__triu), 0, 0, 1, 1},
  {&__pyx_n_s__triu_indices, __pyx_k__triu_indices, sizeof(__pyx_k__triu_indices), 0, 0, 1, 1},
  {&__pyx_n_s__triu_indices_from, __pyx_k__triu_indices_from, sizeof(__pyx_k__triu_indices_from), 0, 0, 1, 1},
  {&__pyx_n_s__tup, __pyx_k__tup, sizeof(__pyx_k__tup), 0, 0, 1, 1},
  {&__pyx_n_s__type, __pyx_k__type, sizeof(__pyx_k__type), 0, 0, 1, 1},
  {&__pyx_n_s__type1, __pyx_k__type1, sizeof(__pyx_k__type1), 0, 0, 1, 1},
  {&__pyx_n_s__type2, __pyx_k__type2, sizeof(__pyx_k__type2), 0, 0, 1, 1},
  {&__pyx_n_s__typechars, __pyx_k__typechars, sizeof(__pyx_k__typechars), 0, 0, 1, 1},
  {&__pyx_n_s__typename, __pyx_k__typename, sizeof(__pyx_k__typename), 0, 0, 1, 1},
  {&__pyx_n_s__typeset, __pyx_k__typeset, sizeof(__pyx_k__typeset), 0, 0, 1, 1},
  {&__pyx_n_s__u, __pyx_k__u, sizeof(__pyx_k__u), 0, 0, 1, 1},
  {&__pyx_n_s__under, __pyx_k__under, sizeof(__pyx_k__under), 0, 0, 1, 1},
  {&__pyx_n_s__union1d, __pyx_k__union1d, sizeof(__pyx_k__union1d), 0, 0, 1, 1},
  {&__pyx_n_s__unique, __pyx_k__unique, sizeof(__pyx_k__unique), 0, 0, 1, 1},
  {&__pyx_n_s__unpack, __pyx_k__unpack, sizeof(__pyx_k__unpack), 0, 0, 1, 1},
  {&__pyx_n_s__unpackbits, __pyx_k__unpackbits, sizeof(__pyx_k__unpackbits), 0, 0, 1, 1},
  {&__pyx_n_s__unravel_index, __pyx_k__unravel_index, sizeof(__pyx_k__unravel_index), 0, 0, 1, 1},
  {&__pyx_n_s__unwrap, __pyx_k__unwrap, sizeof(__pyx_k__unwrap), 0, 0, 1, 1},
  {&__pyx_n_s__usecols, __pyx_k__usecols, sizeof(__pyx_k__usecols), 0, 0, 1, 1},
  {&__pyx_n_s__usemask, __pyx_k__usemask, sizeof(__pyx_k__usemask), 0, 0, 1, 1},
  {&__pyx_n_s__v, __pyx_k__v, sizeof(__pyx_k__v), 0, 0, 1, 1},
  {&__pyx_n_s__val, __pyx_k__val, sizeof(__pyx_k__val), 0, 0, 1, 1},
  {&__pyx_n_s__valid, __pyx_k__valid, sizeof(__pyx_k__valid), 0, 0, 1, 1},
  {&__pyx_n_s__vals, __pyx_k__vals, sizeof(__pyx_k__vals), 0, 0, 1, 1},
  {&__pyx_n_s__values, __pyx_k__values, sizeof(__pyx_k__values), 0, 0, 1, 1},
  {&__pyx_n_s__vander, __pyx_k__vander, sizeof(__pyx_k__vander), 0, 0, 1, 1},
  {&__pyx_n_s__var, __pyx_k__var, sizeof(__pyx_k__var), 0, 0, 1, 1},
  {&__pyx_n_s__vardict, __pyx_k__vardict, sizeof(__pyx_k__vardict), 0, 0, 1, 1},
  {&__pyx_n_s__vdot, __pyx_k__vdot, sizeof(__pyx_k__vdot), 0, 0, 1, 1},
  {&__pyx_n_s__vsplit, __pyx_k__vsplit, sizeof(__pyx_k__vsplit), 0, 0, 1, 1},
  {&__pyx_n_s__vstack, __pyx_k__vstack, sizeof(__pyx_k__vstack), 0, 0, 1, 1},
  {&__pyx_n_s__weights, __pyx_k__weights, sizeof(__pyx_k__weights), 0, 0, 1, 1},
  {&__pyx_n_s__what, __pyx_k__what, sizeof(__pyx_k__what), 0, 0, 1, 1},
  {&__pyx_n_s__when, __pyx_k__when, sizeof(__pyx_k__when), 0, 0, 1, 1},
  {&__pyx_n_s__where, __pyx_k__where, sizeof(__pyx_k__where), 0, 0, 1, 1},
  {&__pyx_n_s__who, __pyx_k__who, sizeof(__pyx_k__who), 0, 0, 1, 1},
  {&__pyx_n_s__width, __pyx_k__width, sizeof(__pyx_k__width), 0, 0, 1, 1},
  {&__pyx_n_s__x, __pyx_k__x, sizeof(__pyx_k__x), 0, 0, 1, 1},
  {&__pyx_n_s__xp, __pyx_k__xp, sizeof(__pyx_k__xp), 0, 0, 1, 1},
  {&__pyx_n_s__y, __pyx_k__y, sizeof(__pyx_k__y), 0, 0, 1, 1},
  {&__pyx_n_s__z, __pyx_k__z, sizeof(__pyx_k__z), 0, 0, 1, 1},
  {0, 0, 0, 0, 0, 0, 0}
};
static int __Pyx_InitCachedBuiltins(void) {
  __pyx_builtin_NotImplementedError = __Pyx_GetBuiltinName(__pyx_n_s__NotImplementedError); if (!__pyx_builtin_NotImplementedError) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 18; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s__ValueError); if (!__pyx_builtin_ValueError) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 215; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_builtin_range = __Pyx_GetBuiltinName(__pyx_n_s__range); if (!__pyx_builtin_range) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 228; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_builtin_RuntimeError = __Pyx_GetBuiltinName(__pyx_n_s__RuntimeError); if (!__pyx_builtin_RuntimeError) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 799; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  return 0;
  __pyx_L1_error:;
  return -1;
}

static int __Pyx_InitCachedConstants(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants", 0);

  /* "numpy.pxd":215
 *             if ((flags & pybuf.PyBUF_C_CONTIGUOUS == pybuf.PyBUF_C_CONTIGUOUS)
 *                 and not PyArray_CHKFLAGS(self, NPY_C_CONTIGUOUS)):
 *                 raise ValueError(u"ndarray is not C contiguous")             # <<<<<<<<<<<<<<
 * 
 *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)
 */
  __pyx_k_tuple_54 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_u_53)); if (unlikely(!__pyx_k_tuple_54)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 215; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_54);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_54));

  /* "numpy.pxd":219
 *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)
 *                 and not PyArray_CHKFLAGS(self, NPY_F_CONTIGUOUS)):
 *                 raise ValueError(u"ndarray is not Fortran contiguous")             # <<<<<<<<<<<<<<
 * 
 *             info.buf = PyArray_DATA(self)
 */
  __pyx_k_tuple_56 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_u_55)); if (unlikely(!__pyx_k_tuple_56)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 219; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_56);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_56));

  /* "numpy.pxd":257
 *                 if ((descr.byteorder == c'>' and little_endian) or
 *                     (descr.byteorder == c'<' and not little_endian)):
 *                     raise ValueError(u"Non-native byte order not supported")             # <<<<<<<<<<<<<<
 *                 if   t == NPY_BYTE:        f = "b"
 *                 elif t == NPY_UBYTE:       f = "B"
 */
  __pyx_k_tuple_58 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_u_57)); if (unlikely(!__pyx_k_tuple_58)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 257; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_58);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_58));

  /* "numpy.pxd":799
 * 
 *         if (end - f) - (new_offset - offset[0]) < 15:
 *             raise RuntimeError(u"Format string allocated too short, see comment in numpy.pxd")             # <<<<<<<<<<<<<<
 * 
 *         if ((child.byteorder == c'>' and little_endian) or
 */
  __pyx_k_tuple_61 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_u_60)); if (unlikely(!__pyx_k_tuple_61)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 799; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_61);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_61));

  /* "numpy.pxd":803
 *         if ((child.byteorder == c'>' and little_endian) or
 *             (child.byteorder == c'<' and not little_endian)):
 *             raise ValueError(u"Non-native byte order not supported")             # <<<<<<<<<<<<<<
 *             # One could encode it in the format string and have Cython
 *             # complain instead, BUT: < and > in format strings also imply
 */
  __pyx_k_tuple_62 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_u_57)); if (unlikely(!__pyx_k_tuple_62)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 803; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_62);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_62));

  /* "numpy.pxd":823
 *             t = child.type_num
 *             if end - f < 5:
 *                 raise RuntimeError(u"Format string allocated too short.")             # <<<<<<<<<<<<<<
 * 
 *             # Until ticket #99 is fixed, use integers to avoid warnings
 */
  __pyx_k_tuple_64 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_u_63)); if (unlikely(!__pyx_k_tuple_64)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 823; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_64);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_64));

  /* "ga4py/gain/notimplemented.pyx":8
 * 
 * 
 * def docstring(obj, docstring):             # <<<<<<<<<<<<<<
 *     """docstring(obj, docstring)
 * 
 */
  __pyx_k_tuple_65 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__obj), ((PyObject *)__pyx_n_s__docstring)); if (unlikely(!__pyx_k_tuple_65)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_65);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_65));
  __pyx_k_codeobj_66 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_65, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__docstring, 8, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_66)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":21
 * 
 * 
 * def add_newdoc(place, obj, doc):             # <<<<<<<<<<<<<<
 *     """Adds documentation to obj which is in module place.
 * 
 */
  __pyx_k_tuple_69 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__place), ((PyObject *)__pyx_n_s__obj), ((PyObject *)__pyx_n_s__doc)); if (unlikely(!__pyx_k_tuple_69)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 21; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_69);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_69));
  __pyx_k_codeobj_70 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_69, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__add_newdoc, 21, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_70)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 21; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":40
 * 
 * 
 * def all(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Test whether all array elements along a given axis evaluate to True.
 * 
 */
  __pyx_k_tuple_71 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__axis), ((PyObject *)__pyx_n_s__out)); if (unlikely(!__pyx_k_tuple_71)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 40; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_71);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_71));
  __pyx_k_codeobj_72 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_71, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__all, 40, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_72)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 40; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":99
 * 
 * 
 * def allclose(a, b, rtol=1e-05, atol=1e-08):             # <<<<<<<<<<<<<<
 *     """Returns True if two arrays are element-wise equal within a tolerance.
 * 
 */
  __pyx_k_tuple_73 = PyTuple_Pack(4, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__b), ((PyObject *)__pyx_n_s__rtol), ((PyObject *)__pyx_n_s__atol)); if (unlikely(!__pyx_k_tuple_73)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 99; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_73);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_73));
  __pyx_k_codeobj_74 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_73, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__allclose, 99, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_74)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 99; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":153
 * 
 * 
 * def alltrue(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Check if all elements of input array are true.
 * 
 */
  __pyx_k_tuple_75 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__axis), ((PyObject *)__pyx_n_s__out)); if (unlikely(!__pyx_k_tuple_75)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 153; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_75);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_75));
  __pyx_k_codeobj_76 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_75, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__alltrue, 153, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_76)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 153; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":164
 * 
 * 
 * def alterdot():             # <<<<<<<<<<<<<<
 *     """Change `dot`, `vdot`, and `innerproduct` to use accelerated BLAS functions.
 * 
 */
  __pyx_k_codeobj_77 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__alterdot, 164, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_77)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 164; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":187
 * 
 * 
 * def amax(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the maximum of an array or maximum along an axis.
 * 
 */
  __pyx_k_tuple_78 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__axis), ((PyObject *)__pyx_n_s__out)); if (unlikely(!__pyx_k_tuple_78)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 187; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_78);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_78));
  __pyx_k_codeobj_79 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_78, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__amax, 187, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_79)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 187; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":244
 * 
 * 
 * def amin(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the minimum of an array or minimum along an axis.
 * 
 */
  __pyx_k_tuple_80 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__axis), ((PyObject *)__pyx_n_s__out)); if (unlikely(!__pyx_k_tuple_80)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 244; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_80);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_80));
  __pyx_k_codeobj_81 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_80, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__amin, 244, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_81)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 244; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":301
 * 
 * 
 * def angle(z, deg=0):             # <<<<<<<<<<<<<<
 *     """Return the angle of the complex argument.
 * 
 */
  __pyx_k_tuple_82 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__z), ((PyObject *)__pyx_n_s__deg)); if (unlikely(!__pyx_k_tuple_82)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 301; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_82);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_82));
  __pyx_k_codeobj_83 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_82, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__angle, 301, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_83)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 301; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":335
 * 
 * 
 * def any(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Test whether any array element along a given axis evaluates to True.
 * 
 */
  __pyx_k_tuple_84 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__axis), ((PyObject *)__pyx_n_s__out)); if (unlikely(!__pyx_k_tuple_84)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 335; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_84);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_84));
  __pyx_k_codeobj_85 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_84, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__any, 335, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_85)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 335; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":401
 * 
 * 
 * def append(arr, values, axis=None):             # <<<<<<<<<<<<<<
 *     """Append values to the end of an array.
 * 
 */
  __pyx_k_tuple_86 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__arr), ((PyObject *)__pyx_n_s__values), ((PyObject *)__pyx_n_s__axis)); if (unlikely(!__pyx_k_tuple_86)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 401; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_86);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_86));
  __pyx_k_codeobj_87 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_86, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__append, 401, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_87)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 401; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":449
 * 
 * 
 * def apply_along_axis(func1d, axis, arr):             # <<<<<<<<<<<<<<
 *     """Apply a function to 1-D slices along the given axis.
 * 
 */
  __pyx_k_tuple_88 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__func1d), ((PyObject *)__pyx_n_s__axis), ((PyObject *)__pyx_n_s__arr)); if (unlikely(!__pyx_k_tuple_88)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 449; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_88);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_88));
  __pyx_k_codeobj_89 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_88, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__apply_along_axis, 449, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_89)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 449; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":506
 * 
 * 
 * def apply_over_axes(func, a, axes):             # <<<<<<<<<<<<<<
 *     """Apply a function repeatedly over multiple axes.
 * 
 */
  __pyx_k_tuple_90 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__func), ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__axes)); if (unlikely(!__pyx_k_tuple_90)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 506; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_90);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_90));
  __pyx_k_codeobj_91 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_90, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__apply_over_axes, 506, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_91)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 506; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":560
 * 
 * 
 * def argmax(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Indices of the maximum values along an axis.
 * 
 */
  __pyx_k_tuple_92 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__axis)); if (unlikely(!__pyx_k_tuple_92)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 560; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_92);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_92));
  __pyx_k_codeobj_93 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_92, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__argmax, 560, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_93)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 560; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":612
 * 
 * 
 * def argmin(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Return the indices of the minimum values along an axis.
 * 
 */
  __pyx_k_tuple_94 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__axis)); if (unlikely(!__pyx_k_tuple_94)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 612; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_94);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_94));
  __pyx_k_codeobj_95 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_94, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__argmin, 612, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_95)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 612; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":624
 * 
 * 
 * def argsort(a, axis=-1, kind='quicksort', order=None):             # <<<<<<<<<<<<<<
 *     """Returns the indices that would sort an array.
 * 
 */
  __pyx_k_tuple_96 = PyTuple_Pack(4, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__axis), ((PyObject *)__pyx_n_s__kind), ((PyObject *)__pyx_n_s__order)); if (unlikely(!__pyx_k_tuple_96)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 624; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_96);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_96));
  __pyx_k_codeobj_97 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_96, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__argsort, 624, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_97)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 624; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":704
 * 
 * 
 * def argwhere(a):             # <<<<<<<<<<<<<<
 *     """Find the indices of array elements that are non-zero, grouped by element.
 * 
 */
  __pyx_k_tuple_98 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__a)); if (unlikely(!__pyx_k_tuple_98)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 704; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_98);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_98));
  __pyx_k_codeobj_99 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_98, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__argwhere, 704, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_99)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 704; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":744
 * 
 * 
 * def around(a, decimals=0, out=None):             # <<<<<<<<<<<<<<
 *     """Evenly round to the given number of decimals.
 * 
 */
  __pyx_k_tuple_100 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__decimals), ((PyObject *)__pyx_n_s__out)); if (unlikely(!__pyx_k_tuple_100)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 744; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_100);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_100));
  __pyx_k_codeobj_101 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_100, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__around, 744, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_101)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 744; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":812
 * 
 * 
 * def array(object, dtype=None, copy=True, order=None, subok=False, ndmin=0):             # <<<<<<<<<<<<<<
 *     """array(object, dtype=None, copy=True, order=None, subok=False, ndmin=0)
 * 
 */
  __pyx_k_tuple_102 = PyTuple_Pack(6, ((PyObject *)__pyx_n_s__object), ((PyObject *)__pyx_n_s__dtype), ((PyObject *)__pyx_n_s__copy), ((PyObject *)__pyx_n_s__order), ((PyObject *)__pyx_n_s__subok), ((PyObject *)__pyx_n_s__ndmin)); if (unlikely(!__pyx_k_tuple_102)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 812; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_102);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_102));
  __pyx_k_codeobj_103 = (PyObject*)__Pyx_PyCode_New(6, 0, 6, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_102, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__array, 812, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_103)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 812; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":906
 * 
 * 
 * def array2string(a, max_line_width=None, precision=None, suppress_small=None, separator=' ', prefix='', style=repr):             # <<<<<<<<<<<<<<
 *     """Return a string representation of an array.
 * 
 */
  __pyx_k_tuple_104 = PyTuple_Pack(7, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__max_line_width), ((PyObject *)__pyx_n_s__precision), ((PyObject *)__pyx_n_s__suppress_small), ((PyObject *)__pyx_n_s__separator), ((PyObject *)__pyx_n_s__prefix), ((PyObject *)__pyx_n_s__style)); if (unlikely(!__pyx_k_tuple_104)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 906; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_104);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_104));
  __pyx_k_codeobj_105 = (PyObject*)__Pyx_PyCode_New(7, 0, 7, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_104, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__array2string, 906, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_105)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 906; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":955
 * 
 * 
 * def array_equal(a1, a2):             # <<<<<<<<<<<<<<
 *     """True if two arrays have the same shape and elements, False otherwise.
 * 
 */
  __pyx_k_tuple_106 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__a1), ((PyObject *)__pyx_n_s__a2)); if (unlikely(!__pyx_k_tuple_106)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 955; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_106);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_106));
  __pyx_k_codeobj_107 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_106, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__array_equal, 955, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_107)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 955; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":990
 * 
 * 
 * def array_equiv(a1, a2):             # <<<<<<<<<<<<<<
 *     """Returns True if input arrays are shape consistent and all elements equal.
 * 
 */
  __pyx_k_tuple_108 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__a1), ((PyObject *)__pyx_n_s__a2)); if (unlikely(!__pyx_k_tuple_108)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 990; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_108);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_108));
  __pyx_k_codeobj_109 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_108, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__array_equiv, 990, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_109)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 990; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":1027
 * 
 * 
 * def array_repr(arr, max_line_width=None, precision=None, suppress_small=None):             # <<<<<<<<<<<<<<
 *     """Return the string representation of an array.
 * 
 */
  __pyx_k_tuple_110 = PyTuple_Pack(4, ((PyObject *)__pyx_n_s__arr), ((PyObject *)__pyx_n_s__max_line_width), ((PyObject *)__pyx_n_s__precision), ((PyObject *)__pyx_n_s__suppress_small)); if (unlikely(!__pyx_k_tuple_110)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1027; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_110);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_110));
  __pyx_k_codeobj_111 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_110, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__array_repr, 1027, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_111)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1027; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":1071
 * 
 * 
 * def array_split(ary, indices_or_sections, axis=0):             # <<<<<<<<<<<<<<
 *     """Split an array into multiple sub-arrays of equal or near-equal size.
 * 
 */
  __pyx_k_tuple_112 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__ary), ((PyObject *)__pyx_n_s__indices_or_sections), ((PyObject *)__pyx_n_s__axis)); if (unlikely(!__pyx_k_tuple_112)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1071; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_112);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_112));
  __pyx_k_codeobj_113 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_112, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__array_split, 1071, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_113)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1071; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":1093
 * 
 * 
 * def array_str(a, max_line_width=None, precision=None, suppress_small=None):             # <<<<<<<<<<<<<<
 *     """Return a string representation of the data in an array.
 * 
 */
  __pyx_k_tuple_114 = PyTuple_Pack(4, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__max_line_width), ((PyObject *)__pyx_n_s__precision), ((PyObject *)__pyx_n_s__suppress_small)); if (unlikely(!__pyx_k_tuple_114)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1093; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_114);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_114));
  __pyx_k_codeobj_115 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_114, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__array_str, 1093, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_115)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1093; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":1129
 * 
 * 
 * def asanyarray(a, dtype=None, order=None):             # <<<<<<<<<<<<<<
 *     """Convert the input to an ndarray, but pass ndarray subclasses through.
 * 
 */
  __pyx_k_tuple_116 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__dtype), ((PyObject *)__pyx_n_s__order)); if (unlikely(!__pyx_k_tuple_116)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1129; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_116);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_116));
  __pyx_k_codeobj_117 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_116, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__asanyarray, 1129, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_117)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1129; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":1181
 * 
 * 
 * def asarray_chkfinite(a):             # <<<<<<<<<<<<<<
 *     """Convert the input to an array, checking for NaNs or Infs.
 * 
 */
  __pyx_k_tuple_118 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__a)); if (unlikely(!__pyx_k_tuple_118)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1181; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_118);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_118));
  __pyx_k_codeobj_119 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_118, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__asarray_chkfinite, 1181, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_119)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1181; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":1243
 * 
 * 
 * def ascontiguousarray(a, dtype=None):             # <<<<<<<<<<<<<<
 *     """Return a contiguous array in memory (C order).
 * 
 */
  __pyx_k_tuple_120 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__dtype)); if (unlikely(!__pyx_k_tuple_120)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1243; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_120);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_120));
  __pyx_k_codeobj_121 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_120, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__ascontiguousarray, 1243, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_121)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1243; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":1279
 * 
 * 
 * def asfarray(a, dtype=np.float64):             # <<<<<<<<<<<<<<
 *     """Return an array converted to a float type.
 * 
 */
  __pyx_k_tuple_122 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__dtype)); if (unlikely(!__pyx_k_tuple_122)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1279; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_122);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_122));
  __pyx_k_codeobj_123 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_122, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__asfarray, 1279, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_123)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1279; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":1308
 * 
 * 
 * def asfortranarray(a, dtype=None):             # <<<<<<<<<<<<<<
 *     """Return an array laid out in Fortran order in memory.
 * 
 */
  __pyx_k_tuple_124 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__dtype)); if (unlikely(!__pyx_k_tuple_124)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1308; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_124);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_124));
  __pyx_k_codeobj_125 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_124, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__asfortranarray, 1308, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_125)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1308; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":1344
 * 
 * 
 * def asmatrix(data, dtype=None):             # <<<<<<<<<<<<<<
 *     """Interpret the input as a matrix.
 * 
 */
  __pyx_k_tuple_126 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__data), ((PyObject *)__pyx_n_s__dtype)); if (unlikely(!__pyx_k_tuple_126)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1344; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_126);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_126));
  __pyx_k_codeobj_127 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_126, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__asmatrix, 1344, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_127)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1344; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":1376
 * 
 * 
 * def asscalar(a):             # <<<<<<<<<<<<<<
 *     """Convert an array of size 1 to its scalar equivalent.
 * 
 */
  __pyx_k_tuple_128 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__a)); if (unlikely(!__pyx_k_tuple_128)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1376; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_128);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_128));
  __pyx_k_codeobj_129 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_128, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__asscalar, 1376, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_129)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1376; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":1398
 * 
 * 
 * def atleast_1d():             # <<<<<<<<<<<<<<
 *     """Convert inputs to arrays with at least one dimension.
 * 
 */
  __pyx_k_codeobj_130 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__atleast_1d, 1398, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_130)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1398; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":1439
 * 
 * 
 * def atleast_2d():             # <<<<<<<<<<<<<<
 *     """View inputs as arrays with at least two dimensions.
 * 
 */
  __pyx_k_codeobj_131 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__atleast_2d, 1439, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_131)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1439; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":1478
 * 
 * 
 * def atleast_3d():             # <<<<<<<<<<<<<<
 *     """View inputs as arrays with at least three dimensions.
 * 
 */
  __pyx_k_codeobj_132 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__atleast_3d, 1478, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_132)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1478; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":1529
 * 
 * 
 * def average(a, axis=None, weights=None, returned=False):             # <<<<<<<<<<<<<<
 *     """Compute the weighted average along the specified axis.
 * 
 */
  __pyx_k_tuple_133 = PyTuple_Pack(4, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__axis), ((PyObject *)__pyx_n_s__weights), ((PyObject *)__pyx_n_s__returned)); if (unlikely(!__pyx_k_tuple_133)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1529; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_133);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_133));
  __pyx_k_codeobj_134 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_133, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__average, 1529, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_134)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1529; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":1604
 * 
 * 
 * def bartlett(M):             # <<<<<<<<<<<<<<
 *     """Return the Bartlett window.
 * 
 */
  __pyx_k_tuple_135 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__M)); if (unlikely(!__pyx_k_tuple_135)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1604; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_135);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_135));
  __pyx_k_codeobj_136 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_135, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__bartlett, 1604, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_136)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1604; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":1708
 * 
 * 
 * def base_repr(number, base=2, padding=0):             # <<<<<<<<<<<<<<
 *     """Return a string representation of a number in the given base system.
 * 
 */
  __pyx_k_tuple_137 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__number), ((PyObject *)__pyx_n_s__base), ((PyObject *)__pyx_n_s__padding)); if (unlikely(!__pyx_k_tuple_137)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1708; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_137);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_137));
  __pyx_k_codeobj_138 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_137, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__base_repr, 1708, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_138)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1708; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":1748
 * 
 * 
 * def binary_repr(num, width=None):             # <<<<<<<<<<<<<<
 *     """Return the binary representation of the input number as a string.
 * 
 */
  __pyx_k_tuple_139 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__num), ((PyObject *)__pyx_n_s__width)); if (unlikely(!__pyx_k_tuple_139)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1748; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_139);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_139));
  __pyx_k_codeobj_140 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_139, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__binary_repr, 1748, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_140)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1748; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":1808
 * 
 * 
 * def bincount(x, weights=None, minlength=None):             # <<<<<<<<<<<<<<
 *     """bincount(x, weights=None, minlength=None)
 * 
 */
  __pyx_k_tuple_141 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__x), ((PyObject *)__pyx_n_s__weights), ((PyObject *)__pyx_n_s__minlength)); if (unlikely(!__pyx_k_tuple_141)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1808; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_141);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_141));
  __pyx_k_codeobj_142 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_141, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__bincount, 1808, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_142)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1808; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":1883
 * 
 * 
 * def blackman(M):             # <<<<<<<<<<<<<<
 *     """Return the Blackman window.
 * 
 */
  __pyx_k_tuple_143 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__M)); if (unlikely(!__pyx_k_tuple_143)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1883; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_143);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_143));
  __pyx_k_codeobj_144 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_143, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__blackman, 1883, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_144)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1883; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":1979
 * 
 * 
 * def bmat(obj, ldict=None, gdict=None):             # <<<<<<<<<<<<<<
 *     """Build a matrix object from a string, nested sequence, or array.
 * 
 */
  __pyx_k_tuple_145 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__obj), ((PyObject *)__pyx_n_s__ldict), ((PyObject *)__pyx_n_s__gdict)); if (unlikely(!__pyx_k_tuple_145)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1979; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_145);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_145));
  __pyx_k_codeobj_146 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_145, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__bmat, 1979, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_146)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1979; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":2026
 * 
 * 
 * def broadcast_arrays():             # <<<<<<<<<<<<<<
 *     """Broadcast any number of arrays against each other.
 * 
 */
  __pyx_k_codeobj_147 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__broadcast_arrays, 2026, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_147)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2026; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":2067
 * 
 * 
 * def byte_bounds(a):             # <<<<<<<<<<<<<<
 *     """Returns pointers to the end-points of an array.
 * 
 */
  __pyx_k_tuple_148 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__a)); if (unlikely(!__pyx_k_tuple_148)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2067; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_148);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_148));
  __pyx_k_codeobj_149 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_148, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__byte_bounds, 2067, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_149)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2067; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":2099
 * 
 * 
 * def can_cast():             # <<<<<<<<<<<<<<
 *     """can_cast(from, totype, casting = 'safe')
 * 
 */
  __pyx_k_codeobj_150 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__can_cast, 2099, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_150)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2099; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":2202
 * 
 * 
 * def choose(a, choices, out=None, mode='raise'):             # <<<<<<<<<<<<<<
 *     """Construct an array from an index array and a set of arrays to choose from.
 * 
 */
  __pyx_k_tuple_151 = PyTuple_Pack(4, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__choices), ((PyObject *)__pyx_n_s__out), ((PyObject *)__pyx_n_s__mode)); if (unlikely(!__pyx_k_tuple_151)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2202; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_151);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_151));
  __pyx_k_codeobj_152 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_151, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__choose, 2202, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_152)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2202; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":2323
 * 
 * 
 * def column_stack(tup):             # <<<<<<<<<<<<<<
 *     """Stack 1-D arrays as columns into a 2-D array.
 * 
 */
  __pyx_k_tuple_153 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__tup)); if (unlikely(!__pyx_k_tuple_153)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2323; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_153);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_153));
  __pyx_k_codeobj_154 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_153, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__column_stack, 2323, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_154)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2323; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":2362
 * 
 * 
 * def common_type():             # <<<<<<<<<<<<<<
 *     """Return a scalar type which is common to the input arrays.
 * 
 */
  __pyx_k_codeobj_155 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__common_type, 2362, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_155)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2362; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":2400
 * 
 * 
 * def compare_chararrays():             # <<<<<<<<<<<<<<
 *     """
 * 
 */
  __pyx_k_codeobj_156 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__compare_chararrays, 2400, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_156)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2400; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":2408
 * 
 * 
 * def compress(condition, a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return selected slices of an array along given axis.
 * 
 */
  __pyx_k_tuple_157 = PyTuple_Pack(4, ((PyObject *)__pyx_n_s__condition), ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__axis), ((PyObject *)__pyx_n_s__out)); if (unlikely(!__pyx_k_tuple_157)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2408; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_157);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_157));
  __pyx_k_codeobj_158 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_157, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__compress, 2408, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_158)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2408; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":2469
 * 
 * 
 * def concatenate():             # <<<<<<<<<<<<<<
 *     """concatenate((a1, a2, ...), axis=0)
 * 
 */
  __pyx_k_codeobj_159 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__concatenate, 2469, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_159)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2469; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":2545
 * 
 * 
 * def convolve(a, v, mode='full'):             # <<<<<<<<<<<<<<
 *     """Returns the discrete, linear convolution of two one-dimensional sequences.
 * 
 */
  __pyx_k_tuple_160 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__v), ((PyObject *)__pyx_n_s__mode)); if (unlikely(!__pyx_k_tuple_160)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2545; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_160);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_160));
  __pyx_k_codeobj_161 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_160, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__convolve, 2545, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_161)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2545; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":2630
 * 
 * 
 * def copy(a):             # <<<<<<<<<<<<<<
 *     """Return an array copy of the given object.
 * 
 */
  __pyx_k_tuple_162 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__a)); if (unlikely(!__pyx_k_tuple_162)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2630; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_162);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_162));
  __pyx_k_codeobj_163 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_162, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__copy, 2630, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_163)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2630; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":2669
 * 
 * 
 * def corrcoef(x, y=None, rowvar=1, bias=0, ddof=None):             # <<<<<<<<<<<<<<
 *     """Return correlation coefficients.
 * 
 */
  __pyx_k_tuple_164 = PyTuple_Pack(5, ((PyObject *)__pyx_n_s__x), ((PyObject *)__pyx_n_s__y), ((PyObject *)__pyx_n_s__rowvar), ((PyObject *)__pyx_n_s__bias), ((PyObject *)__pyx_n_s__ddof)); if (unlikely(!__pyx_k_tuple_164)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2669; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_164);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_164));
  __pyx_k_codeobj_165 = (PyObject*)__Pyx_PyCode_New(5, 0, 5, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_164, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__corrcoef, 2669, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_165)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2669; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":2718
 * 
 * 
 * def correlate(a, v, mode='valid', old_behavior=False):             # <<<<<<<<<<<<<<
 *     """Cross-correlation of two 1-dimensional sequences.
 * 
 */
  __pyx_k_tuple_166 = PyTuple_Pack(4, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__v), ((PyObject *)__pyx_n_s__mode), ((PyObject *)__pyx_n_s__old_behavior)); if (unlikely(!__pyx_k_tuple_166)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2718; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_166);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_166));
  __pyx_k_codeobj_167 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_166, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__correlate, 2718, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_167)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2718; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":2758
 * 
 * 
 * def count_nonzero(a):             # <<<<<<<<<<<<<<
 *     """count_nonzero(a)
 * 
 */
  __pyx_k_tuple_168 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__a)); if (unlikely(!__pyx_k_tuple_168)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2758; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_168);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_168));
  __pyx_k_codeobj_169 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_168, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__count_nonzero, 2758, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_169)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2758; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":2790
 * 
 * 
 * def cov(m, y=None, rowvar=1, bias=0, ddof=None):             # <<<<<<<<<<<<<<
 *     """Estimate a covariance matrix, given data.
 * 
 */
  __pyx_k_tuple_170 = PyTuple_Pack(5, ((PyObject *)__pyx_n_s__m), ((PyObject *)__pyx_n_s__y), ((PyObject *)__pyx_n_s__rowvar), ((PyObject *)__pyx_n_s__bias), ((PyObject *)__pyx_n_s__ddof)); if (unlikely(!__pyx_k_tuple_170)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2790; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_170);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_170));
  __pyx_k_codeobj_171 = (PyObject*)__Pyx_PyCode_New(5, 0, 5, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_170, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__cov, 2790, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_171)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2790; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":2871
 * 
 * 
 * def cross(a, b, axisa=-1, axisb=-1, axisc=-1, axis=None):             # <<<<<<<<<<<<<<
 *     """Return the cross product of two (arrays of) vectors.
 * 
 */
  __pyx_k_tuple_172 = PyTuple_Pack(6, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__b), ((PyObject *)__pyx_n_s__axisa), ((PyObject *)__pyx_n_s__axisb), ((PyObject *)__pyx_n_s__axisc), ((PyObject *)__pyx_n_s__axis)); if (unlikely(!__pyx_k_tuple_172)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2871; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_172);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_172));
  __pyx_k_codeobj_173 = (PyObject*)__Pyx_PyCode_New(6, 0, 6, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_172, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__cross, 2871, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_173)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2871; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":2979
 * 
 * 
 * def cumprod(a, axis=None, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the cumulative product of elements along a given axis.
 * 
 */
  __pyx_k_tuple_174 = PyTuple_Pack(4, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__axis), ((PyObject *)__pyx_n_s__dtype), ((PyObject *)__pyx_n_s__out)); if (unlikely(!__pyx_k_tuple_174)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2979; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_174);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_174));
  __pyx_k_codeobj_175 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_174, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__cumprod, 2979, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_175)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2979; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":3041
 * 
 * 
 * def cumproduct(a, axis=None, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the cumulative product over the given axis.
 * 
 */
  __pyx_k_tuple_176 = PyTuple_Pack(4, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__axis), ((PyObject *)__pyx_n_s__dtype), ((PyObject *)__pyx_n_s__out)); if (unlikely(!__pyx_k_tuple_176)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3041; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_176);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_176));
  __pyx_k_codeobj_177 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_176, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__cumproduct, 3041, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_177)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3041; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":3053
 * 
 * 
 * def cumsum(a, axis=None, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the cumulative sum of the elements along a given axis.
 * 
 */
  __pyx_k_tuple_178 = PyTuple_Pack(4, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__axis), ((PyObject *)__pyx_n_s__dtype), ((PyObject *)__pyx_n_s__out)); if (unlikely(!__pyx_k_tuple_178)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3053; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_178);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_178));
  __pyx_k_codeobj_179 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_178, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__cumsum, 3053, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_179)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3053; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":3117
 * 
 * 
 * def datetime_data(dtype):             # <<<<<<<<<<<<<<
 *     """Return (unit, numerator, denominator, events) from a datetime dtype
 * 
 */
  __pyx_k_tuple_180 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__dtype)); if (unlikely(!__pyx_k_tuple_180)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3117; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_180);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_180));
  __pyx_k_codeobj_181 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_180, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__datetime_data, 3117, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_181)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3117; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":3124
 * 
 * 
 * def delete(arr, obj, axis=None):             # <<<<<<<<<<<<<<
 *     """Return a new array with sub-arrays along an axis deleted.
 * 
 */
  __pyx_k_tuple_182 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__arr), ((PyObject *)__pyx_n_s__obj), ((PyObject *)__pyx_n_s__axis)); if (unlikely(!__pyx_k_tuple_182)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3124; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_182);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_182));
  __pyx_k_codeobj_183 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_182, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__delete, 3124, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_183)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3124; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":3171
 * 
 * 
 * def deprecate():             # <<<<<<<<<<<<<<
 *     """Issues a DeprecationWarning, adds warning to `old_name`'s
 *     docstring, rebinds ``old_name.__name__`` and returns the new
 */
  __pyx_k_codeobj_184 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__deprecate, 3171, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_184)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3171; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":3214
 * 
 * 
 * def deprecate_with_doc(msg):             # <<<<<<<<<<<<<<
 *     """message
 * 
 */
  __pyx_k_tuple_185 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__msg)); if (unlikely(!__pyx_k_tuple_185)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3214; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_185);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_185));
  __pyx_k_codeobj_186 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_185, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__deprecate_with_doc, 3214, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_186)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3214; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":3221
 * 
 * 
 * def diag_indices(n, ndim=2):             # <<<<<<<<<<<<<<
 *     """Return the indices to access the main diagonal of an array.
 * 
 */
  __pyx_k_tuple_187 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__n), ((PyObject *)__pyx_n_s__ndim)); if (unlikely(!__pyx_k_tuple_187)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3221; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_187);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_187));
  __pyx_k_codeobj_188 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_187, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__diag_indices, 3221, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_188)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3221; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":3287
 * 
 * 
 * def diag_indices_from(arr):             # <<<<<<<<<<<<<<
 *     """Return the indices to access the main diagonal of an n-dimensional array.
 * 
 */
  __pyx_k_tuple_189 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__arr)); if (unlikely(!__pyx_k_tuple_189)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3287; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_189);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_189));
  __pyx_k_codeobj_190 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_189, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__diag_indices_from, 3287, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_190)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3287; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":3308
 * 
 * 
 * def diagflat(v, k=0):             # <<<<<<<<<<<<<<
 *     """Create a two-dimensional array with the flattened input as a diagonal.
 * 
 */
  __pyx_k_tuple_191 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__v), ((PyObject *)__pyx_n_s__k)); if (unlikely(!__pyx_k_tuple_191)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3308; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_191);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_191));
  __pyx_k_codeobj_192 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_191, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__diagflat, 3308, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_192)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3308; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":3349
 * 
 * 
 * def diff(a, n=1, axis=-1):             # <<<<<<<<<<<<<<
 *     """Calculate the n-th order discrete difference along given axis.
 * 
 */
  __pyx_k_tuple_193 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__n), ((PyObject *)__pyx_n_s__axis)); if (unlikely(!__pyx_k_tuple_193)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3349; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_193);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_193));
  __pyx_k_codeobj_194 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_193, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__diff, 3349, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_194)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3349; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":3394
 * 
 * 
 * def digitize(x, bins):             # <<<<<<<<<<<<<<
 *     """digitize(x, bins)
 * 
 */
  __pyx_k_tuple_195 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__x), ((PyObject *)__pyx_n_s__bins)); if (unlikely(!__pyx_k_tuple_195)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3394; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_195);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_195));
  __pyx_k_codeobj_196 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_195, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__digitize, 3394, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_196)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3394; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":3453
 * 
 * 
 * def disp(mesg, device=None, linefeed=True):             # <<<<<<<<<<<<<<
 *     """Display a message on a device.
 * 
 */
  __pyx_k_tuple_197 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__mesg), ((PyObject *)__pyx_n_s__device), ((PyObject *)__pyx_n_s__linefeed)); if (unlikely(!__pyx_k_tuple_197)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3453; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_197);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_197));
  __pyx_k_codeobj_198 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_197, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__disp, 3453, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_198)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3453; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":3487
 * 
 * 
 * def dsplit(ary, indices_or_sections):             # <<<<<<<<<<<<<<
 *     """Split array into multiple sub-arrays along the 3rd axis (depth).
 * 
 */
  __pyx_k_tuple_199 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__ary), ((PyObject *)__pyx_n_s__indices_or_sections)); if (unlikely(!__pyx_k_tuple_199)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3487; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_199);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_199));
  __pyx_k_codeobj_200 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_199, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__dsplit, 3487, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_200)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3487; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":3530
 * 
 * 
 * def dstack(tup):             # <<<<<<<<<<<<<<
 *     """Stack arrays in sequence depth wise (along third axis).
 * 
 */
  __pyx_k_tuple_201 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__tup)); if (unlikely(!__pyx_k_tuple_201)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3530; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_201);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_201));
  __pyx_k_codeobj_202 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_201, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__dstack, 3530, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_202)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3530; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":3580
 * 
 * 
 * def ediff1d(ary, to_end=None, to_begin=None):             # <<<<<<<<<<<<<<
 *     """The differences between consecutive elements of an array.
 * 
 */
  __pyx_k_tuple_203 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__ary), ((PyObject *)__pyx_n_s__to_end), ((PyObject *)__pyx_n_s__to_begin)); if (unlikely(!__pyx_k_tuple_203)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3580; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_203);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_203));
  __pyx_k_codeobj_204 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_203, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__ediff1d, 3580, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_204)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3580; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":3625
 * 
 * 
 * def einsum():             # <<<<<<<<<<<<<<
 *     """einsum(subscripts, *operands, out=None, dtype=None, order='K', casting='safe')
 * 
 */
  __pyx_k_codeobj_205 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__einsum, 3625, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_205)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3625; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":3817
 * 
 * 
 * def expand_dims(a, axis):             # <<<<<<<<<<<<<<
 *     """Expand the shape of an array.
 * 
 */
  __pyx_k_tuple_206 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__axis)); if (unlikely(!__pyx_k_tuple_206)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3817; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_206);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_206));
  __pyx_k_codeobj_207 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_206, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__expand_dims, 3817, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_207)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3817; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":3870
 * 
 * 
 * def extract(condition, arr):             # <<<<<<<<<<<<<<
 *     """Return the elements of an array that satisfy some condition.
 * 
 */
  __pyx_k_tuple_208 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__condition), ((PyObject *)__pyx_n_s__arr)); if (unlikely(!__pyx_k_tuple_208)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3870; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_208);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_208));
  __pyx_k_codeobj_209 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_208, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__extract, 3870, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_209)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3870; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":3913
 * 
 * 
 * def _fastCopyAndTranspose(a):             # <<<<<<<<<<<<<<
 *     """_fastCopyAndTranspose(a)
 * 
 */
  __pyx_k_tuple_210 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__a)); if (unlikely(!__pyx_k_tuple_210)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3913; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_210);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_210));
  __pyx_k_codeobj_211 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_210, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s_212, 3913, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_211)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3913; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":3921
 * 
 * 
 * def fill_diagonal(a, val):             # <<<<<<<<<<<<<<
 *     """Fill the main diagonal of the given array of any dimensionality.
 * 
 */
  __pyx_k_tuple_213 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__val)); if (unlikely(!__pyx_k_tuple_213)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3921; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_213);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_213));
  __pyx_k_codeobj_214 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_213, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__fill_diagonal, 3921, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_214)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3921; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":3982
 * 
 * 
 * def find_common_type(array_types, scalar_types):             # <<<<<<<<<<<<<<
 *     """Determine common type following standard coercion rules.
 * 
 */
  __pyx_k_tuple_215 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__array_types), ((PyObject *)__pyx_n_s__scalar_types)); if (unlikely(!__pyx_k_tuple_215)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3982; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_215);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_215));
  __pyx_k_codeobj_216 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_215, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__find_common_type, 3982, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_216)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3982; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":4035
 * 
 * 
 * def fix(x, y=None):             # <<<<<<<<<<<<<<
 *     """Round to nearest integer towards zero.
 * 
 */
  __pyx_k_tuple_217 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__x), ((PyObject *)__pyx_n_s__y)); if (unlikely(!__pyx_k_tuple_217)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4035; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_217);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_217));
  __pyx_k_codeobj_218 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_217, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__fix, 4035, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_218)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4035; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":4071
 * 
 * 
 * def flatnonzero(a):             # <<<<<<<<<<<<<<
 *     """Return indices that are non-zero in the flattened version of a.
 * 
 */
  __pyx_k_tuple_219 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__a)); if (unlikely(!__pyx_k_tuple_219)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4071; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_219);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_219));
  __pyx_k_codeobj_220 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_219, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__flatnonzero, 4071, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_220)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4071; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":4110
 * 
 * 
 * def fliplr(m):             # <<<<<<<<<<<<<<
 *     """Flip array in the left/right direction.
 * 
 */
  __pyx_k_tuple_221 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__m)); if (unlikely(!__pyx_k_tuple_221)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4110; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_221);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_221));
  __pyx_k_codeobj_222 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_221, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__fliplr, 4110, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_222)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4110; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":4157
 * 
 * 
 * def flipud(m):             # <<<<<<<<<<<<<<
 *     """Flip array in the up/down direction.
 * 
 */
  __pyx_k_tuple_223 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__m)); if (unlikely(!__pyx_k_tuple_223)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4157; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_223);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_223));
  __pyx_k_codeobj_224 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_223, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__flipud, 4157, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_224)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4157; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":4207
 * 
 * 
 * def frombuffer(buffer, dtype=float, count=-1, offset=0):             # <<<<<<<<<<<<<<
 *     """frombuffer(buffer, dtype=float, count=-1, offset=0)
 * 
 */
  __pyx_k_tuple_225 = PyTuple_Pack(4, ((PyObject *)__pyx_n_s__buffer), ((PyObject *)__pyx_n_s__dtype), ((PyObject *)__pyx_n_s__count), ((PyObject *)__pyx_n_s__offset)); if (unlikely(!__pyx_k_tuple_225)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4207; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_225);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_225));
  __pyx_k_codeobj_226 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_225, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__frombuffer, 4207, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_226)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4207; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":4247
 * 
 * 
 * def fromfile(file, dtype=float, count=-1, sep=''):             # <<<<<<<<<<<<<<
 *     """fromfile(file, dtype=float, count=-1, sep='')
 * 
 */
  __pyx_k_tuple_227 = PyTuple_Pack(4, ((PyObject *)__pyx_n_s__file), ((PyObject *)__pyx_n_s__dtype), ((PyObject *)__pyx_n_s__count), ((PyObject *)__pyx_n_s__sep)); if (unlikely(!__pyx_k_tuple_227)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4247; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_227);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_227));
  __pyx_k_codeobj_228 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_227, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__fromfile, 4247, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_228)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4247; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":4324
 * 
 * 
 * def fromiter(iterable, dtype, count=-1):             # <<<<<<<<<<<<<<
 *     """fromiter(iterable, dtype, count=-1)
 * 
 */
  __pyx_k_tuple_229 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__iterable), ((PyObject *)__pyx_n_s__dtype), ((PyObject *)__pyx_n_s__count)); if (unlikely(!__pyx_k_tuple_229)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4324; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_229);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_229));
  __pyx_k_codeobj_230 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_229, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__fromiter, 4324, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_230)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4324; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":4360
 * 
 * 
 * def frompyfunc(func, nin, nout):             # <<<<<<<<<<<<<<
 *     """frompyfunc(func, nin, nout)
 * 
 */
  __pyx_k_tuple_231 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__func), ((PyObject *)__pyx_n_s__nin), ((PyObject *)__pyx_n_s__nout)); if (unlikely(!__pyx_k_tuple_231)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4360; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_231);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_231));
  __pyx_k_codeobj_232 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_231, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__frompyfunc, 4360, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_232)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4360; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":4402
 * 
 * 
 * def fromregex(file, regexp, dtype):             # <<<<<<<<<<<<<<
 *     """Construct an array from a text file, using regular expression parsing.
 * 
 */
  __pyx_k_tuple_233 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__file), ((PyObject *)__pyx_n_s__regexp), ((PyObject *)__pyx_n_s__dtype)); if (unlikely(!__pyx_k_tuple_233)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4402; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_233);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_233));
  __pyx_k_codeobj_234 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_233, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__fromregex, 4402, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_234)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4402; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":4459
 * 
 * 
 * def fromstring(string, dtype=float, count=-1, sep=''):             # <<<<<<<<<<<<<<
 *     """fromstring(string, dtype=float, count=-1, sep='')
 * 
 */
  __pyx_k_tuple_235 = PyTuple_Pack(4, ((PyObject *)__pyx_n_s__string), ((PyObject *)__pyx_n_s__dtype), ((PyObject *)__pyx_n_s__count), ((PyObject *)__pyx_n_s__sep)); if (unlikely(!__pyx_k_tuple_235)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4459; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_235);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_235));
  __pyx_k_codeobj_236 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_235, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__fromstring, 4459, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_236)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4459; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":4513
 * 
 * 
 * def fv(rate, nper, pmt, pv, when='end'):             # <<<<<<<<<<<<<<
 *     """Compute the future value.
 * 
 */
  __pyx_k_tuple_237 = PyTuple_Pack(5, ((PyObject *)__pyx_n_s__rate), ((PyObject *)__pyx_n_s__nper), ((PyObject *)__pyx_n_s__pmt), ((PyObject *)__pyx_n_s__pv), ((PyObject *)__pyx_n_s__when)); if (unlikely(!__pyx_k_tuple_237)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4513; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_237);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_237));
  __pyx_k_codeobj_238 = (PyObject*)__Pyx_PyCode_New(5, 0, 5, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_237, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__fv, 4513, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_238)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4513; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":4596
 * 
 * 
 * def genfromtxt(fname, dtype=float, comments='#', delimiter=None, skiprows=0, skip_header=0, skip_footer=0, converters=None, missing='', missing_values=None, filling_values=None, usecols=None, names=None, excludelist=None, deletechars=None, replace_space='_', autostrip=False, case_sensitive=True, defaultfmt='f%i', unpack=None, usemask=False, loose=True, invalid_raise=True):             # <<<<<<<<<<<<<<
 *     """Load data from a text file, with missing values handled as specified.
 * 
 */
  __pyx_k_tuple_239 = PyTuple_Pack(23, ((PyObject *)__pyx_n_s__fname), ((PyObject *)__pyx_n_s__dtype), ((PyObject *)__pyx_n_s__comments), ((PyObject *)__pyx_n_s__delimiter), ((PyObject *)__pyx_n_s__skiprows), ((PyObject *)__pyx_n_s__skip_header), ((PyObject *)__pyx_n_s__skip_footer), ((PyObject *)__pyx_n_s__converters), ((PyObject *)__pyx_n_s__missing), ((PyObject *)__pyx_n_s__missing_values), ((PyObject *)__pyx_n_s__filling_values), ((PyObject *)__pyx_n_s__usecols), ((PyObject *)__pyx_n_s__names), ((PyObject *)__pyx_n_s__excludelist), ((PyObject *)__pyx_n_s__deletechars), ((PyObject *)__pyx_n_s__replace_space), ((PyObject *)__pyx_n_s__autostrip), ((PyObject *)__pyx_n_s__case_sensitive), ((PyObject *)__pyx_n_s__defaultfmt), ((PyObject *)__pyx_n_s__unpack), ((PyObject *)__pyx_n_s__usemask), ((PyObject *)__pyx_n_s__loose), ((PyObject *)__pyx_n_s__invalid_raise)); if (unlikely(!__pyx_k_tuple_239)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4596; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_239);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_239));
  __pyx_k_codeobj_240 = (PyObject*)__Pyx_PyCode_New(23, 0, 23, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_239, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__genfromtxt, 4596, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_240)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4596; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":4734
 * 
 * 
 * def get_array_wrap():             # <<<<<<<<<<<<<<
 *     """Find the wrapper for the array with the highest priority.
 * 
 */
  __pyx_k_codeobj_241 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__get_array_wrap, 4734, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_241)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4734; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":4743
 * 
 * 
 * def get_include():             # <<<<<<<<<<<<<<
 *     """Return the directory that contains the NumPy \*.h header files.
 * 
 */
  __pyx_k_codeobj_242 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__get_include, 4743, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_242)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4743; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":4764
 * 
 * 
 * def get_numarray_include(type=None):             # <<<<<<<<<<<<<<
 *     """Return the directory that contains the numarray \*.h header files.
 * 
 */
  __pyx_k_tuple_243 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__type)); if (unlikely(!__pyx_k_tuple_243)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4764; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_243);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_243));
  __pyx_k_codeobj_244 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_243, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s_245, 4764, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_244)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4764; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":4800
 * 
 * 
 * def get_printoptions():             # <<<<<<<<<<<<<<
 *     """Return the current print options.
 * 
 */
  __pyx_k_codeobj_246 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__get_printoptions, 4800, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_246)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4800; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":4826
 * 
 * 
 * def getbuffer():             # <<<<<<<<<<<<<<
 *     """getbuffer(obj [,offset[, size]])
 * 
 */
  __pyx_k_codeobj_247 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__getbuffer, 4826, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_247)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4826; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":4862
 * 
 * 
 * def getbufsize():             # <<<<<<<<<<<<<<
 *     """Return the size of the buffer used in ufuncs.
 * 
 */
  __pyx_k_codeobj_248 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__getbufsize, 4862, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_248)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4862; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":4869
 * 
 * 
 * def geterr():             # <<<<<<<<<<<<<<
 *     """Get the current way of handling floating-point errors.
 * 
 */
  __pyx_k_codeobj_249 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__geterr, 4869, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_249)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4869; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":4908
 * 
 * 
 * def geterrcall():             # <<<<<<<<<<<<<<
 *     """Return the current callback function used on floating-point errors.
 * 
 */
  __pyx_k_codeobj_250 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__geterrcall, 4908, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_250)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4908; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":4952
 * 
 * 
 * def geterrobj():             # <<<<<<<<<<<<<<
 *     """geterrobj()
 * 
 */
  __pyx_k_codeobj_251 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__geterrobj, 4952, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_251)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4952; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":5018
 * 
 * 
 * def gradient(f):             # <<<<<<<<<<<<<<
 *     """Return the gradient of an N-dimensional array.
 * 
 */
  __pyx_k_tuple_252 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__f)); if (unlikely(!__pyx_k_tuple_252)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5018; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_252);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_252));
  __pyx_k_codeobj_253 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_252, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__gradient, 5018, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_253)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5018; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":5058
 * 
 * 
 * def hamming(M):             # <<<<<<<<<<<<<<
 *     """Return the Hamming window.
 * 
 */
  __pyx_k_tuple_254 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__M)); if (unlikely(!__pyx_k_tuple_254)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5058; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_254);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_254));
  __pyx_k_codeobj_255 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_254, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__hamming, 5058, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_255)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5058; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":5152
 * 
 * 
 * def hanning(M):             # <<<<<<<<<<<<<<
 *     """Return the Hanning window.
 * 
 */
  __pyx_k_tuple_256 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__M)); if (unlikely(!__pyx_k_tuple_256)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5152; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_256);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_256));
  __pyx_k_codeobj_257 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_256, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__hanning, 5152, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_257)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5152; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":5248
 * 
 * 
 * def histogram(a, bins=10, range=None, normed=False, weights=None, density=None):             # <<<<<<<<<<<<<<
 *     """Compute the histogram of a set of data.
 * 
 */
  __pyx_k_tuple_258 = PyTuple_Pack(6, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__bins), ((PyObject *)__pyx_n_s__range), ((PyObject *)__pyx_n_s__normed), ((PyObject *)__pyx_n_s__weights), ((PyObject *)__pyx_n_s__density)); if (unlikely(!__pyx_k_tuple_258)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5248; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_258);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_258));
  __pyx_k_codeobj_259 = (PyObject*)__Pyx_PyCode_New(6, 0, 6, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_258, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__histogram, 5248, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_259)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5248; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":5333
 * 
 * 
 * def histogram2d(x, y, bins=10, range=None, normed=False, weights=None):             # <<<<<<<<<<<<<<
 *     """Compute the bi-dimensional histogram of two data samples.
 * 
 */
  __pyx_k_tuple_260 = PyTuple_Pack(6, ((PyObject *)__pyx_n_s__x), ((PyObject *)__pyx_n_s__y), ((PyObject *)__pyx_n_s__bins), ((PyObject *)__pyx_n_s__range), ((PyObject *)__pyx_n_s__normed), ((PyObject *)__pyx_n_s__weights)); if (unlikely(!__pyx_k_tuple_260)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5333; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_260);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_260));
  __pyx_k_codeobj_261 = (PyObject*)__Pyx_PyCode_New(6, 0, 6, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_260, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__histogram2d, 5333, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_261)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5333; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":5418
 * 
 * 
 * def histogramdd(sample, bins=10, range=None, normed=False, weights=None):             # <<<<<<<<<<<<<<
 *     """Compute the multidimensional histogram of some data.
 * 
 */
  __pyx_k_tuple_262 = PyTuple_Pack(5, ((PyObject *)__pyx_n_s__sample), ((PyObject *)__pyx_n_s__bins), ((PyObject *)__pyx_n_s__range), ((PyObject *)__pyx_n_s__normed), ((PyObject *)__pyx_n_s__weights)); if (unlikely(!__pyx_k_tuple_262)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5418; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_262);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_262));
  __pyx_k_codeobj_263 = (PyObject*)__Pyx_PyCode_New(5, 0, 5, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_262, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__histogramdd, 5418, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_263)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5418; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":5471
 * 
 * 
 * def hsplit(ary, indices_or_sections):             # <<<<<<<<<<<<<<
 *     """Split an array into multiple sub-arrays horizontally (column-wise).
 * 
 */
  __pyx_k_tuple_264 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__ary), ((PyObject *)__pyx_n_s__indices_or_sections)); if (unlikely(!__pyx_k_tuple_264)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5471; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_264);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_264));
  __pyx_k_codeobj_265 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_264, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__hsplit, 5471, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_265)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5471; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":5528
 * 
 * 
 * def hstack(tup):             # <<<<<<<<<<<<<<
 *     """Stack arrays in sequence horizontally (column wise).
 * 
 */
  __pyx_k_tuple_266 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__tup)); if (unlikely(!__pyx_k_tuple_266)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5528; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_266);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_266));
  __pyx_k_codeobj_267 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_266, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__hstack, 5528, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_267)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5528; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":5572
 * 
 * 
 * def i0(x):             # <<<<<<<<<<<<<<
 *     """Modified Bessel function of the first kind, order 0.
 * 
 */
  __pyx_k_tuple_268 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__x)); if (unlikely(!__pyx_k_tuple_268)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5572; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_268);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_268));
  __pyx_k_codeobj_269 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_268, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__i0, 5572, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_269)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5572; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":5628
 * 
 * 
 * def imag(val):             # <<<<<<<<<<<<<<
 *     """Return the imaginary part of the elements of the array.
 * 
 */
  __pyx_k_tuple_270 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__val)); if (unlikely(!__pyx_k_tuple_270)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5628; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_270);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_270));
  __pyx_k_codeobj_271 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_270, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__imag, 5628, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_271)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5628; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":5659
 * 
 * 
 * def in1d(ar1, ar2, assume_unique=False):             # <<<<<<<<<<<<<<
 *     """Test whether each element of a 1D array is also present in a second array.
 * 
 */
  __pyx_k_tuple_272 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__ar1), ((PyObject *)__pyx_n_s__ar2), ((PyObject *)__pyx_n_s__assume_unique)); if (unlikely(!__pyx_k_tuple_272)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5659; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_272);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_272));
  __pyx_k_codeobj_273 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_272, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__in1d, 5659, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_273)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5659; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":5707
 * 
 * 
 * def indices(dimensions, dtype=int):             # <<<<<<<<<<<<<<
 *     """Return an array representing the indices of a grid.
 * 
 */
  __pyx_k_tuple_274 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__dimensions), ((PyObject *)__pyx_n_s__dtype)); if (unlikely(!__pyx_k_tuple_274)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5707; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_274);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_274));
  __pyx_k_codeobj_275 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_274, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__indices, 5707, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_275)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5707; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":5769
 * 
 * 
 * def info(object=None, maxwidth=76, output=sys.stdout, toplevel='numpy'):             # <<<<<<<<<<<<<<
 *     """Get help information for a function, class, or module.
 * 
 */
  __pyx_k_tuple_276 = PyTuple_Pack(4, ((PyObject *)__pyx_n_s__object), ((PyObject *)__pyx_n_s__maxwidth), ((PyObject *)__pyx_n_s__output), ((PyObject *)__pyx_n_s__toplevel)); if (unlikely(!__pyx_k_tuple_276)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5769; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_276);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_276));
  __pyx_k_codeobj_277 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_276, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__info, 5769, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_277)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5769; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":5819
 * 
 * 
 * def inner(a, b):             # <<<<<<<<<<<<<<
 *     """inner(a, b)
 * 
 */
  __pyx_k_tuple_278 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__b)); if (unlikely(!__pyx_k_tuple_278)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5819; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_278);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_278));
  __pyx_k_codeobj_279 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_278, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__inner, 5819, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_279)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5819; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":5895
 * 
 * 
 * def insert(arr, obj, values, axis=None):             # <<<<<<<<<<<<<<
 *     """Insert values along the given axis before the given indices.
 * 
 */
  __pyx_k_tuple_280 = PyTuple_Pack(4, ((PyObject *)__pyx_n_s__arr), ((PyObject *)__pyx_n_s__obj), ((PyObject *)__pyx_n_s__values), ((PyObject *)__pyx_n_s__axis)); if (unlikely(!__pyx_k_tuple_280)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5895; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_280);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_280));
  __pyx_k_codeobj_281 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_280, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__insert, 5895, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_281)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5895; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":5960
 * 
 * 
 * def int_asbuffer():             # <<<<<<<<<<<<<<
 *     """
 * 
 */
  __pyx_k_codeobj_282 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__int_asbuffer, 5960, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_282)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5960; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":5968
 * 
 * 
 * def interp(x, xp, fp, left=None, right=None):             # <<<<<<<<<<<<<<
 *     """One-dimensional linear interpolation.
 * 
 */
  __pyx_k_tuple_283 = PyTuple_Pack(5, ((PyObject *)__pyx_n_s__x), ((PyObject *)__pyx_n_s__xp), ((PyObject *)__pyx_n_s__fp), ((PyObject *)__pyx_n_s__left), ((PyObject *)__pyx_n_s__right)); if (unlikely(!__pyx_k_tuple_283)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5968; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_283);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_283));
  __pyx_k_codeobj_284 = (PyObject*)__Pyx_PyCode_New(5, 0, 5, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_283, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__interp, 5968, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_284)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5968; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":6039
 * 
 * 
 * def intersect1d(ar1, ar2, assume_unique=False):             # <<<<<<<<<<<<<<
 *     """Find the intersection of two arrays.
 * 
 */
  __pyx_k_tuple_285 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__ar1), ((PyObject *)__pyx_n_s__ar2), ((PyObject *)__pyx_n_s__assume_unique)); if (unlikely(!__pyx_k_tuple_285)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6039; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_285);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_285));
  __pyx_k_codeobj_286 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_285, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__intersect1d, 6039, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_286)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6039; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":6071
 * 
 * 
 * def ipmt(rate, per, nper, pv, fv=0.0, when='end'):             # <<<<<<<<<<<<<<
 *     """Not implemented. Compute the payment portion for loan interest.
 * 
 */
  __pyx_k_tuple_287 = PyTuple_Pack(6, ((PyObject *)__pyx_n_s__rate), ((PyObject *)__pyx_n_s__per), ((PyObject *)__pyx_n_s__nper), ((PyObject *)__pyx_n_s__pv), ((PyObject *)__pyx_n_s__fv), ((PyObject *)__pyx_n_s__when)); if (unlikely(!__pyx_k_tuple_287)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6071; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_287);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_287));
  __pyx_k_codeobj_288 = (PyObject*)__Pyx_PyCode_New(6, 0, 6, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_287, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__ipmt, 6071, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_288)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6071; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":6113
 * 
 * 
 * def irr(values):             # <<<<<<<<<<<<<<
 *     """Return the Internal Rate of Return (IRR).
 * 
 */
  __pyx_k_tuple_289 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__values)); if (unlikely(!__pyx_k_tuple_289)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6113; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_289);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_289));
  __pyx_k_codeobj_290 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_289, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__irr, 6113, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_290)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6113; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":6168
 * 
 * 
 * def iscomplex(x):             # <<<<<<<<<<<<<<
 *     """Returns a bool array, where True if input element is complex.
 * 
 */
  __pyx_k_tuple_291 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__x)); if (unlikely(!__pyx_k_tuple_291)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6168; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_291);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_291));
  __pyx_k_codeobj_292 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_291, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__iscomplex, 6168, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_292)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6168; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":6199
 * 
 * 
 * def iscomplexobj(x):             # <<<<<<<<<<<<<<
 *     """Return True if x is a complex type or an array of complex numbers.
 * 
 */
  __pyx_k_tuple_293 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__x)); if (unlikely(!__pyx_k_tuple_293)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6199; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_293);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_293));
  __pyx_k_codeobj_294 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_293, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__iscomplexobj, 6199, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_294)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6199; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":6233
 * 
 * 
 * def isfortran(a):             # <<<<<<<<<<<<<<
 *     """Returns True if array is arranged in Fortran-order in memory
 *     and dimension > 1.
 */
  __pyx_k_tuple_295 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__a)); if (unlikely(!__pyx_k_tuple_295)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6233; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_295);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_295));
  __pyx_k_codeobj_296 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_295, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__isfortran, 6233, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_296)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6233; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":6290
 * 
 * 
 * def isneginf(x, y=None):             # <<<<<<<<<<<<<<
 *     """Test element-wise for negative infinity, return result as bool array.
 * 
 */
  __pyx_k_tuple_297 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__x), ((PyObject *)__pyx_n_s__y)); if (unlikely(!__pyx_k_tuple_297)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6290; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_297);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_297));
  __pyx_k_codeobj_298 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_297, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__isneginf, 6290, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_298)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6290; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":6349
 * 
 * 
 * def isposinf(x, y=None):             # <<<<<<<<<<<<<<
 *     """Test element-wise for positive infinity, return result as bool array.
 * 
 */
  __pyx_k_tuple_299 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__x), ((PyObject *)__pyx_n_s__y)); if (unlikely(!__pyx_k_tuple_299)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6349; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_299);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_299));
  __pyx_k_codeobj_300 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_299, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__isposinf, 6349, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_300)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6349; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":6407
 * 
 * 
 * def isreal(x):             # <<<<<<<<<<<<<<
 *     """Returns a bool array, where True if input element is real.
 * 
 */
  __pyx_k_tuple_301 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__x)); if (unlikely(!__pyx_k_tuple_301)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6407; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_301);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_301));
  __pyx_k_codeobj_302 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_301, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__isreal, 6407, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_302)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6407; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":6437
 * 
 * 
 * def isrealobj(x):             # <<<<<<<<<<<<<<
 *     """Return True if x is a not complex type or an array of complex numbers.
 * 
 */
  __pyx_k_tuple_303 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__x)); if (unlikely(!__pyx_k_tuple_303)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6437; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_303);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_303));
  __pyx_k_codeobj_304 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_303, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__isrealobj, 6437, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_304)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6437; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":6471
 * 
 * 
 * def isscalar(num):             # <<<<<<<<<<<<<<
 *     """Returns True if the type of `num` is a scalar type.
 * 
 */
  __pyx_k_tuple_305 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__num)); if (unlikely(!__pyx_k_tuple_305)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6471; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_305);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_305));
  __pyx_k_codeobj_306 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_305, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__isscalar, 6471, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_306)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6471; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":6497
 * 
 * 
 * def issctype(rep):             # <<<<<<<<<<<<<<
 *     """Determines whether the given object represents a scalar data-type.
 * 
 */
  __pyx_k_tuple_307 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__rep)); if (unlikely(!__pyx_k_tuple_307)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6497; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_307);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_307));
  __pyx_k_codeobj_308 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_307, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__issctype, 6497, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_308)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6497; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":6533
 * 
 * 
 * def issubclass_(arg1, arg2):             # <<<<<<<<<<<<<<
 *     """Determine if a class is a subclass of a second class.
 * 
 */
  __pyx_k_tuple_309 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__arg1), ((PyObject *)__pyx_n_s__arg2)); if (unlikely(!__pyx_k_tuple_309)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6533; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_309);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_309));
  __pyx_k_codeobj_310 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_309, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__issubclass_, 6533, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_310)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6533; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":6568
 * 
 * 
 * def issubdtype(arg1, arg2):             # <<<<<<<<<<<<<<
 *     """Returns True if first argument is a typecode lower/equal in type hierarchy.
 * 
 */
  __pyx_k_tuple_311 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__arg1), ((PyObject *)__pyx_n_s__arg2)); if (unlikely(!__pyx_k_tuple_311)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6568; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_311);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_311));
  __pyx_k_codeobj_312 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_311, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__issubdtype, 6568, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_312)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6568; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":6596
 * 
 * 
 * def issubsctype(arg1, arg2):             # <<<<<<<<<<<<<<
 *     """Determine if the first argument is a subclass of the second argument.
 * 
 */
  __pyx_k_tuple_313 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__arg1), ((PyObject *)__pyx_n_s__arg2)); if (unlikely(!__pyx_k_tuple_313)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6596; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_313);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_313));
  __pyx_k_codeobj_314 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_313, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__issubsctype, 6596, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_314)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6596; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":6626
 * 
 * 
 * def iterable(y):             # <<<<<<<<<<<<<<
 *     """Check whether or not an object can be iterated over.
 * 
 */
  __pyx_k_tuple_315 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__y)); if (unlikely(!__pyx_k_tuple_315)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6626; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_315);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_315));
  __pyx_k_codeobj_316 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_315, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__iterable, 6626, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_316)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6626; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":6652
 * 
 * 
 * def ix_():             # <<<<<<<<<<<<<<
 *     """Construct an open mesh from multiple sequences.
 * 
 */
  __pyx_k_codeobj_317 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__ix_, 6652, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_317)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6652; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":6698
 * 
 * 
 * def kaiser(M, beta):             # <<<<<<<<<<<<<<
 *     """Return the Kaiser window.
 * 
 */
  __pyx_k_tuple_318 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__M), ((PyObject *)__pyx_n_s__beta)); if (unlikely(!__pyx_k_tuple_318)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6698; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_318);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_318));
  __pyx_k_codeobj_319 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_318, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__kaiser, 6698, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_319)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6698; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":6825
 * 
 * 
 * def kron(a, b):             # <<<<<<<<<<<<<<
 *     """Kronecker product of two arrays.
 * 
 */
  __pyx_k_tuple_320 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__b)); if (unlikely(!__pyx_k_tuple_320)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6825; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_320);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_320));
  __pyx_k_codeobj_321 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_320, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__kron, 6825, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_321)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6825; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":6897
 * 
 * 
 * def lexsort(keys, axis=-1):             # <<<<<<<<<<<<<<
 *     """lexsort(keys, axis=-1)
 * 
 */
  __pyx_k_tuple_322 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__keys), ((PyObject *)__pyx_n_s__axis)); if (unlikely(!__pyx_k_tuple_322)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6897; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_322);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_322));
  __pyx_k_codeobj_323 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_322, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__lexsort, 6897, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_323)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6897; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":6975
 * 
 * 
 * def load(file, mmap_mode=None):             # <<<<<<<<<<<<<<
 *     """Load a pickled, ``.npy``, or ``.npz`` binary file.
 * 
 */
  __pyx_k_tuple_324 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__file), ((PyObject *)__pyx_n_s__mmap_mode)); if (unlikely(!__pyx_k_tuple_324)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6975; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_324);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_324));
  __pyx_k_codeobj_325 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_324, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__load, 6975, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_325)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6975; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":7037
 * 
 * 
 * def loads():             # <<<<<<<<<<<<<<
 *     """loads(string) -- Load a pickle from the given string
 * 
 */
  __pyx_k_codeobj_326 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__loads, 7037, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_326)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7037; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":7045
 * 
 * 
 * def loadtxt(fname, dtype=float, comments='#', delimiter=None, converters=None, skiprows=0, usecols=None, unpack=False, ndmin=0):             # <<<<<<<<<<<<<<
 *     """Load data from a text file.
 * 
 */
  __pyx_k_tuple_327 = PyTuple_Pack(9, ((PyObject *)__pyx_n_s__fname), ((PyObject *)__pyx_n_s__dtype), ((PyObject *)__pyx_n_s__comments), ((PyObject *)__pyx_n_s__delimiter), ((PyObject *)__pyx_n_s__converters), ((PyObject *)__pyx_n_s__skiprows), ((PyObject *)__pyx_n_s__usecols), ((PyObject *)__pyx_n_s__unpack), ((PyObject *)__pyx_n_s__ndmin)); if (unlikely(!__pyx_k_tuple_327)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7045; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_327);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_327));
  __pyx_k_codeobj_328 = (PyObject*)__Pyx_PyCode_New(9, 0, 9, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_327, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__loadtxt, 7045, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_328)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7045; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":7132
 * 
 * 
 * def lookfor(what, module=None, import_modules=True, regenerate=False, output=None):             # <<<<<<<<<<<<<<
 *     """Do a keyword search on docstrings.
 * 
 */
  __pyx_k_tuple_329 = PyTuple_Pack(5, ((PyObject *)__pyx_n_s__what), ((PyObject *)__pyx_n_s__module), ((PyObject *)__pyx_n_s__import_modules), ((PyObject *)__pyx_n_s__regenerate), ((PyObject *)__pyx_n_s__output)); if (unlikely(!__pyx_k_tuple_329)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7132; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_329);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_329));
  __pyx_k_codeobj_330 = (PyObject*)__Pyx_PyCode_New(5, 0, 5, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_329, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__lookfor, 7132, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_330)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7132; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":7179
 * 
 * 
 * def mafromtxt(fname):             # <<<<<<<<<<<<<<
 *     """Load ASCII data stored in a text file and return a masked array.
 * 
 */
  __pyx_k_tuple_331 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__fname)); if (unlikely(!__pyx_k_tuple_331)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7179; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_331);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_331));
  __pyx_k_codeobj_332 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_331, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__mafromtxt, 7179, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_332)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7179; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":7192
 * 
 * 
 * def mask_indices(n, mask_func, k=0):             # <<<<<<<<<<<<<<
 *     """Return the indices to access (n, n) arrays, given a masking function.
 * 
 */
  __pyx_k_tuple_333 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__n), ((PyObject *)__pyx_n_s__mask_func), ((PyObject *)__pyx_n_s__k)); if (unlikely(!__pyx_k_tuple_333)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7192; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_333);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_333));
  __pyx_k_codeobj_334 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_333, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__mask_indices, 7192, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_334)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7192; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":7259
 * 
 * 
 * def mat(data, dtype=None):             # <<<<<<<<<<<<<<
 *     """Interpret the input as a matrix.
 * 
 */
  __pyx_k_tuple_335 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__data), ((PyObject *)__pyx_n_s__dtype)); if (unlikely(!__pyx_k_tuple_335)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7259; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_335);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_335));
  __pyx_k_codeobj_336 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_335, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__mat, 7259, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_336)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7259; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":7291
 * 
 * 
 * def max(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the maximum of an array or maximum along an axis.
 * 
 */
  __pyx_k_tuple_337 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__axis), ((PyObject *)__pyx_n_s__out)); if (unlikely(!__pyx_k_tuple_337)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7291; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_337);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_337));
  __pyx_k_codeobj_338 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_337, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__max, 7291, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_338)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7291; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":7348
 * 
 * 
 * def maximum_sctype(t):             # <<<<<<<<<<<<<<
 *     """Return the scalar type of highest precision of the same kind as the input.
 * 
 */
  __pyx_k_tuple_339 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__t)); if (unlikely(!__pyx_k_tuple_339)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7348; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_339);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_339));
  __pyx_k_codeobj_340 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_339, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__maximum_sctype, 7348, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_340)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7348; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":7388
 * 
 * 
 * def may_share_memory(a, b):             # <<<<<<<<<<<<<<
 *     """Determine if two arrays can share memory
 * 
 */
  __pyx_k_tuple_341 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__b)); if (unlikely(!__pyx_k_tuple_341)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7388; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_341);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_341));
  __pyx_k_codeobj_342 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_341, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__may_share_memory, 7388, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_342)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7388; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":7414
 * 
 * 
 * def mean(a, axis=None, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Compute the arithmetic mean along the specified axis.
 * 
 */
  __pyx_k_tuple_343 = PyTuple_Pack(4, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__axis), ((PyObject *)__pyx_n_s__dtype), ((PyObject *)__pyx_n_s__out)); if (unlikely(!__pyx_k_tuple_343)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7414; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_343);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_343));
  __pyx_k_codeobj_344 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_343, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__mean, 7414, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_344)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7414; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":7487
 * 
 * 
 * def median(a, axis=None, out=None, overwrite_input=False):             # <<<<<<<<<<<<<<
 *     """Compute the median along the specified axis.
 * 
 */
  __pyx_k_tuple_345 = PyTuple_Pack(4, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__axis), ((PyObject *)__pyx_n_s__out), ((PyObject *)__pyx_n_s__overwrite_input)); if (unlikely(!__pyx_k_tuple_345)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7487; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_345);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_345));
  __pyx_k_codeobj_346 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_345, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__median, 7487, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_346)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7487; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":7563
 * 
 * 
 * def meshgrid(x, y):             # <<<<<<<<<<<<<<
 *     """Return coordinate matrices from two coordinate vectors.
 * 
 */
  __pyx_k_tuple_347 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__x), ((PyObject *)__pyx_n_s__y)); if (unlikely(!__pyx_k_tuple_347)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7563; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_347);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_347));
  __pyx_k_codeobj_348 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_347, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__meshgrid, 7563, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_348)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7563; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":7611
 * 
 * 
 * def min(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the minimum of an array or minimum along an axis.
 * 
 */
  __pyx_k_tuple_349 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__axis), ((PyObject *)__pyx_n_s__out)); if (unlikely(!__pyx_k_tuple_349)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7611; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_349);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_349));
  __pyx_k_codeobj_350 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_349, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__min, 7611, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_350)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7611; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":7668
 * 
 * 
 * def min_scalar_type(a):             # <<<<<<<<<<<<<<
 *     """min_scalar_type(a)
 * 
 */
  __pyx_k_tuple_351 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__a)); if (unlikely(!__pyx_k_tuple_351)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7668; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_351);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_351));
  __pyx_k_codeobj_352 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_351, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__min_scalar_type, 7668, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_352)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7668; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":7718
 * 
 * 
 * def mintypecode(typechars, typeset='GDFgdf', default='d'):             # <<<<<<<<<<<<<<
 *     """Return the character for the minimum-size type to which given types can
 *     be safely cast.
 */
  __pyx_k_tuple_353 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__typechars), ((PyObject *)__pyx_n_s__typeset), ((PyObject *)__pyx_n_s__default)); if (unlikely(!__pyx_k_tuple_353)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7718; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_353);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_353));
  __pyx_k_codeobj_354 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_353, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__mintypecode, 7718, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_354)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7718; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":7763
 * 
 * 
 * def mirr(values, finance_rate, reinvest_rate):             # <<<<<<<<<<<<<<
 *     """Modified internal rate of return.
 * 
 */
  __pyx_k_tuple_355 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__values), ((PyObject *)__pyx_n_s__finance_rate), ((PyObject *)__pyx_n_s__reinvest_rate)); if (unlikely(!__pyx_k_tuple_355)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7763; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_355);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_355));
  __pyx_k_codeobj_356 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_355, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__mirr, 7763, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_356)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7763; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":7785
 * 
 * 
 * def msort(a):             # <<<<<<<<<<<<<<
 *     """Return a copy of an array sorted along the first axis.
 * 
 */
  __pyx_k_tuple_357 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__a)); if (unlikely(!__pyx_k_tuple_357)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7785; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_357);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_357));
  __pyx_k_codeobj_358 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_357, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__msort, 7785, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_358)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7785; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":7810
 * 
 * 
 * def nan_to_num(x):             # <<<<<<<<<<<<<<
 *     """Replace nan with zero and inf with finite numbers.
 * 
 */
  __pyx_k_tuple_359 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__x)); if (unlikely(!__pyx_k_tuple_359)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7810; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_359);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_359));
  __pyx_k_codeobj_360 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_359, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__nan_to_num, 7810, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_360)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7810; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":7857
 * 
 * 
 * def nanargmax(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Return indices of the maximum values over an axis, ignoring NaNs.
 * 
 */
  __pyx_k_tuple_361 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__axis)); if (unlikely(!__pyx_k_tuple_361)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7857; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_361);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_361));
  __pyx_k_codeobj_362 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_361, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__nanargmax, 7857, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_362)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7857; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":7892
 * 
 * 
 * def nanargmin(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Return indices of the minimum values over an axis, ignoring NaNs.
 * 
 */
  __pyx_k_tuple_363 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__axis)); if (unlikely(!__pyx_k_tuple_363)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7892; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_363);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_363));
  __pyx_k_codeobj_364 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_363, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__nanargmin, 7892, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_364)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7892; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":7927
 * 
 * 
 * def nanmax(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Return the maximum of an array or maximum along an axis ignoring any NaNs.
 * 
 */
  __pyx_k_tuple_365 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__axis)); if (unlikely(!__pyx_k_tuple_365)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7927; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_365);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_365));
  __pyx_k_codeobj_366 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_365, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__nanmax, 7927, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_366)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7927; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":7984
 * 
 * 
 * def nanmin(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Return the minimum of an array or minimum along an axis ignoring any NaNs.
 * 
 */
  __pyx_k_tuple_367 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__axis)); if (unlikely(!__pyx_k_tuple_367)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7984; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_367);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_367));
  __pyx_k_codeobj_368 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_367, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__nanmin, 7984, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_368)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7984; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":8039
 * 
 * 
 * def nansum(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Return the sum of array elements over a given axis treating
 *     Not a Numbers (NaNs) as zero.
 */
  __pyx_k_tuple_369 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__axis)); if (unlikely(!__pyx_k_tuple_369)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8039; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_369);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_369));
  __pyx_k_codeobj_370 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_369, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__nansum, 8039, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_370)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8039; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":8107
 * 
 * 
 * def ndfromtxt(fname):             # <<<<<<<<<<<<<<
 *     """Load ASCII data stored in a file and return it as a single array.
 * 
 */
  __pyx_k_tuple_371 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__fname)); if (unlikely(!__pyx_k_tuple_371)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8107; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_371);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_371));
  __pyx_k_codeobj_372 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_371, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__ndfromtxt, 8107, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_372)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8107; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":8121
 * 
 * 
 * def ndim(a):             # <<<<<<<<<<<<<<
 *     """Return the number of dimensions of an array.
 * 
 */
  __pyx_k_tuple_373 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__a)); if (unlikely(!__pyx_k_tuple_373)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8121; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_373);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_373));
  __pyx_k_codeobj_374 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_373, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__ndim, 8121, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_374)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8121; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":8154
 * 
 * 
 * def nested_iters():             # <<<<<<<<<<<<<<
 *     """
 * 
 */
  __pyx_k_codeobj_375 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__nested_iters, 8154, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_375)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8154; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":8162
 * 
 * 
 * def newbuffer(size):             # <<<<<<<<<<<<<<
 *     """newbuffer(size)
 * 
 */
  __pyx_k_tuple_376 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__size)); if (unlikely(!__pyx_k_tuple_376)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8162; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_376);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_376));
  __pyx_k_codeobj_377 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_376, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__newbuffer, 8162, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_377)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8162; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":8172
 * 
 * 
 * def nonzero(a):             # <<<<<<<<<<<<<<
 *     """Return the indices of the elements that are non-zero.
 * 
 */
  __pyx_k_tuple_378 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__a)); if (unlikely(!__pyx_k_tuple_378)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8172; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_378);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_378));
  __pyx_k_codeobj_379 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_378, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__nonzero, 8172, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_379)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8172; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":8247
 * 
 * 
 * def nper(rate, pmt, pv, fv=0, when='end'):             # <<<<<<<<<<<<<<
 *     """Compute the number of periodic payments.
 * 
 */
  __pyx_k_tuple_380 = PyTuple_Pack(5, ((PyObject *)__pyx_n_s__rate), ((PyObject *)__pyx_n_s__pmt), ((PyObject *)__pyx_n_s__pv), ((PyObject *)__pyx_n_s__fv), ((PyObject *)__pyx_n_s__when)); if (unlikely(!__pyx_k_tuple_380)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8247; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_380);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_380));
  __pyx_k_codeobj_381 = (PyObject*)__Pyx_PyCode_New(5, 0, 5, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_380, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__nper, 8247, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_381)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8247; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":8298
 * 
 * 
 * def npv(rate, values):             # <<<<<<<<<<<<<<
 *     """Returns the NPV (Net Present Value) of a cash flow series.
 * 
 */
  __pyx_k_tuple_382 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__rate), ((PyObject *)__pyx_n_s__values)); if (unlikely(!__pyx_k_tuple_382)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8298; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_382);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_382));
  __pyx_k_codeobj_383 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_382, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__npv, 8298, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_383)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8298; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":8342
 * 
 * 
 * def obj2sctype(rep, default=None):             # <<<<<<<<<<<<<<
 *     """Return the scalar dtype or NumPy equivalent of Python type of an object.
 * 
 */
  __pyx_k_tuple_384 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__rep), ((PyObject *)__pyx_n_s__default)); if (unlikely(!__pyx_k_tuple_384)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8342; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_384);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_384));
  __pyx_k_codeobj_385 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_384, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__obj2sctype, 8342, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_385)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8342; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":8383
 * 
 * 
 * def outer(a, b):             # <<<<<<<<<<<<<<
 *     """Compute the outer product of two vectors.
 * 
 */
  __pyx_k_tuple_386 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__b)); if (unlikely(!__pyx_k_tuple_386)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8383; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_386);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_386));
  __pyx_k_codeobj_387 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_386, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__outer, 8383, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_387)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8383; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":8454
 * 
 * 
 * def packbits(myarray, axis=None):             # <<<<<<<<<<<<<<
 *     """packbits(myarray, axis=None)
 * 
 */
  __pyx_k_tuple_388 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__myarray), ((PyObject *)__pyx_n_s__axis)); if (unlikely(!__pyx_k_tuple_388)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8454; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_388);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_388));
  __pyx_k_codeobj_389 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_388, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__packbits, 8454, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_389)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8454; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":8500
 * 
 * 
 * def percentile(a, q, axis=None, out=None, overwrite_input=False):             # <<<<<<<<<<<<<<
 *     """Compute the qth percentile of the data along the specified axis.
 * 
 */
  __pyx_k_tuple_390 = PyTuple_Pack(5, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__q), ((PyObject *)__pyx_n_s__axis), ((PyObject *)__pyx_n_s__out), ((PyObject *)__pyx_n_s__overwrite_input)); if (unlikely(!__pyx_k_tuple_390)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8500; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_390);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_390));
  __pyx_k_codeobj_391 = (PyObject*)__Pyx_PyCode_New(5, 0, 5, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_390, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__percentile, 8500, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_391)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8500; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":8580
 * 
 * 
 * def piecewise(x, condlist, funclist):             # <<<<<<<<<<<<<<
 *     """Evaluate a piecewise-defined function.
 * 
 */
  __pyx_k_tuple_392 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__x), ((PyObject *)__pyx_n_s__condlist), ((PyObject *)__pyx_n_s__funclist)); if (unlikely(!__pyx_k_tuple_392)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8580; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_392);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_392));
  __pyx_k_codeobj_393 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_392, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__piecewise, 8580, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_393)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8580; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":8663
 * 
 * 
 * def pkgload():             # <<<<<<<<<<<<<<
 *     """Load one or more packages into parent package top-level namespace.
 * 
 */
  __pyx_k_codeobj_394 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__pkgload, 8663, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_394)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8663; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":8702
 * 
 * 
 * def place(arr, mask, vals):             # <<<<<<<<<<<<<<
 *     """Change elements of an array based on conditional and input values.
 * 
 */
  __pyx_k_tuple_395 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__arr), ((PyObject *)__pyx_n_s__mask), ((PyObject *)__pyx_n_s__vals)); if (unlikely(!__pyx_k_tuple_395)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8702; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_395);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_395));
  __pyx_k_codeobj_396 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_395, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__place, 8702, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_396)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8702; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":8738
 * 
 * 
 * def pmt(rate, nper, pv, fv=0, when='end'):             # <<<<<<<<<<<<<<
 *     """Compute the payment against loan principal plus interest.
 * 
 */
  __pyx_k_tuple_397 = PyTuple_Pack(5, ((PyObject *)__pyx_n_s__rate), ((PyObject *)__pyx_n_s__nper), ((PyObject *)__pyx_n_s__pv), ((PyObject *)__pyx_n_s__fv), ((PyObject *)__pyx_n_s__when)); if (unlikely(!__pyx_k_tuple_397)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8738; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_397);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_397));
  __pyx_k_codeobj_398 = (PyObject*)__Pyx_PyCode_New(5, 0, 5, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_397, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__pmt, 8738, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_398)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8738; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":8823
 * 
 * 
 * def poly(seq_of_zeros):             # <<<<<<<<<<<<<<
 *     """Find the coefficients of a polynomial with the given sequence of roots.
 * 
 */
  __pyx_k_tuple_399 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__seq_of_zeros)); if (unlikely(!__pyx_k_tuple_399)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8823; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_399);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_399));
  __pyx_k_codeobj_400 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_399, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__poly, 8823, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_400)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8823; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":8917
 * 
 * 
 * def polyadd(a1, a2):             # <<<<<<<<<<<<<<
 *     """Find the sum of two polynomials.
 * 
 */
  __pyx_k_tuple_401 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__a1), ((PyObject *)__pyx_n_s__a2)); if (unlikely(!__pyx_k_tuple_401)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8917; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_401);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_401));
  __pyx_k_codeobj_402 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_401, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__polyadd, 8917, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_402)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8917; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":8963
 * 
 * 
 * def polyder(p, m=1):             # <<<<<<<<<<<<<<
 *     """Return the derivative of the specified order of a polynomial.
 * 
 */
  __pyx_k_tuple_403 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__p), ((PyObject *)__pyx_n_s__m)); if (unlikely(!__pyx_k_tuple_403)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8963; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_403);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_403));
  __pyx_k_codeobj_404 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_403, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__polyder, 8963, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_404)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8963; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":9017
 * 
 * 
 * def polydiv(u, v):             # <<<<<<<<<<<<<<
 *     """Returns the quotient and remainder of polynomial division.
 * 
 */
  __pyx_k_tuple_405 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__u), ((PyObject *)__pyx_n_s__v)); if (unlikely(!__pyx_k_tuple_405)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9017; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_405);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_405));
  __pyx_k_codeobj_406 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_405, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__polydiv, 9017, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_406)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9017; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":9064
 * 
 * 
 * def polyfit(x, y, deg, rcond=None, full=False):             # <<<<<<<<<<<<<<
 *     """Least squares polynomial fit.
 * 
 */
  __pyx_k_tuple_407 = PyTuple_Pack(5, ((PyObject *)__pyx_n_s__x), ((PyObject *)__pyx_n_s__y), ((PyObject *)__pyx_n_s__deg), ((PyObject *)__pyx_n_s__rcond), ((PyObject *)__pyx_n_s__full)); if (unlikely(!__pyx_k_tuple_407)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9064; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_407);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_407));
  __pyx_k_codeobj_408 = (PyObject*)__Pyx_PyCode_New(5, 0, 5, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_407, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__polyfit, 9064, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_408)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9064; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":9200
 * 
 * 
 * def polyint(p, m=1, k=None):             # <<<<<<<<<<<<<<
 *     """Return an antiderivative (indefinite integral) of a polynomial.
 * 
 */
  __pyx_k_tuple_409 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__p), ((PyObject *)__pyx_n_s__m), ((PyObject *)__pyx_n_s__k)); if (unlikely(!__pyx_k_tuple_409)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9200; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_409);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_409));
  __pyx_k_codeobj_410 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_409, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__polyint, 9200, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_410)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9200; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":9269
 * 
 * 
 * def polymul(a1, a2):             # <<<<<<<<<<<<<<
 *     """Find the product of two polynomials.
 * 
 */
  __pyx_k_tuple_411 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__a1), ((PyObject *)__pyx_n_s__a2)); if (unlikely(!__pyx_k_tuple_411)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9269; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_411);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_411));
  __pyx_k_codeobj_412 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_411, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__polymul, 9269, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_412)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9269; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":9318
 * 
 * 
 * def polysub(a1, a2):             # <<<<<<<<<<<<<<
 *     """Difference (subtraction) of two polynomials.
 * 
 */
  __pyx_k_tuple_413 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__a1), ((PyObject *)__pyx_n_s__a2)); if (unlikely(!__pyx_k_tuple_413)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9318; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_413);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_413));
  __pyx_k_codeobj_414 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_413, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__polysub, 9318, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_414)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9318; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":9350
 * 
 * 
 * def polyval(p, x):             # <<<<<<<<<<<<<<
 *     """Evaluate a polynomial at specific values.
 * 
 */
  __pyx_k_tuple_415 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__p), ((PyObject *)__pyx_n_s__x)); if (unlikely(!__pyx_k_tuple_415)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9350; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_415);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_415));
  __pyx_k_codeobj_416 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_415, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__polyval, 9350, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_416)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9350; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":9411
 * 
 * 
 * def ppmt(rate, per, nper, pv, fv=0.0, when='end'):             # <<<<<<<<<<<<<<
 *     """Not implemented. Compute the payment against loan principal.
 * 
 */
  __pyx_k_tuple_417 = PyTuple_Pack(6, ((PyObject *)__pyx_n_s__rate), ((PyObject *)__pyx_n_s__per), ((PyObject *)__pyx_n_s__nper), ((PyObject *)__pyx_n_s__pv), ((PyObject *)__pyx_n_s__fv), ((PyObject *)__pyx_n_s__when)); if (unlikely(!__pyx_k_tuple_417)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9411; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_417);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_417));
  __pyx_k_codeobj_418 = (PyObject*)__Pyx_PyCode_New(6, 0, 6, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_417, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__ppmt, 9411, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_418)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9411; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":9438
 * 
 * 
 * def prod(a, axis=None, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the product of array elements over a given axis.
 * 
 */
  __pyx_k_tuple_419 = PyTuple_Pack(4, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__axis), ((PyObject *)__pyx_n_s__dtype), ((PyObject *)__pyx_n_s__out)); if (unlikely(!__pyx_k_tuple_419)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9438; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_419);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_419));
  __pyx_k_codeobj_420 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_419, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__prod, 9438, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_420)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9438; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":9514
 * 
 * 
 * def product(a, axis=None, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the product of array elements over a given axis.
 * 
 */
  __pyx_k_tuple_421 = PyTuple_Pack(4, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__axis), ((PyObject *)__pyx_n_s__dtype), ((PyObject *)__pyx_n_s__out)); if (unlikely(!__pyx_k_tuple_421)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9514; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_421);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_421));
  __pyx_k_codeobj_422 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_421, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__product, 9514, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_422)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9514; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":9525
 * 
 * 
 * def promote_types(type1, type2):             # <<<<<<<<<<<<<<
 *     """promote_types(type1, type2)
 * 
 */
  __pyx_k_tuple_423 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__type1), ((PyObject *)__pyx_n_s__type2)); if (unlikely(!__pyx_k_tuple_423)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9525; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_423);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_423));
  __pyx_k_codeobj_424 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_423, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__promote_types, 9525, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_424)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9525; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":9575
 * 
 * 
 * def ptp(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Range of values (maximum - minimum) along an axis.
 * 
 */
  __pyx_k_tuple_425 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__axis), ((PyObject *)__pyx_n_s__out)); if (unlikely(!__pyx_k_tuple_425)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9575; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_425);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_425));
  __pyx_k_codeobj_426 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_425, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__ptp, 9575, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_426)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9575; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":9615
 * 
 * 
 * def put(a, ind, v, mode='raise'):             # <<<<<<<<<<<<<<
 *     """Replaces specified elements of an array with given values.
 * 
 */
  __pyx_k_tuple_427 = PyTuple_Pack(4, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__ind), ((PyObject *)__pyx_n_s__v), ((PyObject *)__pyx_n_s__mode)); if (unlikely(!__pyx_k_tuple_427)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9615; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_427);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_427));
  __pyx_k_codeobj_428 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_427, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__put, 9615, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_428)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9615; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":9665
 * 
 * 
 * def putmask(a, mask, values):             # <<<<<<<<<<<<<<
 *     """putmask(a, mask, values)
 * 
 */
  __pyx_k_tuple_429 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__mask), ((PyObject *)__pyx_n_s__values)); if (unlikely(!__pyx_k_tuple_429)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9665; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_429);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_429));
  __pyx_k_codeobj_430 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_429, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__putmask, 9665, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_430)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9665; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":9709
 * 
 * 
 * def pv(rate, nper, pmt, fv=0.0, when='end'):             # <<<<<<<<<<<<<<
 *     """Compute the present value.
 * 
 */
  __pyx_k_tuple_431 = PyTuple_Pack(5, ((PyObject *)__pyx_n_s__rate), ((PyObject *)__pyx_n_s__nper), ((PyObject *)__pyx_n_s__pmt), ((PyObject *)__pyx_n_s__fv), ((PyObject *)__pyx_n_s__when)); if (unlikely(!__pyx_k_tuple_431)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9709; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_431);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_431));
  __pyx_k_codeobj_432 = (PyObject*)__Pyx_PyCode_New(5, 0, 5, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_431, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__pv, 9709, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_432)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9709; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":9797
 * 
 * 
 * def rank(a):             # <<<<<<<<<<<<<<
 *     """Return the number of dimensions of an array.
 * 
 */
  __pyx_k_tuple_433 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__a)); if (unlikely(!__pyx_k_tuple_433)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9797; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_433);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_433));
  __pyx_k_codeobj_434 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_433, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__rank, 9797, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_434)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9797; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":9839
 * 
 * 
 * def rate(nper, pmt, pv, fv, when='end', guess=0.1, tol=1e-06, maxiter=100):             # <<<<<<<<<<<<<<
 *     """Compute the rate of interest per period.
 * 
 */
  __pyx_k_tuple_435 = PyTuple_Pack(8, ((PyObject *)__pyx_n_s__nper), ((PyObject *)__pyx_n_s__pmt), ((PyObject *)__pyx_n_s__pv), ((PyObject *)__pyx_n_s__fv), ((PyObject *)__pyx_n_s__when), ((PyObject *)__pyx_n_s__guess), ((PyObject *)__pyx_n_s__tol), ((PyObject *)__pyx_n_s__maxiter)); if (unlikely(!__pyx_k_tuple_435)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9839; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_435);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_435));
  __pyx_k_codeobj_436 = (PyObject*)__Pyx_PyCode_New(8, 0, 8, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_435, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__rate, 9839, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_436)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9839; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":9884
 * 
 * 
 * def ravel(a, order='C'):             # <<<<<<<<<<<<<<
 *     """Return a flattened array.
 * 
 */
  __pyx_k_tuple_437 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__order)); if (unlikely(!__pyx_k_tuple_437)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9884; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_437);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_437));
  __pyx_k_codeobj_438 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_437, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__ravel, 9884, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_438)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9884; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":9968
 * 
 * 
 * def ravel_multi_index(multi_index, dims, mode='raise', order='C'):             # <<<<<<<<<<<<<<
 *     """ravel_multi_index(multi_index, dims, mode='raise', order='C')
 * 
 */
  __pyx_k_tuple_439 = PyTuple_Pack(4, ((PyObject *)__pyx_n_s__multi_index), ((PyObject *)__pyx_n_s__dims), ((PyObject *)__pyx_n_s__mode), ((PyObject *)__pyx_n_s__order)); if (unlikely(!__pyx_k_tuple_439)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9968; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_439);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_439));
  __pyx_k_codeobj_440 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_439, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__ravel_multi_index, 9968, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_440)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9968; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":10028
 * 
 * 
 * def real(val):             # <<<<<<<<<<<<<<
 *     """Return the real part of the elements of the array.
 * 
 */
  __pyx_k_tuple_441 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__val)); if (unlikely(!__pyx_k_tuple_441)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10028; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_441);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_441));
  __pyx_k_codeobj_442 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_441, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__real, 10028, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_442)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10028; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":10062
 * 
 * 
 * def real_if_close(a, tol=100):             # <<<<<<<<<<<<<<
 *     """If complex input returns a real array if complex parts are close to zero.
 * 
 */
  __pyx_k_tuple_443 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__tol)); if (unlikely(!__pyx_k_tuple_443)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10062; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_443);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_443));
  __pyx_k_codeobj_444 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_443, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__real_if_close, 10062, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_444)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10062; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":10107
 * 
 * 
 * def recfromcsv(fname):             # <<<<<<<<<<<<<<
 *     """Load ASCII data stored in a comma-separated file.
 * 
 */
  __pyx_k_tuple_445 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__fname)); if (unlikely(!__pyx_k_tuple_445)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10107; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_445);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_445));
  __pyx_k_codeobj_446 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_445, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__recfromcsv, 10107, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_446)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10107; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":10124
 * 
 * 
 * def recfromtxt(fname):             # <<<<<<<<<<<<<<
 *     """Load ASCII data from a file and return it in a record array.
 * 
 */
  __pyx_k_tuple_447 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__fname)); if (unlikely(!__pyx_k_tuple_447)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10124; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_447);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_447));
  __pyx_k_codeobj_448 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_447, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__recfromtxt, 10124, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_448)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10124; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":10146
 * 
 * 
 * def repeat(a, repeats, axis=None):             # <<<<<<<<<<<<<<
 *     """Repeat elements of an array.
 * 
 */
  __pyx_k_tuple_449 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__repeats), ((PyObject *)__pyx_n_s__axis)); if (unlikely(!__pyx_k_tuple_449)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10146; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_449);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_449));
  __pyx_k_codeobj_450 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_449, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__repeat, 10146, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_450)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10146; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":10187
 * 
 * 
 * def require(a, dtype=None, requirements=None):             # <<<<<<<<<<<<<<
 *     """Return an ndarray of the provided type that satisfies requirements.
 * 
 */
  __pyx_k_tuple_451 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__dtype), ((PyObject *)__pyx_n_s__requirements)); if (unlikely(!__pyx_k_tuple_451)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10187; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_451);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_451));
  __pyx_k_codeobj_452 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_451, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__require, 10187, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_452)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10187; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":10246
 * 
 * 
 * def reshape(a, newshape, order='C'):             # <<<<<<<<<<<<<<
 *     """Gives a new shape to an array without changing its data.
 * 
 */
  __pyx_k_tuple_453 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__newshape), ((PyObject *)__pyx_n_s__order)); if (unlikely(!__pyx_k_tuple_453)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10246; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_453);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_453));
  __pyx_k_codeobj_454 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_453, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__reshape, 10246, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_454)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10246; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":10308
 * 
 * 
 * def resize(a, new_shape):             # <<<<<<<<<<<<<<
 *     """Return a new array with the specified shape.
 * 
 */
  __pyx_k_tuple_455 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__new_shape)); if (unlikely(!__pyx_k_tuple_455)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10308; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_455);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_455));
  __pyx_k_codeobj_456 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_455, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__resize, 10308, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_456)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10308; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":10348
 * 
 * 
 * def restoredot():             # <<<<<<<<<<<<<<
 *     """Restore `dot`, `vdot`, and `innerproduct` to the default non-BLAS
 *     implementations.
 */
  __pyx_k_codeobj_457 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__restoredot, 10348, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_457)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10348; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":10366
 * 
 * 
 * def result_type(*arrays_and_dtypes):             # <<<<<<<<<<<<<<
 *     """result_type(*arrays_and_dtypes)
 * 
 */
  __pyx_k_tuple_458 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__arrays_and_dtypes), ((PyObject *)__pyx_n_s__arrays_and_dtypes)); if (unlikely(!__pyx_k_tuple_458)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10366; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_458);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_458));
  __pyx_k_codeobj_459 = (PyObject*)__Pyx_PyCode_New(0, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_458, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__result_type, 10366, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_459)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10366; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":10437
 * 
 * 
 * def roll(a, shift, axis=None):             # <<<<<<<<<<<<<<
 *     """Roll array elements along a given axis.
 * 
 */
  __pyx_k_tuple_460 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__shift), ((PyObject *)__pyx_n_s__axis)); if (unlikely(!__pyx_k_tuple_460)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10437; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_460);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_460));
  __pyx_k_codeobj_461 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_460, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__roll, 10437, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_461)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10437; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":10488
 * 
 * 
 * def rollaxis(a, axis, start=0):             # <<<<<<<<<<<<<<
 *     """Roll the specified axis backwards, until it lies in a given position.
 * 
 */
  __pyx_k_tuple_462 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__axis), ((PyObject *)__pyx_n_s__start)); if (unlikely(!__pyx_k_tuple_462)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10488; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_462);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_462));
  __pyx_k_codeobj_463 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_462, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__rollaxis, 10488, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_463)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10488; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":10526
 * 
 * 
 * def roots(p):             # <<<<<<<<<<<<<<
 *     """Return the roots of a polynomial with coefficients given in p.
 * 
 */
  __pyx_k_tuple_464 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__p)); if (unlikely(!__pyx_k_tuple_464)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10526; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_464);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_464));
  __pyx_k_codeobj_465 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_464, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__roots, 10526, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_465)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10526; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":10577
 * 
 * 
 * def rot90(m, k=1):             # <<<<<<<<<<<<<<
 *     """Rotate an array by 90 degrees in the counter-clockwise direction.
 * 
 */
  __pyx_k_tuple_466 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__m), ((PyObject *)__pyx_n_s__k)); if (unlikely(!__pyx_k_tuple_466)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10577; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_466);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_466));
  __pyx_k_codeobj_467 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_466, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__rot90, 10577, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_467)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10577; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":10617
 * 
 * 
 * def round(a, decimals=0, out=None):             # <<<<<<<<<<<<<<
 *     """Round an array to the given number of decimals.
 * 
 */
  __pyx_k_tuple_468 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__decimals), ((PyObject *)__pyx_n_s__out)); if (unlikely(!__pyx_k_tuple_468)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10617; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_468);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_468));
  __pyx_k_codeobj_469 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_468, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__round, 10617, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_469)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10617; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":10630
 * 
 * 
 * def round_(a, decimals=0, out=None):             # <<<<<<<<<<<<<<
 *     """Round an array to the given number of decimals.
 * 
 */
  __pyx_k_tuple_470 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__decimals), ((PyObject *)__pyx_n_s__out)); if (unlikely(!__pyx_k_tuple_470)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10630; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_470);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_470));
  __pyx_k_codeobj_471 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_470, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__round_, 10630, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_471)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10630; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":10643
 * 
 * 
 * def row_stack(tup):             # <<<<<<<<<<<<<<
 *     """Stack arrays in sequence vertically (row wise).
 * 
 */
  __pyx_k_tuple_472 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__tup)); if (unlikely(!__pyx_k_tuple_472)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10643; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_472);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_472));
  __pyx_k_codeobj_473 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_472, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__row_stack, 10643, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_473)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10643; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":10694
 * 
 * 
 * def safe_eval(source):             # <<<<<<<<<<<<<<
 *     """Protected string evaluation.
 * 
 */
  __pyx_k_tuple_474 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__source)); if (unlikely(!__pyx_k_tuple_474)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10694; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_474);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_474));
  __pyx_k_codeobj_475 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_474, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__safe_eval, 10694, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_475)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10694; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":10739
 * 
 * 
 * def save(file, arr):             # <<<<<<<<<<<<<<
 *     """Save an array to a binary file in NumPy ``.npy`` format.
 * 
 */
  __pyx_k_tuple_476 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__file), ((PyObject *)__pyx_n_s__arr)); if (unlikely(!__pyx_k_tuple_476)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10739; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_476);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_476));
  __pyx_k_codeobj_477 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_476, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__save, 10739, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_477)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10739; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":10777
 * 
 * 
 * def savetxt(fname, X, fmt='%.18e', delimiter=' ', newline='\n'):             # <<<<<<<<<<<<<<
 *     """Save an array to a text file.
 * 
 */
  __pyx_k_tuple_478 = PyTuple_Pack(5, ((PyObject *)__pyx_n_s__fname), ((PyObject *)__pyx_n_s__X), ((PyObject *)__pyx_n_s__fmt), ((PyObject *)__pyx_n_s__delimiter), ((PyObject *)__pyx_n_s__newline)); if (unlikely(!__pyx_k_tuple_478)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10777; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_478);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_478));
  __pyx_k_codeobj_479 = (PyObject*)__Pyx_PyCode_New(5, 0, 5, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_478, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__savetxt, 10777, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_479)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10777; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":10868
 * 
 * 
 * def savez(file):             # <<<<<<<<<<<<<<
 *     """Save several arrays into a single file in uncompressed ``.npz`` format.
 * 
 */
  __pyx_k_tuple_480 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__file)); if (unlikely(!__pyx_k_tuple_480)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10868; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_480);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_480));
  __pyx_k_codeobj_481 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_480, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__savez, 10868, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_481)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10868; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":10948
 * 
 * 
 * def savez_compressed(file):             # <<<<<<<<<<<<<<
 *     """Save several arrays into a single file in compressed ``.npz`` format.
 * 
 */
  __pyx_k_tuple_482 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__file)); if (unlikely(!__pyx_k_tuple_482)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10948; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_482);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_482));
  __pyx_k_codeobj_483 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_482, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__savez_compressed, 10948, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_483)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10948; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":10972
 * 
 * 
 * def sctype2char(sctype):             # <<<<<<<<<<<<<<
 *     """Return the string representation of a scalar dtype.
 * 
 */
  __pyx_k_tuple_484 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__sctype)); if (unlikely(!__pyx_k_tuple_484)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10972; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_484);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_484));
  __pyx_k_codeobj_485 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_484, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__sctype2char, 10972, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_485)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10972; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":11016
 * 
 * 
 * def searchsorted(a, v, side='left'):             # <<<<<<<<<<<<<<
 *     """Find indices where elements should be inserted to maintain order.
 * 
 */
  __pyx_k_tuple_486 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__v), ((PyObject *)__pyx_n_s__side)); if (unlikely(!__pyx_k_tuple_486)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11016; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_486);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_486));
  __pyx_k_codeobj_487 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_486, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__searchsorted, 11016, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_487)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11016; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":11064
 * 
 * 
 * def select(condlist, choicelist, default=0):             # <<<<<<<<<<<<<<
 *     """Return an array drawn from elements in choicelist, depending on conditions.
 * 
 */
  __pyx_k_tuple_488 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__condlist), ((PyObject *)__pyx_n_s__choicelist), ((PyObject *)__pyx_n_s__default)); if (unlikely(!__pyx_k_tuple_488)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11064; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_488);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_488));
  __pyx_k_codeobj_489 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_488, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__select, 11064, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_489)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11064; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":11103
 * 
 * 
 * def set_numeric_ops():             # <<<<<<<<<<<<<<
 *     """set_numeric_ops(op1=func1, op2=func2, ...)
 * 
 */
  __pyx_k_codeobj_490 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__set_numeric_ops, 11103, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_490)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11103; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":11149
 * 
 * 
 * def set_printoptions(precision=None, threshold=None, edgeitems=None, linewidth=None, suppress=None, nanstr=None, infstr=None):             # <<<<<<<<<<<<<<
 *     """Set printing options.
 * 
 */
  __pyx_k_tuple_491 = PyTuple_Pack(7, ((PyObject *)__pyx_n_s__precision), ((PyObject *)__pyx_n_s__threshold), ((PyObject *)__pyx_n_s__edgeitems), ((PyObject *)__pyx_n_s__linewidth), ((PyObject *)__pyx_n_s__suppress), ((PyObject *)__pyx_n_s__nanstr), ((PyObject *)__pyx_n_s__infstr)); if (unlikely(!__pyx_k_tuple_491)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11149; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_491);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_491));
  __pyx_k_codeobj_492 = (PyObject*)__Pyx_PyCode_New(7, 0, 7, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_491, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__set_printoptions, 11149, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_492)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11149; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":11214
 * 
 * 
 * def set_string_function(f, repr=True):             # <<<<<<<<<<<<<<
 *     """Set a Python function to be used when pretty printing arrays.
 * 
 */
  __pyx_k_tuple_493 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__f), ((PyObject *)__pyx_n_s__repr)); if (unlikely(!__pyx_k_tuple_493)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11214; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_493);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_493));
  __pyx_k_codeobj_494 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_493, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__set_string_function, 11214, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_494)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11214; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":11267
 * 
 * 
 * def setbufsize(size):             # <<<<<<<<<<<<<<
 *     """Set the size of the buffer used in ufuncs.
 * 
 */
  __pyx_k_tuple_495 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__size)); if (unlikely(!__pyx_k_tuple_495)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11267; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_495);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_495));
  __pyx_k_codeobj_496 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_495, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__setbufsize, 11267, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_496)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11267; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":11279
 * 
 * 
 * def setdiff1d(ar1, ar2, assume_unique=False):             # <<<<<<<<<<<<<<
 *     """Find the set difference of two arrays.
 * 
 */
  __pyx_k_tuple_497 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__ar1), ((PyObject *)__pyx_n_s__ar2), ((PyObject *)__pyx_n_s__assume_unique)); if (unlikely(!__pyx_k_tuple_497)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11279; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_497);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_497));
  __pyx_k_codeobj_498 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_497, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__setdiff1d, 11279, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_498)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11279; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":11315
 * 
 * 
 * def seterr(all=None, divide=None, over=None, under=None, invalid=None):             # <<<<<<<<<<<<<<
 *     """Set how floating-point errors are handled.
 * 
 */
  __pyx_k_tuple_499 = PyTuple_Pack(5, ((PyObject *)__pyx_n_s__all), ((PyObject *)__pyx_n_s__divide), ((PyObject *)__pyx_n_s__over), ((PyObject *)__pyx_n_s__under), ((PyObject *)__pyx_n_s__invalid)); if (unlikely(!__pyx_k_tuple_499)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11315; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_499);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_499));
  __pyx_k_codeobj_500 = (PyObject*)__Pyx_PyCode_New(5, 0, 5, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_499, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__seterr, 11315, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_500)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11315; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":11394
 * 
 * 
 * def seterrcall(func):             # <<<<<<<<<<<<<<
 *     """Set the floating-point error callback function or log object.
 * 
 */
  __pyx_k_tuple_501 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__func)); if (unlikely(!__pyx_k_tuple_501)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11394; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_501);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_501));
  __pyx_k_codeobj_502 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_501, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__seterrcall, 11394, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_502)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11394; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":11477
 * 
 * 
 * def seterrobj(errobj):             # <<<<<<<<<<<<<<
 *     """seterrobj(errobj)
 * 
 */
  __pyx_k_tuple_503 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__errobj)); if (unlikely(!__pyx_k_tuple_503)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11477; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_503);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_503));
  __pyx_k_codeobj_504 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_503, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__seterrobj, 11477, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_504)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11477; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":11538
 * 
 * 
 * def setxor1d(ar1, ar2, assume_unique=False):             # <<<<<<<<<<<<<<
 *     """Find the set exclusive-or of two arrays.
 * 
 */
  __pyx_k_tuple_505 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__ar1), ((PyObject *)__pyx_n_s__ar2), ((PyObject *)__pyx_n_s__assume_unique)); if (unlikely(!__pyx_k_tuple_505)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11538; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_505);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_505));
  __pyx_k_codeobj_506 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_505, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__setxor1d, 11538, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_506)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11538; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":11569
 * 
 * 
 * def show_config():             # <<<<<<<<<<<<<<
 *     """
 * 
 */
  __pyx_k_codeobj_507 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__show_config, 11569, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_507)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11569; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":11576
 * 
 * 
 * def sinc(x):             # <<<<<<<<<<<<<<
 *     """Return the sinc function.
 * 
 */
  __pyx_k_tuple_508 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__x)); if (unlikely(!__pyx_k_tuple_508)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11576; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_508);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_508));
  __pyx_k_codeobj_509 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_508, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__sinc, 11576, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_509)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11576; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":11653
 * 
 * 
 * def size(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Return the number of elements along a given axis.
 * 
 */
  __pyx_k_tuple_510 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__axis)); if (unlikely(!__pyx_k_tuple_510)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11653; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_510);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_510));
  __pyx_k_codeobj_511 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_510, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__size, 11653, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_511)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11653; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":11689
 * 
 * 
 * def sometrue(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Check whether some values are true.
 * 
 */
  __pyx_k_tuple_512 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__axis), ((PyObject *)__pyx_n_s__out)); if (unlikely(!__pyx_k_tuple_512)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11689; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_512);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_512));
  __pyx_k_codeobj_513 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_512, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__sometrue, 11689, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_513)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11689; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":11702
 * 
 * 
 * def sort(a, axis=-1, kind='quicksort', order=None):             # <<<<<<<<<<<<<<
 *     """Return a sorted copy of an array.
 * 
 */
  __pyx_k_tuple_514 = PyTuple_Pack(4, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__axis), ((PyObject *)__pyx_n_s__kind), ((PyObject *)__pyx_n_s__order)); if (unlikely(!__pyx_k_tuple_514)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11702; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_514);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_514));
  __pyx_k_codeobj_515 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_514, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__sort, 11702, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_515)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11702; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":11803
 * 
 * 
 * def sort_complex(a):             # <<<<<<<<<<<<<<
 *     """Sort a complex array using the real part first, then the imaginary part.
 * 
 */
  __pyx_k_tuple_516 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__a)); if (unlikely(!__pyx_k_tuple_516)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11803; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_516);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_516));
  __pyx_k_codeobj_517 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_516, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__sort_complex, 11803, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_517)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11803; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":11828
 * 
 * 
 * def source(object, output=sys.stdout):             # <<<<<<<<<<<<<<
 *     """Print or write to a file the source code for a Numpy object.
 * 
 */
  __pyx_k_tuple_518 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__object), ((PyObject *)__pyx_n_s__output)); if (unlikely(!__pyx_k_tuple_518)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11828; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_518);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_518));
  __pyx_k_codeobj_519 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_518, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__source, 11828, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_519)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11828; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":11868
 * 
 * 
 * def split(ary, indices_or_sections, axis=0):             # <<<<<<<<<<<<<<
 *     """Split an array into multiple sub-arrays of equal size.
 * 
 */
  __pyx_k_tuple_520 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__ary), ((PyObject *)__pyx_n_s__indices_or_sections), ((PyObject *)__pyx_n_s__axis)); if (unlikely(!__pyx_k_tuple_520)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11868; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_520);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_520));
  __pyx_k_codeobj_521 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_520, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__split, 11868, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_521)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11868; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":11935
 * 
 * 
 * def squeeze(a):             # <<<<<<<<<<<<<<
 *     """Remove single-dimensional entries from the shape of an array.
 * 
 */
  __pyx_k_tuple_522 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__a)); if (unlikely(!__pyx_k_tuple_522)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11935; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_522);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_522));
  __pyx_k_codeobj_523 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_522, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__squeeze, 11935, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_523)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11935; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":11961
 * 
 * 
 * def std(a, axis=None, dtype=None, out=None, ddof=0):             # <<<<<<<<<<<<<<
 *     """Compute the standard deviation along the specified axis.
 * 
 */
  __pyx_k_tuple_524 = PyTuple_Pack(5, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__axis), ((PyObject *)__pyx_n_s__dtype), ((PyObject *)__pyx_n_s__out), ((PyObject *)__pyx_n_s__ddof)); if (unlikely(!__pyx_k_tuple_524)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11961; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_524);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_524));
  __pyx_k_codeobj_525 = (PyObject*)__Pyx_PyCode_New(5, 0, 5, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_524, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__std, 11961, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_525)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11961; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":12049
 * 
 * 
 * def sum(a, axis=None, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Sum of array elements over a given axis.
 * 
 */
  __pyx_k_tuple_526 = PyTuple_Pack(4, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__axis), ((PyObject *)__pyx_n_s__dtype), ((PyObject *)__pyx_n_s__out)); if (unlikely(!__pyx_k_tuple_526)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12049; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_526);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_526));
  __pyx_k_codeobj_527 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_526, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__sum, 12049, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_527)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12049; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":12117
 * 
 * 
 * def swapaxes(a, axis1, axis2):             # <<<<<<<<<<<<<<
 *     """Interchange two axes of an array.
 * 
 */
  __pyx_k_tuple_528 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__axis1), ((PyObject *)__pyx_n_s__axis2)); if (unlikely(!__pyx_k_tuple_528)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12117; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_528);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_528));
  __pyx_k_codeobj_529 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_528, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__swapaxes, 12117, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_529)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12117; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":12160
 * 
 * 
 * def take(a, indices, axis=None, out=None, mode='raise'):             # <<<<<<<<<<<<<<
 *     """Take elements from an array along an axis.
 * 
 */
  __pyx_k_tuple_530 = PyTuple_Pack(5, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__indices), ((PyObject *)__pyx_n_s__axis), ((PyObject *)__pyx_n_s__out), ((PyObject *)__pyx_n_s__mode)); if (unlikely(!__pyx_k_tuple_530)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12160; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_530);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_530));
  __pyx_k_codeobj_531 = (PyObject*)__Pyx_PyCode_New(5, 0, 5, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_530, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__take, 12160, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_531)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12160; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":12216
 * 
 * 
 * def tensordot(a, b, axes=2):             # <<<<<<<<<<<<<<
 *     """Compute tensor dot product along specified axes for arrays >= 1-D.
 * 
 */
  __pyx_k_tuple_532 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__b), ((PyObject *)__pyx_n_s__axes)); if (unlikely(!__pyx_k_tuple_532)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12216; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_532);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_532));
  __pyx_k_codeobj_533 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_532, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__tensordot, 12216, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_533)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12216; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":12332
 * 
 * 
 * def tile(A, reps):             # <<<<<<<<<<<<<<
 *     """Construct an array by repeating A the number of times given by reps.
 * 
 */
  __pyx_k_tuple_534 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__A), ((PyObject *)__pyx_n_s__reps)); if (unlikely(!__pyx_k_tuple_534)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12332; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_534);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_534));
  __pyx_k_codeobj_535 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_534, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__tile, 12332, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_535)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12332; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":12390
 * 
 * 
 * def trace(a, offset=0, axis1=0, axis2=1, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the sum along diagonals of the array.
 * 
 */
  __pyx_k_tuple_536 = PyTuple_Pack(6, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__offset), ((PyObject *)__pyx_n_s__axis1), ((PyObject *)__pyx_n_s__axis2), ((PyObject *)__pyx_n_s__dtype), ((PyObject *)__pyx_n_s__out)); if (unlikely(!__pyx_k_tuple_536)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12390; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_536);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_536));
  __pyx_k_codeobj_537 = (PyObject*)__Pyx_PyCode_New(6, 0, 6, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_536, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__trace, 12390, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_537)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12390; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":12448
 * 
 * 
 * def transpose(a, axes=None):             # <<<<<<<<<<<<<<
 *     """Permute the dimensions of an array.
 * 
 */
  __pyx_k_tuple_538 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__axes)); if (unlikely(!__pyx_k_tuple_538)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12448; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_538);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_538));
  __pyx_k_codeobj_539 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_538, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__transpose, 12448, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_539)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12448; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":12488
 * 
 * 
 * def trapz(y, x=None, dx=1.0, axis=-1):             # <<<<<<<<<<<<<<
 *     """Integrate along the given axis using the composite trapezoidal rule.
 * 
 */
  __pyx_k_tuple_540 = PyTuple_Pack(4, ((PyObject *)__pyx_n_s__y), ((PyObject *)__pyx_n_s__x), ((PyObject *)__pyx_n_s__dx), ((PyObject *)__pyx_n_s__axis)); if (unlikely(!__pyx_k_tuple_540)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12488; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_540);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_540));
  __pyx_k_codeobj_541 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_540, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__trapz, 12488, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_541)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12488; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":12549
 * 
 * 
 * def tri(N, M=None, k=0, dtype=float):             # <<<<<<<<<<<<<<
 *     """An array with ones at and below the given diagonal and zeros elsewhere.
 * 
 */
  __pyx_k_tuple_542 = PyTuple_Pack(4, ((PyObject *)__pyx_n_s__N), ((PyObject *)__pyx_n_s__M), ((PyObject *)__pyx_n_s__k), ((PyObject *)__pyx_n_s__dtype)); if (unlikely(!__pyx_k_tuple_542)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12549; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_542);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_542));
  __pyx_k_codeobj_543 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_542, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__tri, 12549, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_543)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12549; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":12588
 * 
 * 
 * def tril(m, k=0):             # <<<<<<<<<<<<<<
 *     """Lower triangle of an array.
 * 
 */
  __pyx_k_tuple_544 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__m), ((PyObject *)__pyx_n_s__k)); if (unlikely(!__pyx_k_tuple_544)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12588; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_544);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_544));
  __pyx_k_codeobj_545 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_544, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__tril, 12588, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_545)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12588; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":12622
 * 
 * 
 * def tril_indices(n, k=0):             # <<<<<<<<<<<<<<
 *     """Return the indices for the lower-triangle of an (n, n) array.
 * 
 */
  __pyx_k_tuple_546 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__n), ((PyObject *)__pyx_n_s__k)); if (unlikely(!__pyx_k_tuple_546)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12622; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_546);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_546));
  __pyx_k_codeobj_547 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_546, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__tril_indices, 12622, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_547)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12622; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":12694
 * 
 * 
 * def tril_indices_from(arr, k=0):             # <<<<<<<<<<<<<<
 *     """Return the indices for the lower-triangle of arr.
 * 
 */
  __pyx_k_tuple_548 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__arr), ((PyObject *)__pyx_n_s__k)); if (unlikely(!__pyx_k_tuple_548)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12694; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_548);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_548));
  __pyx_k_codeobj_549 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_548, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__tril_indices_from, 12694, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_549)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12694; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":12719
 * 
 * 
 * def trim_zeros(filt, trim='fb'):             # <<<<<<<<<<<<<<
 *     """Trim the leading and/or trailing zeros from a 1-D array or sequence.
 * 
 */
  __pyx_k_tuple_550 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__filt), ((PyObject *)__pyx_n_s__trim)); if (unlikely(!__pyx_k_tuple_550)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12719; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_550);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_550));
  __pyx_k_codeobj_551 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_550, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__trim_zeros, 12719, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_551)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12719; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":12754
 * 
 * 
 * def triu(m, k=0):             # <<<<<<<<<<<<<<
 *     """Upper triangle of an array.
 * 
 */
  __pyx_k_tuple_552 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__m), ((PyObject *)__pyx_n_s__k)); if (unlikely(!__pyx_k_tuple_552)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12754; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_552);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_552));
  __pyx_k_codeobj_553 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_552, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__triu, 12754, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_553)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12754; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":12778
 * 
 * 
 * def triu_indices(n, k=0):             # <<<<<<<<<<<<<<
 *     """Return the indices for the upper-triangle of an (n, n) array.
 * 
 */
  __pyx_k_tuple_554 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__n), ((PyObject *)__pyx_n_s__k)); if (unlikely(!__pyx_k_tuple_554)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12778; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_554);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_554));
  __pyx_k_codeobj_555 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_554, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__triu_indices, 12778, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_555)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12778; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":12851
 * 
 * 
 * def triu_indices_from(arr, k=0):             # <<<<<<<<<<<<<<
 *     """Return the indices for the upper-triangle of an (n, n) array.
 * 
 */
  __pyx_k_tuple_556 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__arr), ((PyObject *)__pyx_n_s__k)); if (unlikely(!__pyx_k_tuple_556)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12851; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_556);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_556));
  __pyx_k_codeobj_557 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_556, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__triu_indices_from, 12851, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_557)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12851; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":12876
 * 
 * 
 * def typename(char_):             # <<<<<<<<<<<<<<
 *     """Return a description for the given data type code.
 * 
 */
  __pyx_k_tuple_558 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__char_)); if (unlikely(!__pyx_k_tuple_558)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12876; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_558);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_558));
  __pyx_k_codeobj_559 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_558, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__typename, 12876, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_559)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12876; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":12927
 * 
 * 
 * def union1d(ar1, ar2):             # <<<<<<<<<<<<<<
 *     """Find the union of two arrays.
 * 
 */
  __pyx_k_tuple_560 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__ar1), ((PyObject *)__pyx_n_s__ar2)); if (unlikely(!__pyx_k_tuple_560)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12927; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_560);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_560));
  __pyx_k_codeobj_561 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_560, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__union1d, 12927, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_561)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12927; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":12957
 * 
 * 
 * def unique(ar, return_index=False, return_inverse=False):             # <<<<<<<<<<<<<<
 *     """Find the unique elements of an array.
 * 
 */
  __pyx_k_tuple_562 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__ar), ((PyObject *)__pyx_n_s__return_index), ((PyObject *)__pyx_n_s__return_inverse)); if (unlikely(!__pyx_k_tuple_562)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12957; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_562);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_562));
  __pyx_k_codeobj_563 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_562, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__unique, 12957, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_563)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12957; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":13028
 * 
 * 
 * def unpackbits(myarray, axis=None):             # <<<<<<<<<<<<<<
 *     """unpackbits(myarray, axis=None)
 * 
 */
  __pyx_k_tuple_564 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__myarray), ((PyObject *)__pyx_n_s__axis)); if (unlikely(!__pyx_k_tuple_564)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13028; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_564);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_564));
  __pyx_k_codeobj_565 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_564, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__unpackbits, 13028, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_565)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13028; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":13073
 * 
 * 
 * def unravel_index(indices, dims, order='C'):             # <<<<<<<<<<<<<<
 *     """unravel_index(indices, dims, order='C')
 * 
 */
  __pyx_k_tuple_566 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__indices), ((PyObject *)__pyx_n_s__dims), ((PyObject *)__pyx_n_s__order)); if (unlikely(!__pyx_k_tuple_566)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13073; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_566);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_566));
  __pyx_k_codeobj_567 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_566, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__unravel_index, 13073, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_567)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13073; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":13118
 * 
 * 
 * def unwrap(p, discont=3.14159265359, axis=-1):             # <<<<<<<<<<<<<<
 *     """Unwrap by changing deltas between values to 2*pi complement.
 * 
 */
  __pyx_k_tuple_568 = PyTuple_Pack(3, ((PyObject *)__pyx_n_s__p), ((PyObject *)__pyx_n_s__discont), ((PyObject *)__pyx_n_s__axis)); if (unlikely(!__pyx_k_tuple_568)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13118; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_568);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_568));
  __pyx_k_codeobj_569 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_568, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__unwrap, 13118, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_569)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13118; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":13161
 * 
 * 
 * def vander(x, N=None):             # <<<<<<<<<<<<<<
 *     """Generate a Van der Monde matrix.
 * 
 */
  __pyx_k_tuple_570 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__x), ((PyObject *)__pyx_n_s__N)); if (unlikely(!__pyx_k_tuple_570)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13161; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_570);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_570));
  __pyx_k_codeobj_571 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_570, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__vander, 13161, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_571)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13161; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":13219
 * 
 * 
 * def var(a, axis=None, dtype=None, out=None, ddof=0):             # <<<<<<<<<<<<<<
 *     """Compute the variance along the specified axis.
 * 
 */
  __pyx_k_tuple_572 = PyTuple_Pack(5, ((PyObject *)__pyx_n_s__a), ((PyObject *)__pyx_n_s__axis), ((PyObject *)__pyx_n_s__dtype), ((PyObject *)__pyx_n_s__out), ((PyObject *)__pyx_n_s__ddof)); if (unlikely(!__pyx_k_tuple_572)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13219; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_572);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_572));
  __pyx_k_codeobj_573 = (PyObject*)__Pyx_PyCode_New(5, 0, 5, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_572, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__var, 13219, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_573)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13219; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":13309
 * 
 * 
 * def vdot():             # <<<<<<<<<<<<<<
 *     """Return the dot product of two vectors.
 * 
 */
  __pyx_k_codeobj_574 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__vdot, 13309, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_574)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13309; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":13364
 * 
 * 
 * def vsplit(ary, indices_or_sections):             # <<<<<<<<<<<<<<
 *     """Split an array into multiple sub-arrays vertically (row-wise).
 * 
 */
  __pyx_k_tuple_575 = PyTuple_Pack(2, ((PyObject *)__pyx_n_s__ary), ((PyObject *)__pyx_n_s__indices_or_sections)); if (unlikely(!__pyx_k_tuple_575)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13364; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_575);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_575));
  __pyx_k_codeobj_576 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_575, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__vsplit, 13364, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_576)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13364; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":13413
 * 
 * 
 * def vstack(tup):             # <<<<<<<<<<<<<<
 *     """Stack arrays in sequence vertically (row wise).
 * 
 */
  __pyx_k_tuple_577 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__tup)); if (unlikely(!__pyx_k_tuple_577)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13413; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_577);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_577));
  __pyx_k_codeobj_578 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_577, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__vstack, 13413, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_578)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13413; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":13464
 * 
 * 
 * def where():             # <<<<<<<<<<<<<<
 *     """where(condition, [x, y])
 * 
 */
  __pyx_k_codeobj_579 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__where, 13464, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_579)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13464; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "ga4py/gain/notimplemented.pyx":13526
 * 
 * 
 * def who(vardict=None):             # <<<<<<<<<<<<<<
 *     """Print the Numpy arrays in the given dictionary.
 * 
 */
  __pyx_k_tuple_580 = PyTuple_Pack(1, ((PyObject *)__pyx_n_s__vardict)); if (unlikely(!__pyx_k_tuple_580)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13526; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_580);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_580));
  __pyx_k_codeobj_581 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_580, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_67, __pyx_n_s__who, 13526, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_581)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13526; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_RefNannyFinishContext();
  return 0;
  __pyx_L1_error:;
  __Pyx_RefNannyFinishContext();
  return -1;
}

static int __Pyx_InitGlobals(void) {
  if (__Pyx_InitStrings(__pyx_string_tab) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  __pyx_int_0 = PyInt_FromLong(0); if (unlikely(!__pyx_int_0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  __pyx_int_1 = PyInt_FromLong(1); if (unlikely(!__pyx_int_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  __pyx_int_2 = PyInt_FromLong(2); if (unlikely(!__pyx_int_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  __pyx_int_neg_1 = PyInt_FromLong(-1); if (unlikely(!__pyx_int_neg_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  __pyx_int_10 = PyInt_FromLong(10); if (unlikely(!__pyx_int_10)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  __pyx_int_15 = PyInt_FromLong(15); if (unlikely(!__pyx_int_15)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  __pyx_int_76 = PyInt_FromLong(76); if (unlikely(!__pyx_int_76)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  __pyx_int_100 = PyInt_FromLong(100); if (unlikely(!__pyx_int_100)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  return 0;
  __pyx_L1_error:;
  return -1;
}

#if PY_MAJOR_VERSION < 3
PyMODINIT_FUNC initnotimplemented(void); /*proto*/
PyMODINIT_FUNC initnotimplemented(void)
#else
PyMODINIT_FUNC PyInit_notimplemented(void); /*proto*/
PyMODINIT_FUNC PyInit_notimplemented(void)
#endif
{
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannyDeclarations
  #if CYTHON_REFNANNY
  __Pyx_RefNanny = __Pyx_RefNannyImportAPI("refnanny");
  if (!__Pyx_RefNanny) {
      PyErr_Clear();
      __Pyx_RefNanny = __Pyx_RefNannyImportAPI("Cython.Runtime.refnanny");
      if (!__Pyx_RefNanny)
          Py_FatalError("failed to import 'refnanny' module");
  }
  #endif
  __Pyx_RefNannySetupContext("PyMODINIT_FUNC PyInit_notimplemented(void)", 0);
  if ( __Pyx_check_binary_version() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_empty_bytes = PyBytes_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_bytes)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #ifdef __Pyx_CyFunction_USED
  if (__Pyx_CyFunction_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #endif
  #ifdef __Pyx_FusedFunction_USED
  if (__pyx_FusedFunction_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #endif
  #ifdef __Pyx_Generator_USED
  if (__pyx_Generator_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #endif
  /*--- Library function declarations ---*/
  /*--- Threads initialization code ---*/
  #if defined(__PYX_FORCE_INIT_THREADS) && __PYX_FORCE_INIT_THREADS
  #ifdef WITH_THREAD /* Python build with threading support? */
  PyEval_InitThreads();
  #endif
  #endif
  /*--- Module creation code ---*/
  #if PY_MAJOR_VERSION < 3
  __pyx_m = Py_InitModule4(__Pyx_NAMESTR("notimplemented"), __pyx_methods, 0, 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);
  #else
  __pyx_m = PyModule_Create(&__pyx_moduledef);
  #endif
  if (unlikely(!__pyx_m)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_d = PyModule_GetDict(__pyx_m); if (unlikely(!__pyx_d)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  Py_INCREF(__pyx_d);
  #if PY_MAJOR_VERSION >= 3
  {
    PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    if (!PyDict_GetItemString(modules, "ga4py.gain.notimplemented")) {
      if (unlikely(PyDict_SetItemString(modules, "ga4py.gain.notimplemented", __pyx_m) < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    }
  }
  #endif
  __pyx_b = PyImport_AddModule(__Pyx_NAMESTR(__Pyx_BUILTIN_MODULE_NAME)); if (unlikely(!__pyx_b)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #if CYTHON_COMPILING_IN_PYPY
  Py_INCREF(__pyx_b);
  #endif
  if (__Pyx_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  /*--- Initialize various global constants etc. ---*/
  if (unlikely(__Pyx_InitGlobals() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #if PY_MAJOR_VERSION < 3 && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)
  if (__Pyx_init_sys_getdefaultencoding_params() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #endif
  if (__pyx_module_is_main_ga4py__gain__notimplemented) {
    if (__Pyx_SetAttrString(__pyx_m, "__name__", __pyx_n_s____main__) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  }
  /*--- Builtin init code ---*/
  if (unlikely(__Pyx_InitCachedBuiltins() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  /*--- Constants init code ---*/
  if (unlikely(__Pyx_InitCachedConstants() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  /*--- Global init code ---*/
  /*--- Variable export code ---*/
  /*--- Function export code ---*/
  /*--- Type init code ---*/
  /*--- Type import code ---*/
  __pyx_ptype_7cpython_4type_type = __Pyx_ImportType(__Pyx_BUILTIN_MODULE_NAME, "type", 
  #if CYTHON_COMPILING_IN_PYPY
  sizeof(PyTypeObject),
  #else
  sizeof(PyHeapTypeObject),
  #endif
  0); if (unlikely(!__pyx_ptype_7cpython_4type_type)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 9; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_5numpy_dtype = __Pyx_ImportType("numpy", "dtype", sizeof(PyArray_Descr), 0); if (unlikely(!__pyx_ptype_5numpy_dtype)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 155; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_5numpy_flatiter = __Pyx_ImportType("numpy", "flatiter", sizeof(PyArrayIterObject), 0); if (unlikely(!__pyx_ptype_5numpy_flatiter)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 165; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_5numpy_broadcast = __Pyx_ImportType("numpy", "broadcast", sizeof(PyArrayMultiIterObject), 0); if (unlikely(!__pyx_ptype_5numpy_broadcast)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 169; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_5numpy_ndarray = __Pyx_ImportType("numpy", "ndarray", sizeof(PyArrayObject), 0); if (unlikely(!__pyx_ptype_5numpy_ndarray)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 178; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_5numpy_ufunc = __Pyx_ImportType("numpy", "ufunc", sizeof(PyUFuncObject), 0); if (unlikely(!__pyx_ptype_5numpy_ufunc)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 861; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  /*--- Variable import code ---*/
  /*--- Function import code ---*/
  /*--- Execution code ---*/

  /* "ga4py/gain/notimplemented.pyx":2
 * 
 * import sys             # <<<<<<<<<<<<<<
 * 
 * import numpy as np
 */
  __pyx_t_1 = __Pyx_Import(((PyObject *)__pyx_n_s__sys), 0, -1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__sys, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":4
 * import sys
 * 
 * import numpy as np             # <<<<<<<<<<<<<<
 * cimport numpy as np
 * 
 */
  __pyx_t_1 = __Pyx_Import(((PyObject *)__pyx_n_s__numpy), 0, -1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__np, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":8
 * 
 * 
 * def docstring(obj, docstring):             # <<<<<<<<<<<<<<
 *     """docstring(obj, docstring)
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_1docstring, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__docstring, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":21
 * 
 * 
 * def add_newdoc(place, obj, doc):             # <<<<<<<<<<<<<<
 *     """Adds documentation to obj which is in module place.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_3add_newdoc, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 21; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__add_newdoc, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 21; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":40
 * 
 * 
 * def all(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Test whether all array elements along a given axis evaluate to True.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_5all, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 40; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__all, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 40; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":99
 * 
 * 
 * def allclose(a, b, rtol=1e-05, atol=1e-08):             # <<<<<<<<<<<<<<
 *     """Returns True if two arrays are element-wise equal within a tolerance.
 * 
 */
  __pyx_t_1 = PyFloat_FromDouble(1e-05); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 99; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_k_1 = __pyx_t_1;
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_1 = PyFloat_FromDouble(1e-08); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 99; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_k_2 = __pyx_t_1;
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_7allclose, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 99; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__allclose, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 99; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":153
 * 
 * 
 * def alltrue(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Check if all elements of input array are true.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_9alltrue, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 153; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__alltrue, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 153; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":164
 * 
 * 
 * def alterdot():             # <<<<<<<<<<<<<<
 *     """Change `dot`, `vdot`, and `innerproduct` to use accelerated BLAS functions.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_11alterdot, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 164; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__alterdot, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 164; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":187
 * 
 * 
 * def amax(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the maximum of an array or maximum along an axis.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_13amax, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 187; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__amax, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 187; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":244
 * 
 * 
 * def amin(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the minimum of an array or minimum along an axis.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_15amin, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 244; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__amin, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 244; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":301
 * 
 * 
 * def angle(z, deg=0):             # <<<<<<<<<<<<<<
 *     """Return the angle of the complex argument.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_17angle, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 301; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__angle, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 301; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":335
 * 
 * 
 * def any(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Test whether any array element along a given axis evaluates to True.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_19any, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 335; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__any, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 335; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":401
 * 
 * 
 * def append(arr, values, axis=None):             # <<<<<<<<<<<<<<
 *     """Append values to the end of an array.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_21append, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 401; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__append, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 401; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":449
 * 
 * 
 * def apply_along_axis(func1d, axis, arr):             # <<<<<<<<<<<<<<
 *     """Apply a function to 1-D slices along the given axis.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_23apply_along_axis, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 449; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__apply_along_axis, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 449; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":506
 * 
 * 
 * def apply_over_axes(func, a, axes):             # <<<<<<<<<<<<<<
 *     """Apply a function repeatedly over multiple axes.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_25apply_over_axes, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 506; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__apply_over_axes, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 506; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":560
 * 
 * 
 * def argmax(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Indices of the maximum values along an axis.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_27argmax, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 560; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__argmax, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 560; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":612
 * 
 * 
 * def argmin(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Return the indices of the minimum values along an axis.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_29argmin, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 612; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__argmin, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 612; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":624
 * 
 * 
 * def argsort(a, axis=-1, kind='quicksort', order=None):             # <<<<<<<<<<<<<<
 *     """Returns the indices that would sort an array.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_31argsort, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 624; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__argsort, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 624; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":704
 * 
 * 
 * def argwhere(a):             # <<<<<<<<<<<<<<
 *     """Find the indices of array elements that are non-zero, grouped by element.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_33argwhere, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 704; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__argwhere, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 704; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":744
 * 
 * 
 * def around(a, decimals=0, out=None):             # <<<<<<<<<<<<<<
 *     """Evenly round to the given number of decimals.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_35around, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 744; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__around, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 744; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":812
 * 
 * 
 * def array(object, dtype=None, copy=True, order=None, subok=False, ndmin=0):             # <<<<<<<<<<<<<<
 *     """array(object, dtype=None, copy=True, order=None, subok=False, ndmin=0)
 * 
 */
  __pyx_t_1 = __Pyx_PyBool_FromLong(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 812; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_k_3 = __pyx_t_1;
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 812; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_k_4 = __pyx_t_1;
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_37array, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 812; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__array, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 812; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":906
 * 
 * 
 * def array2string(a, max_line_width=None, precision=None, suppress_small=None, separator=' ', prefix='', style=repr):             # <<<<<<<<<<<<<<
 *     """Return a string representation of an array.
 * 
 */
  __pyx_t_1 = __Pyx_GetBuiltinName(__pyx_n_s__repr); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 906; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_k_7 = __pyx_t_1;
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_39array2string, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 906; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__array2string, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 906; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":955
 * 
 * 
 * def array_equal(a1, a2):             # <<<<<<<<<<<<<<
 *     """True if two arrays have the same shape and elements, False otherwise.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_41array_equal, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 955; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__array_equal, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 955; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":990
 * 
 * 
 * def array_equiv(a1, a2):             # <<<<<<<<<<<<<<
 *     """Returns True if input arrays are shape consistent and all elements equal.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_43array_equiv, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 990; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__array_equiv, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 990; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":1027
 * 
 * 
 * def array_repr(arr, max_line_width=None, precision=None, suppress_small=None):             # <<<<<<<<<<<<<<
 *     """Return the string representation of an array.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_45array_repr, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1027; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__array_repr, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1027; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":1071
 * 
 * 
 * def array_split(ary, indices_or_sections, axis=0):             # <<<<<<<<<<<<<<
 *     """Split an array into multiple sub-arrays of equal or near-equal size.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_47array_split, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1071; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__array_split, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1071; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":1093
 * 
 * 
 * def array_str(a, max_line_width=None, precision=None, suppress_small=None):             # <<<<<<<<<<<<<<
 *     """Return a string representation of the data in an array.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_49array_str, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1093; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__array_str, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1093; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":1129
 * 
 * 
 * def asanyarray(a, dtype=None, order=None):             # <<<<<<<<<<<<<<
 *     """Convert the input to an ndarray, but pass ndarray subclasses through.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_51asanyarray, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1129; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__asanyarray, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1129; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":1181
 * 
 * 
 * def asarray_chkfinite(a):             # <<<<<<<<<<<<<<
 *     """Convert the input to an array, checking for NaNs or Infs.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_53asarray_chkfinite, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1181; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__asarray_chkfinite, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1181; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":1243
 * 
 * 
 * def ascontiguousarray(a, dtype=None):             # <<<<<<<<<<<<<<
 *     """Return a contiguous array in memory (C order).
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_55ascontiguousarray, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1243; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__ascontiguousarray, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1243; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":1279
 * 
 * 
 * def asfarray(a, dtype=np.float64):             # <<<<<<<<<<<<<<
 *     """Return an array converted to a float type.
 * 
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s__np); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1279; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s__float64); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1279; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_k_8 = __pyx_t_2;
  __Pyx_GIVEREF(__pyx_t_2);
  __pyx_t_2 = 0;
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_57asfarray, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1279; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__asfarray, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1279; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":1308
 * 
 * 
 * def asfortranarray(a, dtype=None):             # <<<<<<<<<<<<<<
 *     """Return an array laid out in Fortran order in memory.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_59asfortranarray, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1308; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__asfortranarray, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1308; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":1344
 * 
 * 
 * def asmatrix(data, dtype=None):             # <<<<<<<<<<<<<<
 *     """Interpret the input as a matrix.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_61asmatrix, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1344; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__asmatrix, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1344; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":1376
 * 
 * 
 * def asscalar(a):             # <<<<<<<<<<<<<<
 *     """Convert an array of size 1 to its scalar equivalent.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_63asscalar, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1376; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__asscalar, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1376; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":1398
 * 
 * 
 * def atleast_1d():             # <<<<<<<<<<<<<<
 *     """Convert inputs to arrays with at least one dimension.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_65atleast_1d, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1398; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__atleast_1d, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1398; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":1439
 * 
 * 
 * def atleast_2d():             # <<<<<<<<<<<<<<
 *     """View inputs as arrays with at least two dimensions.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_67atleast_2d, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1439; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__atleast_2d, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1439; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":1478
 * 
 * 
 * def atleast_3d():             # <<<<<<<<<<<<<<
 *     """View inputs as arrays with at least three dimensions.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_69atleast_3d, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1478; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__atleast_3d, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1478; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":1529
 * 
 * 
 * def average(a, axis=None, weights=None, returned=False):             # <<<<<<<<<<<<<<
 *     """Compute the weighted average along the specified axis.
 * 
 */
  __pyx_t_2 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1529; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_k_9 = __pyx_t_2;
  __Pyx_GIVEREF(__pyx_t_2);
  __pyx_t_2 = 0;
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_71average, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1529; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__average, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1529; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":1604
 * 
 * 
 * def bartlett(M):             # <<<<<<<<<<<<<<
 *     """Return the Bartlett window.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_73bartlett, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1604; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__bartlett, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1604; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":1708
 * 
 * 
 * def base_repr(number, base=2, padding=0):             # <<<<<<<<<<<<<<
 *     """Return a string representation of a number in the given base system.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_75base_repr, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1708; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__base_repr, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1708; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":1748
 * 
 * 
 * def binary_repr(num, width=None):             # <<<<<<<<<<<<<<
 *     """Return the binary representation of the input number as a string.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_77binary_repr, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1748; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__binary_repr, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1748; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":1808
 * 
 * 
 * def bincount(x, weights=None, minlength=None):             # <<<<<<<<<<<<<<
 *     """bincount(x, weights=None, minlength=None)
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_79bincount, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1808; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__bincount, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1808; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":1883
 * 
 * 
 * def blackman(M):             # <<<<<<<<<<<<<<
 *     """Return the Blackman window.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_81blackman, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1883; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__blackman, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1883; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":1979
 * 
 * 
 * def bmat(obj, ldict=None, gdict=None):             # <<<<<<<<<<<<<<
 *     """Build a matrix object from a string, nested sequence, or array.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_83bmat, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1979; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__bmat, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1979; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":2026
 * 
 * 
 * def broadcast_arrays():             # <<<<<<<<<<<<<<
 *     """Broadcast any number of arrays against each other.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_85broadcast_arrays, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2026; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__broadcast_arrays, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2026; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":2067
 * 
 * 
 * def byte_bounds(a):             # <<<<<<<<<<<<<<
 *     """Returns pointers to the end-points of an array.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_87byte_bounds, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2067; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__byte_bounds, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2067; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":2099
 * 
 * 
 * def can_cast():             # <<<<<<<<<<<<<<
 *     """can_cast(from, totype, casting = 'safe')
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_89can_cast, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2099; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__can_cast, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2099; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":2202
 * 
 * 
 * def choose(a, choices, out=None, mode='raise'):             # <<<<<<<<<<<<<<
 *     """Construct an array from an index array and a set of arrays to choose from.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_91choose, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2202; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__choose, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2202; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":2323
 * 
 * 
 * def column_stack(tup):             # <<<<<<<<<<<<<<
 *     """Stack 1-D arrays as columns into a 2-D array.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_93column_stack, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2323; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__column_stack, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2323; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":2362
 * 
 * 
 * def common_type():             # <<<<<<<<<<<<<<
 *     """Return a scalar type which is common to the input arrays.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_95common_type, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2362; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__common_type, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2362; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":2400
 * 
 * 
 * def compare_chararrays():             # <<<<<<<<<<<<<<
 *     """
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_97compare_chararrays, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2400; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__compare_chararrays, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2400; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":2408
 * 
 * 
 * def compress(condition, a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return selected slices of an array along given axis.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_99compress, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2408; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__compress, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2408; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":2469
 * 
 * 
 * def concatenate():             # <<<<<<<<<<<<<<
 *     """concatenate((a1, a2, ...), axis=0)
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_101concatenate, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2469; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__concatenate, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2469; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":2545
 * 
 * 
 * def convolve(a, v, mode='full'):             # <<<<<<<<<<<<<<
 *     """Returns the discrete, linear convolution of two one-dimensional sequences.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_103convolve, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2545; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__convolve, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2545; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":2630
 * 
 * 
 * def copy(a):             # <<<<<<<<<<<<<<
 *     """Return an array copy of the given object.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_105copy, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2630; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__copy, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2630; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":2669
 * 
 * 
 * def corrcoef(x, y=None, rowvar=1, bias=0, ddof=None):             # <<<<<<<<<<<<<<
 *     """Return correlation coefficients.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_107corrcoef, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2669; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__corrcoef, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2669; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":2718
 * 
 * 
 * def correlate(a, v, mode='valid', old_behavior=False):             # <<<<<<<<<<<<<<
 *     """Cross-correlation of two 1-dimensional sequences.
 * 
 */
  __pyx_t_2 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2718; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_k_10 = __pyx_t_2;
  __Pyx_GIVEREF(__pyx_t_2);
  __pyx_t_2 = 0;
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_109correlate, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2718; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__correlate, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2718; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":2758
 * 
 * 
 * def count_nonzero(a):             # <<<<<<<<<<<<<<
 *     """count_nonzero(a)
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_111count_nonzero, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2758; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__count_nonzero, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2758; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":2790
 * 
 * 
 * def cov(m, y=None, rowvar=1, bias=0, ddof=None):             # <<<<<<<<<<<<<<
 *     """Estimate a covariance matrix, given data.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_113cov, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2790; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__cov, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2790; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":2871
 * 
 * 
 * def cross(a, b, axisa=-1, axisb=-1, axisc=-1, axis=None):             # <<<<<<<<<<<<<<
 *     """Return the cross product of two (arrays of) vectors.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_115cross, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2871; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__cross, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2871; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":2979
 * 
 * 
 * def cumprod(a, axis=None, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the cumulative product of elements along a given axis.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_117cumprod, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2979; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__cumprod, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2979; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":3041
 * 
 * 
 * def cumproduct(a, axis=None, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the cumulative product over the given axis.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_119cumproduct, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3041; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__cumproduct, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3041; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":3053
 * 
 * 
 * def cumsum(a, axis=None, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the cumulative sum of the elements along a given axis.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_121cumsum, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3053; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__cumsum, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3053; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":3117
 * 
 * 
 * def datetime_data(dtype):             # <<<<<<<<<<<<<<
 *     """Return (unit, numerator, denominator, events) from a datetime dtype
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_123datetime_data, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3117; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__datetime_data, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3117; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":3124
 * 
 * 
 * def delete(arr, obj, axis=None):             # <<<<<<<<<<<<<<
 *     """Return a new array with sub-arrays along an axis deleted.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_125delete, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3124; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__delete, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3124; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":3171
 * 
 * 
 * def deprecate():             # <<<<<<<<<<<<<<
 *     """Issues a DeprecationWarning, adds warning to `old_name`'s
 *     docstring, rebinds ``old_name.__name__`` and returns the new
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_127deprecate, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3171; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__deprecate, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3171; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":3214
 * 
 * 
 * def deprecate_with_doc(msg):             # <<<<<<<<<<<<<<
 *     """message
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_129deprecate_with_doc, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3214; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__deprecate_with_doc, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3214; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":3221
 * 
 * 
 * def diag_indices(n, ndim=2):             # <<<<<<<<<<<<<<
 *     """Return the indices to access the main diagonal of an array.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_131diag_indices, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3221; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__diag_indices, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3221; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":3287
 * 
 * 
 * def diag_indices_from(arr):             # <<<<<<<<<<<<<<
 *     """Return the indices to access the main diagonal of an n-dimensional array.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_133diag_indices_from, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3287; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__diag_indices_from, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3287; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":3308
 * 
 * 
 * def diagflat(v, k=0):             # <<<<<<<<<<<<<<
 *     """Create a two-dimensional array with the flattened input as a diagonal.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_135diagflat, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3308; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__diagflat, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3308; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":3349
 * 
 * 
 * def diff(a, n=1, axis=-1):             # <<<<<<<<<<<<<<
 *     """Calculate the n-th order discrete difference along given axis.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_137diff, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3349; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__diff, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3349; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":3394
 * 
 * 
 * def digitize(x, bins):             # <<<<<<<<<<<<<<
 *     """digitize(x, bins)
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_139digitize, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3394; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__digitize, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3394; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":3453
 * 
 * 
 * def disp(mesg, device=None, linefeed=True):             # <<<<<<<<<<<<<<
 *     """Display a message on a device.
 * 
 */
  __pyx_t_2 = __Pyx_PyBool_FromLong(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3453; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_k_11 = __pyx_t_2;
  __Pyx_GIVEREF(__pyx_t_2);
  __pyx_t_2 = 0;
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_141disp, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3453; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__disp, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3453; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":3487
 * 
 * 
 * def dsplit(ary, indices_or_sections):             # <<<<<<<<<<<<<<
 *     """Split array into multiple sub-arrays along the 3rd axis (depth).
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_143dsplit, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3487; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__dsplit, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3487; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":3530
 * 
 * 
 * def dstack(tup):             # <<<<<<<<<<<<<<
 *     """Stack arrays in sequence depth wise (along third axis).
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_145dstack, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3530; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__dstack, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3530; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":3580
 * 
 * 
 * def ediff1d(ary, to_end=None, to_begin=None):             # <<<<<<<<<<<<<<
 *     """The differences between consecutive elements of an array.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_147ediff1d, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3580; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__ediff1d, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3580; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":3625
 * 
 * 
 * def einsum():             # <<<<<<<<<<<<<<
 *     """einsum(subscripts, *operands, out=None, dtype=None, order='K', casting='safe')
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_149einsum, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3625; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__einsum, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3625; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":3817
 * 
 * 
 * def expand_dims(a, axis):             # <<<<<<<<<<<<<<
 *     """Expand the shape of an array.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_151expand_dims, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3817; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__expand_dims, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3817; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":3870
 * 
 * 
 * def extract(condition, arr):             # <<<<<<<<<<<<<<
 *     """Return the elements of an array that satisfy some condition.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_153extract, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3870; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__extract, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3870; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":3913
 * 
 * 
 * def _fastCopyAndTranspose(a):             # <<<<<<<<<<<<<<
 *     """_fastCopyAndTranspose(a)
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_155_fastCopyAndTranspose, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3913; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_212, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3913; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":3921
 * 
 * 
 * def fill_diagonal(a, val):             # <<<<<<<<<<<<<<
 *     """Fill the main diagonal of the given array of any dimensionality.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_157fill_diagonal, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3921; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__fill_diagonal, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3921; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":3982
 * 
 * 
 * def find_common_type(array_types, scalar_types):             # <<<<<<<<<<<<<<
 *     """Determine common type following standard coercion rules.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_159find_common_type, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3982; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__find_common_type, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3982; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":4035
 * 
 * 
 * def fix(x, y=None):             # <<<<<<<<<<<<<<
 *     """Round to nearest integer towards zero.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_161fix, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4035; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__fix, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4035; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":4071
 * 
 * 
 * def flatnonzero(a):             # <<<<<<<<<<<<<<
 *     """Return indices that are non-zero in the flattened version of a.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_163flatnonzero, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4071; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__flatnonzero, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4071; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":4110
 * 
 * 
 * def fliplr(m):             # <<<<<<<<<<<<<<
 *     """Flip array in the left/right direction.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_165fliplr, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4110; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__fliplr, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4110; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":4157
 * 
 * 
 * def flipud(m):             # <<<<<<<<<<<<<<
 *     """Flip array in the up/down direction.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_167flipud, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4157; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__flipud, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4157; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":4207
 * 
 * 
 * def frombuffer(buffer, dtype=float, count=-1, offset=0):             # <<<<<<<<<<<<<<
 *     """frombuffer(buffer, dtype=float, count=-1, offset=0)
 * 
 */
  __Pyx_INCREF(((PyObject *)((PyObject*)(&PyFloat_Type))));
  __pyx_k_12 = ((PyObject *)((PyObject*)(&PyFloat_Type)));
  __Pyx_GIVEREF(((PyObject*)(&PyFloat_Type)));
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_169frombuffer, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4207; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__frombuffer, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4207; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":4247
 * 
 * 
 * def fromfile(file, dtype=float, count=-1, sep=''):             # <<<<<<<<<<<<<<
 *     """fromfile(file, dtype=float, count=-1, sep='')
 * 
 */
  __Pyx_INCREF(((PyObject *)((PyObject*)(&PyFloat_Type))));
  __pyx_k_13 = ((PyObject *)((PyObject*)(&PyFloat_Type)));
  __Pyx_GIVEREF(((PyObject*)(&PyFloat_Type)));
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_171fromfile, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4247; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__fromfile, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4247; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":4324
 * 
 * 
 * def fromiter(iterable, dtype, count=-1):             # <<<<<<<<<<<<<<
 *     """fromiter(iterable, dtype, count=-1)
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_173fromiter, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4324; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__fromiter, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4324; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":4360
 * 
 * 
 * def frompyfunc(func, nin, nout):             # <<<<<<<<<<<<<<
 *     """frompyfunc(func, nin, nout)
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_175frompyfunc, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4360; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__frompyfunc, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4360; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":4402
 * 
 * 
 * def fromregex(file, regexp, dtype):             # <<<<<<<<<<<<<<
 *     """Construct an array from a text file, using regular expression parsing.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_177fromregex, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4402; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__fromregex, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4402; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":4459
 * 
 * 
 * def fromstring(string, dtype=float, count=-1, sep=''):             # <<<<<<<<<<<<<<
 *     """fromstring(string, dtype=float, count=-1, sep='')
 * 
 */
  __Pyx_INCREF(((PyObject *)((PyObject*)(&PyFloat_Type))));
  __pyx_k_14 = ((PyObject *)((PyObject*)(&PyFloat_Type)));
  __Pyx_GIVEREF(((PyObject*)(&PyFloat_Type)));
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_179fromstring, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4459; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__fromstring, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4459; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":4513
 * 
 * 
 * def fv(rate, nper, pmt, pv, when='end'):             # <<<<<<<<<<<<<<
 *     """Compute the future value.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_181fv, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4513; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__fv, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4513; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":4596
 * 
 * 
 * def genfromtxt(fname, dtype=float, comments='#', delimiter=None, skiprows=0, skip_header=0, skip_footer=0, converters=None, missing='', missing_values=None, filling_values=None, usecols=None, names=None, excludelist=None, deletechars=None, replace_space='_', autostrip=False, case_sensitive=True, defaultfmt='f%i', unpack=None, usemask=False, loose=True, invalid_raise=True):             # <<<<<<<<<<<<<<
 *     """Load data from a text file, with missing values handled as specified.
 * 
 */
  __Pyx_INCREF(((PyObject *)((PyObject*)(&PyFloat_Type))));
  __pyx_k_15 = ((PyObject *)((PyObject*)(&PyFloat_Type)));
  __Pyx_GIVEREF(((PyObject*)(&PyFloat_Type)));
  __pyx_t_2 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4596; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_k_17 = __pyx_t_2;
  __Pyx_GIVEREF(__pyx_t_2);
  __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_PyBool_FromLong(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4596; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_k_18 = __pyx_t_2;
  __Pyx_GIVEREF(__pyx_t_2);
  __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4596; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_k_20 = __pyx_t_2;
  __Pyx_GIVEREF(__pyx_t_2);
  __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_PyBool_FromLong(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4596; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_k_21 = __pyx_t_2;
  __Pyx_GIVEREF(__pyx_t_2);
  __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_PyBool_FromLong(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4596; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_k_22 = __pyx_t_2;
  __Pyx_GIVEREF(__pyx_t_2);
  __pyx_t_2 = 0;
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_183genfromtxt, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4596; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__genfromtxt, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4596; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":4734
 * 
 * 
 * def get_array_wrap():             # <<<<<<<<<<<<<<
 *     """Find the wrapper for the array with the highest priority.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_185get_array_wrap, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4734; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__get_array_wrap, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4734; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":4743
 * 
 * 
 * def get_include():             # <<<<<<<<<<<<<<
 *     """Return the directory that contains the NumPy \*.h header files.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_187get_include, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4743; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__get_include, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4743; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":4764
 * 
 * 
 * def get_numarray_include(type=None):             # <<<<<<<<<<<<<<
 *     """Return the directory that contains the numarray \*.h header files.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_189get_numarray_include, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4764; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_245, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4764; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":4800
 * 
 * 
 * def get_printoptions():             # <<<<<<<<<<<<<<
 *     """Return the current print options.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_191get_printoptions, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4800; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__get_printoptions, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4800; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":4826
 * 
 * 
 * def getbuffer():             # <<<<<<<<<<<<<<
 *     """getbuffer(obj [,offset[, size]])
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_193getbuffer, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4826; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__getbuffer, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4826; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":4862
 * 
 * 
 * def getbufsize():             # <<<<<<<<<<<<<<
 *     """Return the size of the buffer used in ufuncs.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_195getbufsize, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4862; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__getbufsize, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4862; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":4869
 * 
 * 
 * def geterr():             # <<<<<<<<<<<<<<
 *     """Get the current way of handling floating-point errors.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_197geterr, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4869; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__geterr, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4869; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":4908
 * 
 * 
 * def geterrcall():             # <<<<<<<<<<<<<<
 *     """Return the current callback function used on floating-point errors.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_199geterrcall, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4908; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__geterrcall, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4908; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":4952
 * 
 * 
 * def geterrobj():             # <<<<<<<<<<<<<<
 *     """geterrobj()
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_201geterrobj, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4952; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__geterrobj, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4952; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":5018
 * 
 * 
 * def gradient(f):             # <<<<<<<<<<<<<<
 *     """Return the gradient of an N-dimensional array.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_203gradient, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5018; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__gradient, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5018; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":5058
 * 
 * 
 * def hamming(M):             # <<<<<<<<<<<<<<
 *     """Return the Hamming window.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_205hamming, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5058; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__hamming, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5058; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":5152
 * 
 * 
 * def hanning(M):             # <<<<<<<<<<<<<<
 *     """Return the Hanning window.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_207hanning, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5152; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__hanning, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5152; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":5248
 * 
 * 
 * def histogram(a, bins=10, range=None, normed=False, weights=None, density=None):             # <<<<<<<<<<<<<<
 *     """Compute the histogram of a set of data.
 * 
 */
  __pyx_t_2 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5248; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_k_23 = __pyx_t_2;
  __Pyx_GIVEREF(__pyx_t_2);
  __pyx_t_2 = 0;
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_209histogram, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5248; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__histogram, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5248; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":5333
 * 
 * 
 * def histogram2d(x, y, bins=10, range=None, normed=False, weights=None):             # <<<<<<<<<<<<<<
 *     """Compute the bi-dimensional histogram of two data samples.
 * 
 */
  __pyx_t_2 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5333; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_k_24 = __pyx_t_2;
  __Pyx_GIVEREF(__pyx_t_2);
  __pyx_t_2 = 0;
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_211histogram2d, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5333; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__histogram2d, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5333; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":5418
 * 
 * 
 * def histogramdd(sample, bins=10, range=None, normed=False, weights=None):             # <<<<<<<<<<<<<<
 *     """Compute the multidimensional histogram of some data.
 * 
 */
  __pyx_t_2 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5418; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_k_25 = __pyx_t_2;
  __Pyx_GIVEREF(__pyx_t_2);
  __pyx_t_2 = 0;
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_213histogramdd, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5418; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__histogramdd, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5418; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":5471
 * 
 * 
 * def hsplit(ary, indices_or_sections):             # <<<<<<<<<<<<<<
 *     """Split an array into multiple sub-arrays horizontally (column-wise).
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_215hsplit, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5471; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__hsplit, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5471; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":5528
 * 
 * 
 * def hstack(tup):             # <<<<<<<<<<<<<<
 *     """Stack arrays in sequence horizontally (column wise).
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_217hstack, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5528; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__hstack, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5528; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":5572
 * 
 * 
 * def i0(x):             # <<<<<<<<<<<<<<
 *     """Modified Bessel function of the first kind, order 0.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_219i0, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5572; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__i0, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5572; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":5628
 * 
 * 
 * def imag(val):             # <<<<<<<<<<<<<<
 *     """Return the imaginary part of the elements of the array.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_221imag, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5628; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__imag, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5628; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":5659
 * 
 * 
 * def in1d(ar1, ar2, assume_unique=False):             # <<<<<<<<<<<<<<
 *     """Test whether each element of a 1D array is also present in a second array.
 * 
 */
  __pyx_t_2 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5659; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_k_26 = __pyx_t_2;
  __Pyx_GIVEREF(__pyx_t_2);
  __pyx_t_2 = 0;
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_223in1d, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5659; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__in1d, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5659; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":5707
 * 
 * 
 * def indices(dimensions, dtype=int):             # <<<<<<<<<<<<<<
 *     """Return an array representing the indices of a grid.
 * 
 */
  __Pyx_INCREF(((PyObject *)((PyObject*)(&PyInt_Type))));
  __pyx_k_27 = ((PyObject *)((PyObject*)(&PyInt_Type)));
  __Pyx_GIVEREF(((PyObject*)(&PyInt_Type)));
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_225indices, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5707; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__indices, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5707; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":5769
 * 
 * 
 * def info(object=None, maxwidth=76, output=sys.stdout, toplevel='numpy'):             # <<<<<<<<<<<<<<
 *     """Get help information for a function, class, or module.
 * 
 */
  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s__sys); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5769; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s__stdout); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5769; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_k_28 = __pyx_t_1;
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_227info, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5769; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__info, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5769; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":5819
 * 
 * 
 * def inner(a, b):             # <<<<<<<<<<<<<<
 *     """inner(a, b)
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_229inner, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5819; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__inner, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5819; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":5895
 * 
 * 
 * def insert(arr, obj, values, axis=None):             # <<<<<<<<<<<<<<
 *     """Insert values along the given axis before the given indices.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_231insert, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5895; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__insert, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5895; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":5960
 * 
 * 
 * def int_asbuffer():             # <<<<<<<<<<<<<<
 *     """
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_233int_asbuffer, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5960; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__int_asbuffer, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5960; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":5968
 * 
 * 
 * def interp(x, xp, fp, left=None, right=None):             # <<<<<<<<<<<<<<
 *     """One-dimensional linear interpolation.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_235interp, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5968; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__interp, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5968; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":6039
 * 
 * 
 * def intersect1d(ar1, ar2, assume_unique=False):             # <<<<<<<<<<<<<<
 *     """Find the intersection of two arrays.
 * 
 */
  __pyx_t_1 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6039; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_k_29 = __pyx_t_1;
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_237intersect1d, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6039; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__intersect1d, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6039; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":6071
 * 
 * 
 * def ipmt(rate, per, nper, pv, fv=0.0, when='end'):             # <<<<<<<<<<<<<<
 *     """Not implemented. Compute the payment portion for loan interest.
 * 
 */
  __pyx_t_1 = PyFloat_FromDouble(0.0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6071; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_k_30 = __pyx_t_1;
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_239ipmt, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6071; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__ipmt, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6071; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":6113
 * 
 * 
 * def irr(values):             # <<<<<<<<<<<<<<
 *     """Return the Internal Rate of Return (IRR).
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_241irr, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6113; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__irr, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6113; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":6168
 * 
 * 
 * def iscomplex(x):             # <<<<<<<<<<<<<<
 *     """Returns a bool array, where True if input element is complex.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_243iscomplex, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6168; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__iscomplex, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6168; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":6199
 * 
 * 
 * def iscomplexobj(x):             # <<<<<<<<<<<<<<
 *     """Return True if x is a complex type or an array of complex numbers.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_245iscomplexobj, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6199; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__iscomplexobj, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6199; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":6233
 * 
 * 
 * def isfortran(a):             # <<<<<<<<<<<<<<
 *     """Returns True if array is arranged in Fortran-order in memory
 *     and dimension > 1.
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_247isfortran, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6233; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__isfortran, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6233; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":6290
 * 
 * 
 * def isneginf(x, y=None):             # <<<<<<<<<<<<<<
 *     """Test element-wise for negative infinity, return result as bool array.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_249isneginf, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6290; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__isneginf, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6290; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":6349
 * 
 * 
 * def isposinf(x, y=None):             # <<<<<<<<<<<<<<
 *     """Test element-wise for positive infinity, return result as bool array.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_251isposinf, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6349; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__isposinf, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6349; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":6407
 * 
 * 
 * def isreal(x):             # <<<<<<<<<<<<<<
 *     """Returns a bool array, where True if input element is real.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_253isreal, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6407; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__isreal, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6407; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":6437
 * 
 * 
 * def isrealobj(x):             # <<<<<<<<<<<<<<
 *     """Return True if x is a not complex type or an array of complex numbers.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_255isrealobj, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6437; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__isrealobj, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6437; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":6471
 * 
 * 
 * def isscalar(num):             # <<<<<<<<<<<<<<
 *     """Returns True if the type of `num` is a scalar type.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_257isscalar, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6471; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__isscalar, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6471; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":6497
 * 
 * 
 * def issctype(rep):             # <<<<<<<<<<<<<<
 *     """Determines whether the given object represents a scalar data-type.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_259issctype, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6497; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__issctype, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6497; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":6533
 * 
 * 
 * def issubclass_(arg1, arg2):             # <<<<<<<<<<<<<<
 *     """Determine if a class is a subclass of a second class.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_261issubclass_, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6533; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__issubclass_, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6533; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":6568
 * 
 * 
 * def issubdtype(arg1, arg2):             # <<<<<<<<<<<<<<
 *     """Returns True if first argument is a typecode lower/equal in type hierarchy.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_263issubdtype, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6568; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__issubdtype, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6568; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":6596
 * 
 * 
 * def issubsctype(arg1, arg2):             # <<<<<<<<<<<<<<
 *     """Determine if the first argument is a subclass of the second argument.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_265issubsctype, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6596; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__issubsctype, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6596; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":6626
 * 
 * 
 * def iterable(y):             # <<<<<<<<<<<<<<
 *     """Check whether or not an object can be iterated over.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_267iterable, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6626; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__iterable, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6626; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":6652
 * 
 * 
 * def ix_():             # <<<<<<<<<<<<<<
 *     """Construct an open mesh from multiple sequences.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_269ix_, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6652; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__ix_, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6652; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":6698
 * 
 * 
 * def kaiser(M, beta):             # <<<<<<<<<<<<<<
 *     """Return the Kaiser window.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_271kaiser, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6698; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__kaiser, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6698; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":6825
 * 
 * 
 * def kron(a, b):             # <<<<<<<<<<<<<<
 *     """Kronecker product of two arrays.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_273kron, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6825; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__kron, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6825; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":6897
 * 
 * 
 * def lexsort(keys, axis=-1):             # <<<<<<<<<<<<<<
 *     """lexsort(keys, axis=-1)
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_275lexsort, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6897; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__lexsort, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6897; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":6975
 * 
 * 
 * def load(file, mmap_mode=None):             # <<<<<<<<<<<<<<
 *     """Load a pickled, ``.npy``, or ``.npz`` binary file.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_277load, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6975; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__load, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6975; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":7037
 * 
 * 
 * def loads():             # <<<<<<<<<<<<<<
 *     """loads(string) -- Load a pickle from the given string
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_279loads, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7037; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__loads, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7037; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":7045
 * 
 * 
 * def loadtxt(fname, dtype=float, comments='#', delimiter=None, converters=None, skiprows=0, usecols=None, unpack=False, ndmin=0):             # <<<<<<<<<<<<<<
 *     """Load data from a text file.
 * 
 */
  __Pyx_INCREF(((PyObject *)((PyObject*)(&PyFloat_Type))));
  __pyx_k_31 = ((PyObject *)((PyObject*)(&PyFloat_Type)));
  __Pyx_GIVEREF(((PyObject*)(&PyFloat_Type)));
  __pyx_t_1 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7045; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_k_32 = __pyx_t_1;
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_281loadtxt, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7045; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__loadtxt, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7045; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":7132
 * 
 * 
 * def lookfor(what, module=None, import_modules=True, regenerate=False, output=None):             # <<<<<<<<<<<<<<
 *     """Do a keyword search on docstrings.
 * 
 */
  __pyx_t_1 = __Pyx_PyBool_FromLong(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7132; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_k_33 = __pyx_t_1;
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7132; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_k_34 = __pyx_t_1;
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_283lookfor, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7132; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__lookfor, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7132; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":7179
 * 
 * 
 * def mafromtxt(fname):             # <<<<<<<<<<<<<<
 *     """Load ASCII data stored in a text file and return a masked array.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_285mafromtxt, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7179; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__mafromtxt, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7179; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":7192
 * 
 * 
 * def mask_indices(n, mask_func, k=0):             # <<<<<<<<<<<<<<
 *     """Return the indices to access (n, n) arrays, given a masking function.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_287mask_indices, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7192; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__mask_indices, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7192; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":7259
 * 
 * 
 * def mat(data, dtype=None):             # <<<<<<<<<<<<<<
 *     """Interpret the input as a matrix.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_289mat, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7259; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__mat, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7259; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":7291
 * 
 * 
 * def max(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the maximum of an array or maximum along an axis.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_291max, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7291; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__max, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7291; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":7348
 * 
 * 
 * def maximum_sctype(t):             # <<<<<<<<<<<<<<
 *     """Return the scalar type of highest precision of the same kind as the input.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_293maximum_sctype, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7348; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__maximum_sctype, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7348; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":7388
 * 
 * 
 * def may_share_memory(a, b):             # <<<<<<<<<<<<<<
 *     """Determine if two arrays can share memory
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_295may_share_memory, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7388; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__may_share_memory, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7388; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":7414
 * 
 * 
 * def mean(a, axis=None, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Compute the arithmetic mean along the specified axis.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_297mean, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7414; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__mean, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7414; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":7487
 * 
 * 
 * def median(a, axis=None, out=None, overwrite_input=False):             # <<<<<<<<<<<<<<
 *     """Compute the median along the specified axis.
 * 
 */
  __pyx_t_1 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7487; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_k_35 = __pyx_t_1;
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_299median, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7487; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__median, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7487; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":7563
 * 
 * 
 * def meshgrid(x, y):             # <<<<<<<<<<<<<<
 *     """Return coordinate matrices from two coordinate vectors.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_301meshgrid, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7563; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__meshgrid, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7563; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":7611
 * 
 * 
 * def min(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the minimum of an array or minimum along an axis.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_303min, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7611; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__min, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7611; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":7668
 * 
 * 
 * def min_scalar_type(a):             # <<<<<<<<<<<<<<
 *     """min_scalar_type(a)
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_305min_scalar_type, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7668; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__min_scalar_type, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7668; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":7718
 * 
 * 
 * def mintypecode(typechars, typeset='GDFgdf', default='d'):             # <<<<<<<<<<<<<<
 *     """Return the character for the minimum-size type to which given types can
 *     be safely cast.
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_307mintypecode, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7718; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__mintypecode, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7718; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":7763
 * 
 * 
 * def mirr(values, finance_rate, reinvest_rate):             # <<<<<<<<<<<<<<
 *     """Modified internal rate of return.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_309mirr, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7763; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__mirr, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7763; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":7785
 * 
 * 
 * def msort(a):             # <<<<<<<<<<<<<<
 *     """Return a copy of an array sorted along the first axis.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_311msort, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7785; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__msort, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7785; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":7810
 * 
 * 
 * def nan_to_num(x):             # <<<<<<<<<<<<<<
 *     """Replace nan with zero and inf with finite numbers.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_313nan_to_num, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7810; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__nan_to_num, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7810; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":7857
 * 
 * 
 * def nanargmax(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Return indices of the maximum values over an axis, ignoring NaNs.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_315nanargmax, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7857; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__nanargmax, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7857; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":7892
 * 
 * 
 * def nanargmin(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Return indices of the minimum values over an axis, ignoring NaNs.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_317nanargmin, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7892; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__nanargmin, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7892; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":7927
 * 
 * 
 * def nanmax(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Return the maximum of an array or maximum along an axis ignoring any NaNs.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_319nanmax, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7927; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__nanmax, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7927; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":7984
 * 
 * 
 * def nanmin(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Return the minimum of an array or minimum along an axis ignoring any NaNs.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_321nanmin, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7984; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__nanmin, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7984; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":8039
 * 
 * 
 * def nansum(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Return the sum of array elements over a given axis treating
 *     Not a Numbers (NaNs) as zero.
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_323nansum, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8039; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__nansum, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8039; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":8107
 * 
 * 
 * def ndfromtxt(fname):             # <<<<<<<<<<<<<<
 *     """Load ASCII data stored in a file and return it as a single array.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_325ndfromtxt, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8107; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__ndfromtxt, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8107; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":8121
 * 
 * 
 * def ndim(a):             # <<<<<<<<<<<<<<
 *     """Return the number of dimensions of an array.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_327ndim, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8121; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__ndim, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8121; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":8154
 * 
 * 
 * def nested_iters():             # <<<<<<<<<<<<<<
 *     """
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_329nested_iters, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8154; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__nested_iters, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8154; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":8162
 * 
 * 
 * def newbuffer(size):             # <<<<<<<<<<<<<<
 *     """newbuffer(size)
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_331newbuffer, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8162; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__newbuffer, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8162; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":8172
 * 
 * 
 * def nonzero(a):             # <<<<<<<<<<<<<<
 *     """Return the indices of the elements that are non-zero.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_333nonzero, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8172; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__nonzero, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8172; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":8247
 * 
 * 
 * def nper(rate, pmt, pv, fv=0, when='end'):             # <<<<<<<<<<<<<<
 *     """Compute the number of periodic payments.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_335nper, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8247; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__nper, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8247; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":8298
 * 
 * 
 * def npv(rate, values):             # <<<<<<<<<<<<<<
 *     """Returns the NPV (Net Present Value) of a cash flow series.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_337npv, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8298; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__npv, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8298; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":8342
 * 
 * 
 * def obj2sctype(rep, default=None):             # <<<<<<<<<<<<<<
 *     """Return the scalar dtype or NumPy equivalent of Python type of an object.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_339obj2sctype, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8342; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__obj2sctype, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8342; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":8383
 * 
 * 
 * def outer(a, b):             # <<<<<<<<<<<<<<
 *     """Compute the outer product of two vectors.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_341outer, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8383; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__outer, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8383; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":8454
 * 
 * 
 * def packbits(myarray, axis=None):             # <<<<<<<<<<<<<<
 *     """packbits(myarray, axis=None)
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_343packbits, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8454; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__packbits, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8454; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":8500
 * 
 * 
 * def percentile(a, q, axis=None, out=None, overwrite_input=False):             # <<<<<<<<<<<<<<
 *     """Compute the qth percentile of the data along the specified axis.
 * 
 */
  __pyx_t_1 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8500; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_k_36 = __pyx_t_1;
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_345percentile, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8500; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__percentile, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8500; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":8580
 * 
 * 
 * def piecewise(x, condlist, funclist):             # <<<<<<<<<<<<<<
 *     """Evaluate a piecewise-defined function.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_347piecewise, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8580; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__piecewise, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8580; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":8663
 * 
 * 
 * def pkgload():             # <<<<<<<<<<<<<<
 *     """Load one or more packages into parent package top-level namespace.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_349pkgload, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8663; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__pkgload, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8663; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":8702
 * 
 * 
 * def place(arr, mask, vals):             # <<<<<<<<<<<<<<
 *     """Change elements of an array based on conditional and input values.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_351place, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8702; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__place, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8702; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":8738
 * 
 * 
 * def pmt(rate, nper, pv, fv=0, when='end'):             # <<<<<<<<<<<<<<
 *     """Compute the payment against loan principal plus interest.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_353pmt, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8738; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__pmt, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8738; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":8823
 * 
 * 
 * def poly(seq_of_zeros):             # <<<<<<<<<<<<<<
 *     """Find the coefficients of a polynomial with the given sequence of roots.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_355poly, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8823; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__poly, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8823; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":8917
 * 
 * 
 * def polyadd(a1, a2):             # <<<<<<<<<<<<<<
 *     """Find the sum of two polynomials.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_357polyadd, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8917; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__polyadd, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8917; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":8963
 * 
 * 
 * def polyder(p, m=1):             # <<<<<<<<<<<<<<
 *     """Return the derivative of the specified order of a polynomial.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_359polyder, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8963; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__polyder, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8963; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":9017
 * 
 * 
 * def polydiv(u, v):             # <<<<<<<<<<<<<<
 *     """Returns the quotient and remainder of polynomial division.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_361polydiv, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9017; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__polydiv, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9017; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":9064
 * 
 * 
 * def polyfit(x, y, deg, rcond=None, full=False):             # <<<<<<<<<<<<<<
 *     """Least squares polynomial fit.
 * 
 */
  __pyx_t_1 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9064; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_k_37 = __pyx_t_1;
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_363polyfit, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9064; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__polyfit, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9064; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":9200
 * 
 * 
 * def polyint(p, m=1, k=None):             # <<<<<<<<<<<<<<
 *     """Return an antiderivative (indefinite integral) of a polynomial.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_365polyint, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9200; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__polyint, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9200; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":9269
 * 
 * 
 * def polymul(a1, a2):             # <<<<<<<<<<<<<<
 *     """Find the product of two polynomials.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_367polymul, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9269; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__polymul, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9269; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":9318
 * 
 * 
 * def polysub(a1, a2):             # <<<<<<<<<<<<<<
 *     """Difference (subtraction) of two polynomials.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_369polysub, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9318; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__polysub, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9318; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":9350
 * 
 * 
 * def polyval(p, x):             # <<<<<<<<<<<<<<
 *     """Evaluate a polynomial at specific values.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_371polyval, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9350; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__polyval, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9350; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":9411
 * 
 * 
 * def ppmt(rate, per, nper, pv, fv=0.0, when='end'):             # <<<<<<<<<<<<<<
 *     """Not implemented. Compute the payment against loan principal.
 * 
 */
  __pyx_t_1 = PyFloat_FromDouble(0.0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9411; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_k_38 = __pyx_t_1;
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_373ppmt, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9411; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__ppmt, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9411; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":9438
 * 
 * 
 * def prod(a, axis=None, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the product of array elements over a given axis.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_375prod, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9438; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__prod, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9438; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":9514
 * 
 * 
 * def product(a, axis=None, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the product of array elements over a given axis.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_377product, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9514; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__product, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9514; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":9525
 * 
 * 
 * def promote_types(type1, type2):             # <<<<<<<<<<<<<<
 *     """promote_types(type1, type2)
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_379promote_types, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9525; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__promote_types, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9525; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":9575
 * 
 * 
 * def ptp(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Range of values (maximum - minimum) along an axis.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_381ptp, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9575; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__ptp, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9575; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":9615
 * 
 * 
 * def put(a, ind, v, mode='raise'):             # <<<<<<<<<<<<<<
 *     """Replaces specified elements of an array with given values.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_383put, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9615; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__put, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9615; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":9665
 * 
 * 
 * def putmask(a, mask, values):             # <<<<<<<<<<<<<<
 *     """putmask(a, mask, values)
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_385putmask, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9665; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__putmask, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9665; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":9709
 * 
 * 
 * def pv(rate, nper, pmt, fv=0.0, when='end'):             # <<<<<<<<<<<<<<
 *     """Compute the present value.
 * 
 */
  __pyx_t_1 = PyFloat_FromDouble(0.0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9709; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_k_39 = __pyx_t_1;
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_387pv, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9709; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__pv, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9709; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":9797
 * 
 * 
 * def rank(a):             # <<<<<<<<<<<<<<
 *     """Return the number of dimensions of an array.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_389rank, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9797; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__rank, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9797; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":9839
 * 
 * 
 * def rate(nper, pmt, pv, fv, when='end', guess=0.1, tol=1e-06, maxiter=100):             # <<<<<<<<<<<<<<
 *     """Compute the rate of interest per period.
 * 
 */
  __pyx_t_1 = PyFloat_FromDouble(0.1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9839; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_k_40 = __pyx_t_1;
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_1 = PyFloat_FromDouble(1e-06); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9839; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_k_41 = __pyx_t_1;
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_391rate, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9839; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__rate, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9839; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":9884
 * 
 * 
 * def ravel(a, order='C'):             # <<<<<<<<<<<<<<
 *     """Return a flattened array.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_393ravel, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9884; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__ravel, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9884; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":9968
 * 
 * 
 * def ravel_multi_index(multi_index, dims, mode='raise', order='C'):             # <<<<<<<<<<<<<<
 *     """ravel_multi_index(multi_index, dims, mode='raise', order='C')
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_395ravel_multi_index, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9968; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__ravel_multi_index, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9968; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":10028
 * 
 * 
 * def real(val):             # <<<<<<<<<<<<<<
 *     """Return the real part of the elements of the array.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_397real, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10028; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__real, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10028; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":10062
 * 
 * 
 * def real_if_close(a, tol=100):             # <<<<<<<<<<<<<<
 *     """If complex input returns a real array if complex parts are close to zero.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_399real_if_close, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10062; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__real_if_close, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10062; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":10107
 * 
 * 
 * def recfromcsv(fname):             # <<<<<<<<<<<<<<
 *     """Load ASCII data stored in a comma-separated file.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_401recfromcsv, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10107; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__recfromcsv, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10107; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":10124
 * 
 * 
 * def recfromtxt(fname):             # <<<<<<<<<<<<<<
 *     """Load ASCII data from a file and return it in a record array.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_403recfromtxt, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10124; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__recfromtxt, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10124; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":10146
 * 
 * 
 * def repeat(a, repeats, axis=None):             # <<<<<<<<<<<<<<
 *     """Repeat elements of an array.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_405repeat, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10146; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__repeat, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10146; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":10187
 * 
 * 
 * def require(a, dtype=None, requirements=None):             # <<<<<<<<<<<<<<
 *     """Return an ndarray of the provided type that satisfies requirements.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_407require, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10187; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__require, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10187; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":10246
 * 
 * 
 * def reshape(a, newshape, order='C'):             # <<<<<<<<<<<<<<
 *     """Gives a new shape to an array without changing its data.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_409reshape, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10246; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__reshape, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10246; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":10308
 * 
 * 
 * def resize(a, new_shape):             # <<<<<<<<<<<<<<
 *     """Return a new array with the specified shape.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_411resize, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10308; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__resize, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10308; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":10348
 * 
 * 
 * def restoredot():             # <<<<<<<<<<<<<<
 *     """Restore `dot`, `vdot`, and `innerproduct` to the default non-BLAS
 *     implementations.
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_413restoredot, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10348; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__restoredot, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10348; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":10366
 * 
 * 
 * def result_type(*arrays_and_dtypes):             # <<<<<<<<<<<<<<
 *     """result_type(*arrays_and_dtypes)
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_415result_type, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10366; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__result_type, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10366; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":10437
 * 
 * 
 * def roll(a, shift, axis=None):             # <<<<<<<<<<<<<<
 *     """Roll array elements along a given axis.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_417roll, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10437; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__roll, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10437; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":10488
 * 
 * 
 * def rollaxis(a, axis, start=0):             # <<<<<<<<<<<<<<
 *     """Roll the specified axis backwards, until it lies in a given position.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_419rollaxis, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10488; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__rollaxis, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10488; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":10526
 * 
 * 
 * def roots(p):             # <<<<<<<<<<<<<<
 *     """Return the roots of a polynomial with coefficients given in p.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_421roots, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10526; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__roots, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10526; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":10577
 * 
 * 
 * def rot90(m, k=1):             # <<<<<<<<<<<<<<
 *     """Rotate an array by 90 degrees in the counter-clockwise direction.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_423rot90, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10577; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__rot90, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10577; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":10617
 * 
 * 
 * def round(a, decimals=0, out=None):             # <<<<<<<<<<<<<<
 *     """Round an array to the given number of decimals.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_425round, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10617; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__round, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10617; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":10630
 * 
 * 
 * def round_(a, decimals=0, out=None):             # <<<<<<<<<<<<<<
 *     """Round an array to the given number of decimals.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_427round_, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10630; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__round_, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10630; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":10643
 * 
 * 
 * def row_stack(tup):             # <<<<<<<<<<<<<<
 *     """Stack arrays in sequence vertically (row wise).
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_429row_stack, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10643; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__row_stack, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10643; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":10694
 * 
 * 
 * def safe_eval(source):             # <<<<<<<<<<<<<<
 *     """Protected string evaluation.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_431safe_eval, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10694; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__safe_eval, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10694; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":10739
 * 
 * 
 * def save(file, arr):             # <<<<<<<<<<<<<<
 *     """Save an array to a binary file in NumPy ``.npy`` format.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_433save, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10739; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__save, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10739; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":10777
 * 
 * 
 * def savetxt(fname, X, fmt='%.18e', delimiter=' ', newline='\n'):             # <<<<<<<<<<<<<<
 *     """Save an array to a text file.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_435savetxt, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10777; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__savetxt, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10777; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":10868
 * 
 * 
 * def savez(file):             # <<<<<<<<<<<<<<
 *     """Save several arrays into a single file in uncompressed ``.npz`` format.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_437savez, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10868; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__savez, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10868; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":10948
 * 
 * 
 * def savez_compressed(file):             # <<<<<<<<<<<<<<
 *     """Save several arrays into a single file in compressed ``.npz`` format.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_439savez_compressed, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10948; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__savez_compressed, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10948; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":10972
 * 
 * 
 * def sctype2char(sctype):             # <<<<<<<<<<<<<<
 *     """Return the string representation of a scalar dtype.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_441sctype2char, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10972; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__sctype2char, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10972; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":11016
 * 
 * 
 * def searchsorted(a, v, side='left'):             # <<<<<<<<<<<<<<
 *     """Find indices where elements should be inserted to maintain order.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_443searchsorted, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11016; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__searchsorted, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11016; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":11064
 * 
 * 
 * def select(condlist, choicelist, default=0):             # <<<<<<<<<<<<<<
 *     """Return an array drawn from elements in choicelist, depending on conditions.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_445select, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11064; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__select, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11064; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":11103
 * 
 * 
 * def set_numeric_ops():             # <<<<<<<<<<<<<<
 *     """set_numeric_ops(op1=func1, op2=func2, ...)
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_447set_numeric_ops, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11103; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__set_numeric_ops, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11103; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":11149
 * 
 * 
 * def set_printoptions(precision=None, threshold=None, edgeitems=None, linewidth=None, suppress=None, nanstr=None, infstr=None):             # <<<<<<<<<<<<<<
 *     """Set printing options.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_449set_printoptions, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11149; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__set_printoptions, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11149; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":11214
 * 
 * 
 * def set_string_function(f, repr=True):             # <<<<<<<<<<<<<<
 *     """Set a Python function to be used when pretty printing arrays.
 * 
 */
  __pyx_t_1 = __Pyx_PyBool_FromLong(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11214; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_k_44 = __pyx_t_1;
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_451set_string_function, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11214; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__set_string_function, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11214; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":11267
 * 
 * 
 * def setbufsize(size):             # <<<<<<<<<<<<<<
 *     """Set the size of the buffer used in ufuncs.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_453setbufsize, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11267; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__setbufsize, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11267; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":11279
 * 
 * 
 * def setdiff1d(ar1, ar2, assume_unique=False):             # <<<<<<<<<<<<<<
 *     """Find the set difference of two arrays.
 * 
 */
  __pyx_t_1 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11279; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_k_45 = __pyx_t_1;
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_455setdiff1d, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11279; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__setdiff1d, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11279; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":11315
 * 
 * 
 * def seterr(all=None, divide=None, over=None, under=None, invalid=None):             # <<<<<<<<<<<<<<
 *     """Set how floating-point errors are handled.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_457seterr, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11315; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__seterr, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11315; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":11394
 * 
 * 
 * def seterrcall(func):             # <<<<<<<<<<<<<<
 *     """Set the floating-point error callback function or log object.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_459seterrcall, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11394; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__seterrcall, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11394; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":11477
 * 
 * 
 * def seterrobj(errobj):             # <<<<<<<<<<<<<<
 *     """seterrobj(errobj)
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_461seterrobj, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11477; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__seterrobj, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11477; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":11538
 * 
 * 
 * def setxor1d(ar1, ar2, assume_unique=False):             # <<<<<<<<<<<<<<
 *     """Find the set exclusive-or of two arrays.
 * 
 */
  __pyx_t_1 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11538; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_k_46 = __pyx_t_1;
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_463setxor1d, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11538; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__setxor1d, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11538; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":11569
 * 
 * 
 * def show_config():             # <<<<<<<<<<<<<<
 *     """
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_465show_config, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11569; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__show_config, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11569; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":11576
 * 
 * 
 * def sinc(x):             # <<<<<<<<<<<<<<
 *     """Return the sinc function.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_467sinc, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11576; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__sinc, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11576; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":11653
 * 
 * 
 * def size(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Return the number of elements along a given axis.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_469size, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11653; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__size, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11653; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":11689
 * 
 * 
 * def sometrue(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Check whether some values are true.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_471sometrue, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11689; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__sometrue, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11689; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":11702
 * 
 * 
 * def sort(a, axis=-1, kind='quicksort', order=None):             # <<<<<<<<<<<<<<
 *     """Return a sorted copy of an array.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_473sort, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11702; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__sort, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11702; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":11803
 * 
 * 
 * def sort_complex(a):             # <<<<<<<<<<<<<<
 *     """Sort a complex array using the real part first, then the imaginary part.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_475sort_complex, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11803; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__sort_complex, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11803; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":11828
 * 
 * 
 * def source(object, output=sys.stdout):             # <<<<<<<<<<<<<<
 *     """Print or write to a file the source code for a Numpy object.
 * 
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s__sys); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11828; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s__stdout); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11828; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_k_47 = __pyx_t_2;
  __Pyx_GIVEREF(__pyx_t_2);
  __pyx_t_2 = 0;
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_477source, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11828; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__source, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11828; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":11868
 * 
 * 
 * def split(ary, indices_or_sections, axis=0):             # <<<<<<<<<<<<<<
 *     """Split an array into multiple sub-arrays of equal size.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_479split, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11868; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__split, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11868; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":11935
 * 
 * 
 * def squeeze(a):             # <<<<<<<<<<<<<<
 *     """Remove single-dimensional entries from the shape of an array.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_481squeeze, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11935; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__squeeze, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11935; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":11961
 * 
 * 
 * def std(a, axis=None, dtype=None, out=None, ddof=0):             # <<<<<<<<<<<<<<
 *     """Compute the standard deviation along the specified axis.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_483std, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11961; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__std, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11961; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":12049
 * 
 * 
 * def sum(a, axis=None, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Sum of array elements over a given axis.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_485sum, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12049; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__sum, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12049; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":12117
 * 
 * 
 * def swapaxes(a, axis1, axis2):             # <<<<<<<<<<<<<<
 *     """Interchange two axes of an array.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_487swapaxes, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12117; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__swapaxes, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12117; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":12160
 * 
 * 
 * def take(a, indices, axis=None, out=None, mode='raise'):             # <<<<<<<<<<<<<<
 *     """Take elements from an array along an axis.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_489take, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12160; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__take, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12160; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":12216
 * 
 * 
 * def tensordot(a, b, axes=2):             # <<<<<<<<<<<<<<
 *     """Compute tensor dot product along specified axes for arrays >= 1-D.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_491tensordot, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12216; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__tensordot, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12216; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":12332
 * 
 * 
 * def tile(A, reps):             # <<<<<<<<<<<<<<
 *     """Construct an array by repeating A the number of times given by reps.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_493tile, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12332; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__tile, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12332; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":12390
 * 
 * 
 * def trace(a, offset=0, axis1=0, axis2=1, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the sum along diagonals of the array.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_495trace, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12390; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__trace, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12390; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":12448
 * 
 * 
 * def transpose(a, axes=None):             # <<<<<<<<<<<<<<
 *     """Permute the dimensions of an array.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_497transpose, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12448; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__transpose, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12448; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":12488
 * 
 * 
 * def trapz(y, x=None, dx=1.0, axis=-1):             # <<<<<<<<<<<<<<
 *     """Integrate along the given axis using the composite trapezoidal rule.
 * 
 */
  __pyx_t_2 = PyFloat_FromDouble(1.0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12488; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_k_48 = __pyx_t_2;
  __Pyx_GIVEREF(__pyx_t_2);
  __pyx_t_2 = 0;
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_499trapz, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12488; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__trapz, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12488; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":12549
 * 
 * 
 * def tri(N, M=None, k=0, dtype=float):             # <<<<<<<<<<<<<<
 *     """An array with ones at and below the given diagonal and zeros elsewhere.
 * 
 */
  __Pyx_INCREF(((PyObject *)((PyObject*)(&PyFloat_Type))));
  __pyx_k_49 = ((PyObject *)((PyObject*)(&PyFloat_Type)));
  __Pyx_GIVEREF(((PyObject*)(&PyFloat_Type)));
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_501tri, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12549; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__tri, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12549; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":12588
 * 
 * 
 * def tril(m, k=0):             # <<<<<<<<<<<<<<
 *     """Lower triangle of an array.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_503tril, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12588; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__tril, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12588; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":12622
 * 
 * 
 * def tril_indices(n, k=0):             # <<<<<<<<<<<<<<
 *     """Return the indices for the lower-triangle of an (n, n) array.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_505tril_indices, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12622; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__tril_indices, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12622; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":12694
 * 
 * 
 * def tril_indices_from(arr, k=0):             # <<<<<<<<<<<<<<
 *     """Return the indices for the lower-triangle of arr.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_507tril_indices_from, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12694; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__tril_indices_from, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12694; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":12719
 * 
 * 
 * def trim_zeros(filt, trim='fb'):             # <<<<<<<<<<<<<<
 *     """Trim the leading and/or trailing zeros from a 1-D array or sequence.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_509trim_zeros, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12719; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__trim_zeros, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12719; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":12754
 * 
 * 
 * def triu(m, k=0):             # <<<<<<<<<<<<<<
 *     """Upper triangle of an array.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_511triu, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12754; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__triu, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12754; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":12778
 * 
 * 
 * def triu_indices(n, k=0):             # <<<<<<<<<<<<<<
 *     """Return the indices for the upper-triangle of an (n, n) array.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_513triu_indices, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12778; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__triu_indices, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12778; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":12851
 * 
 * 
 * def triu_indices_from(arr, k=0):             # <<<<<<<<<<<<<<
 *     """Return the indices for the upper-triangle of an (n, n) array.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_515triu_indices_from, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12851; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__triu_indices_from, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12851; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":12876
 * 
 * 
 * def typename(char_):             # <<<<<<<<<<<<<<
 *     """Return a description for the given data type code.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_517typename, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12876; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__typename, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12876; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":12927
 * 
 * 
 * def union1d(ar1, ar2):             # <<<<<<<<<<<<<<
 *     """Find the union of two arrays.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_519union1d, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12927; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__union1d, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12927; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":12957
 * 
 * 
 * def unique(ar, return_index=False, return_inverse=False):             # <<<<<<<<<<<<<<
 *     """Find the unique elements of an array.
 * 
 */
  __pyx_t_2 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12957; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_k_50 = __pyx_t_2;
  __Pyx_GIVEREF(__pyx_t_2);
  __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12957; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_k_51 = __pyx_t_2;
  __Pyx_GIVEREF(__pyx_t_2);
  __pyx_t_2 = 0;
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_521unique, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12957; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__unique, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12957; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":13028
 * 
 * 
 * def unpackbits(myarray, axis=None):             # <<<<<<<<<<<<<<
 *     """unpackbits(myarray, axis=None)
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_523unpackbits, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13028; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__unpackbits, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13028; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":13073
 * 
 * 
 * def unravel_index(indices, dims, order='C'):             # <<<<<<<<<<<<<<
 *     """unravel_index(indices, dims, order='C')
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_525unravel_index, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13073; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__unravel_index, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13073; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":13118
 * 
 * 
 * def unwrap(p, discont=3.14159265359, axis=-1):             # <<<<<<<<<<<<<<
 *     """Unwrap by changing deltas between values to 2*pi complement.
 * 
 */
  __pyx_t_2 = PyFloat_FromDouble(3.14159265359); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13118; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_k_52 = __pyx_t_2;
  __Pyx_GIVEREF(__pyx_t_2);
  __pyx_t_2 = 0;
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_527unwrap, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13118; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__unwrap, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13118; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":13161
 * 
 * 
 * def vander(x, N=None):             # <<<<<<<<<<<<<<
 *     """Generate a Van der Monde matrix.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_529vander, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13161; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__vander, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13161; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":13219
 * 
 * 
 * def var(a, axis=None, dtype=None, out=None, ddof=0):             # <<<<<<<<<<<<<<
 *     """Compute the variance along the specified axis.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_531var, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13219; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__var, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13219; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":13309
 * 
 * 
 * def vdot():             # <<<<<<<<<<<<<<
 *     """Return the dot product of two vectors.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_533vdot, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13309; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__vdot, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13309; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":13364
 * 
 * 
 * def vsplit(ary, indices_or_sections):             # <<<<<<<<<<<<<<
 *     """Split an array into multiple sub-arrays vertically (row-wise).
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_535vsplit, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13364; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__vsplit, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13364; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":13413
 * 
 * 
 * def vstack(tup):             # <<<<<<<<<<<<<<
 *     """Stack arrays in sequence vertically (row wise).
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_537vstack, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13413; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__vstack, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13413; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":13464
 * 
 * 
 * def where():             # <<<<<<<<<<<<<<
 *     """where(condition, [x, y])
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_539where, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13464; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__where, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13464; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":13526
 * 
 * 
 * def who(vardict=None):             # <<<<<<<<<<<<<<
 *     """Print the Numpy arrays in the given dictionary.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_541who, NULL, __pyx_n_s_68); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13526; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s__who, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13526; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":2
 * 
 * import sys             # <<<<<<<<<<<<<<
 * 
 * import numpy as np
 */
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_t_2));
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_582), ((PyObject *)__pyx_kp_u_583)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_584), ((PyObject *)__pyx_kp_u_585)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_586), ((PyObject *)__pyx_kp_u_587)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_588), ((PyObject *)__pyx_kp_u_589)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_590), ((PyObject *)__pyx_kp_u_591)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_592), ((PyObject *)__pyx_kp_u_593)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_594), ((PyObject *)__pyx_kp_u_595)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_596), ((PyObject *)__pyx_kp_u_597)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_598), ((PyObject *)__pyx_kp_u_599)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_600), ((PyObject *)__pyx_kp_u_601)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_602), ((PyObject *)__pyx_kp_u_603)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_604), ((PyObject *)__pyx_kp_u_605)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_606), ((PyObject *)__pyx_kp_u_607)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_608), ((PyObject *)__pyx_kp_u_609)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_610), ((PyObject *)__pyx_kp_u_611)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_612), ((PyObject *)__pyx_kp_u_613)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_614), ((PyObject *)__pyx_kp_u_615)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_616), ((PyObject *)__pyx_kp_u_617)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_618), ((PyObject *)__pyx_kp_u_619)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_620), ((PyObject *)__pyx_kp_u_621)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_622), ((PyObject *)__pyx_kp_u_623)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_624), ((PyObject *)__pyx_kp_u_625)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_626), ((PyObject *)__pyx_kp_u_627)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_628), ((PyObject *)__pyx_kp_u_629)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_630), ((PyObject *)__pyx_kp_u_631)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_632), ((PyObject *)__pyx_kp_u_633)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_634), ((PyObject *)__pyx_kp_u_635)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_636), ((PyObject *)__pyx_kp_u_637)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_638), ((PyObject *)__pyx_kp_u_639)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_640), ((PyObject *)__pyx_kp_u_641)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_642), ((PyObject *)__pyx_kp_u_643)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_644), ((PyObject *)__pyx_kp_u_645)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_646), ((PyObject *)__pyx_kp_u_647)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_648), ((PyObject *)__pyx_kp_u_649)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_650), ((PyObject *)__pyx_kp_u_651)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_652), ((PyObject *)__pyx_kp_u_653)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_654), ((PyObject *)__pyx_kp_u_655)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_656), ((PyObject *)__pyx_kp_u_657)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_658), ((PyObject *)__pyx_kp_u_659)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_660), ((PyObject *)__pyx_kp_u_661)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_662), ((PyObject *)__pyx_kp_u_663)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_664), ((PyObject *)__pyx_kp_u_665)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_666), ((PyObject *)__pyx_kp_u_667)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_668), ((PyObject *)__pyx_kp_u_669)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_670), ((PyObject *)__pyx_kp_u_671)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_672), ((PyObject *)__pyx_kp_u_673)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_674), ((PyObject *)__pyx_kp_u_675)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_676), ((PyObject *)__pyx_kp_u_677)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_678), ((PyObject *)__pyx_kp_u_679)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_680), ((PyObject *)__pyx_kp_u_681)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_682), ((PyObject *)__pyx_kp_u_683)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_684), ((PyObject *)__pyx_kp_u_685)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_686), ((PyObject *)__pyx_kp_u_687)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_688), ((PyObject *)__pyx_kp_u_689)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_690), ((PyObject *)__pyx_kp_u_691)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_692), ((PyObject *)__pyx_kp_u_693)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_694), ((PyObject *)__pyx_kp_u_695)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_696), ((PyObject *)__pyx_kp_u_697)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_698), ((PyObject *)__pyx_kp_u_699)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_700), ((PyObject *)__pyx_kp_u_701)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_702), ((PyObject *)__pyx_kp_u_703)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_704), ((PyObject *)__pyx_kp_u_705)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_706), ((PyObject *)__pyx_kp_u_707)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_708), ((PyObject *)__pyx_kp_u_709)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_710), ((PyObject *)__pyx_kp_u_711)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_712), ((PyObject *)__pyx_kp_u_713)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_714), ((PyObject *)__pyx_kp_u_715)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_716), ((PyObject *)__pyx_kp_u_717)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_718), ((PyObject *)__pyx_kp_u_719)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_720), ((PyObject *)__pyx_kp_u_721)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_722), ((PyObject *)__pyx_kp_u_723)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_724), ((PyObject *)__pyx_kp_u_725)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_726), ((PyObject *)__pyx_kp_u_727)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_728), ((PyObject *)__pyx_kp_u_729)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_730), ((PyObject *)__pyx_kp_u_731)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_732), ((PyObject *)__pyx_kp_u_733)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_734), ((PyObject *)__pyx_kp_u_735)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_736), ((PyObject *)__pyx_kp_u_737)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_738), ((PyObject *)__pyx_kp_u_739)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_740), ((PyObject *)__pyx_kp_u_741)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_742), ((PyObject *)__pyx_kp_u_743)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_744), ((PyObject *)__pyx_kp_u_745)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_746), ((PyObject *)__pyx_kp_u_747)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_748), ((PyObject *)__pyx_kp_u_749)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_750), ((PyObject *)__pyx_kp_u_751)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_752), ((PyObject *)__pyx_kp_u_753)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_754), ((PyObject *)__pyx_kp_u_755)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_756), ((PyObject *)__pyx_kp_u_757)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_758), ((PyObject *)__pyx_kp_u_759)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_760), ((PyObject *)__pyx_kp_u_761)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_762), ((PyObject *)__pyx_kp_u_763)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_764), ((PyObject *)__pyx_kp_u_765)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_766), ((PyObject *)__pyx_kp_u_767)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_768), ((PyObject *)__pyx_kp_u_769)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_770), ((PyObject *)__pyx_kp_u_771)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_772), ((PyObject *)__pyx_kp_u_773)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_774), ((PyObject *)__pyx_kp_u_775)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_776), ((PyObject *)__pyx_kp_u_777)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_778), ((PyObject *)__pyx_kp_u_779)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_780), ((PyObject *)__pyx_kp_u_781)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_782), ((PyObject *)__pyx_kp_u_783)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_784), ((PyObject *)__pyx_kp_u_785)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_786), ((PyObject *)__pyx_kp_u_787)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_788), ((PyObject *)__pyx_kp_u_789)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_790), ((PyObject *)__pyx_kp_u_791)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_792), ((PyObject *)__pyx_kp_u_793)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_794), ((PyObject *)__pyx_kp_u_795)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_796), ((PyObject *)__pyx_kp_u_797)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_798), ((PyObject *)__pyx_kp_u_799)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_800), ((PyObject *)__pyx_kp_u_801)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_802), ((PyObject *)__pyx_kp_u_803)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_804), ((PyObject *)__pyx_kp_u_805)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_806), ((PyObject *)__pyx_kp_u_807)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_808), ((PyObject *)__pyx_kp_u_809)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_810), ((PyObject *)__pyx_kp_u_811)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_812), ((PyObject *)__pyx_kp_u_813)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_814), ((PyObject *)__pyx_kp_u_815)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_816), ((PyObject *)__pyx_kp_u_817)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_818), ((PyObject *)__pyx_kp_u_819)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_820), ((PyObject *)__pyx_kp_u_821)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_822), ((PyObject *)__pyx_kp_u_823)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_824), ((PyObject *)__pyx_kp_u_825)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_826), ((PyObject *)__pyx_kp_u_827)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_828), ((PyObject *)__pyx_kp_u_633)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_829), ((PyObject *)__pyx_kp_u_587)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_830), ((PyObject *)__pyx_kp_u_831)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_832), ((PyObject *)__pyx_kp_u_833)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_834), ((PyObject *)__pyx_kp_u_835)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_836), ((PyObject *)__pyx_kp_u_837)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_838), ((PyObject *)__pyx_kp_u_839)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_840), ((PyObject *)__pyx_kp_u_589)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_841), ((PyObject *)__pyx_kp_u_842)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_843), ((PyObject *)__pyx_kp_u_844)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_845), ((PyObject *)__pyx_kp_u_846)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_847), ((PyObject *)__pyx_kp_u_848)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_849), ((PyObject *)__pyx_kp_u_850)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_851), ((PyObject *)__pyx_kp_u_852)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_853), ((PyObject *)__pyx_kp_u_854)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_855), ((PyObject *)__pyx_kp_u_856)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_857), ((PyObject *)__pyx_kp_u_858)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_859), ((PyObject *)__pyx_kp_u_860)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_861), ((PyObject *)__pyx_kp_u_862)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_863), ((PyObject *)__pyx_kp_u_864)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_865), ((PyObject *)__pyx_kp_u_866)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_867), ((PyObject *)__pyx_kp_u_868)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_869), ((PyObject *)__pyx_kp_u_870)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_871), ((PyObject *)__pyx_kp_u_872)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_873), ((PyObject *)__pyx_kp_u_874)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_875), ((PyObject *)__pyx_kp_u_876)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_877), ((PyObject *)__pyx_kp_u_878)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_879), ((PyObject *)__pyx_kp_u_880)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_881), ((PyObject *)__pyx_kp_u_882)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_883), ((PyObject *)__pyx_kp_u_884)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_885), ((PyObject *)__pyx_kp_u_886)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_887), ((PyObject *)__pyx_kp_u_888)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_889), ((PyObject *)__pyx_kp_u_890)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_891), ((PyObject *)__pyx_kp_u_892)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_893), ((PyObject *)__pyx_kp_u_894)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_895), ((PyObject *)__pyx_kp_u_896)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_897), ((PyObject *)__pyx_kp_u_898)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_899), ((PyObject *)__pyx_kp_u_900)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_901), ((PyObject *)__pyx_kp_u_902)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_903), ((PyObject *)__pyx_kp_u_904)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_905), ((PyObject *)__pyx_kp_u_906)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_907), ((PyObject *)__pyx_kp_u_908)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_909), ((PyObject *)__pyx_kp_u_910)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_911), ((PyObject *)__pyx_kp_u_912)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_913), ((PyObject *)__pyx_kp_u_914)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_915), ((PyObject *)__pyx_kp_u_916)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_917), ((PyObject *)__pyx_kp_u_918)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_919), ((PyObject *)__pyx_kp_u_920)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_921), ((PyObject *)__pyx_kp_u_922)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_923), ((PyObject *)__pyx_kp_u_924)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_925), ((PyObject *)__pyx_kp_u_926)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_927), ((PyObject *)__pyx_kp_u_928)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_929), ((PyObject *)__pyx_kp_u_930)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_931), ((PyObject *)__pyx_kp_u_932)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_933), ((PyObject *)__pyx_kp_u_934)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_935), ((PyObject *)__pyx_kp_u_936)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_937), ((PyObject *)__pyx_kp_u_938)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_939), ((PyObject *)__pyx_kp_u_940)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_941), ((PyObject *)__pyx_kp_u_942)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_943), ((PyObject *)__pyx_kp_u_944)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_945), ((PyObject *)__pyx_kp_u_946)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_947), ((PyObject *)__pyx_kp_u_948)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_949), ((PyObject *)__pyx_kp_u_950)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_951), ((PyObject *)__pyx_kp_u_952)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_953), ((PyObject *)__pyx_kp_u_954)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_955), ((PyObject *)__pyx_kp_u_956)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_957), ((PyObject *)__pyx_kp_u_958)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_959), ((PyObject *)__pyx_kp_u_960)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_961), ((PyObject *)__pyx_kp_u_962)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_963), ((PyObject *)__pyx_kp_u_964)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_965), ((PyObject *)__pyx_kp_u_966)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_967), ((PyObject *)__pyx_kp_u_968)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_969), ((PyObject *)__pyx_kp_u_970)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_971), ((PyObject *)__pyx_kp_u_972)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_973), ((PyObject *)__pyx_kp_u_974)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_975), ((PyObject *)__pyx_kp_u_976)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_977), ((PyObject *)__pyx_kp_u_978)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_979), ((PyObject *)__pyx_kp_u_980)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_981), ((PyObject *)__pyx_kp_u_982)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_983), ((PyObject *)__pyx_kp_u_984)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_985), ((PyObject *)__pyx_kp_u_986)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_987), ((PyObject *)__pyx_kp_u_988)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_989), ((PyObject *)__pyx_kp_u_990)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_991), ((PyObject *)__pyx_kp_u_992)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_993), ((PyObject *)__pyx_kp_u_994)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_995), ((PyObject *)__pyx_kp_u_996)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_997), ((PyObject *)__pyx_kp_u_998)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_999), ((PyObject *)__pyx_kp_u_1000)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_1001), ((PyObject *)__pyx_kp_u_1002)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_1003), ((PyObject *)__pyx_kp_u_1004)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_1005), ((PyObject *)__pyx_kp_u_1006)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_1007), ((PyObject *)__pyx_kp_u_1008)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_1009), ((PyObject *)__pyx_kp_u_1010)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_1011), ((PyObject *)__pyx_kp_u_1012)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_1013), ((PyObject *)__pyx_kp_u_1014)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_1015), ((PyObject *)__pyx_kp_u_1016)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_1017), ((PyObject *)__pyx_kp_u_1018)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_1019), ((PyObject *)__pyx_kp_u_1020)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_1021), ((PyObject *)__pyx_kp_u_1022)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_1023), ((PyObject *)__pyx_kp_u_1024)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_1025), ((PyObject *)__pyx_kp_u_1026)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_1027), ((PyObject *)__pyx_kp_u_1028)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_1029), ((PyObject *)__pyx_kp_u_1030)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_1031), ((PyObject *)__pyx_kp_u_1032)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_1033), ((PyObject *)__pyx_kp_u_938)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_1034), ((PyObject *)__pyx_kp_u_1035)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, ((PyObject *)__pyx_kp_u_1036), ((PyObject *)__pyx_kp_u_1037)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_d, __pyx_n_s____test__, ((PyObject *)__pyx_t_2)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;

  /* "numpy.pxd":975
 *      arr.base = baseptr
 * 
 * cdef inline object get_array_base(ndarray arr):             # <<<<<<<<<<<<<<
 *     if arr.base is NULL:
 *         return None
 */
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  if (__pyx_m) {
    __Pyx_AddTraceback("init ga4py.gain.notimplemented", __pyx_clineno, __pyx_lineno, __pyx_filename);
    Py_DECREF(__pyx_m); __pyx_m = 0;
  } else if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_ImportError, "init ga4py.gain.notimplemented");
  }
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  #if PY_MAJOR_VERSION < 3
  return;
  #else
  return __pyx_m;
  #endif
}

/* Runtime support code */
#if CYTHON_REFNANNY
static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname) {
    PyObject *m = NULL, *p = NULL;
    void *r = NULL;
    m = PyImport_ImportModule((char *)modname);
    if (!m) goto end;
    p = PyObject_GetAttrString(m, (char *)"RefNannyAPI");
    if (!p) goto end;
    r = PyLong_AsVoidPtr(p);
end:
    Py_XDECREF(p);
    Py_XDECREF(m);
    return (__Pyx_RefNannyAPIStruct *)r;
}
#endif /* CYTHON_REFNANNY */

static PyObject *__Pyx_GetBuiltinName(PyObject *name) {
    PyObject* result = __Pyx_PyObject_GetAttrStr(__pyx_b, name);
    if (unlikely(!result)) {
        PyErr_Format(PyExc_NameError,
#if PY_MAJOR_VERSION >= 3
            "name '%U' is not defined", name);
#else
            "name '%s' is not defined", PyString_AS_STRING(name));
#endif
    }
    return result;
}

static void __Pyx_RaiseArgtupleInvalid(
    const char* func_name,
    int exact,
    Py_ssize_t num_min,
    Py_ssize_t num_max,
    Py_ssize_t num_found)
{
    Py_ssize_t num_expected;
    const char *more_or_less;
    if (num_found < num_min) {
        num_expected = num_min;
        more_or_less = "at least";
    } else {
        num_expected = num_max;
        more_or_less = "at most";
    }
    if (exact) {
        more_or_less = "exactly";
    }
    PyErr_Format(PyExc_TypeError,
                 "%s() takes %s %" CYTHON_FORMAT_SSIZE_T "d positional argument%s (%" CYTHON_FORMAT_SSIZE_T "d given)",
                 func_name, more_or_less, num_expected,
                 (num_expected == 1) ? "" : "s", num_found);
}

static void __Pyx_RaiseDoubleKeywordsError(
    const char* func_name,
    PyObject* kw_name)
{
    PyErr_Format(PyExc_TypeError,
        #if PY_MAJOR_VERSION >= 3
        "%s() got multiple values for keyword argument '%U'", func_name, kw_name);
        #else
        "%s() got multiple values for keyword argument '%s'", func_name,
        PyString_AsString(kw_name));
        #endif
}

static int __Pyx_ParseOptionalKeywords(
    PyObject *kwds,
    PyObject **argnames[],
    PyObject *kwds2,
    PyObject *values[],
    Py_ssize_t num_pos_args,
    const char* function_name)
{
    PyObject *key = 0, *value = 0;
    Py_ssize_t pos = 0;
    PyObject*** name;
    PyObject*** first_kw_arg = argnames + num_pos_args;
    while (PyDict_Next(kwds, &pos, &key, &value)) {
        name = first_kw_arg;
        while (*name && (**name != key)) name++;
        if (*name) {
            values[name-argnames] = value;
            continue;
        }
        name = first_kw_arg;
        #if PY_MAJOR_VERSION < 3
        if (likely(PyString_CheckExact(key)) || likely(PyString_Check(key))) {
            while (*name) {
                if ((CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**name) == PyString_GET_SIZE(key))
                        && _PyString_Eq(**name, key)) {
                    values[name-argnames] = value;
                    break;
                }
                name++;
            }
            if (*name) continue;
            else {
                PyObject*** argname = argnames;
                while (argname != first_kw_arg) {
                    if ((**argname == key) || (
                            (CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**argname) == PyString_GET_SIZE(key))
                             && _PyString_Eq(**argname, key))) {
                        goto arg_passed_twice;
                    }
                    argname++;
                }
            }
        } else
        #endif
        if (likely(PyUnicode_Check(key))) {
            while (*name) {
                int cmp = (**name == key) ? 0 :
                #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
                    (PyUnicode_GET_SIZE(**name) != PyUnicode_GET_SIZE(key)) ? 1 :
                #endif
                    PyUnicode_Compare(**name, key);
                if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
                if (cmp == 0) {
                    values[name-argnames] = value;
                    break;
                }
                name++;
            }
            if (*name) continue;
            else {
                PyObject*** argname = argnames;
                while (argname != first_kw_arg) {
                    int cmp = (**argname == key) ? 0 :
                    #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
                        (PyUnicode_GET_SIZE(**argname) != PyUnicode_GET_SIZE(key)) ? 1 :
                    #endif
                        PyUnicode_Compare(**argname, key);
                    if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
                    if (cmp == 0) goto arg_passed_twice;
                    argname++;
                }
            }
        } else
            goto invalid_keyword_type;
        if (kwds2) {
            if (unlikely(PyDict_SetItem(kwds2, key, value))) goto bad;
        } else {
            goto invalid_keyword;
        }
    }
    return 0;
arg_passed_twice:
    __Pyx_RaiseDoubleKeywordsError(function_name, key);
    goto bad;
invalid_keyword_type:
    PyErr_Format(PyExc_TypeError,
        "%s() keywords must be strings", function_name);
    goto bad;
invalid_keyword:
    PyErr_Format(PyExc_TypeError,
    #if PY_MAJOR_VERSION < 3
        "%s() got an unexpected keyword argument '%s'",
        function_name, PyString_AsString(key));
    #else
        "%s() got an unexpected keyword argument '%U'",
        function_name, key);
    #endif
bad:
    return -1;
}

static CYTHON_INLINE void __Pyx_ErrRestore(PyObject *type, PyObject *value, PyObject *tb) {
#if CYTHON_COMPILING_IN_CPYTHON
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    PyThreadState *tstate = PyThreadState_GET();
    tmp_type = tstate->curexc_type;
    tmp_value = tstate->curexc_value;
    tmp_tb = tstate->curexc_traceback;
    tstate->curexc_type = type;
    tstate->curexc_value = value;
    tstate->curexc_traceback = tb;
    Py_XDECREF(tmp_type);
    Py_XDECREF(tmp_value);
    Py_XDECREF(tmp_tb);
#else
    PyErr_Restore(type, value, tb);
#endif
}
static CYTHON_INLINE void __Pyx_ErrFetch(PyObject **type, PyObject **value, PyObject **tb) {
#if CYTHON_COMPILING_IN_CPYTHON
    PyThreadState *tstate = PyThreadState_GET();
    *type = tstate->curexc_type;
    *value = tstate->curexc_value;
    *tb = tstate->curexc_traceback;
    tstate->curexc_type = 0;
    tstate->curexc_value = 0;
    tstate->curexc_traceback = 0;
#else
    PyErr_Fetch(type, value, tb);
#endif
}

#if PY_MAJOR_VERSION < 3
static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb,
                        CYTHON_UNUSED PyObject *cause) {
    Py_XINCREF(type);
    if (!value || value == Py_None)
        value = NULL;
    else
        Py_INCREF(value);
    if (!tb || tb == Py_None)
        tb = NULL;
    else {
        Py_INCREF(tb);
        if (!PyTraceBack_Check(tb)) {
            PyErr_SetString(PyExc_TypeError,
                "raise: arg 3 must be a traceback or None");
            goto raise_error;
        }
    }
    #if PY_VERSION_HEX < 0x02050000
    if (PyClass_Check(type)) {
    #else
    if (PyType_Check(type)) {
    #endif
#if CYTHON_COMPILING_IN_PYPY
        if (!value) {
            Py_INCREF(Py_None);
            value = Py_None;
        }
#endif
        PyErr_NormalizeException(&type, &value, &tb);
    } else {
        if (value) {
            PyErr_SetString(PyExc_TypeError,
                "instance exception may not have a separate value");
            goto raise_error;
        }
        value = type;
        #if PY_VERSION_HEX < 0x02050000
        if (PyInstance_Check(type)) {
            type = (PyObject*) ((PyInstanceObject*)type)->in_class;
            Py_INCREF(type);
        } else {
            type = 0;
            PyErr_SetString(PyExc_TypeError,
                "raise: exception must be an old-style class or instance");
            goto raise_error;
        }
        #else
        type = (PyObject*) Py_TYPE(type);
        Py_INCREF(type);
        if (!PyType_IsSubtype((PyTypeObject *)type, (PyTypeObject *)PyExc_BaseException)) {
            PyErr_SetString(PyExc_TypeError,
                "raise: exception class must be a subclass of BaseException");
            goto raise_error;
        }
        #endif
    }
    __Pyx_ErrRestore(type, value, tb);
    return;
raise_error:
    Py_XDECREF(value);
    Py_XDECREF(type);
    Py_XDECREF(tb);
    return;
}
#else /* Python 3+ */
static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause) {
    PyObject* owned_instance = NULL;
    if (tb == Py_None) {
        tb = 0;
    } else if (tb && !PyTraceBack_Check(tb)) {
        PyErr_SetString(PyExc_TypeError,
            "raise: arg 3 must be a traceback or None");
        goto bad;
    }
    if (value == Py_None)
        value = 0;
    if (PyExceptionInstance_Check(type)) {
        if (value) {
            PyErr_SetString(PyExc_TypeError,
                "instance exception may not have a separate value");
            goto bad;
        }
        value = type;
        type = (PyObject*) Py_TYPE(value);
    } else if (PyExceptionClass_Check(type)) {
        PyObject *args;
        if (!value)
            args = PyTuple_New(0);
        else if (PyTuple_Check(value)) {
            Py_INCREF(value);
            args = value;
        } else
            args = PyTuple_Pack(1, value);
        if (!args)
            goto bad;
        owned_instance = PyEval_CallObject(type, args);
        Py_DECREF(args);
        if (!owned_instance)
            goto bad;
        value = owned_instance;
        if (!PyExceptionInstance_Check(value)) {
            PyErr_Format(PyExc_TypeError,
                         "calling %R should have returned an instance of "
                         "BaseException, not %R",
                         type, Py_TYPE(value));
            goto bad;
        }
    } else {
        PyErr_SetString(PyExc_TypeError,
            "raise: exception class must be a subclass of BaseException");
        goto bad;
    }
#if PY_VERSION_HEX >= 0x03030000
    if (cause) {
#else
    if (cause && cause != Py_None) {
#endif
        PyObject *fixed_cause;
        if (cause == Py_None) {
            fixed_cause = NULL;
        } else if (PyExceptionClass_Check(cause)) {
            fixed_cause = PyObject_CallObject(cause, NULL);
            if (fixed_cause == NULL)
                goto bad;
        } else if (PyExceptionInstance_Check(cause)) {
            fixed_cause = cause;
            Py_INCREF(fixed_cause);
        } else {
            PyErr_SetString(PyExc_TypeError,
                            "exception causes must derive from "
                            "BaseException");
            goto bad;
        }
        PyException_SetCause(value, fixed_cause);
    }
    PyErr_SetObject(type, value);
    if (tb) {
        PyThreadState *tstate = PyThreadState_GET();
        PyObject* tmp_tb = tstate->curexc_traceback;
        if (tb != tmp_tb) {
            Py_INCREF(tb);
            tstate->curexc_traceback = tb;
            Py_XDECREF(tmp_tb);
        }
    }
bad:
    Py_XDECREF(owned_instance);
    return;
}
#endif

static CYTHON_INLINE int __Pyx_CheckKeywordStrings(
    PyObject *kwdict,
    const char* function_name,
    int kw_allowed)
{
    PyObject* key = 0;
    Py_ssize_t pos = 0;
#if CPYTHON_COMPILING_IN_PYPY
    if (!kw_allowed && PyDict_Next(kwdict, &pos, &key, 0))
        goto invalid_keyword;
    return 1;
#else
    while (PyDict_Next(kwdict, &pos, &key, 0)) {
        #if PY_MAJOR_VERSION < 3
        if (unlikely(!PyString_CheckExact(key)) && unlikely(!PyString_Check(key)))
        #endif
            if (unlikely(!PyUnicode_Check(key)))
                goto invalid_keyword_type;
    }
    if ((!kw_allowed) && unlikely(key))
        goto invalid_keyword;
    return 1;
invalid_keyword_type:
    PyErr_Format(PyExc_TypeError,
        "%s() keywords must be strings", function_name);
    return 0;
#endif
invalid_keyword:
    PyErr_Format(PyExc_TypeError,
    #if PY_MAJOR_VERSION < 3
        "%s() got an unexpected keyword argument '%s'",
        function_name, PyString_AsString(key));
    #else
        "%s() got an unexpected keyword argument '%U'",
        function_name, key);
    #endif
    return 0;
}

static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected) {
    PyErr_Format(PyExc_ValueError,
                 "too many values to unpack (expected %" CYTHON_FORMAT_SSIZE_T "d)", expected);
}

static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index) {
    PyErr_Format(PyExc_ValueError,
                 "need more than %" CYTHON_FORMAT_SSIZE_T "d value%s to unpack",
                 index, (index == 1) ? "" : "s");
}

static CYTHON_INLINE void __Pyx_RaiseNoneNotIterableError(void) {
    PyErr_SetString(PyExc_TypeError, "'NoneType' object is not iterable");
}

static CYTHON_INLINE int __Pyx_IterFinish(void) {
#if CYTHON_COMPILING_IN_CPYTHON
    PyThreadState *tstate = PyThreadState_GET();
    PyObject* exc_type = tstate->curexc_type;
    if (unlikely(exc_type)) {
        if (likely(exc_type == PyExc_StopIteration) || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration)) {
            PyObject *exc_value, *exc_tb;
            exc_value = tstate->curexc_value;
            exc_tb = tstate->curexc_traceback;
            tstate->curexc_type = 0;
            tstate->curexc_value = 0;
            tstate->curexc_traceback = 0;
            Py_DECREF(exc_type);
            Py_XDECREF(exc_value);
            Py_XDECREF(exc_tb);
            return 0;
        } else {
            return -1;
        }
    }
    return 0;
#else
    if (unlikely(PyErr_Occurred())) {
        if (likely(PyErr_ExceptionMatches(PyExc_StopIteration))) {
            PyErr_Clear();
            return 0;
        } else {
            return -1;
        }
    }
    return 0;
#endif
}

static int __Pyx_IternextUnpackEndCheck(PyObject *retval, Py_ssize_t expected) {
    if (unlikely(retval)) {
        Py_DECREF(retval);
        __Pyx_RaiseTooManyValuesError(expected);
        return -1;
    } else {
        return __Pyx_IterFinish();
    }
    return 0;
}

static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type) {
    if (unlikely(!type)) {
        PyErr_Format(PyExc_SystemError, "Missing type object");
        return 0;
    }
    if (likely(PyObject_TypeCheck(obj, type)))
        return 1;
    PyErr_Format(PyExc_TypeError, "Cannot convert %.200s to %.200s",
                 Py_TYPE(obj)->tp_name, type->tp_name);
    return 0;
}

static CYTHON_INLINE PyObject *__Pyx_GetModuleGlobalName(PyObject *name) {
    PyObject *result;
#if CYTHON_COMPILING_IN_CPYTHON
    result = PyDict_GetItem(__pyx_d, name);
    if (result) {
        Py_INCREF(result);
    } else {
#else
    result = PyObject_GetItem(__pyx_d, name);
    if (!result) {
        PyErr_Clear();
#endif
        result = __Pyx_GetBuiltinName(name);
    }
    return result;
}

static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level) {
    PyObject *empty_list = 0;
    PyObject *module = 0;
    PyObject *global_dict = 0;
    PyObject *empty_dict = 0;
    PyObject *list;
    #if PY_VERSION_HEX < 0x03030000
    PyObject *py_import;
    py_import = __Pyx_PyObject_GetAttrStr(__pyx_b, __pyx_n_s____import__);
    if (!py_import)
        goto bad;
    #endif
    if (from_list)
        list = from_list;
    else {
        empty_list = PyList_New(0);
        if (!empty_list)
            goto bad;
        list = empty_list;
    }
    global_dict = PyModule_GetDict(__pyx_m);
    if (!global_dict)
        goto bad;
    empty_dict = PyDict_New();
    if (!empty_dict)
        goto bad;
    #if PY_VERSION_HEX >= 0x02050000
    {
        #if PY_MAJOR_VERSION >= 3
        if (level == -1) {
            if (strchr(__Pyx_MODULE_NAME, '.')) {
                #if PY_VERSION_HEX < 0x03030000
                PyObject *py_level = PyInt_FromLong(1);
                if (!py_level)
                    goto bad;
                module = PyObject_CallFunctionObjArgs(py_import,
                    name, global_dict, empty_dict, list, py_level, NULL);
                Py_DECREF(py_level);
                #else
                module = PyImport_ImportModuleLevelObject(
                    name, global_dict, empty_dict, list, 1);
                #endif
                if (!module) {
                    if (!PyErr_ExceptionMatches(PyExc_ImportError))
                        goto bad;
                    PyErr_Clear();
                }
            }
            level = 0; /* try absolute import on failure */
        }
        #endif
        if (!module) {
            #if PY_VERSION_HEX < 0x03030000
            PyObject *py_level = PyInt_FromLong(level);
            if (!py_level)
                goto bad;
            module = PyObject_CallFunctionObjArgs(py_import,
                name, global_dict, empty_dict, list, py_level, NULL);
            Py_DECREF(py_level);
            #else
            module = PyImport_ImportModuleLevelObject(
                name, global_dict, empty_dict, list, level);
            #endif
        }
    }
    #else
    if (level>0) {
        PyErr_SetString(PyExc_RuntimeError, "Relative import is not supported for Python <=2.4.");
        goto bad;
    }
    module = PyObject_CallFunctionObjArgs(py_import,
        name, global_dict, empty_dict, list, NULL);
    #endif
bad:
    #if PY_VERSION_HEX < 0x03030000
    Py_XDECREF(py_import);
    #endif
    Py_XDECREF(empty_list);
    Py_XDECREF(empty_dict);
    return module;
}

#if CYTHON_CCOMPLEX
  #ifdef __cplusplus
    static CYTHON_INLINE __pyx_t_float_complex __pyx_t_float_complex_from_parts(float x, float y) {
      return ::std::complex< float >(x, y);
    }
  #else
    static CYTHON_INLINE __pyx_t_float_complex __pyx_t_float_complex_from_parts(float x, float y) {
      return x + y*(__pyx_t_float_complex)_Complex_I;
    }
  #endif
#else
    static CYTHON_INLINE __pyx_t_float_complex __pyx_t_float_complex_from_parts(float x, float y) {
      __pyx_t_float_complex z;
      z.real = x;
      z.imag = y;
      return z;
    }
#endif

#if CYTHON_CCOMPLEX
#else
    static CYTHON_INLINE int __Pyx_c_eqf(__pyx_t_float_complex a, __pyx_t_float_complex b) {
       return (a.real == b.real) && (a.imag == b.imag);
    }
    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_sumf(__pyx_t_float_complex a, __pyx_t_float_complex b) {
        __pyx_t_float_complex z;
        z.real = a.real + b.real;
        z.imag = a.imag + b.imag;
        return z;
    }
    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_difff(__pyx_t_float_complex a, __pyx_t_float_complex b) {
        __pyx_t_float_complex z;
        z.real = a.real - b.real;
        z.imag = a.imag - b.imag;
        return z;
    }
    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_prodf(__pyx_t_float_complex a, __pyx_t_float_complex b) {
        __pyx_t_float_complex z;
        z.real = a.real * b.real - a.imag * b.imag;
        z.imag = a.real * b.imag + a.imag * b.real;
        return z;
    }
    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_quotf(__pyx_t_float_complex a, __pyx_t_float_complex b) {
        __pyx_t_float_complex z;
        float denom = b.real * b.real + b.imag * b.imag;
        z.real = (a.real * b.real + a.imag * b.imag) / denom;
        z.imag = (a.imag * b.real - a.real * b.imag) / denom;
        return z;
    }
    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_negf(__pyx_t_float_complex a) {
        __pyx_t_float_complex z;
        z.real = -a.real;
        z.imag = -a.imag;
        return z;
    }
    static CYTHON_INLINE int __Pyx_c_is_zerof(__pyx_t_float_complex a) {
       return (a.real == 0) && (a.imag == 0);
    }
    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_conjf(__pyx_t_float_complex a) {
        __pyx_t_float_complex z;
        z.real =  a.real;
        z.imag = -a.imag;
        return z;
    }
    #if 1
        static CYTHON_INLINE float __Pyx_c_absf(__pyx_t_float_complex z) {
          #if !defined(HAVE_HYPOT) || defined(_MSC_VER)
            return sqrtf(z.real*z.real + z.imag*z.imag);
          #else
            return hypotf(z.real, z.imag);
          #endif
        }
        static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_powf(__pyx_t_float_complex a, __pyx_t_float_complex b) {
            __pyx_t_float_complex z;
            float r, lnr, theta, z_r, z_theta;
            if (b.imag == 0 && b.real == (int)b.real) {
                if (b.real < 0) {
                    float denom = a.real * a.real + a.imag * a.imag;
                    a.real = a.real / denom;
                    a.imag = -a.imag / denom;
                    b.real = -b.real;
                }
                switch ((int)b.real) {
                    case 0:
                        z.real = 1;
                        z.imag = 0;
                        return z;
                    case 1:
                        return a;
                    case 2:
                        z = __Pyx_c_prodf(a, a);
                        return __Pyx_c_prodf(a, a);
                    case 3:
                        z = __Pyx_c_prodf(a, a);
                        return __Pyx_c_prodf(z, a);
                    case 4:
                        z = __Pyx_c_prodf(a, a);
                        return __Pyx_c_prodf(z, z);
                }
            }
            if (a.imag == 0) {
                if (a.real == 0) {
                    return a;
                }
                r = a.real;
                theta = 0;
            } else {
                r = __Pyx_c_absf(a);
                theta = atan2f(a.imag, a.real);
            }
            lnr = logf(r);
            z_r = expf(lnr * b.real - theta * b.imag);
            z_theta = theta * b.real + lnr * b.imag;
            z.real = z_r * cosf(z_theta);
            z.imag = z_r * sinf(z_theta);
            return z;
        }
    #endif
#endif

#if CYTHON_CCOMPLEX
  #ifdef __cplusplus
    static CYTHON_INLINE __pyx_t_double_complex __pyx_t_double_complex_from_parts(double x, double y) {
      return ::std::complex< double >(x, y);
    }
  #else
    static CYTHON_INLINE __pyx_t_double_complex __pyx_t_double_complex_from_parts(double x, double y) {
      return x + y*(__pyx_t_double_complex)_Complex_I;
    }
  #endif
#else
    static CYTHON_INLINE __pyx_t_double_complex __pyx_t_double_complex_from_parts(double x, double y) {
      __pyx_t_double_complex z;
      z.real = x;
      z.imag = y;
      return z;
    }
#endif

#if CYTHON_CCOMPLEX
#else
    static CYTHON_INLINE int __Pyx_c_eq(__pyx_t_double_complex a, __pyx_t_double_complex b) {
       return (a.real == b.real) && (a.imag == b.imag);
    }
    static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_sum(__pyx_t_double_complex a, __pyx_t_double_complex b) {
        __pyx_t_double_complex z;
        z.real = a.real + b.real;
        z.imag = a.imag + b.imag;
        return z;
    }
    static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_diff(__pyx_t_double_complex a, __pyx_t_double_complex b) {
        __pyx_t_double_complex z;
        z.real = a.real - b.real;
        z.imag = a.imag - b.imag;
        return z;
    }
    static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_prod(__pyx_t_double_complex a, __pyx_t_double_complex b) {
        __pyx_t_double_complex z;
        z.real = a.real * b.real - a.imag * b.imag;
        z.imag = a.real * b.imag + a.imag * b.real;
        return z;
    }
    static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_quot(__pyx_t_double_complex a, __pyx_t_double_complex b) {
        __pyx_t_double_complex z;
        double denom = b.real * b.real + b.imag * b.imag;
        z.real = (a.real * b.real + a.imag * b.imag) / denom;
        z.imag = (a.imag * b.real - a.real * b.imag) / denom;
        return z;
    }
    static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_neg(__pyx_t_double_complex a) {
        __pyx_t_double_complex z;
        z.real = -a.real;
        z.imag = -a.imag;
        return z;
    }
    static CYTHON_INLINE int __Pyx_c_is_zero(__pyx_t_double_complex a) {
       return (a.real == 0) && (a.imag == 0);
    }
    static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_conj(__pyx_t_double_complex a) {
        __pyx_t_double_complex z;
        z.real =  a.real;
        z.imag = -a.imag;
        return z;
    }
    #if 1
        static CYTHON_INLINE double __Pyx_c_abs(__pyx_t_double_complex z) {
          #if !defined(HAVE_HYPOT) || defined(_MSC_VER)
            return sqrt(z.real*z.real + z.imag*z.imag);
          #else
            return hypot(z.real, z.imag);
          #endif
        }
        static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_pow(__pyx_t_double_complex a, __pyx_t_double_complex b) {
            __pyx_t_double_complex z;
            double r, lnr, theta, z_r, z_theta;
            if (b.imag == 0 && b.real == (int)b.real) {
                if (b.real < 0) {
                    double denom = a.real * a.real + a.imag * a.imag;
                    a.real = a.real / denom;
                    a.imag = -a.imag / denom;
                    b.real = -b.real;
                }
                switch ((int)b.real) {
                    case 0:
                        z.real = 1;
                        z.imag = 0;
                        return z;
                    case 1:
                        return a;
                    case 2:
                        z = __Pyx_c_prod(a, a);
                        return __Pyx_c_prod(a, a);
                    case 3:
                        z = __Pyx_c_prod(a, a);
                        return __Pyx_c_prod(z, a);
                    case 4:
                        z = __Pyx_c_prod(a, a);
                        return __Pyx_c_prod(z, z);
                }
            }
            if (a.imag == 0) {
                if (a.real == 0) {
                    return a;
                }
                r = a.real;
                theta = 0;
            } else {
                r = __Pyx_c_abs(a);
                theta = atan2(a.imag, a.real);
            }
            lnr = log(r);
            z_r = exp(lnr * b.real - theta * b.imag);
            z_theta = theta * b.real + lnr * b.imag;
            z.real = z_r * cos(z_theta);
            z.imag = z_r * sin(z_theta);
            return z;
        }
    #endif
#endif

static CYTHON_INLINE unsigned char __Pyx_PyInt_AsUnsignedChar(PyObject* x) {
    const unsigned char neg_one = (unsigned char)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(unsigned char) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(unsigned char)val)) {
            if (!unlikely(val == -1 && PyErr_Occurred())) {
                PyErr_SetString(PyExc_OverflowError,
                    (is_unsigned && unlikely(val < 0)) ?
                    "can't convert negative value to unsigned char" :
                    "value too large to convert to unsigned char");
            }
            return (unsigned char)-1;
        }
        return (unsigned char)val;
    }
    return (unsigned char)__Pyx_PyInt_AsUnsignedLong(x);
}

static CYTHON_INLINE unsigned short __Pyx_PyInt_AsUnsignedShort(PyObject* x) {
    const unsigned short neg_one = (unsigned short)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(unsigned short) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(unsigned short)val)) {
            if (!unlikely(val == -1 && PyErr_Occurred())) {
                PyErr_SetString(PyExc_OverflowError,
                    (is_unsigned && unlikely(val < 0)) ?
                    "can't convert negative value to unsigned short" :
                    "value too large to convert to unsigned short");
            }
            return (unsigned short)-1;
        }
        return (unsigned short)val;
    }
    return (unsigned short)__Pyx_PyInt_AsUnsignedLong(x);
}

static CYTHON_INLINE unsigned int __Pyx_PyInt_AsUnsignedInt(PyObject* x) {
    const unsigned int neg_one = (unsigned int)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(unsigned int) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(unsigned int)val)) {
            if (!unlikely(val == -1 && PyErr_Occurred())) {
                PyErr_SetString(PyExc_OverflowError,
                    (is_unsigned && unlikely(val < 0)) ?
                    "can't convert negative value to unsigned int" :
                    "value too large to convert to unsigned int");
            }
            return (unsigned int)-1;
        }
        return (unsigned int)val;
    }
    return (unsigned int)__Pyx_PyInt_AsUnsignedLong(x);
}

static CYTHON_INLINE char __Pyx_PyInt_AsChar(PyObject* x) {
    const char neg_one = (char)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(char) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(char)val)) {
            if (!unlikely(val == -1 && PyErr_Occurred())) {
                PyErr_SetString(PyExc_OverflowError,
                    (is_unsigned && unlikely(val < 0)) ?
                    "can't convert negative value to char" :
                    "value too large to convert to char");
            }
            return (char)-1;
        }
        return (char)val;
    }
    return (char)__Pyx_PyInt_AsLong(x);
}

static CYTHON_INLINE short __Pyx_PyInt_AsShort(PyObject* x) {
    const short neg_one = (short)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(short) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(short)val)) {
            if (!unlikely(val == -1 && PyErr_Occurred())) {
                PyErr_SetString(PyExc_OverflowError,
                    (is_unsigned && unlikely(val < 0)) ?
                    "can't convert negative value to short" :
                    "value too large to convert to short");
            }
            return (short)-1;
        }
        return (short)val;
    }
    return (short)__Pyx_PyInt_AsLong(x);
}

static CYTHON_INLINE int __Pyx_PyInt_AsInt(PyObject* x) {
    const int neg_one = (int)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(int) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(int)val)) {
            if (!unlikely(val == -1 && PyErr_Occurred())) {
                PyErr_SetString(PyExc_OverflowError,
                    (is_unsigned && unlikely(val < 0)) ?
                    "can't convert negative value to int" :
                    "value too large to convert to int");
            }
            return (int)-1;
        }
        return (int)val;
    }
    return (int)__Pyx_PyInt_AsLong(x);
}

static CYTHON_INLINE signed char __Pyx_PyInt_AsSignedChar(PyObject* x) {
    const signed char neg_one = (signed char)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(signed char) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(signed char)val)) {
            if (!unlikely(val == -1 && PyErr_Occurred())) {
                PyErr_SetString(PyExc_OverflowError,
                    (is_unsigned && unlikely(val < 0)) ?
                    "can't convert negative value to signed char" :
                    "value too large to convert to signed char");
            }
            return (signed char)-1;
        }
        return (signed char)val;
    }
    return (signed char)__Pyx_PyInt_AsSignedLong(x);
}

static CYTHON_INLINE signed short __Pyx_PyInt_AsSignedShort(PyObject* x) {
    const signed short neg_one = (signed short)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(signed short) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(signed short)val)) {
            if (!unlikely(val == -1 && PyErr_Occurred())) {
                PyErr_SetString(PyExc_OverflowError,
                    (is_unsigned && unlikely(val < 0)) ?
                    "can't convert negative value to signed short" :
                    "value too large to convert to signed short");
            }
            return (signed short)-1;
        }
        return (signed short)val;
    }
    return (signed short)__Pyx_PyInt_AsSignedLong(x);
}

static CYTHON_INLINE signed int __Pyx_PyInt_AsSignedInt(PyObject* x) {
    const signed int neg_one = (signed int)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(signed int) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(signed int)val)) {
            if (!unlikely(val == -1 && PyErr_Occurred())) {
                PyErr_SetString(PyExc_OverflowError,
                    (is_unsigned && unlikely(val < 0)) ?
                    "can't convert negative value to signed int" :
                    "value too large to convert to signed int");
            }
            return (signed int)-1;
        }
        return (signed int)val;
    }
    return (signed int)__Pyx_PyInt_AsSignedLong(x);
}

static CYTHON_INLINE int __Pyx_PyInt_AsLongDouble(PyObject* x) {
    const int neg_one = (int)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(int) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(int)val)) {
            if (!unlikely(val == -1 && PyErr_Occurred())) {
                PyErr_SetString(PyExc_OverflowError,
                    (is_unsigned && unlikely(val < 0)) ?
                    "can't convert negative value to int" :
                    "value too large to convert to int");
            }
            return (int)-1;
        }
        return (int)val;
    }
    return (int)__Pyx_PyInt_AsLong(x);
}

#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
#if CYTHON_USE_PYLONG_INTERNALS
#include "longintrepr.h"
#endif
#endif
static CYTHON_INLINE unsigned long __Pyx_PyInt_AsUnsignedLong(PyObject* x) {
    const unsigned long neg_one = (unsigned long)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        long val = PyInt_AS_LONG(x);
        if (is_unsigned && unlikely(val < 0)) {
            PyErr_SetString(PyExc_OverflowError,
                            "can't convert negative value to unsigned long");
            return (unsigned long)-1;
        }
        return (unsigned long)val;
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
#if CYTHON_USE_PYLONG_INTERNALS
            if (sizeof(digit) <= sizeof(unsigned long)) {
                switch (Py_SIZE(x)) {
                    case  0: return 0;
                    case  1: return (unsigned long) ((PyLongObject*)x)->ob_digit[0];
                }
            }
#endif
#endif
            if (unlikely(Py_SIZE(x) < 0)) {
                PyErr_SetString(PyExc_OverflowError,
                                "can't convert negative value to unsigned long");
                return (unsigned long)-1;
            }
            return (unsigned long)PyLong_AsUnsignedLong(x);
        } else {
#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
#if CYTHON_USE_PYLONG_INTERNALS
            if (sizeof(digit) <= sizeof(unsigned long)) {
                switch (Py_SIZE(x)) {
                    case  0: return 0;
                    case  1: return +(unsigned long) ((PyLongObject*)x)->ob_digit[0];
                    case -1: return -(unsigned long) ((PyLongObject*)x)->ob_digit[0];
                }
            }
#endif
#endif
            return (unsigned long)PyLong_AsLong(x);
        }
    } else {
        unsigned long val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (unsigned long)-1;
        val = __Pyx_PyInt_AsUnsignedLong(tmp);
        Py_DECREF(tmp);
        return val;
    }
}

#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
#if CYTHON_USE_PYLONG_INTERNALS
#include "longintrepr.h"
#endif
#endif
static CYTHON_INLINE unsigned PY_LONG_LONG __Pyx_PyInt_AsUnsignedLongLong(PyObject* x) {
    const unsigned PY_LONG_LONG neg_one = (unsigned PY_LONG_LONG)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        long val = PyInt_AS_LONG(x);
        if (is_unsigned && unlikely(val < 0)) {
            PyErr_SetString(PyExc_OverflowError,
                            "can't convert negative value to unsigned PY_LONG_LONG");
            return (unsigned PY_LONG_LONG)-1;
        }
        return (unsigned PY_LONG_LONG)val;
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
#if CYTHON_USE_PYLONG_INTERNALS
            if (sizeof(digit) <= sizeof(unsigned PY_LONG_LONG)) {
                switch (Py_SIZE(x)) {
                    case  0: return 0;
                    case  1: return (unsigned PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
                }
            }
#endif
#endif
            if (unlikely(Py_SIZE(x) < 0)) {
                PyErr_SetString(PyExc_OverflowError,
                                "can't convert negative value to unsigned PY_LONG_LONG");
                return (unsigned PY_LONG_LONG)-1;
            }
            return (unsigned PY_LONG_LONG)PyLong_AsUnsignedLongLong(x);
        } else {
#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
#if CYTHON_USE_PYLONG_INTERNALS
            if (sizeof(digit) <= sizeof(unsigned PY_LONG_LONG)) {
                switch (Py_SIZE(x)) {
                    case  0: return 0;
                    case  1: return +(unsigned PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
                    case -1: return -(unsigned PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
                }
            }
#endif
#endif
            return (unsigned PY_LONG_LONG)PyLong_AsLongLong(x);
        }
    } else {
        unsigned PY_LONG_LONG val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (unsigned PY_LONG_LONG)-1;
        val = __Pyx_PyInt_AsUnsignedLongLong(tmp);
        Py_DECREF(tmp);
        return val;
    }
}

#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
#if CYTHON_USE_PYLONG_INTERNALS
#include "longintrepr.h"
#endif
#endif
static CYTHON_INLINE long __Pyx_PyInt_AsLong(PyObject* x) {
    const long neg_one = (long)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        long val = PyInt_AS_LONG(x);
        if (is_unsigned && unlikely(val < 0)) {
            PyErr_SetString(PyExc_OverflowError,
                            "can't convert negative value to long");
            return (long)-1;
        }
        return (long)val;
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
#if CYTHON_USE_PYLONG_INTERNALS
            if (sizeof(digit) <= sizeof(long)) {
                switch (Py_SIZE(x)) {
                    case  0: return 0;
                    case  1: return (long) ((PyLongObject*)x)->ob_digit[0];
                }
            }
#endif
#endif
            if (unlikely(Py_SIZE(x) < 0)) {
                PyErr_SetString(PyExc_OverflowError,
                                "can't convert negative value to long");
                return (long)-1;
            }
            return (long)PyLong_AsUnsignedLong(x);
        } else {
#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
#if CYTHON_USE_PYLONG_INTERNALS
            if (sizeof(digit) <= sizeof(long)) {
                switch (Py_SIZE(x)) {
                    case  0: return 0;
                    case  1: return +(long) ((PyLongObject*)x)->ob_digit[0];
                    case -1: return -(long) ((PyLongObject*)x)->ob_digit[0];
                }
            }
#endif
#endif
            return (long)PyLong_AsLong(x);
        }
    } else {
        long val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (long)-1;
        val = __Pyx_PyInt_AsLong(tmp);
        Py_DECREF(tmp);
        return val;
    }
}

#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
#if CYTHON_USE_PYLONG_INTERNALS
#include "longintrepr.h"
#endif
#endif
static CYTHON_INLINE PY_LONG_LONG __Pyx_PyInt_AsLongLong(PyObject* x) {
    const PY_LONG_LONG neg_one = (PY_LONG_LONG)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        long val = PyInt_AS_LONG(x);
        if (is_unsigned && unlikely(val < 0)) {
            PyErr_SetString(PyExc_OverflowError,
                            "can't convert negative value to PY_LONG_LONG");
            return (PY_LONG_LONG)-1;
        }
        return (PY_LONG_LONG)val;
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
#if CYTHON_USE_PYLONG_INTERNALS
            if (sizeof(digit) <= sizeof(PY_LONG_LONG)) {
                switch (Py_SIZE(x)) {
                    case  0: return 0;
                    case  1: return (PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
                }
            }
#endif
#endif
            if (unlikely(Py_SIZE(x) < 0)) {
                PyErr_SetString(PyExc_OverflowError,
                                "can't convert negative value to PY_LONG_LONG");
                return (PY_LONG_LONG)-1;
            }
            return (PY_LONG_LONG)PyLong_AsUnsignedLongLong(x);
        } else {
#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
#if CYTHON_USE_PYLONG_INTERNALS
            if (sizeof(digit) <= sizeof(PY_LONG_LONG)) {
                switch (Py_SIZE(x)) {
                    case  0: return 0;
                    case  1: return +(PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
                    case -1: return -(PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
                }
            }
#endif
#endif
            return (PY_LONG_LONG)PyLong_AsLongLong(x);
        }
    } else {
        PY_LONG_LONG val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (PY_LONG_LONG)-1;
        val = __Pyx_PyInt_AsLongLong(tmp);
        Py_DECREF(tmp);
        return val;
    }
}

#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
#if CYTHON_USE_PYLONG_INTERNALS
#include "longintrepr.h"
#endif
#endif
static CYTHON_INLINE signed long __Pyx_PyInt_AsSignedLong(PyObject* x) {
    const signed long neg_one = (signed long)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        long val = PyInt_AS_LONG(x);
        if (is_unsigned && unlikely(val < 0)) {
            PyErr_SetString(PyExc_OverflowError,
                            "can't convert negative value to signed long");
            return (signed long)-1;
        }
        return (signed long)val;
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
#if CYTHON_USE_PYLONG_INTERNALS
            if (sizeof(digit) <= sizeof(signed long)) {
                switch (Py_SIZE(x)) {
                    case  0: return 0;
                    case  1: return (signed long) ((PyLongObject*)x)->ob_digit[0];
                }
            }
#endif
#endif
            if (unlikely(Py_SIZE(x) < 0)) {
                PyErr_SetString(PyExc_OverflowError,
                                "can't convert negative value to signed long");
                return (signed long)-1;
            }
            return (signed long)PyLong_AsUnsignedLong(x);
        } else {
#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
#if CYTHON_USE_PYLONG_INTERNALS
            if (sizeof(digit) <= sizeof(signed long)) {
                switch (Py_SIZE(x)) {
                    case  0: return 0;
                    case  1: return +(signed long) ((PyLongObject*)x)->ob_digit[0];
                    case -1: return -(signed long) ((PyLongObject*)x)->ob_digit[0];
                }
            }
#endif
#endif
            return (signed long)PyLong_AsLong(x);
        }
    } else {
        signed long val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (signed long)-1;
        val = __Pyx_PyInt_AsSignedLong(tmp);
        Py_DECREF(tmp);
        return val;
    }
}

#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
#if CYTHON_USE_PYLONG_INTERNALS
#include "longintrepr.h"
#endif
#endif
static CYTHON_INLINE signed PY_LONG_LONG __Pyx_PyInt_AsSignedLongLong(PyObject* x) {
    const signed PY_LONG_LONG neg_one = (signed PY_LONG_LONG)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        long val = PyInt_AS_LONG(x);
        if (is_unsigned && unlikely(val < 0)) {
            PyErr_SetString(PyExc_OverflowError,
                            "can't convert negative value to signed PY_LONG_LONG");
            return (signed PY_LONG_LONG)-1;
        }
        return (signed PY_LONG_LONG)val;
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
#if CYTHON_USE_PYLONG_INTERNALS
            if (sizeof(digit) <= sizeof(signed PY_LONG_LONG)) {
                switch (Py_SIZE(x)) {
                    case  0: return 0;
                    case  1: return (signed PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
                }
            }
#endif
#endif
            if (unlikely(Py_SIZE(x) < 0)) {
                PyErr_SetString(PyExc_OverflowError,
                                "can't convert negative value to signed PY_LONG_LONG");
                return (signed PY_LONG_LONG)-1;
            }
            return (signed PY_LONG_LONG)PyLong_AsUnsignedLongLong(x);
        } else {
#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
#if CYTHON_USE_PYLONG_INTERNALS
            if (sizeof(digit) <= sizeof(signed PY_LONG_LONG)) {
                switch (Py_SIZE(x)) {
                    case  0: return 0;
                    case  1: return +(signed PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
                    case -1: return -(signed PY_LONG_LONG) ((PyLongObject*)x)->ob_digit[0];
                }
            }
#endif
#endif
            return (signed PY_LONG_LONG)PyLong_AsLongLong(x);
        }
    } else {
        signed PY_LONG_LONG val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (signed PY_LONG_LONG)-1;
        val = __Pyx_PyInt_AsSignedLongLong(tmp);
        Py_DECREF(tmp);
        return val;
    }
}

static int __Pyx_check_binary_version(void) {
    char ctversion[4], rtversion[4];
    PyOS_snprintf(ctversion, 4, "%d.%d", PY_MAJOR_VERSION, PY_MINOR_VERSION);
    PyOS_snprintf(rtversion, 4, "%s", Py_GetVersion());
    if (ctversion[0] != rtversion[0] || ctversion[2] != rtversion[2]) {
        char message[200];
        PyOS_snprintf(message, sizeof(message),
                      "compiletime version %s of module '%.100s' "
                      "does not match runtime version %s",
                      ctversion, __Pyx_MODULE_NAME, rtversion);
        #if PY_VERSION_HEX < 0x02050000
        return PyErr_Warn(NULL, message);
        #else
        return PyErr_WarnEx(NULL, message, 1);
        #endif
    }
    return 0;
}

#ifndef __PYX_HAVE_RT_ImportModule
#define __PYX_HAVE_RT_ImportModule
static PyObject *__Pyx_ImportModule(const char *name) {
    PyObject *py_name = 0;
    PyObject *py_module = 0;
    py_name = __Pyx_PyIdentifier_FromString(name);
    if (!py_name)
        goto bad;
    py_module = PyImport_Import(py_name);
    Py_DECREF(py_name);
    return py_module;
bad:
    Py_XDECREF(py_name);
    return 0;
}
#endif

#ifndef __PYX_HAVE_RT_ImportType
#define __PYX_HAVE_RT_ImportType
static PyTypeObject *__Pyx_ImportType(const char *module_name, const char *class_name,
    size_t size, int strict)
{
    PyObject *py_module = 0;
    PyObject *result = 0;
    PyObject *py_name = 0;
    char warning[200];
    Py_ssize_t basicsize;
#ifdef Py_LIMITED_API
    PyObject *py_basicsize;
#endif
    py_module = __Pyx_ImportModule(module_name);
    if (!py_module)
        goto bad;
    py_name = __Pyx_PyIdentifier_FromString(class_name);
    if (!py_name)
        goto bad;
    result = PyObject_GetAttr(py_module, py_name);
    Py_DECREF(py_name);
    py_name = 0;
    Py_DECREF(py_module);
    py_module = 0;
    if (!result)
        goto bad;
    if (!PyType_Check(result)) {
        PyErr_Format(PyExc_TypeError,
            "%s.%s is not a type object",
            module_name, class_name);
        goto bad;
    }
#ifndef Py_LIMITED_API
    basicsize = ((PyTypeObject *)result)->tp_basicsize;
#else
    py_basicsize = PyObject_GetAttrString(result, "__basicsize__");
    if (!py_basicsize)
        goto bad;
    basicsize = PyLong_AsSsize_t(py_basicsize);
    Py_DECREF(py_basicsize);
    py_basicsize = 0;
    if (basicsize == (Py_ssize_t)-1 && PyErr_Occurred())
        goto bad;
#endif
    if (!strict && (size_t)basicsize > size) {
        PyOS_snprintf(warning, sizeof(warning),
            "%s.%s size changed, may indicate binary incompatibility",
            module_name, class_name);
        #if PY_VERSION_HEX < 0x02050000
        if (PyErr_Warn(NULL, warning) < 0) goto bad;
        #else
        if (PyErr_WarnEx(NULL, warning, 0) < 0) goto bad;
        #endif
    }
    else if ((size_t)basicsize != size) {
        PyErr_Format(PyExc_ValueError,
            "%s.%s has the wrong size, try recompiling",
            module_name, class_name);
        goto bad;
    }
    return (PyTypeObject *)result;
bad:
    Py_XDECREF(py_module);
    Py_XDECREF(result);
    return NULL;
}
#endif

static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line) {
    int start = 0, mid = 0, end = count - 1;
    if (end >= 0 && code_line > entries[end].code_line) {
        return count;
    }
    while (start < end) {
        mid = (start + end) / 2;
        if (code_line < entries[mid].code_line) {
            end = mid;
        } else if (code_line > entries[mid].code_line) {
             start = mid + 1;
        } else {
            return mid;
        }
    }
    if (code_line <= entries[mid].code_line) {
        return mid;
    } else {
        return mid + 1;
    }
}
static PyCodeObject *__pyx_find_code_object(int code_line) {
    PyCodeObject* code_object;
    int pos;
    if (unlikely(!code_line) || unlikely(!__pyx_code_cache.entries)) {
        return NULL;
    }
    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
    if (unlikely(pos >= __pyx_code_cache.count) || unlikely(__pyx_code_cache.entries[pos].code_line != code_line)) {
        return NULL;
    }
    code_object = __pyx_code_cache.entries[pos].code_object;
    Py_INCREF(code_object);
    return code_object;
}
static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object) {
    int pos, i;
    __Pyx_CodeObjectCacheEntry* entries = __pyx_code_cache.entries;
    if (unlikely(!code_line)) {
        return;
    }
    if (unlikely(!entries)) {
        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Malloc(64*sizeof(__Pyx_CodeObjectCacheEntry));
        if (likely(entries)) {
            __pyx_code_cache.entries = entries;
            __pyx_code_cache.max_count = 64;
            __pyx_code_cache.count = 1;
            entries[0].code_line = code_line;
            entries[0].code_object = code_object;
            Py_INCREF(code_object);
        }
        return;
    }
    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
    if ((pos < __pyx_code_cache.count) && unlikely(__pyx_code_cache.entries[pos].code_line == code_line)) {
        PyCodeObject* tmp = entries[pos].code_object;
        entries[pos].code_object = code_object;
        Py_DECREF(tmp);
        return;
    }
    if (__pyx_code_cache.count == __pyx_code_cache.max_count) {
        int new_max = __pyx_code_cache.max_count + 64;
        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Realloc(
            __pyx_code_cache.entries, new_max*sizeof(__Pyx_CodeObjectCacheEntry));
        if (unlikely(!entries)) {
            return;
        }
        __pyx_code_cache.entries = entries;
        __pyx_code_cache.max_count = new_max;
    }
    for (i=__pyx_code_cache.count; i>pos; i--) {
        entries[i] = entries[i-1];
    }
    entries[pos].code_line = code_line;
    entries[pos].code_object = code_object;
    __pyx_code_cache.count++;
    Py_INCREF(code_object);
}

#include "compile.h"
#include "frameobject.h"
#include "traceback.h"
static PyCodeObject* __Pyx_CreateCodeObjectForTraceback(
            const char *funcname, int c_line,
            int py_line, const char *filename) {
    PyCodeObject *py_code = 0;
    PyObject *py_srcfile = 0;
    PyObject *py_funcname = 0;
    #if PY_MAJOR_VERSION < 3
    py_srcfile = PyString_FromString(filename);
    #else
    py_srcfile = PyUnicode_FromString(filename);
    #endif
    if (!py_srcfile) goto bad;
    if (c_line) {
        #if PY_MAJOR_VERSION < 3
        py_funcname = PyString_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
        #else
        py_funcname = PyUnicode_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
        #endif
    }
    else {
        #if PY_MAJOR_VERSION < 3
        py_funcname = PyString_FromString(funcname);
        #else
        py_funcname = PyUnicode_FromString(funcname);
        #endif
    }
    if (!py_funcname) goto bad;
    py_code = __Pyx_PyCode_New(
        0,            /*int argcount,*/
        0,            /*int kwonlyargcount,*/
        0,            /*int nlocals,*/
        0,            /*int stacksize,*/
        0,            /*int flags,*/
        __pyx_empty_bytes, /*PyObject *code,*/
        __pyx_empty_tuple, /*PyObject *consts,*/
        __pyx_empty_tuple, /*PyObject *names,*/
        __pyx_empty_tuple, /*PyObject *varnames,*/
        __pyx_empty_tuple, /*PyObject *freevars,*/
        __pyx_empty_tuple, /*PyObject *cellvars,*/
        py_srcfile,   /*PyObject *filename,*/
        py_funcname,  /*PyObject *name,*/
        py_line,      /*int firstlineno,*/
        __pyx_empty_bytes  /*PyObject *lnotab*/
    );
    Py_DECREF(py_srcfile);
    Py_DECREF(py_funcname);
    return py_code;
bad:
    Py_XDECREF(py_srcfile);
    Py_XDECREF(py_funcname);
    return NULL;
}
static void __Pyx_AddTraceback(const char *funcname, int c_line,
                               int py_line, const char *filename) {
    PyCodeObject *py_code = 0;
    PyObject *py_globals = 0;
    PyFrameObject *py_frame = 0;
    py_code = __pyx_find_code_object(c_line ? c_line : py_line);
    if (!py_code) {
        py_code = __Pyx_CreateCodeObjectForTraceback(
            funcname, c_line, py_line, filename);
        if (!py_code) goto bad;
        __pyx_insert_code_object(c_line ? c_line : py_line, py_code);
    }
    py_globals = PyModule_GetDict(__pyx_m);
    if (!py_globals) goto bad;
    py_frame = PyFrame_New(
        PyThreadState_GET(), /*PyThreadState *tstate,*/
        py_code,             /*PyCodeObject *code,*/
        py_globals,          /*PyObject *globals,*/
        0                    /*PyObject *locals*/
    );
    if (!py_frame) goto bad;
    py_frame->f_lineno = py_line;
    PyTraceBack_Here(py_frame);
bad:
    Py_XDECREF(py_code);
    Py_XDECREF(py_frame);
}

static int __Pyx_InitStrings(__Pyx_StringTabEntry *t) {
    while (t->p) {
        #if PY_MAJOR_VERSION < 3
        if (t->is_unicode) {
            *t->p = PyUnicode_DecodeUTF8(t->s, t->n - 1, NULL);
        } else if (t->intern) {
            *t->p = PyString_InternFromString(t->s);
        } else {
            *t->p = PyString_FromStringAndSize(t->s, t->n - 1);
        }
        #else  /* Python 3+ has unicode identifiers */
        if (t->is_unicode | t->is_str) {
            if (t->intern) {
                *t->p = PyUnicode_InternFromString(t->s);
            } else if (t->encoding) {
                *t->p = PyUnicode_Decode(t->s, t->n - 1, t->encoding, NULL);
            } else {
                *t->p = PyUnicode_FromStringAndSize(t->s, t->n - 1);
            }
        } else {
            *t->p = PyBytes_FromStringAndSize(t->s, t->n - 1);
        }
        #endif
        if (!*t->p)
            return -1;
        ++t;
    }
    return 0;
}

static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(char* c_str) {
    return __Pyx_PyUnicode_FromStringAndSize(c_str, strlen(c_str));
}
static CYTHON_INLINE char* __Pyx_PyObject_AsString(PyObject* o) {
    Py_ssize_t ignore;
    return __Pyx_PyObject_AsStringAndSize(o, &ignore);
}
static CYTHON_INLINE char* __Pyx_PyObject_AsStringAndSize(PyObject* o, Py_ssize_t *length) {
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
    if (
#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
            __Pyx_sys_getdefaultencoding_not_ascii &&
#endif
            PyUnicode_Check(o)) {
#if PY_VERSION_HEX < 0x03030000
        char* defenc_c;
        PyObject* defenc = _PyUnicode_AsDefaultEncodedString(o, NULL);
        if (!defenc) return NULL;
        defenc_c = PyBytes_AS_STRING(defenc);
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
        {
            char* end = defenc_c + PyBytes_GET_SIZE(defenc);
            char* c;
            for (c = defenc_c; c < end; c++) {
                if ((unsigned char) (*c) >= 128) {
                    PyUnicode_AsASCIIString(o);
                    return NULL;
                }
            }
        }
#endif /*__PYX_DEFAULT_STRING_ENCODING_IS_ASCII*/
        *length = PyBytes_GET_SIZE(defenc);
        return defenc_c;
#else /* PY_VERSION_HEX < 0x03030000 */
        if (PyUnicode_READY(o) == -1) return NULL;
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
        if (PyUnicode_IS_ASCII(o)) {
            *length = PyUnicode_GET_DATA_SIZE(o);
            return PyUnicode_AsUTF8(o);
        } else {
            PyUnicode_AsASCIIString(o);
            return NULL;
        }
#else /* __PYX_DEFAULT_STRING_ENCODING_IS_ASCII */
        return PyUnicode_AsUTF8AndSize(o, length);
#endif /* __PYX_DEFAULT_STRING_ENCODING_IS_ASCII */
#endif /* PY_VERSION_HEX < 0x03030000 */
    } else
#endif /* __PYX_DEFAULT_STRING_ENCODING_IS_ASCII  || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT */
    {
        char* result;
        int r = PyBytes_AsStringAndSize(o, &result, length);
        if (r < 0) {
            return NULL;
        } else {
            return result;
        }
    }
}
static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject* x) {
   int is_true = x == Py_True;
   if (is_true | (x == Py_False) | (x == Py_None)) return is_true;
   else return PyObject_IsTrue(x);
}
static CYTHON_INLINE PyObject* __Pyx_PyNumber_Int(PyObject* x) {
  PyNumberMethods *m;
  const char *name = NULL;
  PyObject *res = NULL;
#if PY_MAJOR_VERSION < 3
  if (PyInt_Check(x) || PyLong_Check(x))
#else
  if (PyLong_Check(x))
#endif
    return Py_INCREF(x), x;
  m = Py_TYPE(x)->tp_as_number;
#if PY_MAJOR_VERSION < 3
  if (m && m->nb_int) {
    name = "int";
    res = PyNumber_Int(x);
  }
  else if (m && m->nb_long) {
    name = "long";
    res = PyNumber_Long(x);
  }
#else
  if (m && m->nb_int) {
    name = "int";
    res = PyNumber_Long(x);
  }
#endif
  if (res) {
#if PY_MAJOR_VERSION < 3
    if (!PyInt_Check(res) && !PyLong_Check(res)) {
#else
    if (!PyLong_Check(res)) {
#endif
      PyErr_Format(PyExc_TypeError,
                   "__%s__ returned non-%s (type %.200s)",
                   name, name, Py_TYPE(res)->tp_name);
      Py_DECREF(res);
      return NULL;
    }
  }
  else if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
                    "an integer is required");
  }
  return res;
}
static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject* b) {
  Py_ssize_t ival;
  PyObject* x = PyNumber_Index(b);
  if (!x) return -1;
  ival = PyInt_AsSsize_t(x);
  Py_DECREF(x);
  return ival;
}
static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t ival) {
#if PY_VERSION_HEX < 0x02050000
   if (ival <= LONG_MAX)
       return PyInt_FromLong((long)ival);
   else {
       unsigned char *bytes = (unsigned char *) &ival;
       int one = 1; int little = (int)*(unsigned char*)&one;
       return _PyLong_FromByteArray(bytes, sizeof(size_t), little, 0);
   }
#else
   return PyInt_FromSize_t(ival);
#endif
}
static CYTHON_INLINE size_t __Pyx_PyInt_AsSize_t(PyObject* x) {
   unsigned PY_LONG_LONG val = __Pyx_PyInt_AsUnsignedLongLong(x);
   if (unlikely(val != (unsigned PY_LONG_LONG)(size_t)val)) {
       if ((val != (unsigned PY_LONG_LONG)-1) || !PyErr_Occurred())
           PyErr_SetString(PyExc_OverflowError,
                           "value too large to convert to size_t");
       return (size_t)-1;
   }
   return (size_t)val;
}


#endif /* Py_PYTHON_H */
