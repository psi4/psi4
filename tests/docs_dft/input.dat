#! This test is used to construct the documentation;
#! it is not suitable for emulation by users.

funcdict = {}

for super in superfunctional_list():
    sfname = super.name()

    if super.dispersion():
        funcdict[sfname] = {
            'name'                   : super.name(),
            'description'            : super.description().strip(),
            'citation'               : super.citation().strip(),
            'ansatz'                 : super.ansatz(),
            'max_points'             : super.max_points(),
            'deriv'                  : super.deriv(),
            'x_omega'                : super.x_omega(),
            'c_omega'                : super.c_omega(),
            'x_alpha'                : super.x_alpha(),
            'c_alpha'                : super.c_alpha(),
            'dispersion'             : super.dispersion(),
            'dispersion_name'        : super.dispersion().name(),
            'dispersion_description' : super.dispersion().description().strip(),
            'dispersion_citation'    : super.dispersion().citation().strip(),
            'is_gga'                 : super.is_gga(),
            'is_meta'                : super.is_meta(),
            'is_x_lrc'               : super.is_x_lrc(),
            'is_c_lrc'               : super.is_c_lrc(),
            'is_x_hybrid'            : super.is_x_hybrid(),
            'is_c_hybrid'            : super.is_c_hybrid(),
                           }

    else:
        funcdict[sfname] = {
            'name'                   : super.name(),
            'description'            : super.description().strip(),
            'citation'               : super.citation().strip(),
            'ansatz'                 : super.ansatz(),
            'max_points'             : super.max_points(),
            'deriv'                  : super.deriv(),
            'x_omega'                : super.x_omega(),
            'c_omega'                : super.c_omega(),
            'x_alpha'                : super.x_alpha(),
            'c_alpha'                : super.c_alpha(),
            'dispersion'             : super.dispersion(),
            'is_gga'                 : super.is_gga(),
            'is_meta'                : super.is_meta(),
            'is_x_lrc'               : super.is_x_lrc(),
            'is_c_lrc'               : super.is_c_lrc(),
            'is_x_hybrid'            : super.is_x_hybrid(),
            'is_c_hybrid'            : super.is_c_hybrid(),
                           }

    #print funcdict[sfname]
    #print '\n\n'

    super.print_detail(3)


def tf(rungbool, rungparam=0.0):
    """Function to return reST formatted table cell from boolean/value info."""

    if rungbool is False:
        return '   ---    '
    else:
        if rungparam == 0.0:
            return '    Y     '
        else:
            return ' %8.6f ' % (rungparam)


def header(filep, label, caption):
    """Function to write reST table header."""

    filep.write('\n.. _`table:dft_%s`:\n' % (label))
    filep.write('\n.. table:: %s\n\n' % (caption))
    filep.write('   +-%20s-+-%80s-+-%10s-+-%10s-+-%10s-+-%10s-+-%10s-+-%10s-+-%20s-+-%60s-+\n' % 
        (20 * '-', 80 * '-', 10 * '-', 10 * '-', 10 * '-', 10 * '-', 10 * '-', 10 * '-',
         20 * '-', 60 * '-'))
    filep.write('   | %20s | %80s | %10s | %10s | %10s | %10s | %10s | %10s | %20s | %60s |\n' % 
        ('Name', 'Description', 'GGA?', 'Meta?', 'X_LRC?', 'X_Hybrid?', 'C_LRC?', 'C_Hybrid?',
         'Dispersion?', 'Dispersion Description'))
    filep.write('   +=%20s=+=%80s=+=%10s=+=%10s=+=%10s=+=%10s=+=%10s=+=%10s=+=%20s=+=%60s=+\n' % 
        (20 * '=', 80 * '=', 10 * '=', 10 * '=', 10 * '=', 10 * '=', 10 * '=', 10 * '=',
         20 * '=', 60 * '='))


def body(filep, funcdict, fctl):
    """Function to write line of reST table."""

    filep.write('   | %20s | %80s | %10s | %10s | %10s | %10s | %10s | %10s |' % 
        (funcdict[fctl]['name'], funcdict[fctl]['description'],
        tf(funcdict[fctl]['is_gga']), tf(funcdict[fctl]['is_meta']),
        tf(funcdict[fctl]['is_x_lrc'], funcdict[fctl]['x_omega']),
        tf(funcdict[fctl]['is_x_hybrid'], funcdict[fctl]['x_alpha']),
        tf(funcdict[fctl]['is_c_lrc'], funcdict[fctl]['c_omega']),
        tf(funcdict[fctl]['is_c_hybrid'], funcdict[fctl]['c_alpha'])))

    if funcdict[fctl]['dispersion']:
        filep.write(' %20s | %60s |\n' %
            (funcdict[fctl]['dispersion_name'], funcdict[fctl]['dispersion_description']))
    else:
        filep.write(' %20s | %60s |\n' %
            ('   ---    ', '   ---    '))
    filep.write('   +-%20s-+-%80s-+-%10s-+-%10s-+-%10s-+-%10s-+-%10s-+-%10s-+-%20s-+-%60s-+\n' % 
        (20 * '-', 80 * '-', 10 * '-', 10 * '-', 10 * '-', 10 * '-', 10 * '-', 10 * '-', 
         20 * '-', 60 * '-'))


fall = open('autodoc_dft_all.rst', 'w')
header(fall, 'all', 'DFT functionals available in |PSIfour|')
fgga = open('autodoc_dft_gga.rst', 'w')
header(fgga, 'gga', 'GGA functionals available in |PSIfour|')
fmeta= open('autodoc_dft_meta.rst', 'w')
header(fmeta, 'meta', 'Meta functionals available in |PSIfour|')
flrc= open('autodoc_dft_lrc.rst', 'w')
header(flrc, 'lrc', 'Long-Range-Corrected functionals available in |PSIfour|')
fhybrid= open('autodoc_dft_hybrid.rst', 'w')
header(fhybrid, 'hybrid', 'Hybrid functionals available in |PSIfour|')
fdisp= open('autodoc_dft_disp.rst', 'w')
header(fdisp, 'disp', 'Dispersion-Corrected functionals available in |PSIfour|')

for fctl in sorted(funcdict.iterkeys()):

    body(fall, funcdict, fctl)

    if funcdict[fctl]['is_gga']:
        body(fgga, funcdict, fctl)

    if funcdict[fctl]['is_meta']:
        body(fmeta, funcdict, fctl)

    if funcdict[fctl]['is_x_lrc'] or funcdict[fctl]['is_c_lrc']:
        body(flrc, funcdict, fctl)

    if funcdict[fctl]['is_x_hybrid'] or funcdict[fctl]['is_c_hybrid']:
        body(fhybrid, funcdict, fctl)

    if funcdict[fctl]['dispersion']:
        body(fdisp, funcdict, fctl)

fall.write('\n')
fall.close()
fgga.write('\n')
fgga.close()
fmeta.write('\n')
fmeta.close()
flrc.write('\n')
flrc.close()
fhybrid.write('\n')
fhybrid.close()
fdisp.write('\n')
fdisp.close()

