#! Computation of VMFC-corrected water trimer Hessian (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015))

distributed = os.environ.get("_PSI4_USE_QCF", False)
if distributed:
    from qcfractal.snowflake import FractalSnowflake
    snowflake = FractalSnowflake()
    client = snowflake.client()

import numpy as np

molecule water_trimer {
O      -2.76373224  -1.24377706  -0.15444566
H      -1.12357791  -2.06227970  -0.05243799
H      -3.80792362  -2.08705525   1.06090407
--
O       2.46924614  -1.75437739  -0.17092884
H       3.76368260  -2.21425403   1.00846104
H       2.30598330   0.07098445  -0.03942473
--
O       0.29127930   3.00875625   0.20308515
H      -1.21253048   1.95820900   0.10303324
H       0.10002049   4.24958115  -1.10222079
no_reorient
no_com
symmetry c1
units bohr
}

if distributed:
    plan = psi4.hessian('SCF/STO-3G', molecule=water_trimer, bsse_type='vmfc', max_nbody=2,
                                      return_total_data=True, return_plan=True)
    plan.compute(client)
    snowflake.await_results()
    h, wfn = plan.get_psi_results(client, return_wfn=True)
else:
    h, wfn = psi4.hessian('SCF/STO-3G', molecule=water_trimer, bsse_type='vmfc', max_nbody=2,
                                      return_total_data=True, return_wfn=True)
core.clean()

# renamed for v1.10
# * '2' -> 'VMFC-CORRECTED TOTAL ENERGY THROUGH 2-BODY'
# * 'HESSIAN 2' -> 'VMFC-CORRECTED TOTAL HESSIAN THROUGH 2-BODY'

vmfc_scheme = {'((1, 2), (1, 2))': 1, '((1, 3), (1, 3))': 1, '((2, 3), (2, 3))': 1, #TEST
               '((1,), (1, 2))': -1, '((1,), (1, 3))': -1, '((2,), (1, 2))': -1, #TEST
               '((2,), (2, 3))': -1, '((3,), (1, 3))': -1, '((3,), (2, 3))': -1, #TEST
               '((1,), (1,))': 1, '((2,), (2,))': 1, '((3,), (3,))': 1} #TEST

import qcmanybody as qcmb  #TEST
sz_dict = {1: 3, 2: 3, 3: 3}
sl_dict = {1: slice(0, 3), 2: slice(3, 6), 3: slice(6, 9)}

energy_dict, hessian_dict = {}, {} #TEST
for i in vmfc_scheme: #TEST
    mol = water_trimer.extract_subsets(eval(i)[0], list(set(eval(i)[1]) - set(eval(i)[0]))) #TEST
    hessian_dict[i], wfn_mol = hessian('SCF/STO-3G', molecule=mol, return_wfn=True) #TEST
    energy_dict[i] = core.variable('CURRENT ENERGY') #TEST
    core.clean() #TEST

    compare_values(energy_dict[i], wfn.variable(f"1_{i}"), 8, 'Energy of %s' %i) #TEST
    # the hessian_dict is of natural size, while the variable HESSIAN is padded with zeros to
    #   supersystem size. so we'll test both and the qcmb.resize_hessian at the same time.
    expanded_hessian = qcmb.resize_hessian(hessian_dict[i].np, eval(i)[1], sz_dict, sl_dict)  #TEST
    contracted_hessian = qcmb.resize_hessian(wfn.variable(f"HESSIAN 1_{i}").np, eval(i)[1], sz_dict, sl_dict, reverse=True)  #TEST
    compare_arrays(expanded_hessian, wfn.variable(f"HESSIAN 1_{i}"), 2.e-8, 'Hessian of %s' %i) #TEST
    compare_arrays(hessian_dict[i], contracted_hessian, 2.e-8, 'Hessian of %s' %i) #TEST

ene, hess = 0, np.zeros((9*3, 9*3)) #TEST

for i in vmfc_scheme: #TEST
    ene += vmfc_scheme[i] * energy_dict[i] #TEST

compare_values(ene, wfn.variable('VMFC-CORRECTED TOTAL ENERGY THROUGH 2-BODY'), 8, 'VMFC-Corrected Energy') #TEST

for i in range(3): #TEST
    key = '((%i,), (%i,))' %(i + 1, i + 1) #TEST
    hess[i*3*3: i*3*3 + 3*3, i*3*3: i*3*3 + 3*3] += vmfc_scheme.pop(key) * np.array(hessian_dict[key]) #TEST

for key in vmfc_scheme: #TEST
    i, j = eval(key)[1][0]-1, eval(key)[1][1]-1 #TEST
    index = [] #TEST
    for ind in range(9): #TEST
        index.append(i*3*3+ind) #TEST
    for ind in range(9): #TEST
        index.append(j*3*3+ind) #TEST

    hess[np.ix_(index, index)] += vmfc_scheme[key] * np.array(hessian_dict[key]) #TEST

compare_arrays(hess, wfn.variable('VMFC-CORRECTED TOTAL HESSIAN THROUGH 2-BODY'), 2.e-8, 'VMFC-Corrected Hessian') #TEST

if distributed:
    snowflake.stop()
