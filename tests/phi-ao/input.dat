#! Test of the new phi_ao code (for puream and non-puream basis functions)
import numpy as np

REF_NELECTRON = 10.0000000 # TEST

mol = psi4.geometry("""
  0 1
  O
  H 1 1.0
  H 1 1.0 2 104.5
  symmetry c1
  no_reorient
  no_com
""")

TEST_NELECTRON = {}

for puream in [True, False]:
    psi4.set_options({'basis' : 'cc-pVQZ', 'puream' : puream})

    # Create puream and non-puream basissets and grids
    basis = psi4.core.BasisSet.build(mol, "ORBITAL", psi4.core.get_global_option("BASIS"), puream=puream)
    grid = psi4.core.DFTGrid.build(mol, basis)

    # Run an SCF calculation to get Electron Density
    e, wfn = energy('scf', return_wfn=True)

    # Density Matrix
    D = np.asarray(wfn.Da())
    
    # Grid information
    total_points = grid.npoints()
    blocks = grid.blocks()
    nbf = basis.nbf()

    phi_ao_points = np.zeros((total_points, nbf))
    weights = np.zeros(total_points)

    running_points = 0
    for block in blocks:

        npoints = block.npoints()
        w = np.asarray(block.w())
        x = np.asarray(block.x())
        y = np.asarray(block.y())
        z = np.asarray(block.z())

        for point in range(npoints):
            phi_ao_points[running_points + point] = basis.compute_phi(x[point], y[point], z[point])
            weights[running_points + point] = w[point]

        running_points += npoints

    # Creative manipulations for speedy calculations
    phi_prime = np.einsum('uv,pu->pv', D, phi_ao_points)
    TEST_NELECTRON[puream] = 2.0 * np.einsum('p,pv,pv->', weights, phi_prime, phi_ao_points)

    if puream:
        testname = 'SPHERICAL BASIS PHI_AO TEST'
    else:
        testname = 'CARTESIAN BASIS PHI_AO TEST'
    
    compare_values(TEST_NELECTRON[puream], REF_NELECTRON, 4, testname)

